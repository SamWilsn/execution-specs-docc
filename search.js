this.SEARCH_INDEX = [{"source": {"identifier": "ethereum.istanbul.vm.precompiled_contracts.alt_bn128", "specifier": 0, "path": "src/ethereum/istanbul/vm/precompiled_contracts/alt_bn128.py"}, "content": {"type": ["module"], "name": ["ethereum.istanbul.vm.precompiled_contracts.alt_bn128"], "text": ["Ethereum Virtual Machine (EVM) ALT_BN128 CONTRACTS ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementation of the ALT_BN128 precompiled contracts."]}}, {"source": {"identifier": "ethereum.istanbul.vm.precompiled_contracts.alt_bn128.alt_bn128_add", "specifier": 0, "path": "src/ethereum/istanbul/vm/precompiled_contracts/alt_bn128.py"}, "content": {"type": ["function"], "name": ["alt_bn128_add"], "text": ["The ALT_BN128 addition precompiled contract. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.istanbul.vm.precompiled_contracts.alt_bn128.alt_bn128_mul", "specifier": 0, "path": "src/ethereum/istanbul/vm/precompiled_contracts/alt_bn128.py"}, "content": {"type": ["function"], "name": ["alt_bn128_mul"], "text": ["The ALT_BN128 multiplication precompiled contract. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.istanbul.vm.precompiled_contracts.alt_bn128.alt_bn128_pairing_check", "specifier": 0, "path": "src/ethereum/istanbul/vm/precompiled_contracts/alt_bn128.py"}, "content": {"type": ["function"], "name": ["alt_bn128_pairing_check"], "text": ["The ALT_BN128 pairing check precompiled contract. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.bitwise", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/bitwise.py"}, "content": {"type": ["module"], "name": ["ethereum.homestead.vm.instructions.bitwise"], "text": ["Ethereum Virtual Machine (EVM) Bitwise Instructions ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementations of the EVM bitwise instructions."]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.bitwise.bitwise_and", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/bitwise.py"}, "content": {"type": ["function"], "name": ["bitwise_and"], "text": ["Bitwise AND operation of the top 2 elements of the stack. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.bitwise.bitwise_or", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/bitwise.py"}, "content": {"type": ["function"], "name": ["bitwise_or"], "text": ["Bitwise OR operation of the top 2 elements of the stack. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.bitwise.bitwise_xor", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/bitwise.py"}, "content": {"type": ["function"], "name": ["bitwise_xor"], "text": ["Bitwise XOR operation of the top 2 elements of the stack. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.bitwise.bitwise_not", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/bitwise.py"}, "content": {"type": ["function"], "name": ["bitwise_not"], "text": ["Bitwise NOT operation of the top element of the stack. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.bitwise.get_byte", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/bitwise.py"}, "content": {"type": ["function"], "name": ["get_byte"], "text": ["For a word (defined by next top element of the stack), retrieve the Nth byte (0-indexed and defined by top element of stack) from the left (most significant) to right (least significant). Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.istanbul.vm.precompiled_contracts.ripemd160", "specifier": 0, "path": "src/ethereum/istanbul/vm/precompiled_contracts/ripemd160.py"}, "content": {"type": ["module"], "name": ["ethereum.istanbul.vm.precompiled_contracts.ripemd160"], "text": ["Ethereum Virtual Machine (EVM) RIPEMD160 PRECOMPILED CONTRACT ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementation of the  RIPEMD160  precompiled contract."]}}, {"source": {"identifier": "ethereum.istanbul.vm.precompiled_contracts.ripemd160.ripemd160", "specifier": 0, "path": "src/ethereum/istanbul/vm/precompiled_contracts/ripemd160.py"}, "content": {"type": ["function"], "name": ["ripemd160"], "text": ["Writes the ripemd160 hash to output. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.environment", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/environment.py"}, "content": {"type": ["module"], "name": ["ethereum.homestead.vm.instructions.environment"], "text": ["Ethereum Virtual Machine (EVM) Environmental Instructions ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementations of the EVM environment related instructions."]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.environment.address", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["address"], "text": ["Pushes the address of the current executing account to the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.environment.balance", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["balance"], "text": ["Pushes the balance of the given account onto the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.environment.origin", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["origin"], "text": ["Pushes the address of the original transaction sender to the stack. The origin address can only be an EOA. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.environment.caller", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["caller"], "text": ["Pushes the address of the caller onto the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.environment.callvalue", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["callvalue"], "text": ["Push the value (in wei) sent with the call onto the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.environment.calldataload", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["calldataload"], "text": ["Push a word (32 bytes) of the input data belonging to the current environment onto the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.environment.calldatasize", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["calldatasize"], "text": ["Push the size of input data in current environment onto the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.environment.calldatacopy", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["calldatacopy"], "text": ["Copy a portion of the input data in current environment to memory. This will also expand the memory, in case that the memory is insufficient to store the data. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.environment.codesize", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["codesize"], "text": ["Push the size of code running in current environment onto the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.environment.codecopy", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["codecopy"], "text": ["Copy a portion of the code in current environment to memory. This will also expand the memory, in case that the memory is insufficient to store the data. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.environment.gasprice", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["gasprice"], "text": ["Push the gas price used in current environment onto the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.environment.extcodesize", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["extcodesize"], "text": ["Push the code size of a given account onto the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.environment.extcodecopy", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["extcodecopy"], "text": ["Copy a portion of an account's code to memory. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.tangerine_whistle.fork_types", "specifier": 0, "path": "src/ethereum/tangerine_whistle/fork_types.py"}, "content": {"type": ["module"], "name": ["ethereum.tangerine_whistle.fork_types"], "text": ["Ethereum Types ^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Types re-used throughout the specification, which are specific to Ethereum."]}}, {"source": {"identifier": "ethereum.tangerine_whistle.fork_types.Address", "specifier": 0, "path": "src/ethereum/tangerine_whistle/fork_types.py"}, "content": {"type": ["attribute"], "name": ["Address"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.fork_types.Root", "specifier": 0, "path": "src/ethereum/tangerine_whistle/fork_types.py"}, "content": {"type": ["attribute"], "name": ["Root"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.fork_types.Bloom", "specifier": 0, "path": "src/ethereum/tangerine_whistle/fork_types.py"}, "content": {"type": ["attribute"], "name": ["Bloom"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.fork_types.TX_BASE_COST", "specifier": 0, "path": "src/ethereum/tangerine_whistle/fork_types.py"}, "content": {"type": ["attribute"], "name": ["TX_BASE_COST"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.fork_types.TX_DATA_COST_PER_NON_ZERO", "specifier": 0, "path": "src/ethereum/tangerine_whistle/fork_types.py"}, "content": {"type": ["attribute"], "name": ["TX_DATA_COST_PER_NON_ZERO"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.fork_types.TX_DATA_COST_PER_ZERO", "specifier": 0, "path": "src/ethereum/tangerine_whistle/fork_types.py"}, "content": {"type": ["attribute"], "name": ["TX_DATA_COST_PER_ZERO"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.fork_types.TX_CREATE_COST", "specifier": 0, "path": "src/ethereum/tangerine_whistle/fork_types.py"}, "content": {"type": ["attribute"], "name": ["TX_CREATE_COST"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.fork_types.Transaction", "specifier": 0, "path": "src/ethereum/tangerine_whistle/fork_types.py"}, "content": {"type": ["class"], "name": ["Transaction"], "text": ["Atomic operation performed on the block chain."]}}, {"source": {"identifier": "ethereum.tangerine_whistle.fork_types.Transaction.nonce", "specifier": 0, "path": "src/ethereum/tangerine_whistle/fork_types.py"}, "content": {"type": ["attribute"], "name": ["nonce"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.fork_types.Transaction.gas_price", "specifier": 0, "path": "src/ethereum/tangerine_whistle/fork_types.py"}, "content": {"type": ["attribute"], "name": ["gas_price"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.fork_types.Transaction.gas", "specifier": 0, "path": "src/ethereum/tangerine_whistle/fork_types.py"}, "content": {"type": ["attribute"], "name": ["gas"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.fork_types.Transaction.to", "specifier": 0, "path": "src/ethereum/tangerine_whistle/fork_types.py"}, "content": {"type": ["attribute"], "name": ["to"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.fork_types.Transaction.value", "specifier": 0, "path": "src/ethereum/tangerine_whistle/fork_types.py"}, "content": {"type": ["attribute"], "name": ["value"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.fork_types.Transaction.data", "specifier": 0, "path": "src/ethereum/tangerine_whistle/fork_types.py"}, "content": {"type": ["attribute"], "name": ["data"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.fork_types.Transaction.v", "specifier": 0, "path": "src/ethereum/tangerine_whistle/fork_types.py"}, "content": {"type": ["attribute"], "name": ["v"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.fork_types.Transaction.r", "specifier": 0, "path": "src/ethereum/tangerine_whistle/fork_types.py"}, "content": {"type": ["attribute"], "name": ["r"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.fork_types.Transaction.s", "specifier": 0, "path": "src/ethereum/tangerine_whistle/fork_types.py"}, "content": {"type": ["attribute"], "name": ["s"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.fork_types.Account", "specifier": 0, "path": "src/ethereum/tangerine_whistle/fork_types.py"}, "content": {"type": ["class"], "name": ["Account"], "text": ["State associated with an address."]}}, {"source": {"identifier": "ethereum.tangerine_whistle.fork_types.Account.nonce", "specifier": 0, "path": "src/ethereum/tangerine_whistle/fork_types.py"}, "content": {"type": ["attribute"], "name": ["nonce"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.fork_types.Account.balance", "specifier": 0, "path": "src/ethereum/tangerine_whistle/fork_types.py"}, "content": {"type": ["attribute"], "name": ["balance"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.fork_types.Account.code", "specifier": 0, "path": "src/ethereum/tangerine_whistle/fork_types.py"}, "content": {"type": ["attribute"], "name": ["code"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.fork_types.EMPTY_ACCOUNT", "specifier": 0, "path": "src/ethereum/tangerine_whistle/fork_types.py"}, "content": {"type": ["attribute"], "name": ["EMPTY_ACCOUNT"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.fork_types.encode_account", "specifier": 0, "path": "src/ethereum/tangerine_whistle/fork_types.py"}, "content": {"type": ["function"], "name": ["encode_account"], "text": ["Encode  Account  dataclass. Storage is not stored in the  Account  dataclass, so  Accounts  cannot be encoded with providing a storage root."]}}, {"source": {"identifier": "ethereum.tangerine_whistle.fork_types.Header", "specifier": 0, "path": "src/ethereum/tangerine_whistle/fork_types.py"}, "content": {"type": ["class"], "name": ["Header"], "text": ["Header portion of a block on the chain."]}}, {"source": {"identifier": "ethereum.tangerine_whistle.fork_types.Header.parent_hash", "specifier": 0, "path": "src/ethereum/tangerine_whistle/fork_types.py"}, "content": {"type": ["attribute"], "name": ["parent_hash"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.fork_types.Header.ommers_hash", "specifier": 0, "path": "src/ethereum/tangerine_whistle/fork_types.py"}, "content": {"type": ["attribute"], "name": ["ommers_hash"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.fork_types.Header.coinbase", "specifier": 0, "path": "src/ethereum/tangerine_whistle/fork_types.py"}, "content": {"type": ["attribute"], "name": ["coinbase"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.fork_types.Header.state_root", "specifier": 0, "path": "src/ethereum/tangerine_whistle/fork_types.py"}, "content": {"type": ["attribute"], "name": ["state_root"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.fork_types.Header.transactions_root", "specifier": 0, "path": "src/ethereum/tangerine_whistle/fork_types.py"}, "content": {"type": ["attribute"], "name": ["transactions_root"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.fork_types.Header.receipt_root", "specifier": 0, "path": "src/ethereum/tangerine_whistle/fork_types.py"}, "content": {"type": ["attribute"], "name": ["receipt_root"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.fork_types.Header.bloom", "specifier": 0, "path": "src/ethereum/tangerine_whistle/fork_types.py"}, "content": {"type": ["attribute"], "name": ["bloom"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.fork_types.Header.difficulty", "specifier": 0, "path": "src/ethereum/tangerine_whistle/fork_types.py"}, "content": {"type": ["attribute"], "name": ["difficulty"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.fork_types.Header.number", "specifier": 0, "path": "src/ethereum/tangerine_whistle/fork_types.py"}, "content": {"type": ["attribute"], "name": ["number"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.fork_types.Header.gas_limit", "specifier": 0, "path": "src/ethereum/tangerine_whistle/fork_types.py"}, "content": {"type": ["attribute"], "name": ["gas_limit"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.fork_types.Header.gas_used", "specifier": 0, "path": "src/ethereum/tangerine_whistle/fork_types.py"}, "content": {"type": ["attribute"], "name": ["gas_used"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.fork_types.Header.timestamp", "specifier": 0, "path": "src/ethereum/tangerine_whistle/fork_types.py"}, "content": {"type": ["attribute"], "name": ["timestamp"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.fork_types.Header.extra_data", "specifier": 0, "path": "src/ethereum/tangerine_whistle/fork_types.py"}, "content": {"type": ["attribute"], "name": ["extra_data"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.fork_types.Header.mix_digest", "specifier": 0, "path": "src/ethereum/tangerine_whistle/fork_types.py"}, "content": {"type": ["attribute"], "name": ["mix_digest"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.fork_types.Header.nonce", "specifier": 0, "path": "src/ethereum/tangerine_whistle/fork_types.py"}, "content": {"type": ["attribute"], "name": ["nonce"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.fork_types.Block", "specifier": 0, "path": "src/ethereum/tangerine_whistle/fork_types.py"}, "content": {"type": ["class"], "name": ["Block"], "text": ["A complete block."]}}, {"source": {"identifier": "ethereum.tangerine_whistle.fork_types.Block.header", "specifier": 0, "path": "src/ethereum/tangerine_whistle/fork_types.py"}, "content": {"type": ["attribute"], "name": ["header"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.fork_types.Block.transactions", "specifier": 0, "path": "src/ethereum/tangerine_whistle/fork_types.py"}, "content": {"type": ["attribute"], "name": ["transactions"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.fork_types.Block.ommers", "specifier": 0, "path": "src/ethereum/tangerine_whistle/fork_types.py"}, "content": {"type": ["attribute"], "name": ["ommers"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.fork_types.Log", "specifier": 0, "path": "src/ethereum/tangerine_whistle/fork_types.py"}, "content": {"type": ["class"], "name": ["Log"], "text": ["Data record produced during the execution of a transaction."]}}, {"source": {"identifier": "ethereum.tangerine_whistle.fork_types.Log.address", "specifier": 0, "path": "src/ethereum/tangerine_whistle/fork_types.py"}, "content": {"type": ["attribute"], "name": ["address"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.fork_types.Log.topics", "specifier": 0, "path": "src/ethereum/tangerine_whistle/fork_types.py"}, "content": {"type": ["attribute"], "name": ["topics"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.fork_types.Log.data", "specifier": 0, "path": "src/ethereum/tangerine_whistle/fork_types.py"}, "content": {"type": ["attribute"], "name": ["data"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.fork_types.Receipt", "specifier": 0, "path": "src/ethereum/tangerine_whistle/fork_types.py"}, "content": {"type": ["class"], "name": ["Receipt"], "text": ["Result of a transaction."]}}, {"source": {"identifier": "ethereum.tangerine_whistle.fork_types.Receipt.post_state", "specifier": 0, "path": "src/ethereum/tangerine_whistle/fork_types.py"}, "content": {"type": ["attribute"], "name": ["post_state"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.fork_types.Receipt.cumulative_gas_used", "specifier": 0, "path": "src/ethereum/tangerine_whistle/fork_types.py"}, "content": {"type": ["attribute"], "name": ["cumulative_gas_used"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.fork_types.Receipt.bloom", "specifier": 0, "path": "src/ethereum/tangerine_whistle/fork_types.py"}, "content": {"type": ["attribute"], "name": ["bloom"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.fork_types.Receipt.logs", "specifier": 0, "path": "src/ethereum/tangerine_whistle/fork_types.py"}, "content": {"type": ["attribute"], "name": ["logs"]}}, {"source": {"identifier": "ethereum.istanbul.vm.precompiled_contracts.sha256", "specifier": 0, "path": "src/ethereum/istanbul/vm/precompiled_contracts/sha256.py"}, "content": {"type": ["module"], "name": ["ethereum.istanbul.vm.precompiled_contracts.sha256"], "text": ["Ethereum Virtual Machine (EVM) SHA256 PRECOMPILED CONTRACT ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementation of the  SHA256  precompiled contract."]}}, {"source": {"identifier": "ethereum.istanbul.vm.precompiled_contracts.sha256.sha256", "specifier": 0, "path": "src/ethereum/istanbul/vm/precompiled_contracts/sha256.py"}, "content": {"type": ["function"], "name": ["sha256"], "text": ["Writes the sha256 hash to output. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.stack", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/stack.py"}, "content": {"type": ["module"], "name": ["ethereum.homestead.vm.instructions.stack"], "text": ["Ethereum Virtual Machine (EVM) Stack Instructions ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementations of the EVM stack related instructions."]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.stack.pop", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/stack.py"}, "content": {"type": ["function"], "name": ["pop"], "text": ["Remove item from stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.stack.push_n", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/stack.py"}, "content": {"type": ["function"], "name": ["push_n"], "text": ["Pushes a N-byte immediate onto the stack. Parameters evm : The current EVM frame. num_bytes : The number of immediate bytes to be read from the code and pushed to the stack."]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.stack.dup_n", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/stack.py"}, "content": {"type": ["function"], "name": ["dup_n"], "text": ["Duplicate the Nth stack item (from top of the stack) to the top of stack. Parameters evm : The current EVM frame. item_number : The stack item number (0-indexed from top of stack) to be duplicated to the top of stack."]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.stack.swap_n", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/stack.py"}, "content": {"type": ["function"], "name": ["swap_n"], "text": ["Swap the top and the  item_number  element of the stack, where the top of the stack is position zero. If  item_number  is zero, this function does nothing (which should not be possible, since there is no  SWAP0  instruction). Parameters evm : The current EVM frame. item_number : The stack item number (0-indexed from top of stack) to be swapped with the top of stack element."]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.stack.push1", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push1"]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.stack.push2", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push2"]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.stack.push3", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push3"]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.stack.push4", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push4"]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.stack.push5", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push5"]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.stack.push6", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push6"]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.stack.push7", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push7"]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.stack.push8", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push8"]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.stack.push9", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push9"]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.stack.push10", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push10"]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.stack.push11", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push11"]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.stack.push12", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push12"]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.stack.push13", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push13"]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.stack.push14", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push14"]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.stack.push15", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push15"]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.stack.push16", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push16"]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.stack.push17", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push17"]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.stack.push18", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push18"]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.stack.push19", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push19"]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.stack.push20", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push20"]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.stack.push21", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push21"]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.stack.push22", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push22"]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.stack.push23", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push23"]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.stack.push24", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push24"]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.stack.push25", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push25"]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.stack.push26", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push26"]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.stack.push27", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push27"]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.stack.push28", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push28"]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.stack.push29", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push29"]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.stack.push30", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push30"]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.stack.push31", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push31"]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.stack.push32", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push32"]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.stack.dup1", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup1"]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.stack.dup2", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup2"]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.stack.dup3", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup3"]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.stack.dup4", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup4"]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.stack.dup5", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup5"]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.stack.dup6", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup6"]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.stack.dup7", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup7"]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.stack.dup8", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup8"]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.stack.dup9", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup9"]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.stack.dup10", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup10"]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.stack.dup11", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup11"]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.stack.dup12", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup12"]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.stack.dup13", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup13"]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.stack.dup14", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup14"]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.stack.dup15", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup15"]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.stack.dup16", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup16"]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.stack.swap1", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap1"]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.stack.swap2", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap2"]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.stack.swap3", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap3"]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.stack.swap4", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap4"]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.stack.swap5", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap5"]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.stack.swap6", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap6"]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.stack.swap7", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap7"]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.stack.swap8", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap8"]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.stack.swap9", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap9"]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.stack.swap10", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap10"]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.stack.swap11", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap11"]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.stack.swap12", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap12"]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.stack.swap13", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap13"]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.stack.swap14", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap14"]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.stack.swap15", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap15"]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.stack.swap16", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap16"]}}, {"source": {"identifier": "ethereum.istanbul.vm.precompiled_contracts.modexp", "specifier": 0, "path": "src/ethereum/istanbul/vm/precompiled_contracts/modexp.py"}, "content": {"type": ["module"], "name": ["ethereum.istanbul.vm.precompiled_contracts.modexp"], "text": ["Ethereum Virtual Machine (EVM) MODEXP PRECOMPILED CONTRACT ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementation of the  MODEXP  precompiled contract."]}}, {"source": {"identifier": "ethereum.istanbul.vm.precompiled_contracts.modexp.GQUADDIVISOR", "specifier": 0, "path": "src/ethereum/istanbul/vm/precompiled_contracts/modexp.py"}, "content": {"type": ["attribute"], "name": ["GQUADDIVISOR"]}}, {"source": {"identifier": "ethereum.istanbul.vm.precompiled_contracts.modexp.modexp", "specifier": 0, "path": "src/ethereum/istanbul/vm/precompiled_contracts/modexp.py"}, "content": {"type": ["function"], "name": ["modexp"], "text": ["Calculates  (base**exp) % modulus  for arbitary sized  base ,  exp  and. modulus . The return value is the same length as the modulus."]}}, {"source": {"identifier": "ethereum.istanbul.vm.precompiled_contracts.modexp.get_mult_complexity", "specifier": 0, "path": "src/ethereum/istanbul/vm/precompiled_contracts/modexp.py"}, "content": {"type": ["function"], "name": ["get_mult_complexity"], "text": ["Estimate the complexity of performing Karatsuba multiplication."]}}, {"source": {"identifier": "ethereum.homestead.utils", "specifier": 0, "path": "src/ethereum/homestead/utils/__init__.py"}, "content": {"type": ["module"], "name": ["ethereum.homestead.utils"], "text": ["Hardfork Utility Functions ^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Utility functions used in this homestead version of specification."]}}, {"source": {"identifier": "ethereum.istanbul.vm.precompiled_contracts.ecrecover", "specifier": 0, "path": "src/ethereum/istanbul/vm/precompiled_contracts/ecrecover.py"}, "content": {"type": ["module"], "name": ["ethereum.istanbul.vm.precompiled_contracts.ecrecover"], "text": ["Ethereum Virtual Machine (EVM) ECRECOVER PRECOMPILED CONTRACT ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementation of the ECRECOVER precompiled contract."]}}, {"source": {"identifier": "ethereum.istanbul.vm.precompiled_contracts.ecrecover.ecrecover", "specifier": 0, "path": "src/ethereum/istanbul/vm/precompiled_contracts/ecrecover.py"}, "content": {"type": ["function"], "name": ["ecrecover"], "text": ["Decrypts the address using elliptic curve DSA recovery mechanism and writes the address to output. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.homestead.utils.address", "specifier": 0, "path": "src/ethereum/homestead/utils/address.py"}, "content": {"type": ["module"], "name": ["ethereum.homestead.utils.address"], "text": ["Hardfork Utility Functions For Addresses ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Address specific functions used in this homestead version of specification."]}}, {"source": {"identifier": "ethereum.homestead.utils.address.to_address", "specifier": 0, "path": "src/ethereum/homestead/utils/address.py"}, "content": {"type": ["function"], "name": ["to_address"], "text": ["Convert a Uint or U256 value to a valid address (20 bytes). Parameters data : The string to be converted to bytes. Returns address :  Address The obtained address."]}}, {"source": {"identifier": "ethereum.homestead.utils.address.compute_contract_address", "specifier": 0, "path": "src/ethereum/homestead/utils/address.py"}, "content": {"type": ["function"], "name": ["compute_contract_address"], "text": ["Computes address of the new account that needs to be created. Parameters address : The address of the account that wants to create the new account. nonce : The transaction count of the account that wants to create the new account. Returns address:  ethereum.homestead.fork_types.Address The computed address of the new account."]}}, {"source": {"identifier": "ethereum.istanbul.vm.precompiled_contracts.identity", "specifier": 0, "path": "src/ethereum/istanbul/vm/precompiled_contracts/identity.py"}, "content": {"type": ["module"], "name": ["ethereum.istanbul.vm.precompiled_contracts.identity"], "text": ["Ethereum Virtual Machine (EVM) IDENTITY PRECOMPILED CONTRACT ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementation of the  IDENTITY  precompiled contract."]}}, {"source": {"identifier": "ethereum.istanbul.vm.precompiled_contracts.identity.identity", "specifier": 0, "path": "src/ethereum/istanbul/vm/precompiled_contracts/identity.py"}, "content": {"type": ["function"], "name": ["identity"], "text": ["Writes the message data to output. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.homestead.utils.message", "specifier": 0, "path": "src/ethereum/homestead/utils/message.py"}, "content": {"type": ["module"], "name": ["ethereum.homestead.utils.message"], "text": ["Hardfork Utility Functions For The Message Data-structure ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Message specific functions used in this homestead version of specification."]}}, {"source": {"identifier": "ethereum.homestead.utils.message.prepare_message", "specifier": 0, "path": "src/ethereum/homestead/utils/message.py"}, "content": {"type": ["function"], "name": ["prepare_message"], "text": ["Execute a transaction against the provided environment. Parameters caller : Address which initiated the transaction target : Address whose code will be executed value : Value to be transferred. data : Array of bytes provided to the code in  target . gas : Gas provided for the code in  target . env : Environment for the Ethereum Virtual Machine. code_address : This is usually same as the  target  address except when an alternative accounts code needs to be executed. eg.  CALLCODE  calling a precompile. should_transfer_value : if True ETH should be transferred while executing a message call. Returns message:  ethereum.homestead.vm.Message Items containing contract creation or message call specific data."]}}, {"source": {"identifier": "ethereum.tangerine_whistle.trie", "specifier": 0, "path": "src/ethereum/tangerine_whistle/trie.py"}, "content": {"type": ["module"], "name": ["ethereum.tangerine_whistle.trie"], "text": ["State Trie ^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction The state trie is the structure responsible for storing .fork_types.Account  objects."]}}, {"source": {"identifier": "ethereum.tangerine_whistle.trie.EMPTY_TRIE_ROOT", "specifier": 0, "path": "src/ethereum/tangerine_whistle/trie.py"}, "content": {"type": ["attribute"], "name": ["EMPTY_TRIE_ROOT"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.trie.Node", "specifier": 0, "path": "src/ethereum/tangerine_whistle/trie.py"}, "content": {"type": ["attribute"], "name": ["Node"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.trie.K", "specifier": 0, "path": "src/ethereum/tangerine_whistle/trie.py"}, "content": {"type": ["attribute"], "name": ["K"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.trie.V", "specifier": 0, "path": "src/ethereum/tangerine_whistle/trie.py"}, "content": {"type": ["attribute"], "name": ["V"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.trie.LeafNode", "specifier": 0, "path": "src/ethereum/tangerine_whistle/trie.py"}, "content": {"type": ["class"], "name": ["LeafNode"], "text": ["Leaf node in the Merkle Trie"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.trie.LeafNode.rest_of_key", "specifier": 0, "path": "src/ethereum/tangerine_whistle/trie.py"}, "content": {"type": ["attribute"], "name": ["rest_of_key"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.trie.LeafNode.value", "specifier": 0, "path": "src/ethereum/tangerine_whistle/trie.py"}, "content": {"type": ["attribute"], "name": ["value"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.trie.ExtensionNode", "specifier": 0, "path": "src/ethereum/tangerine_whistle/trie.py"}, "content": {"type": ["class"], "name": ["ExtensionNode"], "text": ["Extension node in the Merkle Trie"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.trie.ExtensionNode.key_segment", "specifier": 0, "path": "src/ethereum/tangerine_whistle/trie.py"}, "content": {"type": ["attribute"], "name": ["key_segment"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.trie.ExtensionNode.subnode", "specifier": 0, "path": "src/ethereum/tangerine_whistle/trie.py"}, "content": {"type": ["attribute"], "name": ["subnode"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.trie.BranchNode", "specifier": 0, "path": "src/ethereum/tangerine_whistle/trie.py"}, "content": {"type": ["class"], "name": ["BranchNode"], "text": ["Branch node in the Merkle Trie"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.trie.BranchNode.subnodes", "specifier": 0, "path": "src/ethereum/tangerine_whistle/trie.py"}, "content": {"type": ["attribute"], "name": ["subnodes"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.trie.BranchNode.value", "specifier": 0, "path": "src/ethereum/tangerine_whistle/trie.py"}, "content": {"type": ["attribute"], "name": ["value"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.trie.InternalNode", "specifier": 0, "path": "src/ethereum/tangerine_whistle/trie.py"}, "content": {"type": ["attribute"], "name": ["InternalNode"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.trie.encode_internal_node", "specifier": 0, "path": "src/ethereum/tangerine_whistle/trie.py"}, "content": {"type": ["function"], "name": ["encode_internal_node"], "text": ["Encodes a Merkle Trie node into its RLP form. The RLP will then be serialized into a  Bytes  and hashed unless it is less that 32 bytes when serialized. This function also accepts  None , representing the absence of a node, which is encoded to  b\"\" . Parameters node : Optional[InternalNode] The node to encode. Returns encoded :  rlp.RLP The node encoded as RLP."]}}, {"source": {"identifier": "ethereum.tangerine_whistle.trie.encode_node", "specifier": 0, "path": "src/ethereum/tangerine_whistle/trie.py"}, "content": {"type": ["function"], "name": ["encode_node"], "text": ["Encode a Node for storage in the Merkle Trie. Currently mostly an unimplemented stub."]}}, {"source": {"identifier": "ethereum.tangerine_whistle.trie.Trie", "specifier": 0, "path": "src/ethereum/tangerine_whistle/trie.py"}, "content": {"type": ["class"], "name": ["Trie"], "text": ["The Merkle Trie."]}}, {"source": {"identifier": "ethereum.tangerine_whistle.trie.Trie.secured", "specifier": 0, "path": "src/ethereum/tangerine_whistle/trie.py"}, "content": {"type": ["attribute"], "name": ["secured"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.trie.Trie.default", "specifier": 0, "path": "src/ethereum/tangerine_whistle/trie.py"}, "content": {"type": ["attribute"], "name": ["default"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.trie.Trie._data", "specifier": 0, "path": "src/ethereum/tangerine_whistle/trie.py"}, "content": {"type": ["attribute"], "name": ["_data"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.trie.copy_trie", "specifier": 0, "path": "src/ethereum/tangerine_whistle/trie.py"}, "content": {"type": ["function"], "name": ["copy_trie"], "text": ["Create a copy of  trie . Since only frozen objects may be stored in tries, the contents are reused. Parameters trie:  Trie Trie to copy. Returns new_trie :  Trie[K, V] A copy of the trie."]}}, {"source": {"identifier": "ethereum.tangerine_whistle.trie.trie_set", "specifier": 0, "path": "src/ethereum/tangerine_whistle/trie.py"}, "content": {"type": ["function"], "name": ["trie_set"], "text": ["Stores an item in a Merkle Trie. This method deletes the key if  value == trie.default , because the Merkle Trie represents the default value by omitting it from the trie. Parameters trie:  Trie Trie to store in. key :  Bytes Key to lookup. value :  V Node to insert at  key ."]}}, {"source": {"identifier": "ethereum.tangerine_whistle.trie.trie_get", "specifier": 0, "path": "src/ethereum/tangerine_whistle/trie.py"}, "content": {"type": ["function"], "name": ["trie_get"], "text": ["Gets an item from the Merkle Trie. This method returns  trie.default  if the key is missing. Parameters trie: Trie to lookup in. key : Key to lookup. Returns node :  V Node at  key  in the trie."]}}, {"source": {"identifier": "ethereum.tangerine_whistle.trie.common_prefix_length", "specifier": 0, "path": "src/ethereum/tangerine_whistle/trie.py"}, "content": {"type": ["function"], "name": ["common_prefix_length"], "text": ["Find the longest common prefix of two sequences."]}}, {"source": {"identifier": "ethereum.tangerine_whistle.trie.nibble_list_to_compact", "specifier": 0, "path": "src/ethereum/tangerine_whistle/trie.py"}, "content": {"type": ["function"], "name": ["nibble_list_to_compact"], "text": ["Compresses nibble-list into a standard byte array with a flag. A nibble-list is a list of byte values no greater than  15 . The flag is encoded in high nibble of the highest byte. The flag nibble can be broken down into two two-bit flags. Highest nibble:: +---+---+----------+--------+\n| _ | _ | is_leaf | parity |\n+---+---+----------+--------+\n  3   2      1         0\n The lowest bit of the nibble encodes the parity of the length of the remaining nibbles --  0  when even and  1  when odd. The second lowest bit is used to distinguish leaf and extension nodes. The other two bits are not used. Parameters x : Array of nibbles. is_leaf : True if this is part of a leaf node, or false if it is an extension node. Returns compressed :  bytearray Compact byte array."]}}, {"source": {"identifier": "ethereum.tangerine_whistle.trie.bytes_to_nibble_list", "specifier": 0, "path": "src/ethereum/tangerine_whistle/trie.py"}, "content": {"type": ["function"], "name": ["bytes_to_nibble_list"], "text": ["Converts a  Bytes  into to a sequence of nibbles (bytes with value < 16). Parameters bytes_: The  Bytes  to convert. Returns nibble_list :  Bytes The  Bytes  in nibble-list format."]}}, {"source": {"identifier": "ethereum.tangerine_whistle.trie._prepare_trie", "specifier": 0, "path": "src/ethereum/tangerine_whistle/trie.py"}, "content": {"type": ["function"], "name": ["_prepare_trie"], "text": ["Prepares the trie for root calculation. Removes values that are empty, hashes the keys (if  secured == True ) and encodes all the nodes. Parameters trie : The  Trie  to prepare. get_storage_root : Function to get the storage root of an account. Needed to encode Account  objects. Returns out :  Mapping[ethereum.base_types.Bytes, Node] Object with keys mapped to nibble-byte form."]}}, {"source": {"identifier": "ethereum.tangerine_whistle.trie.root", "specifier": 0, "path": "src/ethereum/tangerine_whistle/trie.py"}, "content": {"type": ["function"], "name": ["root"], "text": ["Computes the root of a modified merkle patricia trie (MPT). Parameters trie : Trie  to get the root of. get_storage_root : Function to get the storage root of an account. Needed to encode Account  objects. Returns root :  .fork_types.Root MPT root of the underlying key-value pairs."]}}, {"source": {"identifier": "ethereum.tangerine_whistle.trie.patricialize", "specifier": 0, "path": "src/ethereum/tangerine_whistle/trie.py"}, "content": {"type": ["function"], "name": ["patricialize"], "text": ["Structural composition function. Used to recursively patricialize and merkleize a dictionary. Includes memoization of the tree structure and hashes. Parameters obj : Underlying trie key-value pairs, with keys in nibble-list format. level : Current trie level. Returns node :  ethereum.base_types.Bytes Root node of  obj ."]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.memory", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/memory.py"}, "content": {"type": ["module"], "name": ["ethereum.istanbul.vm.instructions.memory"], "text": ["Ethereum Virtual Machine (EVM) Memory Instructions ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementations of the EVM Memory instructions."]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.memory.mstore", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/memory.py"}, "content": {"type": ["function"], "name": ["mstore"], "text": ["Stores a word to memory. This also expands the memory, if the memory is insufficient to store the word. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.memory.mstore8", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/memory.py"}, "content": {"type": ["function"], "name": ["mstore8"], "text": ["Stores a byte to memory. This also expands the memory, if the memory is insufficient to store the word. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.memory.mload", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/memory.py"}, "content": {"type": ["function"], "name": ["mload"], "text": ["Load word from memory. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.memory.msize", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/memory.py"}, "content": {"type": ["function"], "name": ["msize"], "text": ["Push the size of active memory in bytes onto the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.homestead.utils.hexadecimal", "specifier": 0, "path": "src/ethereum/homestead/utils/hexadecimal.py"}, "content": {"type": ["module"], "name": ["ethereum.homestead.utils.hexadecimal"], "text": ["Utility Functions For Hexadecimal Strings ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Hexadecimal utility functions used in this specification, specific to Homestead types."]}}, {"source": {"identifier": "ethereum.homestead.utils.hexadecimal.hex_to_root", "specifier": 0, "path": "src/ethereum/homestead/utils/hexadecimal.py"}, "content": {"type": ["function"], "name": ["hex_to_root"], "text": ["Convert hex string to trie root. Parameters hex_string : The hexadecimal string to be converted to trie root. Returns root :  Root Trie root obtained from the given hexadecimal string."]}}, {"source": {"identifier": "ethereum.homestead.utils.hexadecimal.hex_to_bloom", "specifier": 0, "path": "src/ethereum/homestead/utils/hexadecimal.py"}, "content": {"type": ["function"], "name": ["hex_to_bloom"], "text": ["Convert hex string to bloom. Parameters hex_string : The hexadecimal string to be converted to bloom. Returns bloom :  Bloom Bloom obtained from the given hexadecimal string."]}}, {"source": {"identifier": "ethereum.homestead.utils.hexadecimal.hex_to_address", "specifier": 0, "path": "src/ethereum/homestead/utils/hexadecimal.py"}, "content": {"type": ["function"], "name": ["hex_to_address"], "text": ["Convert hex string to Address (20 bytes). Parameters hex_string : The hexadecimal string to be converted to Address. Returns address :  Address The address obtained from the given hexadecimal string."]}}, {"source": {"identifier": "ethereum.tangerine_whistle.state", "specifier": 0, "path": "src/ethereum/tangerine_whistle/state.py"}, "content": {"type": ["module"], "name": ["ethereum.tangerine_whistle.state"], "text": ["State ^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction The state contains all information that is preserved between transactions. It consists of a main account trie and storage tries for each contract. There is a distinction between an account that does not exist and EMPTY_ACCOUNT ."]}}, {"source": {"identifier": "ethereum.tangerine_whistle.state.State", "specifier": 0, "path": "src/ethereum/tangerine_whistle/state.py"}, "content": {"type": ["class"], "name": ["State"], "text": ["Contains all information that is preserved between transactions."]}}, {"source": {"identifier": "ethereum.tangerine_whistle.state.State._main_trie", "specifier": 0, "path": "src/ethereum/tangerine_whistle/state.py"}, "content": {"type": ["attribute"], "name": ["_main_trie"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.state.State._storage_tries", "specifier": 0, "path": "src/ethereum/tangerine_whistle/state.py"}, "content": {"type": ["attribute"], "name": ["_storage_tries"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.state.State._snapshots", "specifier": 0, "path": "src/ethereum/tangerine_whistle/state.py"}, "content": {"type": ["attribute"], "name": ["_snapshots"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.state.close_state", "specifier": 0, "path": "src/ethereum/tangerine_whistle/state.py"}, "content": {"type": ["function"], "name": ["close_state"], "text": ["Free resources held by the state. Used by optimized implementations to release file descriptors."]}}, {"source": {"identifier": "ethereum.tangerine_whistle.state.begin_transaction", "specifier": 0, "path": "src/ethereum/tangerine_whistle/state.py"}, "content": {"type": ["function"], "name": ["begin_transaction"], "text": ["Start a state transaction. Transactions are entirely implicit and can be nested. It is not possible to calculate the state root during a transaction. Parameters state : State The state."]}}, {"source": {"identifier": "ethereum.tangerine_whistle.state.commit_transaction", "specifier": 0, "path": "src/ethereum/tangerine_whistle/state.py"}, "content": {"type": ["function"], "name": ["commit_transaction"], "text": ["Commit a state transaction. Parameters state : State The state."]}}, {"source": {"identifier": "ethereum.tangerine_whistle.state.rollback_transaction", "specifier": 0, "path": "src/ethereum/tangerine_whistle/state.py"}, "content": {"type": ["function"], "name": ["rollback_transaction"], "text": ["Rollback a state transaction, resetting the state to the point when the corresponding  start_transaction()  call was made. Parameters state : State The state."]}}, {"source": {"identifier": "ethereum.tangerine_whistle.state.get_account", "specifier": 0, "path": "src/ethereum/tangerine_whistle/state.py"}, "content": {"type": ["function"], "name": ["get_account"], "text": ["Get the  Account  object at an address. Returns  EMPTY_ACCOUNT  if there is no account at the address. Use  get_account_optional()  if you care about the difference between a non-existent account and  EMPTY_ACCOUNT . Parameters state:  State The state address :  Address Address to lookup. Returns account :  Account Account at address."]}}, {"source": {"identifier": "ethereum.tangerine_whistle.state.get_account_optional", "specifier": 0, "path": "src/ethereum/tangerine_whistle/state.py"}, "content": {"type": ["function"], "name": ["get_account_optional"], "text": ["Get the  Account  object at an address. Returns  None  (rather than EMPTY_ACCOUNT ) if there is no account at the address. Parameters state:  State The state address :  Address Address to lookup. Returns account :  Account Account at address."]}}, {"source": {"identifier": "ethereum.tangerine_whistle.state.set_account", "specifier": 0, "path": "src/ethereum/tangerine_whistle/state.py"}, "content": {"type": ["function"], "name": ["set_account"], "text": ["Set the  Account  object at an address. Setting to  None  deletes the account (but not its storage, see  destroy_account() ). Parameters state:  State The state address :  Address Address to set. account :  Account Account to set at address."]}}, {"source": {"identifier": "ethereum.tangerine_whistle.state.destroy_account", "specifier": 0, "path": "src/ethereum/tangerine_whistle/state.py"}, "content": {"type": ["function"], "name": ["destroy_account"], "text": ["Completely remove the account at  address  and all of its storage. This function is made available exclusively for the  SELFDESTRUCT opcode. It is expected that  SELFDESTRUCT  will be disabled in a future hardfork and this function will be removed. Parameters state:  State The state address :  Address Address of account to destroy."]}}, {"source": {"identifier": "ethereum.tangerine_whistle.state.destroy_storage", "specifier": 0, "path": "src/ethereum/tangerine_whistle/state.py"}, "content": {"type": ["function"], "name": ["destroy_storage"], "text": ["Completely remove the storage at  address . Parameters state:  State The state address :  Address Address of account whose storage is to be deleted."]}}, {"source": {"identifier": "ethereum.tangerine_whistle.state.get_storage", "specifier": 0, "path": "src/ethereum/tangerine_whistle/state.py"}, "content": {"type": ["function"], "name": ["get_storage"], "text": ["Get a value at a storage key on an account. Returns  U256(0)  if the storage key has not been set previously. Parameters state:  State The state address :  Address Address of the account. key :  Bytes Key to lookup. Returns value :  U256 Value at the key."]}}, {"source": {"identifier": "ethereum.tangerine_whistle.state.set_storage", "specifier": 0, "path": "src/ethereum/tangerine_whistle/state.py"}, "content": {"type": ["function"], "name": ["set_storage"], "text": ["Set a value at a storage key on an account. Setting to  U256(0)  deletes the key. Parameters state:  State The state address :  Address Address of the account. key :  Bytes Key to set. value :  U256 Value to set at the key."]}}, {"source": {"identifier": "ethereum.tangerine_whistle.state.storage_root", "specifier": 0, "path": "src/ethereum/tangerine_whistle/state.py"}, "content": {"type": ["function"], "name": ["storage_root"], "text": ["Calculate the storage root of an account. Parameters state: The state address : Address of the account. Returns root :  Root Storage root of the account."]}}, {"source": {"identifier": "ethereum.tangerine_whistle.state.state_root", "specifier": 0, "path": "src/ethereum/tangerine_whistle/state.py"}, "content": {"type": ["function"], "name": ["state_root"], "text": ["Calculate the state root. Parameters state: The current state. Returns root :  Root The state root."]}}, {"source": {"identifier": "ethereum.tangerine_whistle.state.account_exists", "specifier": 0, "path": "src/ethereum/tangerine_whistle/state.py"}, "content": {"type": ["function"], "name": ["account_exists"], "text": ["Checks if an account exists in the state trie Parameters state: The state address: Address of the account that needs to be checked. Returns account_exists :  bool True if account exists in the state trie, False otherwise"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.state.account_has_code_or_nonce", "specifier": 0, "path": "src/ethereum/tangerine_whistle/state.py"}, "content": {"type": ["function"], "name": ["account_has_code_or_nonce"], "text": ["Checks if an account has non zero nonce or non empty code Parameters state: The state address: Address of the account that needs to be checked. Returns has_code_or_nonce :  bool True if if an account has non zero nonce or non empty code, False otherwise."]}}, {"source": {"identifier": "ethereum.tangerine_whistle.state.modify_state", "specifier": 0, "path": "src/ethereum/tangerine_whistle/state.py"}, "content": {"type": ["function"], "name": ["modify_state"], "text": ["Modify an  Account  in the  State ."]}}, {"source": {"identifier": "ethereum.tangerine_whistle.state.move_ether", "specifier": 0, "path": "src/ethereum/tangerine_whistle/state.py"}, "content": {"type": ["function"], "name": ["move_ether"], "text": ["Move funds between accounts."]}}, {"source": {"identifier": "ethereum.tangerine_whistle.state.set_account_balance", "specifier": 0, "path": "src/ethereum/tangerine_whistle/state.py"}, "content": {"type": ["function"], "name": ["set_account_balance"], "text": ["Sets the balance of an account. Parameters state: The current state. address: Address of the account whose nonce needs to be incremented. amount: The amount that needs to set in balance."]}}, {"source": {"identifier": "ethereum.tangerine_whistle.state.touch_account", "specifier": 0, "path": "src/ethereum/tangerine_whistle/state.py"}, "content": {"type": ["function"], "name": ["touch_account"], "text": ["Initializes an account to state. Parameters state: The current state. address: The address of the account that need to initialised."]}}, {"source": {"identifier": "ethereum.tangerine_whistle.state.increment_nonce", "specifier": 0, "path": "src/ethereum/tangerine_whistle/state.py"}, "content": {"type": ["function"], "name": ["increment_nonce"], "text": ["Increments the nonce of an account. Parameters state: The current state. address: Address of the account whose nonce needs to be incremented."]}}, {"source": {"identifier": "ethereum.tangerine_whistle.state.set_code", "specifier": 0, "path": "src/ethereum/tangerine_whistle/state.py"}, "content": {"type": ["function"], "name": ["set_code"], "text": ["Sets Account code. Parameters state: The current state. address: Address of the account whose code needs to be update. code: The bytecode that needs to be set."]}}, {"source": {"identifier": "ethereum.tangerine_whistle.state.create_ether", "specifier": 0, "path": "src/ethereum/tangerine_whistle/state.py"}, "content": {"type": ["function"], "name": ["create_ether"], "text": ["Add newly created ether to an account. Parameters state: The current state. address: Address of the account to which ether is added. amount: The amount of ether to be added to the account of interest."]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.system", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/system.py"}, "content": {"type": ["module"], "name": ["ethereum.istanbul.vm.instructions.system"], "text": ["Ethereum Virtual Machine (EVM) System Instructions ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementations of the EVM system related instructions."]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.system.generic_create", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/system.py"}, "content": {"type": ["function"], "name": ["generic_create"], "text": ["Core logic used by the  CREATE*  family of opcodes."]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.system.create", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/system.py"}, "content": {"type": ["function"], "name": ["create"], "text": ["Creates a new account with associated code. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.system.create2", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/system.py"}, "content": {"type": ["function"], "name": ["create2"], "text": ["Creates a new account with associated code. It's similar to CREATE opcode except that the address of new account depends on the init_code instead of the nonce of sender. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.system.return_", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/system.py"}, "content": {"type": ["function"], "name": ["return_"], "text": ["Halts execution returning output data. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.system.generic_call", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/system.py"}, "content": {"type": ["function"], "name": ["generic_call"], "text": ["Perform the core logic of the  CALL*  family of opcodes."]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.system.call", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/system.py"}, "content": {"type": ["function"], "name": ["call"], "text": ["Message-call into an account. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.system.callcode", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/system.py"}, "content": {"type": ["function"], "name": ["callcode"], "text": ["Message-call into this account with alternative account\u2019s code. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.system.selfdestruct", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/system.py"}, "content": {"type": ["function"], "name": ["selfdestruct"], "text": ["Halt execution and register account for later deletion. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.system.delegatecall", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/system.py"}, "content": {"type": ["function"], "name": ["delegatecall"], "text": ["Message-call into an account. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.system.staticcall", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/system.py"}, "content": {"type": ["function"], "name": ["staticcall"], "text": ["Message-call into an account. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.system.revert", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/system.py"}, "content": {"type": ["function"], "name": ["revert"], "text": ["Stop execution and revert state changes, without consuming all provided gas and also has the ability to return a reason Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.tangerine_whistle", "specifier": 0, "path": "src/ethereum/tangerine_whistle/__init__.py"}, "content": {"type": ["module"], "name": ["ethereum.tangerine_whistle"], "text": ["Ethereum Tangerine Whistle Hardfork ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ The fourth Ethereum hardfork."]}}, {"source": {"identifier": "ethereum.tangerine_whistle.MAINNET_FORK_BLOCK", "specifier": 0, "path": "src/ethereum/tangerine_whistle/__init__.py"}, "content": {"type": ["attribute"], "name": ["MAINNET_FORK_BLOCK"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/__init__.py"}, "content": {"type": ["module"], "name": ["ethereum.istanbul.vm.instructions"], "text": ["EVM Instruction Encoding (Opcodes) ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Machine readable representations of EVM instructions, and a mapping to their implementations."]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.Ops", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/__init__.py"}, "content": {"type": ["class"], "name": ["Ops"], "text": ["Enum for EVM Opcodes"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.Ops.ADD", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["ADD"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.Ops.MUL", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["MUL"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.Ops.SUB", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SUB"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.Ops.DIV", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DIV"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.Ops.SDIV", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SDIV"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.Ops.MOD", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["MOD"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.Ops.SMOD", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SMOD"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.Ops.ADDMOD", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["ADDMOD"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.Ops.MULMOD", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["MULMOD"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.Ops.EXP", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["EXP"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.Ops.SIGNEXTEND", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SIGNEXTEND"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.Ops.LT", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["LT"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.Ops.GT", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["GT"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.Ops.SLT", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SLT"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.Ops.SGT", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SGT"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.Ops.EQ", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["EQ"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.Ops.ISZERO", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["ISZERO"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.Ops.AND", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["AND"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.Ops.OR", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["OR"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.Ops.XOR", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["XOR"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.Ops.NOT", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["NOT"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.Ops.BYTE", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["BYTE"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.Ops.SHL", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SHL"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.Ops.SHR", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SHR"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.Ops.SAR", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SAR"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.Ops.KECCAK", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["KECCAK"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.Ops.ADDRESS", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["ADDRESS"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.Ops.BALANCE", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["BALANCE"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.Ops.ORIGIN", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["ORIGIN"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.Ops.CALLER", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["CALLER"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.Ops.CALLVALUE", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["CALLVALUE"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.Ops.CALLDATALOAD", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["CALLDATALOAD"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.Ops.CALLDATASIZE", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["CALLDATASIZE"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.Ops.CALLDATACOPY", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["CALLDATACOPY"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.Ops.CODESIZE", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["CODESIZE"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.Ops.CODECOPY", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["CODECOPY"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.Ops.GASPRICE", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["GASPRICE"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.Ops.EXTCODESIZE", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["EXTCODESIZE"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.Ops.EXTCODECOPY", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["EXTCODECOPY"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.Ops.RETURNDATASIZE", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["RETURNDATASIZE"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.Ops.RETURNDATACOPY", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["RETURNDATACOPY"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.Ops.EXTCODEHASH", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["EXTCODEHASH"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.Ops.BLOCKHASH", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["BLOCKHASH"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.Ops.COINBASE", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["COINBASE"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.Ops.TIMESTAMP", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["TIMESTAMP"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.Ops.NUMBER", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["NUMBER"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.Ops.DIFFICULTY", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DIFFICULTY"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.Ops.GASLIMIT", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["GASLIMIT"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.Ops.CHAINID", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["CHAINID"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.Ops.SELFBALANCE", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SELFBALANCE"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.Ops.STOP", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["STOP"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.Ops.JUMP", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["JUMP"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.Ops.JUMPI", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["JUMPI"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.Ops.PC", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PC"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.Ops.GAS", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["GAS"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.Ops.JUMPDEST", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["JUMPDEST"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.Ops.SLOAD", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SLOAD"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.Ops.SSTORE", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SSTORE"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.Ops.POP", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["POP"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.Ops.PUSH1", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH1"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.Ops.PUSH2", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH2"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.Ops.PUSH3", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH3"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.Ops.PUSH4", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH4"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.Ops.PUSH5", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH5"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.Ops.PUSH6", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH6"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.Ops.PUSH7", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH7"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.Ops.PUSH8", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH8"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.Ops.PUSH9", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH9"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.Ops.PUSH10", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH10"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.Ops.PUSH11", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH11"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.Ops.PUSH12", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH12"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.Ops.PUSH13", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH13"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.Ops.PUSH14", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH14"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.Ops.PUSH15", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH15"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.Ops.PUSH16", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH16"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.Ops.PUSH17", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH17"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.Ops.PUSH18", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH18"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.Ops.PUSH19", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH19"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.Ops.PUSH20", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH20"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.Ops.PUSH21", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH21"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.Ops.PUSH22", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH22"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.Ops.PUSH23", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH23"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.Ops.PUSH24", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH24"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.Ops.PUSH25", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH25"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.Ops.PUSH26", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH26"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.Ops.PUSH27", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH27"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.Ops.PUSH28", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH28"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.Ops.PUSH29", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH29"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.Ops.PUSH30", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH30"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.Ops.PUSH31", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH31"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.Ops.PUSH32", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH32"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.Ops.DUP1", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP1"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.Ops.DUP2", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP2"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.Ops.DUP3", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP3"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.Ops.DUP4", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP4"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.Ops.DUP5", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP5"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.Ops.DUP6", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP6"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.Ops.DUP7", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP7"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.Ops.DUP8", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP8"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.Ops.DUP9", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP9"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.Ops.DUP10", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP10"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.Ops.DUP11", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP11"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.Ops.DUP12", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP12"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.Ops.DUP13", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP13"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.Ops.DUP14", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP14"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.Ops.DUP15", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP15"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.Ops.DUP16", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP16"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.Ops.SWAP1", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP1"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.Ops.SWAP2", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP2"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.Ops.SWAP3", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP3"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.Ops.SWAP4", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP4"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.Ops.SWAP5", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP5"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.Ops.SWAP6", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP6"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.Ops.SWAP7", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP7"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.Ops.SWAP8", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP8"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.Ops.SWAP9", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP9"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.Ops.SWAP10", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP10"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.Ops.SWAP11", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP11"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.Ops.SWAP12", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP12"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.Ops.SWAP13", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP13"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.Ops.SWAP14", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP14"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.Ops.SWAP15", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP15"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.Ops.SWAP16", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP16"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.Ops.MLOAD", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["MLOAD"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.Ops.MSTORE", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["MSTORE"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.Ops.MSTORE8", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["MSTORE8"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.Ops.MSIZE", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["MSIZE"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.Ops.LOG0", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["LOG0"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.Ops.LOG1", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["LOG1"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.Ops.LOG2", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["LOG2"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.Ops.LOG3", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["LOG3"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.Ops.LOG4", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["LOG4"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.Ops.CREATE", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["CREATE"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.Ops.RETURN", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["RETURN"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.Ops.CALL", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["CALL"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.Ops.CALLCODE", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["CALLCODE"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.Ops.DELEGATECALL", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DELEGATECALL"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.Ops.STATICCALL", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["STATICCALL"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.Ops.REVERT", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["REVERT"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.Ops.SELFDESTRUCT", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SELFDESTRUCT"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.Ops.CREATE2", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["CREATE2"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.op_implementation", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["op_implementation"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.bloom", "specifier": 0, "path": "src/ethereum/tangerine_whistle/bloom.py"}, "content": {"type": ["module"], "name": ["ethereum.tangerine_whistle.bloom"], "text": ["Ethereum Logs Bloom ^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction This modules defines functions for calculating bloom filters of logs. For the general theory of bloom filters see e.g.  Wikipedia <https://en.wikipedia.org/wiki/Bloom_filter> _. Bloom filters are used to allow for efficient searching of logs by address and/or topic, by rapidly eliminating blocks and reciepts from their search."]}}, {"source": {"identifier": "ethereum.tangerine_whistle.bloom.add_to_bloom", "specifier": 0, "path": "src/ethereum/tangerine_whistle/bloom.py"}, "content": {"type": ["function"], "name": ["add_to_bloom"], "text": ["Add a bloom entry to the bloom filter ( bloom ). The number of hash functions used is 3. They are calculated by taking the least significant 11 bits from the first 3 16-bit words of the keccak_256()  hash of  bloom_entry . Parameters bloom : The bloom filter. bloom_entry : An entry which is to be added to bloom filter."]}}, {"source": {"identifier": "ethereum.tangerine_whistle.bloom.logs_bloom", "specifier": 0, "path": "src/ethereum/tangerine_whistle/bloom.py"}, "content": {"type": ["function"], "name": ["logs_bloom"], "text": ["Obtain the logs bloom from a list of log entries. The address and each topic of a log are added to the bloom filter. Parameters logs : List of logs for which the logs bloom is to be obtained. Returns logs_bloom :  Bloom The logs bloom obtained which is 256 bytes with some bits set as per the caller address and the log topics."]}}, {"source": {"identifier": "ethereum.tangerine_whistle.fork", "specifier": 0, "path": "src/ethereum/tangerine_whistle/fork.py"}, "content": {"type": ["module"], "name": ["ethereum.tangerine_whistle.fork"], "text": ["Ethereum Specification ^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Entry point for the Ethereum specification."]}}, {"source": {"identifier": "ethereum.tangerine_whistle.fork.BLOCK_REWARD", "specifier": 0, "path": "src/ethereum/tangerine_whistle/fork.py"}, "content": {"type": ["attribute"], "name": ["BLOCK_REWARD"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.fork.GAS_LIMIT_ADJUSTMENT_FACTOR", "specifier": 0, "path": "src/ethereum/tangerine_whistle/fork.py"}, "content": {"type": ["attribute"], "name": ["GAS_LIMIT_ADJUSTMENT_FACTOR"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.fork.GAS_LIMIT_MINIMUM", "specifier": 0, "path": "src/ethereum/tangerine_whistle/fork.py"}, "content": {"type": ["attribute"], "name": ["GAS_LIMIT_MINIMUM"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.fork.MINIMUM_DIFFICULTY", "specifier": 0, "path": "src/ethereum/tangerine_whistle/fork.py"}, "content": {"type": ["attribute"], "name": ["MINIMUM_DIFFICULTY"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.fork.MAX_OMMER_DEPTH", "specifier": 0, "path": "src/ethereum/tangerine_whistle/fork.py"}, "content": {"type": ["attribute"], "name": ["MAX_OMMER_DEPTH"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.fork.BlockChain", "specifier": 0, "path": "src/ethereum/tangerine_whistle/fork.py"}, "content": {"type": ["class"], "name": ["BlockChain"], "text": ["History and current state of the block chain."]}}, {"source": {"identifier": "ethereum.tangerine_whistle.fork.BlockChain.blocks", "specifier": 0, "path": "src/ethereum/tangerine_whistle/fork.py"}, "content": {"type": ["attribute"], "name": ["blocks"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.fork.BlockChain.state", "specifier": 0, "path": "src/ethereum/tangerine_whistle/fork.py"}, "content": {"type": ["attribute"], "name": ["state"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.fork.BlockChain.chain_id", "specifier": 0, "path": "src/ethereum/tangerine_whistle/fork.py"}, "content": {"type": ["attribute"], "name": ["chain_id"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.fork.apply_fork", "specifier": 0, "path": "src/ethereum/tangerine_whistle/fork.py"}, "content": {"type": ["function"], "name": ["apply_fork"], "text": ["Transforms the state from the previous hard fork ( old ) into the block chain object for this hard fork and returns it. When forks need to implement an irregular state transition, this function is used to handle the irregularity. See the :ref: DAO Fork <dao-fork>  for an example. Parameters old : Previous block chain object. Returns new :  BlockChain Upgraded block chain object for this hard fork."]}}, {"source": {"identifier": "ethereum.tangerine_whistle.fork.get_last_256_block_hashes", "specifier": 0, "path": "src/ethereum/tangerine_whistle/fork.py"}, "content": {"type": ["function"], "name": ["get_last_256_block_hashes"], "text": ["Obtain the list of hashes of the previous 256 blocks in order of increasing block number. This function will return less hashes for the first 256 blocks. The  BLOCKHASH  opcode needs to access the latest hashes on the chain, therefore this function retrieves them. Parameters chain : History and current state. Returns recent_block_hashes :  List[Hash32] Hashes of the recent 256 blocks in order of increasing block number."]}}, {"source": {"identifier": "ethereum.tangerine_whistle.fork.state_transition", "specifier": 0, "path": "src/ethereum/tangerine_whistle/fork.py"}, "content": {"type": ["function"], "name": ["state_transition"], "text": ["Attempts to apply a block to an existing block chain. All parts of the block's contents need to be verified before being added to the chain. Blocks are verified by ensuring that the contents of the block make logical sense with the contents of the parent block. The information in the block's header must also match the corresponding information in the block. To implement Ethereum, in theory clients are only required to store the most recent 255 blocks of the chain since as far as execution is concerned, only those blocks are accessed. Practically, however, clients should store more blocks to handle reorgs. Parameters chain : History and current state. block : Block to apply to  chain ."]}}, {"source": {"identifier": "ethereum.tangerine_whistle.fork.validate_header", "specifier": 0, "path": "src/ethereum/tangerine_whistle/fork.py"}, "content": {"type": ["function"], "name": ["validate_header"], "text": ["Verifies a block header. In order to consider a block's header valid, the logic for the quantities in the header should match the logic for the block itself. For example the header timestamp should be greater than the block's parent timestamp because the block was created  after  the parent block. Additionally, the block's number should be directly folowing the parent block's number since it is the next block in the sequence. Parameters header : Header to check for correctness. parent_header : Parent Header of the header to check for correctness"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.fork.generate_header_hash_for_pow", "specifier": 0, "path": "src/ethereum/tangerine_whistle/fork.py"}, "content": {"type": ["function"], "name": ["generate_header_hash_for_pow"], "text": ["Generate rlp hash of the header which is to be used for Proof-of-Work verification. In other words, the PoW artefacts  mix_digest  and  nonce  are ignored while calculating this hash. A particular PoW is valid for a single hash, that hash is computed by this function. The  nonce  and  mix_digest  are omitted from this hash because they are being changed by miners in their search for a sufficient proof-of-work. Parameters header : The header object for which the hash is to be generated. Returns hash :  Hash32 The PoW valid rlp hash of the passed in header."]}}, {"source": {"identifier": "ethereum.tangerine_whistle.fork.validate_proof_of_work", "specifier": 0, "path": "src/ethereum/tangerine_whistle/fork.py"}, "content": {"type": ["function"], "name": ["validate_proof_of_work"], "text": ["Validates the Proof of Work constraints. In order to verify that a miner's proof-of-work is valid for a block, a mix-digest  and  result  are calculated using the  hashimoto_light hash function. The mix digest is a hash of the header and the nonce that is passed through and it confirms whether or not proof-of-work was done on the correct block. The result is the actual hash value of the block. Parameters header : Header of interest."]}}, {"source": {"identifier": "ethereum.tangerine_whistle.fork.check_transaction", "specifier": 0, "path": "src/ethereum/tangerine_whistle/fork.py"}, "content": {"type": ["function"], "name": ["check_transaction"], "text": ["Check if the transaction is includable in the block. Parameters tx : The transaction. gas_available : The gas remaining in the block. Returns sender_address : The sender of the transaction. Raises InvalidBlock : If the transaction is not includable."]}}, {"source": {"identifier": "ethereum.tangerine_whistle.fork.make_receipt", "specifier": 0, "path": "src/ethereum/tangerine_whistle/fork.py"}, "content": {"type": ["function"], "name": ["make_receipt"], "text": ["Make the receipt for a transaction that was executed. Parameters tx : The executed transaction. post_state : The state root immediately after this transaction. cumulative_gas_used : The total gas used so far in the block after the transaction was executed. logs : The logs produced by the transaction. Returns receipt : The receipt for the transaction."]}}, {"source": {"identifier": "ethereum.tangerine_whistle.fork.apply_body", "specifier": 0, "path": "src/ethereum/tangerine_whistle/fork.py"}, "content": {"type": ["function"], "name": ["apply_body"], "text": ["Executes a block. Many of the contents of a block are stored in data structures called tries. There is a transactions trie which is similar to a ledger of the transactions stored in the current block. There is also a receipts trie which stores the results of executing a transaction, like the post state and gas used. This function creates and executes the block that is to be added to the chain. Parameters state : Current account state. block_hashes : List of hashes of the previous 256 blocks in the order of increasing block number. coinbase : Address of account which receives block reward and transaction fees. block_number : Position of the block within the chain. block_gas_limit : Initial amount of gas available for execution in this block. block_time : Time the block was produced, measured in seconds since the epoch. block_difficulty : Difficulty of the block. transactions : Transactions included in the block. ommers : Headers of ancestor blocks which are not direct parents (formerly uncles.) Returns gas_available :  ethereum.base_types.Uint Remaining gas after all transactions have been executed. transactions_root :  ethereum.fork_types.Root Trie root of all the transactions in the block. receipt_root :  ethereum.fork_types.Root Trie root of all the receipts in the block. block_logs_bloom :  Bloom Logs bloom of all the logs included in all the transactions of the block. state :  ethereum.fork_types.State State after all transactions have been executed."]}}, {"source": {"identifier": "ethereum.tangerine_whistle.fork.validate_ommers", "specifier": 0, "path": "src/ethereum/tangerine_whistle/fork.py"}, "content": {"type": ["function"], "name": ["validate_ommers"], "text": ["Validates the ommers mentioned in the block. An ommer block is a block that wasn't canonically added to the blockchain because it wasn't validated as fast as the canonical block but was mined at the same time. To be considered valid, the ommers must adhere to the rules defined in the Ethereum protocol. The maximum amount of ommers is 2 per block and there cannot be duplicate ommers in a block. Many of the other ommer contraints are listed in the in-line comments of this function. Parameters ommers : List of ommers mentioned in the current block. block_header: The header of current block. chain : History and current state."]}}, {"source": {"identifier": "ethereum.tangerine_whistle.fork.pay_rewards", "specifier": 0, "path": "src/ethereum/tangerine_whistle/fork.py"}, "content": {"type": ["function"], "name": ["pay_rewards"], "text": ["Pay rewards to the block miner as well as the ommers miners. The miner of the canonical block is rewarded with the predetermined block reward,  BLOCK_REWARD , plus a variable award based off of the number of ommer blocks that were mined around the same time, and included in the canonical block's header. An ommer block is a block that wasn't added to the canonical blockchain because it wasn't validated as fast as the accepted block but was mined at the same time. Although not all blocks that are mined are added to the canonical chain, miners are still paid a reward for their efforts. This reward is called an ommer reward and is calculated based on the number associated with the ommer block that they mined. Parameters state : Current account state. block_number : Position of the block within the chain. coinbase : Address of account which receives block reward and transaction fees. ommers : List of ommers mentioned in the current block."]}}, {"source": {"identifier": "ethereum.tangerine_whistle.fork.process_transaction", "specifier": 0, "path": "src/ethereum/tangerine_whistle/fork.py"}, "content": {"type": ["function"], "name": ["process_transaction"], "text": ["Execute a transaction against the provided environment. This function processes the actions needed to execute a transaction. It decrements the sender's account after calculating the gas fee and refunds them the proper amount after execution. Calling contracts, deploying code, and incrementing nonces are all examples of actions that happen within this function or from a call made within this function. Accounts that are marked for deletion are processed and destroyed after execution. Parameters env : Environment for the Ethereum Virtual Machine. tx : Transaction to execute. Returns gas_left :  ethereum.base_types.U256 Remaining gas after execution. logs :  Tuple[ethereum.fork_types.Log, ...] Logs generated during execution."]}}, {"source": {"identifier": "ethereum.tangerine_whistle.fork.validate_transaction", "specifier": 0, "path": "src/ethereum/tangerine_whistle/fork.py"}, "content": {"type": ["function"], "name": ["validate_transaction"], "text": ["Verifies a transaction. The gas in a transaction gets used to pay for the intrinsic cost of operations, therefore if there is insufficient gas then it would not be possible to execute a transaction and it will be declared invalid. Additionally, the nonce of a transaction must not equal or exceed the limit defined in  EIP-2681 <https://eips.ethereum.org/EIPS/eip-2681> _. In practice, defining the limit as  2**64-1  has no impact because sending  2**64-1  transactions is improbable. It's not strictly impossible though,  2**64-1  transactions is the entire capacity of the Ethereum blockchain at 2022 gas limits for a little over 22 years. Parameters tx : Transaction to validate. Returns verified :  bool True if the transaction can be executed, or False otherwise."]}}, {"source": {"identifier": "ethereum.tangerine_whistle.fork.calculate_intrinsic_cost", "specifier": 0, "path": "src/ethereum/tangerine_whistle/fork.py"}, "content": {"type": ["function"], "name": ["calculate_intrinsic_cost"], "text": ["Calculates the gas that is charged before execution is started. The intrinsic cost of the transaction is charged before execution has begun. Functions/operations in the EVM cost money to execute so this intrinsic cost is for the operations that need to be paid for as part of the transaction. Data transfer, for example, is part of this intrinsic cost. It costs ether to send data over the wire and that ether is accounted for in the intrinsic cost calculated in this function. This intrinsic cost must be calculated and paid for before execution in order for all operations to be implemented. Parameters tx : Transaction to compute the intrinsic cost of. Returns verified :  ethereum.base_types.Uint The intrinsic cost of the transaction."]}}, {"source": {"identifier": "ethereum.tangerine_whistle.fork.recover_sender", "specifier": 0, "path": "src/ethereum/tangerine_whistle/fork.py"}, "content": {"type": ["function"], "name": ["recover_sender"], "text": ["Extracts the sender address from a transaction. The v, r, and s values are the three parts that make up the signature of a transaction. In order to recover the sender of a transaction the two components needed are the signature ( v ,  r , and  s ) and the signing hash of the transaction. The sender's public key can be obtained with these two values and therefore the sender address can be retrieved. Parameters tx : Transaction of interest. Returns sender :  ethereum.fork_types.Address The address of the account that signed the transaction."]}}, {"source": {"identifier": "ethereum.tangerine_whistle.fork.signing_hash", "specifier": 0, "path": "src/ethereum/tangerine_whistle/fork.py"}, "content": {"type": ["function"], "name": ["signing_hash"], "text": ["Compute the hash of a transaction used in the signature. The values that are used to compute the signing hash set the rules for a transaction. For example, signing over the gas sets a limit for the amount of money that is allowed to be pulled out of the sender's account. Parameters tx : Transaction of interest. Returns hash :  ethereum.crypto.hash.Hash32 Hash of the transaction."]}}, {"source": {"identifier": "ethereum.tangerine_whistle.fork.compute_header_hash", "specifier": 0, "path": "src/ethereum/tangerine_whistle/fork.py"}, "content": {"type": ["function"], "name": ["compute_header_hash"], "text": ["Computes the hash of a block header. The header hash of a block is the canonical hash that is used to refer to a specific block and completely distinguishes a block from another. keccak256  is a function that produces a 256 bit hash of any input. It also takes in any number of bytes as an input and produces a single hash for them. A hash is a completely unique output for a single input. So an input corresponds to one unique hash that can be used to identify the input exactly. Prior to using the  keccak256  hash function, the header must be encoded using the Recursive-Length Prefix. See :ref: rlp . RLP encoding the header converts it into a space-efficient format that allows for easy transfer of data between nodes. The purpose of RLP is to encode arbitrarily nested arrays of binary data, and RLP is the primary encoding method used to serialize objects in Ethereum's execution layer. The only purpose of RLP is to encode structure; encoding specific data types (e.g. strings, floats) is left up to higher-order protocols. Parameters header : Header of interest. Returns hash :  ethereum.crypto.hash.Hash32 Hash of the header."]}}, {"source": {"identifier": "ethereum.tangerine_whistle.fork.check_gas_limit", "specifier": 0, "path": "src/ethereum/tangerine_whistle/fork.py"}, "content": {"type": ["function"], "name": ["check_gas_limit"], "text": ["Validates the gas limit for a block. The bounds of the gas limit,  max_adjustment_delta , is set as the quotient of the parent block's gas limit and the GAS_LIMIT_ADJUSTMENT_FACTOR . Therefore, if the gas limit that is passed through as a parameter is greater than or equal to the  sum  of the parent's gas and the adjustment delta then the limit for gas is too high and fails this function's check. Similarly, if the limit is less than or equal to the  difference  of the parent's gas and the adjustment delta  or  the predefined  GAS_LIMIT_MINIMUM  then this function's check fails because the gas limit doesn't allow for a sufficient or reasonable amount of gas to be used on a block. Parameters gas_limit : Gas limit to validate. parent_gas_limit : Gas limit of the parent block. Returns check :  bool True if gas limit constraints are satisfied, False otherwise."]}}, {"source": {"identifier": "ethereum.tangerine_whistle.fork.calculate_block_difficulty", "specifier": 0, "path": "src/ethereum/tangerine_whistle/fork.py"}, "content": {"type": ["function"], "name": ["calculate_block_difficulty"], "text": ["Computes difficulty of a block using its header and parent header. The difficulty is determined by the time the block was created after its parent. The  offset  is calculated using the parent block's difficulty, parent_difficulty , and the timestamp between blocks. This offset is then added to the parent difficulty and is stored as the  difficulty variable. If the time between the block and its parent is too short, the offset will result in a positive number thus making the sum of parent_difficulty  and  offset  to be a greater value in order to avoid mass forking. But, if the time is long enough, then the offset results in a negative value making the block less difficult than its parent. The base standard for a block's difficulty is the predefined value set for the genesis block since it has no parent. So, a block can't be less difficult than the genesis block, therefore each block's difficulty is set to the maximum value between the calculated difficulty and the  GENESIS_DIFFICULTY . Parameters block_number : Block number of the block. block_timestamp : Timestamp of the block. parent_timestamp : Timestamp of the parent block. parent_difficulty : difficulty of the parent block. Returns difficulty :  ethereum.base_types.Uint Computed difficulty for a block."]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.control_flow", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/control_flow.py"}, "content": {"type": ["module"], "name": ["ethereum.istanbul.vm.instructions.control_flow"], "text": ["Ethereum Virtual Machine (EVM) Control Flow Instructions ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementations of the EVM control flow instructions."]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.control_flow.stop", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/control_flow.py"}, "content": {"type": ["function"], "name": ["stop"], "text": ["Stop further execution of EVM code. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.control_flow.jump", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/control_flow.py"}, "content": {"type": ["function"], "name": ["jump"], "text": ["Alter the program counter to the location specified by the top of the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.control_flow.jumpi", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/control_flow.py"}, "content": {"type": ["function"], "name": ["jumpi"], "text": ["Alter the program counter to the specified location if and only if a condition is true. If the condition is not true, then the program counter would increase only by 1. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.control_flow.pc", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/control_flow.py"}, "content": {"type": ["function"], "name": ["pc"], "text": ["Push onto the stack the value of the program counter after reaching the current instruction and without increasing it for the next instruction. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.control_flow.gas_left", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/control_flow.py"}, "content": {"type": ["function"], "name": ["gas_left"], "text": ["Push the amount of available gas (including the corresponding reduction for the cost of this instruction) onto the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.control_flow.jumpdest", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/control_flow.py"}, "content": {"type": ["function"], "name": ["jumpdest"], "text": ["Mark a valid destination for jumps. This is a noop, present only to be used by  JUMP  and  JUMPI  opcodes to verify that their jump is valid. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.memory", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/memory.py"}, "content": {"type": ["module"], "name": ["ethereum.tangerine_whistle.vm.memory"], "text": ["Ethereum Virtual Machine (EVM) Memory ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction EVM memory operations."]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.memory.memory_write", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/memory.py"}, "content": {"type": ["function"], "name": ["memory_write"], "text": ["Writes to memory. Parameters memory : Memory contents of the EVM. start_position : Starting pointer to the memory. value : Data to write to memory."]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.memory.memory_read_bytes", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/memory.py"}, "content": {"type": ["function"], "name": ["memory_read_bytes"], "text": ["Read bytes from memory. Parameters memory : Memory contents of the EVM. start_position : Starting pointer to the memory. size : Size of the data that needs to be read from  start_position . Returns data_bytes : Data read from memory."]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.memory.buffer_read", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/memory.py"}, "content": {"type": ["function"], "name": ["buffer_read"], "text": ["Read bytes from a buffer. Padding with zeros if neccesary. Parameters buffer : Memory contents of the EVM. start_position : Starting pointer to the memory. size : Size of the data that needs to be read from  start_position . Returns data_bytes : Data read from memory."]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.comparison", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/comparison.py"}, "content": {"type": ["module"], "name": ["ethereum.istanbul.vm.instructions.comparison"], "text": ["Ethereum Virtual Machine (EVM) Comparison Instructions ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementations of the EVM Comparison instructions."]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.comparison.less_than", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/comparison.py"}, "content": {"type": ["function"], "name": ["less_than"], "text": ["Checks if the top element is less than the next top element. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.comparison.signed_less_than", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/comparison.py"}, "content": {"type": ["function"], "name": ["signed_less_than"], "text": ["Signed less-than comparison. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.comparison.greater_than", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/comparison.py"}, "content": {"type": ["function"], "name": ["greater_than"], "text": ["Checks if the top element is greater than the next top element. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.comparison.signed_greater_than", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/comparison.py"}, "content": {"type": ["function"], "name": ["signed_greater_than"], "text": ["Signed greater-than comparison. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.comparison.equal", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/comparison.py"}, "content": {"type": ["function"], "name": ["equal"], "text": ["Checks if the top element is equal to the next top element. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.comparison.is_zero", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/comparison.py"}, "content": {"type": ["function"], "name": ["is_zero"], "text": ["Checks if the top element is equal to 0. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.exceptions", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/exceptions.py"}, "content": {"type": ["module"], "name": ["ethereum.tangerine_whistle.vm.exceptions"], "text": ["Ethereum Virtual Machine (EVM) Exceptions ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Exceptions which cause the EVM to halt exceptionally."]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.exceptions.ExceptionalHalt", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/exceptions.py"}, "content": {"type": ["class"], "name": ["ExceptionalHalt"], "text": ["Indicates that the EVM has experienced an exceptional halt. This causes execution to immediately end with all gas being consumed."]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.exceptions.StackUnderflowError", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/exceptions.py"}, "content": {"type": ["class"], "name": ["StackUnderflowError"], "text": ["Occurs when a pop is executed on an empty stack."]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.exceptions.StackOverflowError", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/exceptions.py"}, "content": {"type": ["class"], "name": ["StackOverflowError"], "text": ["Occurs when a push is executed on a stack at max capacity."]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.exceptions.OutOfGasError", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/exceptions.py"}, "content": {"type": ["class"], "name": ["OutOfGasError"], "text": ["Occurs when an operation costs more than the amount of gas left in the frame."]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.exceptions.InvalidOpcode", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/exceptions.py"}, "content": {"type": ["class"], "name": ["InvalidOpcode"], "text": ["Raised when an invalid opcode is encountered."]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.exceptions.InvalidJumpDestError", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/exceptions.py"}, "content": {"type": ["class"], "name": ["InvalidJumpDestError"], "text": ["Occurs when the destination of a jump operation doesn't meet any of the following criteria: The jump destination is less than the length of the code. The jump destination should have the  JUMPDEST  opcode (0x5B). The jump destination shouldn't be part of the data corresponding to PUSH-N  opcodes."]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.exceptions.StackDepthLimitError", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/exceptions.py"}, "content": {"type": ["class"], "name": ["StackDepthLimitError"], "text": ["Raised when the message depth is greater than  1024"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.log", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/log.py"}, "content": {"type": ["module"], "name": ["ethereum.istanbul.vm.instructions.log"], "text": ["Ethereum Virtual Machine (EVM) Logging Instructions ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementations of the EVM logging instructions."]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.log.log_n", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/log.py"}, "content": {"type": ["function"], "name": ["log_n"], "text": ["Appends a log entry, having  num_topics  topics, to the evm logs. This will also expand the memory if the data (required by the log entry) corresponding to the memory is not accessible. Parameters evm : The current EVM frame. num_topics : The number of topics to be included in the log entry."]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.log.log0", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/log.py"}, "content": {"type": ["attribute"], "name": ["log0"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.log.log1", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/log.py"}, "content": {"type": ["attribute"], "name": ["log1"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.log.log2", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/log.py"}, "content": {"type": ["attribute"], "name": ["log2"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.log.log3", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/log.py"}, "content": {"type": ["attribute"], "name": ["log3"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.log.log4", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/log.py"}, "content": {"type": ["attribute"], "name": ["log4"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/__init__.py"}, "content": {"type": ["module"], "name": ["ethereum.tangerine_whistle.vm"], "text": ["Ethereum Virtual Machine (EVM) ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction The abstract computer which runs the code stored in an .fork_types.Account ."]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.__all__", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["__all__"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.Environment", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/__init__.py"}, "content": {"type": ["class"], "name": ["Environment"], "text": ["Items external to the virtual machine itself, provided by the environment."]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.Environment.caller", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["caller"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.Environment.block_hashes", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["block_hashes"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.Environment.origin", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["origin"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.Environment.coinbase", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["coinbase"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.Environment.number", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["number"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.Environment.gas_limit", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["gas_limit"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.Environment.gas_price", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["gas_price"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.Environment.time", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["time"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.Environment.difficulty", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["difficulty"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.Environment.state", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["state"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.Message", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/__init__.py"}, "content": {"type": ["class"], "name": ["Message"], "text": ["Items that are used by contract creation or message call."]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.Message.caller", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["caller"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.Message.target", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["target"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.Message.current_target", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["current_target"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.Message.gas", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["gas"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.Message.value", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["value"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.Message.data", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["data"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.Message.code_address", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["code_address"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.Message.code", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["code"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.Message.depth", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["depth"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.Message.should_transfer_value", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["should_transfer_value"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.Evm", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/__init__.py"}, "content": {"type": ["class"], "name": ["Evm"], "text": ["The internal state of the virtual machine."]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.Evm.pc", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["pc"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.Evm.stack", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["stack"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.Evm.memory", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["memory"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.Evm.code", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["code"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.Evm.gas_left", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["gas_left"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.Evm.env", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["env"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.Evm.valid_jump_destinations", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["valid_jump_destinations"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.Evm.logs", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["logs"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.Evm.refund_counter", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["refund_counter"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.Evm.running", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["running"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.Evm.message", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["message"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.Evm.output", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["output"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.Evm.accounts_to_delete", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["accounts_to_delete"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.Evm.has_erred", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["has_erred"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.incorporate_child_on_success", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/__init__.py"}, "content": {"type": ["function"], "name": ["incorporate_child_on_success"], "text": ["Incorporate the state of a successful  child_evm  into the parent  evm . Parameters evm : The parent  EVM . child_evm : The child evm to incorporate."]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.incorporate_child_on_error", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/__init__.py"}, "content": {"type": ["function"], "name": ["incorporate_child_on_error"], "text": ["Incorporate the state of an unsuccessful  child_evm  into the parent  evm . Parameters evm : The parent  EVM . child_evm : The child evm to incorporate."]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.storage", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/storage.py"}, "content": {"type": ["module"], "name": ["ethereum.istanbul.vm.instructions.storage"], "text": ["Ethereum Virtual Machine (EVM) Storage Instructions ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementations of the EVM storage related instructions."]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.storage.sload", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/storage.py"}, "content": {"type": ["function"], "name": ["sload"], "text": ["Loads to the stack, the value corresponding to a certain key from the storage of the current account. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.storage.sstore", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/storage.py"}, "content": {"type": ["function"], "name": ["sstore"], "text": ["Stores a value at a certain key in the current context's storage. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.runtime", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/runtime.py"}, "content": {"type": ["module"], "name": ["ethereum.tangerine_whistle.vm.runtime"], "text": ["Ethereum Virtual Machine (EVM) Runtime Operations ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Runtime related operations used while executing EVM code."]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.runtime.get_valid_jump_destinations", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/runtime.py"}, "content": {"type": ["function"], "name": ["get_valid_jump_destinations"], "text": ["Analyze the evm code to obtain the set of valid jump destinations. Valid jump destinations are defined as follows: * The jump destination is less than the length of the code. * The jump destination should have the  JUMPDEST  opcode (0x5B). * The jump destination shouldn't be part of the data corresponding to PUSH-N  opcodes. Note - Jump destinations are 0-indexed. Parameters code : The EVM code which is to be executed. Returns valid_jump_destinations:  Set[Uint] The set of valid jump destinations in the code."]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.block", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/block.py"}, "content": {"type": ["module"], "name": ["ethereum.istanbul.vm.instructions.block"], "text": ["Ethereum Virtual Machine (EVM) Block Instructions ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementations of the EVM block instructions."]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.block.block_hash", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/block.py"}, "content": {"type": ["function"], "name": ["block_hash"], "text": ["Push the hash of one of the 256 most recent complete blocks onto the stack. The block number to hash is present at the top of the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.block.coinbase", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/block.py"}, "content": {"type": ["function"], "name": ["coinbase"], "text": ["Push the current block's beneficiary address (address of the block miner) onto the stack. Here the current block refers to the block in which the currently executing transaction/call resides. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.block.timestamp", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/block.py"}, "content": {"type": ["function"], "name": ["timestamp"], "text": ["Push the current block's timestamp onto the stack. Here the timestamp being referred is actually the unix timestamp in seconds. Here the current block refers to the block in which the currently executing transaction/call resides. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.block.number", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/block.py"}, "content": {"type": ["function"], "name": ["number"], "text": ["Push the current block's number onto the stack. Here the current block refers to the block in which the currently executing transaction/call resides. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.block.difficulty", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/block.py"}, "content": {"type": ["function"], "name": ["difficulty"], "text": ["Push the current block's difficulty onto the stack. Here the current block refers to the block in which the currently executing transaction/call resides. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.block.gas_limit", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/block.py"}, "content": {"type": ["function"], "name": ["gas_limit"], "text": ["Push the current block's gas limit onto the stack. Here the current block refers to the block in which the currently executing transaction/call resides. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.block.chain_id", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/block.py"}, "content": {"type": ["function"], "name": ["chain_id"], "text": ["Push the chain id onto the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.interpreter", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/interpreter.py"}, "content": {"type": ["module"], "name": ["ethereum.tangerine_whistle.vm.interpreter"], "text": ["Ethereum Virtual Machine (EVM) Interpreter ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction A straightforward interpreter that executes EVM code."]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.interpreter.STACK_DEPTH_LIMIT", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/interpreter.py"}, "content": {"type": ["attribute"], "name": ["STACK_DEPTH_LIMIT"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.interpreter.MessageCallOutput", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/interpreter.py"}, "content": {"type": ["class"], "name": ["MessageCallOutput"], "text": ["Output of a particular message call Contains the following:   1. `gas_left`: remaining gas after execution.\n  2. `refund_counter`: gas to refund after execution.\n  3. `logs`: list of `Log` generated during execution.\n  4. `accounts_to_delete`: Contracts which have self-destructed.\n  5. `has_erred`: True if execution has caused an error.\n"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.interpreter.MessageCallOutput.gas_left", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/interpreter.py"}, "content": {"type": ["attribute"], "name": ["gas_left"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.interpreter.MessageCallOutput.refund_counter", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/interpreter.py"}, "content": {"type": ["attribute"], "name": ["refund_counter"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.interpreter.MessageCallOutput.logs", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/interpreter.py"}, "content": {"type": ["attribute"], "name": ["logs"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.interpreter.MessageCallOutput.accounts_to_delete", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/interpreter.py"}, "content": {"type": ["attribute"], "name": ["accounts_to_delete"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.interpreter.MessageCallOutput.has_erred", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/interpreter.py"}, "content": {"type": ["attribute"], "name": ["has_erred"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.interpreter.process_message_call", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/interpreter.py"}, "content": {"type": ["function"], "name": ["process_message_call"], "text": ["If  message.current  is empty then it creates a smart contract else it executes a call from the  message.caller  to the  message.target . Parameters message : Transaction specific items. env : External items required for EVM execution. Returns output :  MessageCallOutput Output of the message call"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.interpreter.process_create_message", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/interpreter.py"}, "content": {"type": ["function"], "name": ["process_create_message"], "text": ["Executes a call to create a smart contract. Parameters message : Transaction specific items. env : External items required for EVM execution. Returns evm: :py:class: ~ethereum.tangerine_whistle.vm.Evm Items containing execution specific objects."]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.interpreter.process_message", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/interpreter.py"}, "content": {"type": ["function"], "name": ["process_message"], "text": ["Executes a call to create a smart contract. Parameters message : Transaction specific items. env : External items required for EVM execution. Returns evm: :py:class: ~ethereum.tangerine_whistle.vm.Evm Items containing execution specific objects"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.interpreter.execute_code", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/interpreter.py"}, "content": {"type": ["function"], "name": ["execute_code"], "text": ["Executes bytecode present in the  message . Parameters message : Transaction specific items. env : External items required for EVM execution. Returns evm:  ethereum.vm.EVM Items containing execution specific objects"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.arithmetic", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/arithmetic.py"}, "content": {"type": ["module"], "name": ["ethereum.istanbul.vm.instructions.arithmetic"], "text": ["Ethereum Virtual Machine (EVM) Arithmetic Instructions ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementations of the EVM Arithmetic instructions."]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.arithmetic.add", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/arithmetic.py"}, "content": {"type": ["function"], "name": ["add"], "text": ["Adds the top two elements of the stack together, and pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.arithmetic.sub", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/arithmetic.py"}, "content": {"type": ["function"], "name": ["sub"], "text": ["Subtracts the top two elements of the stack, and pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.arithmetic.mul", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/arithmetic.py"}, "content": {"type": ["function"], "name": ["mul"], "text": ["Multiply the top two elements of the stack, and pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.arithmetic.div", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/arithmetic.py"}, "content": {"type": ["function"], "name": ["div"], "text": ["Integer division of the top two elements of the stack. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.arithmetic.sdiv", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/arithmetic.py"}, "content": {"type": ["function"], "name": ["sdiv"], "text": ["Signed integer division of the top two elements of the stack. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.arithmetic.mod", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/arithmetic.py"}, "content": {"type": ["function"], "name": ["mod"], "text": ["Modulo remainder of the top two elements of the stack. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.arithmetic.smod", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/arithmetic.py"}, "content": {"type": ["function"], "name": ["smod"], "text": ["Signed modulo remainder of the top two elements of the stack. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.arithmetic.addmod", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/arithmetic.py"}, "content": {"type": ["function"], "name": ["addmod"], "text": ["Modulo addition of the top 2 elements with the 3rd element. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.arithmetic.mulmod", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/arithmetic.py"}, "content": {"type": ["function"], "name": ["mulmod"], "text": ["Modulo multiplication of the top 2 elements with the 3rd element. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.arithmetic.exp", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/arithmetic.py"}, "content": {"type": ["function"], "name": ["exp"], "text": ["Exponential operation of the top 2 elements. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.arithmetic.signextend", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/arithmetic.py"}, "content": {"type": ["function"], "name": ["signextend"], "text": ["Sign extend operation. In other words, extend a signed number which fits in N bytes to 32 bytes. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.stack", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/stack.py"}, "content": {"type": ["module"], "name": ["ethereum.tangerine_whistle.vm.stack"], "text": ["Ethereum Virtual Machine (EVM) Stack ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementation of the stack operators for the EVM."]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.stack.pop", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/stack.py"}, "content": {"type": ["function"], "name": ["pop"], "text": ["Pops the top item off of  stack . Parameters stack : EVM stack. Returns value :  U256 The top element on the stack."]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.stack.push", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/stack.py"}, "content": {"type": ["function"], "name": ["push"], "text": ["Pushes  value  onto  stack . Parameters stack : EVM stack. value : Item to be pushed onto  stack ."]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.keccak", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/keccak.py"}, "content": {"type": ["module"], "name": ["ethereum.istanbul.vm.instructions.keccak"], "text": ["Ethereum Virtual Machine (EVM) Keccak Instructions ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementations of the EVM keccak instructions."]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.keccak.keccak", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/keccak.py"}, "content": {"type": ["function"], "name": ["keccak"], "text": ["Pushes to the stack the Keccak-256 hash of a region of memory. This also expands the memory, in case the memory is insufficient to access the data's memory location. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.gas", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/gas.py"}, "content": {"type": ["module"], "name": ["ethereum.tangerine_whistle.vm.gas"], "text": ["Ethereum Virtual Machine (EVM) Gas ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction EVM gas constants and calculators."]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.gas.GAS_JUMPDEST", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_JUMPDEST"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.gas.GAS_BASE", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_BASE"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.gas.GAS_VERY_LOW", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_VERY_LOW"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.gas.GAS_SLOAD", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_SLOAD"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.gas.GAS_STORAGE_SET", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_STORAGE_SET"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.gas.GAS_STORAGE_UPDATE", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_STORAGE_UPDATE"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.gas.GAS_STORAGE_CLEAR_REFUND", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_STORAGE_CLEAR_REFUND"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.gas.GAS_LOW", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_LOW"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.gas.GAS_MID", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_MID"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.gas.GAS_HIGH", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_HIGH"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.gas.GAS_EXPONENTIATION", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_EXPONENTIATION"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.gas.GAS_EXPONENTIATION_PER_BYTE", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_EXPONENTIATION_PER_BYTE"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.gas.GAS_MEMORY", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_MEMORY"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.gas.GAS_KECCAK256", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_KECCAK256"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.gas.GAS_KECCAK256_WORD", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_KECCAK256_WORD"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.gas.GAS_COPY", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_COPY"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.gas.GAS_BLOCK_HASH", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_BLOCK_HASH"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.gas.GAS_EXTERNAL", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_EXTERNAL"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.gas.GAS_BALANCE", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_BALANCE"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.gas.GAS_LOG", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_LOG"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.gas.GAS_LOG_DATA", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_LOG_DATA"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.gas.GAS_LOG_TOPIC", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_LOG_TOPIC"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.gas.GAS_CREATE", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_CREATE"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.gas.GAS_CODE_DEPOSIT", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_CODE_DEPOSIT"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.gas.GAS_ZERO", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_ZERO"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.gas.GAS_CALL", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_CALL"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.gas.GAS_NEW_ACCOUNT", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_NEW_ACCOUNT"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.gas.GAS_CALL_VALUE", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_CALL_VALUE"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.gas.GAS_CALL_STIPEND", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_CALL_STIPEND"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.gas.GAS_SELF_DESTRUCT", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_SELF_DESTRUCT"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.gas.GAS_SELF_DESTRUCT_NEW_ACCOUNT", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_SELF_DESTRUCT_NEW_ACCOUNT"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.gas.REFUND_SELF_DESTRUCT", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["REFUND_SELF_DESTRUCT"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.gas.GAS_ECRECOVER", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_ECRECOVER"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.gas.GAS_SHA256", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_SHA256"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.gas.GAS_SHA256_WORD", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_SHA256_WORD"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.gas.GAS_RIPEMD160", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_RIPEMD160"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.gas.GAS_RIPEMD160_WORD", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_RIPEMD160_WORD"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.gas.GAS_IDENTITY", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_IDENTITY"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.gas.GAS_IDENTITY_WORD", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_IDENTITY_WORD"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.gas.ExtendMemory", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/gas.py"}, "content": {"type": ["class"], "name": ["ExtendMemory"], "text": ["Define the parameters for memory extension in opcodes cost :  ethereum.base_types.Uint The gas required to perform the extension expand_by :  ethereum.base_types.Uint The size by which the memory will be extended"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.gas.ExtendMemory.cost", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["cost"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.gas.ExtendMemory.expand_by", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["expand_by"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.gas.MessageCallGas", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/gas.py"}, "content": {"type": ["class"], "name": ["MessageCallGas"], "text": ["Define the gas cost and stipend for executing the call opcodes. cost :  ethereum.base_types.Uint The non-refundable portion of gas reserved for executing the call opcode. stipend :  ethereum.base_types.Uint The portion of gas available to sub-calls that is refundable if not consumed"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.gas.MessageCallGas.cost", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["cost"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.gas.MessageCallGas.stipend", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["stipend"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.gas.charge_gas", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/gas.py"}, "content": {"type": ["function"], "name": ["charge_gas"], "text": ["Subtracts  amount  from  evm.gas_left . Parameters evm : The current EVM. amount : The amount of gas the current operation requires."]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.gas.calculate_memory_gas_cost", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/gas.py"}, "content": {"type": ["function"], "name": ["calculate_memory_gas_cost"], "text": ["Calculates the gas cost for allocating memory to the smallest multiple of 32 bytes, such that the allocated size is at least as big as the given size. Parameters size_in_bytes : The size of the data in bytes. Returns total_gas_cost :  ethereum.base_types.Uint The gas cost for storing data in memory."]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.gas.calculate_gas_extend_memory", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/gas.py"}, "content": {"type": ["function"], "name": ["calculate_gas_extend_memory"], "text": ["Calculates the gas amount to extend memory Parameters memory : Memory contents of the EVM. extensions: List of extensions to be made to the memory. Consists of a tuple of start position and size. Returns extend_memory:  ExtendMemory"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.gas.calculate_message_call_gas", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/gas.py"}, "content": {"type": ["function"], "name": ["calculate_message_call_gas"], "text": ["Calculates the MessageCallGas (cost and stipend) for executing call Opcodes. Parameters value: The amount of  ETH  that needs to be transferred. gas : The amount of gas provided to the message-call. gas_left : The amount of gas left in the current frame. memory_cost : The amount needed to extend the memory in the current frame. extra_gas : The amount of gas needed for transferring value + creating a new account inside a message call. call_stipend : The amount of stipend provided to a message call to execute code while transferring value(ETH). Returns message_call_gas:  MessageCallGas"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.gas.max_message_call_gas", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/gas.py"}, "content": {"type": ["function"], "name": ["max_message_call_gas"], "text": ["Calculates the maximum gas that is allowed for making a message call Parameters gas : The amount of gas provided to the message-call. Returns max_allowed_message_call_gas:  ethereum.base_types.Uint The maximum gas allowed for making the message-call."]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.bitwise", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/bitwise.py"}, "content": {"type": ["module"], "name": ["ethereum.istanbul.vm.instructions.bitwise"], "text": ["Ethereum Virtual Machine (EVM) Bitwise Instructions ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementations of the EVM bitwise instructions."]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.bitwise.bitwise_and", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/bitwise.py"}, "content": {"type": ["function"], "name": ["bitwise_and"], "text": ["Bitwise AND operation of the top 2 elements of the stack. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.bitwise.bitwise_or", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/bitwise.py"}, "content": {"type": ["function"], "name": ["bitwise_or"], "text": ["Bitwise OR operation of the top 2 elements of the stack. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.bitwise.bitwise_xor", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/bitwise.py"}, "content": {"type": ["function"], "name": ["bitwise_xor"], "text": ["Bitwise XOR operation of the top 2 elements of the stack. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.bitwise.bitwise_not", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/bitwise.py"}, "content": {"type": ["function"], "name": ["bitwise_not"], "text": ["Bitwise NOT operation of the top element of the stack. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.bitwise.get_byte", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/bitwise.py"}, "content": {"type": ["function"], "name": ["get_byte"], "text": ["For a word (defined by next top element of the stack), retrieve the Nth byte (0-indexed and defined by top element of stack) from the left (most significant) to right (least significant). Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.bitwise.bitwise_shl", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/bitwise.py"}, "content": {"type": ["function"], "name": ["bitwise_shl"], "text": ["Logical shift left (SHL) operation of the top 2 elements of the stack. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.bitwise.bitwise_shr", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/bitwise.py"}, "content": {"type": ["function"], "name": ["bitwise_shr"], "text": ["Logical shift right (SHR) operation of the top 2 elements of the stack. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.bitwise.bitwise_sar", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/bitwise.py"}, "content": {"type": ["function"], "name": ["bitwise_sar"], "text": ["Arithmetic shift right (SAR) operation of the top 2 elements of the stack. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.precompiled_contracts.mapping", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/precompiled_contracts/mapping.py"}, "content": {"type": ["module"], "name": ["ethereum.tangerine_whistle.vm.precompiled_contracts.mapping"], "text": ["Precompiled Contract Addresses ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Mapping of precompiled contracts their implementations."]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.precompiled_contracts.mapping.PRE_COMPILED_CONTRACTS", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/precompiled_contracts/mapping.py"}, "content": {"type": ["attribute"], "name": ["PRE_COMPILED_CONTRACTS"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.environment", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/environment.py"}, "content": {"type": ["module"], "name": ["ethereum.istanbul.vm.instructions.environment"], "text": ["Ethereum Virtual Machine (EVM) Environmental Instructions ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementations of the EVM environment related instructions."]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.environment.address", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["address"], "text": ["Pushes the address of the current executing account to the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.environment.balance", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["balance"], "text": ["Pushes the balance of the given account onto the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.environment.origin", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["origin"], "text": ["Pushes the address of the original transaction sender to the stack. The origin address can only be an EOA. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.environment.caller", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["caller"], "text": ["Pushes the address of the caller onto the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.environment.callvalue", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["callvalue"], "text": ["Push the value (in wei) sent with the call onto the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.environment.calldataload", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["calldataload"], "text": ["Push a word (32 bytes) of the input data belonging to the current environment onto the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.environment.calldatasize", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["calldatasize"], "text": ["Push the size of input data in current environment onto the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.environment.calldatacopy", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["calldatacopy"], "text": ["Copy a portion of the input data in current environment to memory. This will also expand the memory, in case that the memory is insufficient to store the data. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.environment.codesize", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["codesize"], "text": ["Push the size of code running in current environment onto the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.environment.codecopy", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["codecopy"], "text": ["Copy a portion of the code in current environment to memory. This will also expand the memory, in case that the memory is insufficient to store the data. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.environment.gasprice", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["gasprice"], "text": ["Push the gas price used in current environment onto the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.environment.extcodesize", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["extcodesize"], "text": ["Push the code size of a given account onto the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.environment.extcodecopy", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["extcodecopy"], "text": ["Copy a portion of an account's code to memory. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.environment.returndatasize", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["returndatasize"], "text": ["Pushes the size of the return data buffer onto the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.environment.returndatacopy", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["returndatacopy"], "text": ["Copies data from the return data buffer code to memory Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.environment.extcodehash", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["extcodehash"], "text": ["Returns the keccak256 hash of a contract\u2019s bytecode Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.environment.self_balance", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["self_balance"], "text": ["Pushes the balance of the current address to the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.precompiled_contracts", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/precompiled_contracts/__init__.py"}, "content": {"type": ["module"], "name": ["ethereum.tangerine_whistle.vm.precompiled_contracts"], "text": ["Precompiled Contract Addresses ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Addresses of precompiled contracts and mappings to their implementations."]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.precompiled_contracts.__all__", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/precompiled_contracts/__init__.py"}, "content": {"type": ["attribute"], "name": ["__all__"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.precompiled_contracts.ECRECOVER_ADDRESS", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/precompiled_contracts/__init__.py"}, "content": {"type": ["attribute"], "name": ["ECRECOVER_ADDRESS"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.precompiled_contracts.SHA256_ADDRESS", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/precompiled_contracts/__init__.py"}, "content": {"type": ["attribute"], "name": ["SHA256_ADDRESS"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.precompiled_contracts.RIPEMD160_ADDRESS", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/precompiled_contracts/__init__.py"}, "content": {"type": ["attribute"], "name": ["RIPEMD160_ADDRESS"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.precompiled_contracts.IDENTITY_ADDRESS", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/precompiled_contracts/__init__.py"}, "content": {"type": ["attribute"], "name": ["IDENTITY_ADDRESS"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.stack", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/stack.py"}, "content": {"type": ["module"], "name": ["ethereum.istanbul.vm.instructions.stack"], "text": ["Ethereum Virtual Machine (EVM) Stack Instructions ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementations of the EVM stack related instructions."]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.stack.pop", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/stack.py"}, "content": {"type": ["function"], "name": ["pop"], "text": ["Remove item from stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.stack.push_n", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/stack.py"}, "content": {"type": ["function"], "name": ["push_n"], "text": ["Pushes a N-byte immediate onto the stack. Parameters evm : The current EVM frame. num_bytes : The number of immediate bytes to be read from the code and pushed to the stack."]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.stack.dup_n", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/stack.py"}, "content": {"type": ["function"], "name": ["dup_n"], "text": ["Duplicate the Nth stack item (from top of the stack) to the top of stack. Parameters evm : The current EVM frame. item_number : The stack item number (0-indexed from top of stack) to be duplicated to the top of stack."]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.stack.swap_n", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/stack.py"}, "content": {"type": ["function"], "name": ["swap_n"], "text": ["Swap the top and the  item_number  element of the stack, where the top of the stack is position zero. If  item_number  is zero, this function does nothing (which should not be possible, since there is no  SWAP0  instruction). Parameters evm : The current EVM frame. item_number : The stack item number (0-indexed from top of stack) to be swapped with the top of stack element."]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.stack.push1", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push1"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.stack.push2", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push2"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.stack.push3", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push3"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.stack.push4", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push4"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.stack.push5", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push5"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.stack.push6", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push6"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.stack.push7", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push7"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.stack.push8", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push8"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.stack.push9", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push9"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.stack.push10", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push10"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.stack.push11", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push11"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.stack.push12", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push12"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.stack.push13", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push13"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.stack.push14", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push14"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.stack.push15", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push15"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.stack.push16", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push16"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.stack.push17", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push17"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.stack.push18", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push18"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.stack.push19", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push19"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.stack.push20", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push20"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.stack.push21", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push21"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.stack.push22", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push22"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.stack.push23", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push23"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.stack.push24", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push24"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.stack.push25", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push25"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.stack.push26", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push26"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.stack.push27", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push27"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.stack.push28", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push28"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.stack.push29", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push29"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.stack.push30", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push30"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.stack.push31", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push31"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.stack.push32", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push32"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.stack.dup1", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup1"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.stack.dup2", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup2"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.stack.dup3", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup3"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.stack.dup4", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup4"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.stack.dup5", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup5"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.stack.dup6", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup6"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.stack.dup7", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup7"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.stack.dup8", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup8"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.stack.dup9", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup9"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.stack.dup10", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup10"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.stack.dup11", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup11"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.stack.dup12", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup12"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.stack.dup13", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup13"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.stack.dup14", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup14"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.stack.dup15", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup15"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.stack.dup16", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup16"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.stack.swap1", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap1"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.stack.swap2", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap2"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.stack.swap3", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap3"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.stack.swap4", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap4"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.stack.swap5", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap5"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.stack.swap6", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap6"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.stack.swap7", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap7"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.stack.swap8", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap8"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.stack.swap9", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap9"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.stack.swap10", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap10"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.stack.swap11", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap11"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.stack.swap12", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap12"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.stack.swap13", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap13"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.stack.swap14", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap14"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.stack.swap15", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap15"]}}, {"source": {"identifier": "ethereum.istanbul.vm.instructions.stack.swap16", "specifier": 0, "path": "src/ethereum/istanbul/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap16"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.precompiled_contracts.ripemd160", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/precompiled_contracts/ripemd160.py"}, "content": {"type": ["module"], "name": ["ethereum.tangerine_whistle.vm.precompiled_contracts.ripemd160"], "text": ["Ethereum Virtual Machine (EVM) RIPEMD160 PRECOMPILED CONTRACT ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementation of the  RIPEMD160  precompiled contract."]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.precompiled_contracts.ripemd160.ripemd160", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/precompiled_contracts/ripemd160.py"}, "content": {"type": ["function"], "name": ["ripemd160"], "text": ["Writes the ripemd160 hash to output. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.istanbul.utils", "specifier": 0, "path": "src/ethereum/istanbul/utils/__init__.py"}, "content": {"type": ["module"], "name": ["ethereum.istanbul.utils"], "text": ["Hardfork Utility Functions ^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Utility functions used in this istanbul version of specification."]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.precompiled_contracts.sha256", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/precompiled_contracts/sha256.py"}, "content": {"type": ["module"], "name": ["ethereum.tangerine_whistle.vm.precompiled_contracts.sha256"], "text": ["Ethereum Virtual Machine (EVM) SHA256 PRECOMPILED CONTRACT ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementation of the  SHA256  precompiled contract."]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.precompiled_contracts.sha256.sha256", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/precompiled_contracts/sha256.py"}, "content": {"type": ["function"], "name": ["sha256"], "text": ["Writes the sha256 hash to output. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.istanbul.utils.address", "specifier": 0, "path": "src/ethereum/istanbul/utils/address.py"}, "content": {"type": ["module"], "name": ["ethereum.istanbul.utils.address"], "text": ["Hardfork Utility Functions For Addresses ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Address specific functions used in this istanbul version of specification."]}}, {"source": {"identifier": "ethereum.istanbul.utils.address.to_address", "specifier": 0, "path": "src/ethereum/istanbul/utils/address.py"}, "content": {"type": ["function"], "name": ["to_address"], "text": ["Convert a Uint or U256 value to a valid address (20 bytes). Parameters data : The string to be converted to bytes. Returns address :  Address The obtained address."]}}, {"source": {"identifier": "ethereum.istanbul.utils.address.compute_contract_address", "specifier": 0, "path": "src/ethereum/istanbul/utils/address.py"}, "content": {"type": ["function"], "name": ["compute_contract_address"], "text": ["Computes address of the new account that needs to be created. Parameters address : The address of the account that wants to create the new account. nonce : The transaction count of the account that wants to create the new account. Returns address:  Address The computed address of the new account."]}}, {"source": {"identifier": "ethereum.istanbul.utils.address.compute_create2_contract_address", "specifier": 0, "path": "src/ethereum/istanbul/utils/address.py"}, "content": {"type": ["function"], "name": ["compute_create2_contract_address"], "text": ["Computes address of the new account that needs to be created, which is based on the sender address, salt and the call data as well. Parameters address : The address of the account that wants to create the new account. salt : Address generation salt. call_data : The code of the new account which is to be created. Returns address:  ethereum.istanbul.fork_types.Address The computed address of the new account."]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.precompiled_contracts.ecrecover", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/precompiled_contracts/ecrecover.py"}, "content": {"type": ["module"], "name": ["ethereum.tangerine_whistle.vm.precompiled_contracts.ecrecover"], "text": ["Ethereum Virtual Machine (EVM) ECRECOVER PRECOMPILED CONTRACT ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementation of the ECRECOVER precompiled contract."]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.precompiled_contracts.ecrecover.ecrecover", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/precompiled_contracts/ecrecover.py"}, "content": {"type": ["function"], "name": ["ecrecover"], "text": ["Decrypts the address using elliptic curve DSA recovery mechanism and writes the address to output. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.istanbul.utils.message", "specifier": 0, "path": "src/ethereum/istanbul/utils/message.py"}, "content": {"type": ["module"], "name": ["ethereum.istanbul.utils.message"], "text": ["Hardfork Utility Functions For The Message Data-structure ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Message specific functions used in this istanbul version of specification."]}}, {"source": {"identifier": "ethereum.istanbul.utils.message.prepare_message", "specifier": 0, "path": "src/ethereum/istanbul/utils/message.py"}, "content": {"type": ["function"], "name": ["prepare_message"], "text": ["Execute a transaction against the provided environment. Parameters caller : Address which initiated the transaction target : Address whose code will be executed value : Value to be transferred. data : Array of bytes provided to the code in  target . gas : Gas provided for the code in  target . env : Environment for the Ethereum Virtual Machine. code_address : This is usually same as the  target  address except when an alternative accounts code needs to be executed. eg.  CALLCODE  calling a precompile. should_transfer_value : if True ETH should be transferred while executing a message call. is_static: if True then it prevents all state-changing operations from being executed. Returns message:  ethereum.istanbul.vm.Message Items containing contract creation or message call specific data."]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.precompiled_contracts.identity", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/precompiled_contracts/identity.py"}, "content": {"type": ["module"], "name": ["ethereum.tangerine_whistle.vm.precompiled_contracts.identity"], "text": ["Ethereum Virtual Machine (EVM) IDENTITY PRECOMPILED CONTRACT ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementation of the  IDENTITY  precompiled contract."]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.precompiled_contracts.identity.identity", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/precompiled_contracts/identity.py"}, "content": {"type": ["function"], "name": ["identity"], "text": ["Writes the message data to output. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.istanbul.utils.hexadecimal", "specifier": 0, "path": "src/ethereum/istanbul/utils/hexadecimal.py"}, "content": {"type": ["module"], "name": ["ethereum.istanbul.utils.hexadecimal"], "text": ["Utility Functions For Hexadecimal Strings ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Hexadecimal utility functions used in this specification, specific to Istanbul types."]}}, {"source": {"identifier": "ethereum.istanbul.utils.hexadecimal.hex_to_root", "specifier": 0, "path": "src/ethereum/istanbul/utils/hexadecimal.py"}, "content": {"type": ["function"], "name": ["hex_to_root"], "text": ["Convert hex string to trie root. Parameters hex_string : The hexadecimal string to be converted to trie root. Returns root :  Root Trie root obtained from the given hexadecimal string."]}}, {"source": {"identifier": "ethereum.istanbul.utils.hexadecimal.hex_to_bloom", "specifier": 0, "path": "src/ethereum/istanbul/utils/hexadecimal.py"}, "content": {"type": ["function"], "name": ["hex_to_bloom"], "text": ["Convert hex string to bloom. Parameters hex_string : The hexadecimal string to be converted to bloom. Returns bloom :  Bloom Bloom obtained from the given hexadecimal string."]}}, {"source": {"identifier": "ethereum.istanbul.utils.hexadecimal.hex_to_address", "specifier": 0, "path": "src/ethereum/istanbul/utils/hexadecimal.py"}, "content": {"type": ["function"], "name": ["hex_to_address"], "text": ["Convert hex string to Address (20 bytes). Parameters hex_string : The hexadecimal string to be converted to Address. Returns address :  Address The address obtained from the given hexadecimal string."]}}, {"source": {"identifier": "ethereum.frontier.state", "specifier": 0, "path": "src/ethereum/frontier/state.py"}, "content": {"type": ["module"], "name": ["ethereum.frontier.state"], "text": ["State ^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction The state contains all information that is preserved between transactions. It consists of a main account trie and storage tries for each contract. There is a distinction between an account that does not exist and EMPTY_ACCOUNT ."]}}, {"source": {"identifier": "ethereum.frontier.state.State", "specifier": 0, "path": "src/ethereum/frontier/state.py"}, "content": {"type": ["class"], "name": ["State"], "text": ["Contains all information that is preserved between transactions."]}}, {"source": {"identifier": "ethereum.frontier.state.State._main_trie", "specifier": 0, "path": "src/ethereum/frontier/state.py"}, "content": {"type": ["attribute"], "name": ["_main_trie"]}}, {"source": {"identifier": "ethereum.frontier.state.State._storage_tries", "specifier": 0, "path": "src/ethereum/frontier/state.py"}, "content": {"type": ["attribute"], "name": ["_storage_tries"]}}, {"source": {"identifier": "ethereum.frontier.state.State._snapshots", "specifier": 0, "path": "src/ethereum/frontier/state.py"}, "content": {"type": ["attribute"], "name": ["_snapshots"]}}, {"source": {"identifier": "ethereum.frontier.state.close_state", "specifier": 0, "path": "src/ethereum/frontier/state.py"}, "content": {"type": ["function"], "name": ["close_state"], "text": ["Free resources held by the state. Used by optimized implementations to release file descriptors."]}}, {"source": {"identifier": "ethereum.frontier.state.begin_transaction", "specifier": 0, "path": "src/ethereum/frontier/state.py"}, "content": {"type": ["function"], "name": ["begin_transaction"], "text": ["Start a state transaction. Transactions are entirely implicit and can be nested. It is not possible to calculate the state root during a transaction. Parameters state : State The state."]}}, {"source": {"identifier": "ethereum.frontier.state.commit_transaction", "specifier": 0, "path": "src/ethereum/frontier/state.py"}, "content": {"type": ["function"], "name": ["commit_transaction"], "text": ["Commit a state transaction. Parameters state : State The state."]}}, {"source": {"identifier": "ethereum.frontier.state.rollback_transaction", "specifier": 0, "path": "src/ethereum/frontier/state.py"}, "content": {"type": ["function"], "name": ["rollback_transaction"], "text": ["Rollback a state transaction, resetting the state to the point when the corresponding  start_transaction()  call was made. Parameters state : State The state."]}}, {"source": {"identifier": "ethereum.frontier.state.get_account", "specifier": 0, "path": "src/ethereum/frontier/state.py"}, "content": {"type": ["function"], "name": ["get_account"], "text": ["Get the  Account  object at an address. Returns  EMPTY_ACCOUNT  if there is no account at the address. Use  get_account_optional()  if you care about the difference between a non-existent account and  EMPTY_ACCOUNT . Parameters state:  State The state address :  Address Address to lookup. Returns account :  Account Account at address."]}}, {"source": {"identifier": "ethereum.frontier.state.get_account_optional", "specifier": 0, "path": "src/ethereum/frontier/state.py"}, "content": {"type": ["function"], "name": ["get_account_optional"], "text": ["Get the  Account  object at an address. Returns  None  (rather than EMPTY_ACCOUNT ) if there is no account at the address. Parameters state:  State The state address :  Address Address to lookup. Returns account :  Account Account at address."]}}, {"source": {"identifier": "ethereum.frontier.state.set_account", "specifier": 0, "path": "src/ethereum/frontier/state.py"}, "content": {"type": ["function"], "name": ["set_account"], "text": ["Set the  Account  object at an address. Setting to  None  deletes the account (but not its storage, see  destroy_account() ). Parameters state:  State The state address :  Address Address to set. account :  Account Account to set at address."]}}, {"source": {"identifier": "ethereum.frontier.state.destroy_account", "specifier": 0, "path": "src/ethereum/frontier/state.py"}, "content": {"type": ["function"], "name": ["destroy_account"], "text": ["Completely remove the account at  address  and all of its storage. This function is made available exclusively for the  SELFDESTRUCT opcode. It is expected that  SELFDESTRUCT  will be disabled in a future hardfork and this function will be removed. Parameters state:  State The state address :  Address Address of account to destroy."]}}, {"source": {"identifier": "ethereum.frontier.state.destroy_storage", "specifier": 0, "path": "src/ethereum/frontier/state.py"}, "content": {"type": ["function"], "name": ["destroy_storage"], "text": ["Completely remove the storage at  address . Parameters state:  State The state address :  Address Address of account whose storage is to be deleted."]}}, {"source": {"identifier": "ethereum.frontier.state.get_storage", "specifier": 0, "path": "src/ethereum/frontier/state.py"}, "content": {"type": ["function"], "name": ["get_storage"], "text": ["Get a value at a storage key on an account. Returns  U256(0)  if the storage key has not been set previously. Parameters state:  State The state address :  Address Address of the account. key :  Bytes Key to lookup. Returns value :  U256 Value at the key."]}}, {"source": {"identifier": "ethereum.frontier.state.set_storage", "specifier": 0, "path": "src/ethereum/frontier/state.py"}, "content": {"type": ["function"], "name": ["set_storage"], "text": ["Set a value at a storage key on an account. Setting to  U256(0)  deletes the key. Parameters state:  State The state address :  Address Address of the account. key :  Bytes Key to set. value :  U256 Value to set at the key."]}}, {"source": {"identifier": "ethereum.frontier.state.storage_root", "specifier": 0, "path": "src/ethereum/frontier/state.py"}, "content": {"type": ["function"], "name": ["storage_root"], "text": ["Calculate the storage root of an account. Parameters state: The state address : Address of the account. Returns root :  Root Storage root of the account."]}}, {"source": {"identifier": "ethereum.frontier.state.state_root", "specifier": 0, "path": "src/ethereum/frontier/state.py"}, "content": {"type": ["function"], "name": ["state_root"], "text": ["Calculate the state root. Parameters state: The current state. Returns root :  Root The state root."]}}, {"source": {"identifier": "ethereum.frontier.state.account_exists", "specifier": 0, "path": "src/ethereum/frontier/state.py"}, "content": {"type": ["function"], "name": ["account_exists"], "text": ["Checks if an account exists in the state trie Parameters state: The state address: Address of the account that needs to be checked. Returns account_exists :  bool True if account exists in the state trie, False otherwise"]}}, {"source": {"identifier": "ethereum.frontier.state.account_has_code_or_nonce", "specifier": 0, "path": "src/ethereum/frontier/state.py"}, "content": {"type": ["function"], "name": ["account_has_code_or_nonce"], "text": ["Checks if an account has non zero nonce or non empty code Parameters state: The state address: Address of the account that needs to be checked. Returns has_code_or_nonce :  bool True if if an account has non zero nonce or non empty code, False otherwise."]}}, {"source": {"identifier": "ethereum.frontier.state.modify_state", "specifier": 0, "path": "src/ethereum/frontier/state.py"}, "content": {"type": ["function"], "name": ["modify_state"], "text": ["Modify an  Account  in the  State ."]}}, {"source": {"identifier": "ethereum.frontier.state.move_ether", "specifier": 0, "path": "src/ethereum/frontier/state.py"}, "content": {"type": ["function"], "name": ["move_ether"], "text": ["Move funds between accounts."]}}, {"source": {"identifier": "ethereum.frontier.state.set_account_balance", "specifier": 0, "path": "src/ethereum/frontier/state.py"}, "content": {"type": ["function"], "name": ["set_account_balance"], "text": ["Sets the balance of an account. Parameters state: The current state. address: Address of the account whose nonce needs to be incremented. amount: The amount that needs to set in balance."]}}, {"source": {"identifier": "ethereum.frontier.state.touch_account", "specifier": 0, "path": "src/ethereum/frontier/state.py"}, "content": {"type": ["function"], "name": ["touch_account"], "text": ["Initializes an account to state. Parameters state: The current state. address: The address of the account that need to initialised."]}}, {"source": {"identifier": "ethereum.frontier.state.increment_nonce", "specifier": 0, "path": "src/ethereum/frontier/state.py"}, "content": {"type": ["function"], "name": ["increment_nonce"], "text": ["Increments the nonce of an account. Parameters state: The current state. address: Address of the account whose nonce needs to be incremented."]}}, {"source": {"identifier": "ethereum.frontier.state.set_code", "specifier": 0, "path": "src/ethereum/frontier/state.py"}, "content": {"type": ["function"], "name": ["set_code"], "text": ["Sets Account code. Parameters state: The current state. address: Address of the account whose code needs to be update. code: The bytecode that needs to be set."]}}, {"source": {"identifier": "ethereum.frontier.state.create_ether", "specifier": 0, "path": "src/ethereum/frontier/state.py"}, "content": {"type": ["function"], "name": ["create_ether"], "text": ["Add newly created ether to an account. Parameters state: The current state. address: Address of the account to which ether is added. amount: The amount of ether to be added to the account of interest."]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.memory", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/memory.py"}, "content": {"type": ["module"], "name": ["ethereum.tangerine_whistle.vm.instructions.memory"], "text": ["Ethereum Virtual Machine (EVM) Memory Instructions ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementations of the EVM Memory instructions."]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.memory.mstore", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/memory.py"}, "content": {"type": ["function"], "name": ["mstore"], "text": ["Stores a word to memory. This also expands the memory, if the memory is insufficient to store the word. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.memory.mstore8", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/memory.py"}, "content": {"type": ["function"], "name": ["mstore8"], "text": ["Stores a byte to memory. This also expands the memory, if the memory is insufficient to store the word. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.memory.mload", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/memory.py"}, "content": {"type": ["function"], "name": ["mload"], "text": ["Load word from memory. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.memory.msize", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/memory.py"}, "content": {"type": ["function"], "name": ["msize"], "text": ["Push the size of active memory in bytes onto the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.frontier", "specifier": 0, "path": "src/ethereum/frontier/__init__.py"}, "content": {"type": ["module"], "name": ["ethereum.frontier"], "text": ["Ethereum Frontier Hardfork ^^^^^^^^^^^^^^^^^^^^^^^^^^ The first Ethereum hardfork."]}}, {"source": {"identifier": "ethereum.frontier.MAINNET_FORK_BLOCK", "specifier": 0, "path": "src/ethereum/frontier/__init__.py"}, "content": {"type": ["attribute"], "name": ["MAINNET_FORK_BLOCK"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.system", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/system.py"}, "content": {"type": ["module"], "name": ["ethereum.tangerine_whistle.vm.instructions.system"], "text": ["Ethereum Virtual Machine (EVM) System Instructions ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementations of the EVM system related instructions."]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.system.create", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/system.py"}, "content": {"type": ["function"], "name": ["create"], "text": ["Creates a new account with associated code. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.system.return_", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/system.py"}, "content": {"type": ["function"], "name": ["return_"], "text": ["Halts execution returning output data. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.system.generic_call", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/system.py"}, "content": {"type": ["function"], "name": ["generic_call"], "text": ["Perform the core logic of the  CALL*  family of opcodes."]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.system.call", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/system.py"}, "content": {"type": ["function"], "name": ["call"], "text": ["Message-call into an account. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.system.callcode", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/system.py"}, "content": {"type": ["function"], "name": ["callcode"], "text": ["Message-call into this account with alternative account\u2019s code. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.system.selfdestruct", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/system.py"}, "content": {"type": ["function"], "name": ["selfdestruct"], "text": ["Halt execution and register account for later deletion. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.system.delegatecall", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/system.py"}, "content": {"type": ["function"], "name": ["delegatecall"], "text": ["Message-call into an account. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.frontier.bloom", "specifier": 0, "path": "src/ethereum/frontier/bloom.py"}, "content": {"type": ["module"], "name": ["ethereum.frontier.bloom"], "text": ["Ethereum Logs Bloom ^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction This modules defines functions for calculating bloom filters of logs. For the general theory of bloom filters see e.g.  Wikipedia <https://en.wikipedia.org/wiki/Bloom_filter> _. Bloom filters are used to allow for efficient searching of logs by address and/or topic, by rapidly eliminating blocks and reciepts from their search."]}}, {"source": {"identifier": "ethereum.frontier.bloom.add_to_bloom", "specifier": 0, "path": "src/ethereum/frontier/bloom.py"}, "content": {"type": ["function"], "name": ["add_to_bloom"], "text": ["Add a bloom entry to the bloom filter ( bloom ). The number of hash functions used is 3. They are calculated by taking the least significant 11 bits from the first 3 16-bit words of the keccak_256()  hash of  bloom_entry . Parameters bloom : The bloom filter. bloom_entry : An entry which is to be added to bloom filter."]}}, {"source": {"identifier": "ethereum.frontier.bloom.logs_bloom", "specifier": 0, "path": "src/ethereum/frontier/bloom.py"}, "content": {"type": ["function"], "name": ["logs_bloom"], "text": ["Obtain the logs bloom from a list of log entries. The address and each topic of a log are added to the bloom filter. Parameters logs : List of logs for which the logs bloom is to be obtained. Returns logs_bloom :  Bloom The logs bloom obtained which is 256 bytes with some bits set as per the caller address and the log topics."]}}, {"source": {"identifier": "ethereum.frontier.fork_types", "specifier": 0, "path": "src/ethereum/frontier/fork_types.py"}, "content": {"type": ["module"], "name": ["ethereum.frontier.fork_types"], "text": ["Ethereum Types ^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Types re-used throughout the specification, which are specific to Ethereum."]}}, {"source": {"identifier": "ethereum.frontier.fork_types.Address", "specifier": 0, "path": "src/ethereum/frontier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["Address"]}}, {"source": {"identifier": "ethereum.frontier.fork_types.Root", "specifier": 0, "path": "src/ethereum/frontier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["Root"]}}, {"source": {"identifier": "ethereum.frontier.fork_types.Bloom", "specifier": 0, "path": "src/ethereum/frontier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["Bloom"]}}, {"source": {"identifier": "ethereum.frontier.fork_types.TX_BASE_COST", "specifier": 0, "path": "src/ethereum/frontier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["TX_BASE_COST"]}}, {"source": {"identifier": "ethereum.frontier.fork_types.TX_DATA_COST_PER_NON_ZERO", "specifier": 0, "path": "src/ethereum/frontier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["TX_DATA_COST_PER_NON_ZERO"]}}, {"source": {"identifier": "ethereum.frontier.fork_types.TX_DATA_COST_PER_ZERO", "specifier": 0, "path": "src/ethereum/frontier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["TX_DATA_COST_PER_ZERO"]}}, {"source": {"identifier": "ethereum.frontier.fork_types.Transaction", "specifier": 0, "path": "src/ethereum/frontier/fork_types.py"}, "content": {"type": ["class"], "name": ["Transaction"], "text": ["Atomic operation performed on the block chain."]}}, {"source": {"identifier": "ethereum.frontier.fork_types.Transaction.nonce", "specifier": 0, "path": "src/ethereum/frontier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["nonce"]}}, {"source": {"identifier": "ethereum.frontier.fork_types.Transaction.gas_price", "specifier": 0, "path": "src/ethereum/frontier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["gas_price"]}}, {"source": {"identifier": "ethereum.frontier.fork_types.Transaction.gas", "specifier": 0, "path": "src/ethereum/frontier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["gas"]}}, {"source": {"identifier": "ethereum.frontier.fork_types.Transaction.to", "specifier": 0, "path": "src/ethereum/frontier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["to"]}}, {"source": {"identifier": "ethereum.frontier.fork_types.Transaction.value", "specifier": 0, "path": "src/ethereum/frontier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["value"]}}, {"source": {"identifier": "ethereum.frontier.fork_types.Transaction.data", "specifier": 0, "path": "src/ethereum/frontier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["data"]}}, {"source": {"identifier": "ethereum.frontier.fork_types.Transaction.v", "specifier": 0, "path": "src/ethereum/frontier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["v"]}}, {"source": {"identifier": "ethereum.frontier.fork_types.Transaction.r", "specifier": 0, "path": "src/ethereum/frontier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["r"]}}, {"source": {"identifier": "ethereum.frontier.fork_types.Transaction.s", "specifier": 0, "path": "src/ethereum/frontier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["s"]}}, {"source": {"identifier": "ethereum.frontier.fork_types.Account", "specifier": 0, "path": "src/ethereum/frontier/fork_types.py"}, "content": {"type": ["class"], "name": ["Account"], "text": ["State associated with an address."]}}, {"source": {"identifier": "ethereum.frontier.fork_types.Account.nonce", "specifier": 0, "path": "src/ethereum/frontier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["nonce"]}}, {"source": {"identifier": "ethereum.frontier.fork_types.Account.balance", "specifier": 0, "path": "src/ethereum/frontier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["balance"]}}, {"source": {"identifier": "ethereum.frontier.fork_types.Account.code", "specifier": 0, "path": "src/ethereum/frontier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["code"]}}, {"source": {"identifier": "ethereum.frontier.fork_types.EMPTY_ACCOUNT", "specifier": 0, "path": "src/ethereum/frontier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["EMPTY_ACCOUNT"]}}, {"source": {"identifier": "ethereum.frontier.fork_types.encode_account", "specifier": 0, "path": "src/ethereum/frontier/fork_types.py"}, "content": {"type": ["function"], "name": ["encode_account"], "text": ["Encode  Account  dataclass. Storage is not stored in the  Account  dataclass, so  Accounts  cannot be encoded with providing a storage root."]}}, {"source": {"identifier": "ethereum.frontier.fork_types.Header", "specifier": 0, "path": "src/ethereum/frontier/fork_types.py"}, "content": {"type": ["class"], "name": ["Header"], "text": ["Header portion of a block on the chain."]}}, {"source": {"identifier": "ethereum.frontier.fork_types.Header.parent_hash", "specifier": 0, "path": "src/ethereum/frontier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["parent_hash"]}}, {"source": {"identifier": "ethereum.frontier.fork_types.Header.ommers_hash", "specifier": 0, "path": "src/ethereum/frontier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["ommers_hash"]}}, {"source": {"identifier": "ethereum.frontier.fork_types.Header.coinbase", "specifier": 0, "path": "src/ethereum/frontier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["coinbase"]}}, {"source": {"identifier": "ethereum.frontier.fork_types.Header.state_root", "specifier": 0, "path": "src/ethereum/frontier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["state_root"]}}, {"source": {"identifier": "ethereum.frontier.fork_types.Header.transactions_root", "specifier": 0, "path": "src/ethereum/frontier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["transactions_root"]}}, {"source": {"identifier": "ethereum.frontier.fork_types.Header.receipt_root", "specifier": 0, "path": "src/ethereum/frontier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["receipt_root"]}}, {"source": {"identifier": "ethereum.frontier.fork_types.Header.bloom", "specifier": 0, "path": "src/ethereum/frontier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["bloom"]}}, {"source": {"identifier": "ethereum.frontier.fork_types.Header.difficulty", "specifier": 0, "path": "src/ethereum/frontier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["difficulty"]}}, {"source": {"identifier": "ethereum.frontier.fork_types.Header.number", "specifier": 0, "path": "src/ethereum/frontier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["number"]}}, {"source": {"identifier": "ethereum.frontier.fork_types.Header.gas_limit", "specifier": 0, "path": "src/ethereum/frontier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["gas_limit"]}}, {"source": {"identifier": "ethereum.frontier.fork_types.Header.gas_used", "specifier": 0, "path": "src/ethereum/frontier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["gas_used"]}}, {"source": {"identifier": "ethereum.frontier.fork_types.Header.timestamp", "specifier": 0, "path": "src/ethereum/frontier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["timestamp"]}}, {"source": {"identifier": "ethereum.frontier.fork_types.Header.extra_data", "specifier": 0, "path": "src/ethereum/frontier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["extra_data"]}}, {"source": {"identifier": "ethereum.frontier.fork_types.Header.mix_digest", "specifier": 0, "path": "src/ethereum/frontier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["mix_digest"]}}, {"source": {"identifier": "ethereum.frontier.fork_types.Header.nonce", "specifier": 0, "path": "src/ethereum/frontier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["nonce"]}}, {"source": {"identifier": "ethereum.frontier.fork_types.Block", "specifier": 0, "path": "src/ethereum/frontier/fork_types.py"}, "content": {"type": ["class"], "name": ["Block"], "text": ["A complete block."]}}, {"source": {"identifier": "ethereum.frontier.fork_types.Block.header", "specifier": 0, "path": "src/ethereum/frontier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["header"]}}, {"source": {"identifier": "ethereum.frontier.fork_types.Block.transactions", "specifier": 0, "path": "src/ethereum/frontier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["transactions"]}}, {"source": {"identifier": "ethereum.frontier.fork_types.Block.ommers", "specifier": 0, "path": "src/ethereum/frontier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["ommers"]}}, {"source": {"identifier": "ethereum.frontier.fork_types.Log", "specifier": 0, "path": "src/ethereum/frontier/fork_types.py"}, "content": {"type": ["class"], "name": ["Log"], "text": ["Data record produced during the execution of a transaction."]}}, {"source": {"identifier": "ethereum.frontier.fork_types.Log.address", "specifier": 0, "path": "src/ethereum/frontier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["address"]}}, {"source": {"identifier": "ethereum.frontier.fork_types.Log.topics", "specifier": 0, "path": "src/ethereum/frontier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["topics"]}}, {"source": {"identifier": "ethereum.frontier.fork_types.Log.data", "specifier": 0, "path": "src/ethereum/frontier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["data"]}}, {"source": {"identifier": "ethereum.frontier.fork_types.Receipt", "specifier": 0, "path": "src/ethereum/frontier/fork_types.py"}, "content": {"type": ["class"], "name": ["Receipt"], "text": ["Result of a transaction."]}}, {"source": {"identifier": "ethereum.frontier.fork_types.Receipt.post_state", "specifier": 0, "path": "src/ethereum/frontier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["post_state"]}}, {"source": {"identifier": "ethereum.frontier.fork_types.Receipt.cumulative_gas_used", "specifier": 0, "path": "src/ethereum/frontier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["cumulative_gas_used"]}}, {"source": {"identifier": "ethereum.frontier.fork_types.Receipt.bloom", "specifier": 0, "path": "src/ethereum/frontier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["bloom"]}}, {"source": {"identifier": "ethereum.frontier.fork_types.Receipt.logs", "specifier": 0, "path": "src/ethereum/frontier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["logs"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/__init__.py"}, "content": {"type": ["module"], "name": ["ethereum.tangerine_whistle.vm.instructions"], "text": ["EVM Instruction Encoding (Opcodes) ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Machine readable representations of EVM instructions, and a mapping to their implementations."]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.Ops", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/__init__.py"}, "content": {"type": ["class"], "name": ["Ops"], "text": ["Enum for EVM Opcodes"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.Ops.ADD", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["ADD"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.Ops.MUL", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["MUL"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.Ops.SUB", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SUB"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.Ops.DIV", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DIV"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.Ops.SDIV", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SDIV"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.Ops.MOD", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["MOD"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.Ops.SMOD", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SMOD"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.Ops.ADDMOD", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["ADDMOD"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.Ops.MULMOD", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["MULMOD"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.Ops.EXP", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["EXP"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.Ops.SIGNEXTEND", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SIGNEXTEND"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.Ops.LT", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["LT"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.Ops.GT", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["GT"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.Ops.SLT", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SLT"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.Ops.SGT", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SGT"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.Ops.EQ", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["EQ"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.Ops.ISZERO", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["ISZERO"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.Ops.AND", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["AND"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.Ops.OR", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["OR"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.Ops.XOR", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["XOR"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.Ops.NOT", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["NOT"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.Ops.BYTE", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["BYTE"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.Ops.KECCAK", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["KECCAK"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.Ops.ADDRESS", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["ADDRESS"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.Ops.BALANCE", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["BALANCE"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.Ops.ORIGIN", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["ORIGIN"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.Ops.CALLER", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["CALLER"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.Ops.CALLVALUE", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["CALLVALUE"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.Ops.CALLDATALOAD", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["CALLDATALOAD"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.Ops.CALLDATASIZE", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["CALLDATASIZE"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.Ops.CALLDATACOPY", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["CALLDATACOPY"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.Ops.CODESIZE", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["CODESIZE"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.Ops.CODECOPY", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["CODECOPY"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.Ops.GASPRICE", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["GASPRICE"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.Ops.EXTCODESIZE", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["EXTCODESIZE"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.Ops.EXTCODECOPY", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["EXTCODECOPY"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.Ops.BLOCKHASH", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["BLOCKHASH"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.Ops.COINBASE", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["COINBASE"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.Ops.TIMESTAMP", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["TIMESTAMP"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.Ops.NUMBER", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["NUMBER"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.Ops.DIFFICULTY", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DIFFICULTY"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.Ops.GASLIMIT", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["GASLIMIT"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.Ops.STOP", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["STOP"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.Ops.JUMP", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["JUMP"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.Ops.JUMPI", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["JUMPI"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.Ops.PC", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PC"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.Ops.GAS", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["GAS"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.Ops.JUMPDEST", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["JUMPDEST"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.Ops.SLOAD", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SLOAD"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.Ops.SSTORE", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SSTORE"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.Ops.POP", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["POP"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.Ops.PUSH1", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH1"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.Ops.PUSH2", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH2"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.Ops.PUSH3", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH3"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.Ops.PUSH4", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH4"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.Ops.PUSH5", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH5"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.Ops.PUSH6", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH6"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.Ops.PUSH7", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH7"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.Ops.PUSH8", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH8"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.Ops.PUSH9", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH9"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.Ops.PUSH10", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH10"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.Ops.PUSH11", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH11"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.Ops.PUSH12", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH12"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.Ops.PUSH13", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH13"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.Ops.PUSH14", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH14"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.Ops.PUSH15", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH15"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.Ops.PUSH16", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH16"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.Ops.PUSH17", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH17"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.Ops.PUSH18", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH18"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.Ops.PUSH19", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH19"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.Ops.PUSH20", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH20"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.Ops.PUSH21", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH21"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.Ops.PUSH22", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH22"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.Ops.PUSH23", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH23"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.Ops.PUSH24", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH24"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.Ops.PUSH25", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH25"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.Ops.PUSH26", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH26"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.Ops.PUSH27", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH27"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.Ops.PUSH28", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH28"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.Ops.PUSH29", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH29"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.Ops.PUSH30", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH30"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.Ops.PUSH31", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH31"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.Ops.PUSH32", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH32"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.Ops.DUP1", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP1"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.Ops.DUP2", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP2"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.Ops.DUP3", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP3"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.Ops.DUP4", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP4"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.Ops.DUP5", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP5"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.Ops.DUP6", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP6"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.Ops.DUP7", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP7"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.Ops.DUP8", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP8"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.Ops.DUP9", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP9"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.Ops.DUP10", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP10"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.Ops.DUP11", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP11"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.Ops.DUP12", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP12"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.Ops.DUP13", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP13"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.Ops.DUP14", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP14"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.Ops.DUP15", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP15"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.Ops.DUP16", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP16"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.Ops.SWAP1", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP1"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.Ops.SWAP2", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP2"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.Ops.SWAP3", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP3"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.Ops.SWAP4", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP4"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.Ops.SWAP5", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP5"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.Ops.SWAP6", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP6"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.Ops.SWAP7", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP7"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.Ops.SWAP8", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP8"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.Ops.SWAP9", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP9"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.Ops.SWAP10", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP10"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.Ops.SWAP11", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP11"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.Ops.SWAP12", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP12"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.Ops.SWAP13", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP13"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.Ops.SWAP14", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP14"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.Ops.SWAP15", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP15"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.Ops.SWAP16", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP16"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.Ops.MLOAD", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["MLOAD"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.Ops.MSTORE", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["MSTORE"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.Ops.MSTORE8", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["MSTORE8"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.Ops.MSIZE", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["MSIZE"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.Ops.LOG0", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["LOG0"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.Ops.LOG1", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["LOG1"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.Ops.LOG2", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["LOG2"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.Ops.LOG3", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["LOG3"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.Ops.LOG4", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["LOG4"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.Ops.CREATE", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["CREATE"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.Ops.RETURN", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["RETURN"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.Ops.CALL", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["CALL"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.Ops.CALLCODE", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["CALLCODE"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.Ops.DELEGATECALL", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DELEGATECALL"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.Ops.SELFDESTRUCT", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SELFDESTRUCT"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.op_implementation", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["op_implementation"]}}, {"source": {"identifier": "ethereum.frontier.trie", "specifier": 0, "path": "src/ethereum/frontier/trie.py"}, "content": {"type": ["module"], "name": ["ethereum.frontier.trie"], "text": ["State Trie ^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction The state trie is the structure responsible for storing .fork_types.Account  objects."]}}, {"source": {"identifier": "ethereum.frontier.trie.EMPTY_TRIE_ROOT", "specifier": 0, "path": "src/ethereum/frontier/trie.py"}, "content": {"type": ["attribute"], "name": ["EMPTY_TRIE_ROOT"]}}, {"source": {"identifier": "ethereum.frontier.trie.Node", "specifier": 0, "path": "src/ethereum/frontier/trie.py"}, "content": {"type": ["attribute"], "name": ["Node"]}}, {"source": {"identifier": "ethereum.frontier.trie.K", "specifier": 0, "path": "src/ethereum/frontier/trie.py"}, "content": {"type": ["attribute"], "name": ["K"]}}, {"source": {"identifier": "ethereum.frontier.trie.V", "specifier": 0, "path": "src/ethereum/frontier/trie.py"}, "content": {"type": ["attribute"], "name": ["V"]}}, {"source": {"identifier": "ethereum.frontier.trie.LeafNode", "specifier": 0, "path": "src/ethereum/frontier/trie.py"}, "content": {"type": ["class"], "name": ["LeafNode"], "text": ["Leaf node in the Merkle Trie"]}}, {"source": {"identifier": "ethereum.frontier.trie.LeafNode.rest_of_key", "specifier": 0, "path": "src/ethereum/frontier/trie.py"}, "content": {"type": ["attribute"], "name": ["rest_of_key"]}}, {"source": {"identifier": "ethereum.frontier.trie.LeafNode.value", "specifier": 0, "path": "src/ethereum/frontier/trie.py"}, "content": {"type": ["attribute"], "name": ["value"]}}, {"source": {"identifier": "ethereum.frontier.trie.ExtensionNode", "specifier": 0, "path": "src/ethereum/frontier/trie.py"}, "content": {"type": ["class"], "name": ["ExtensionNode"], "text": ["Extension node in the Merkle Trie"]}}, {"source": {"identifier": "ethereum.frontier.trie.ExtensionNode.key_segment", "specifier": 0, "path": "src/ethereum/frontier/trie.py"}, "content": {"type": ["attribute"], "name": ["key_segment"]}}, {"source": {"identifier": "ethereum.frontier.trie.ExtensionNode.subnode", "specifier": 0, "path": "src/ethereum/frontier/trie.py"}, "content": {"type": ["attribute"], "name": ["subnode"]}}, {"source": {"identifier": "ethereum.frontier.trie.BranchNode", "specifier": 0, "path": "src/ethereum/frontier/trie.py"}, "content": {"type": ["class"], "name": ["BranchNode"], "text": ["Branch node in the Merkle Trie"]}}, {"source": {"identifier": "ethereum.frontier.trie.BranchNode.subnodes", "specifier": 0, "path": "src/ethereum/frontier/trie.py"}, "content": {"type": ["attribute"], "name": ["subnodes"]}}, {"source": {"identifier": "ethereum.frontier.trie.BranchNode.value", "specifier": 0, "path": "src/ethereum/frontier/trie.py"}, "content": {"type": ["attribute"], "name": ["value"]}}, {"source": {"identifier": "ethereum.frontier.trie.InternalNode", "specifier": 0, "path": "src/ethereum/frontier/trie.py"}, "content": {"type": ["attribute"], "name": ["InternalNode"]}}, {"source": {"identifier": "ethereum.frontier.trie.encode_internal_node", "specifier": 0, "path": "src/ethereum/frontier/trie.py"}, "content": {"type": ["function"], "name": ["encode_internal_node"], "text": ["Encodes a Merkle Trie node into its RLP form. The RLP will then be serialized into a  Bytes  and hashed unless it is less that 32 bytes when serialized. This function also accepts  None , representing the absence of a node, which is encoded to  b\"\" . Parameters node : Optional[InternalNode] The node to encode. Returns encoded :  rlp.RLP The node encoded as RLP."]}}, {"source": {"identifier": "ethereum.frontier.trie.encode_node", "specifier": 0, "path": "src/ethereum/frontier/trie.py"}, "content": {"type": ["function"], "name": ["encode_node"], "text": ["Encode a Node for storage in the Merkle Trie. Currently mostly an unimplemented stub."]}}, {"source": {"identifier": "ethereum.frontier.trie.Trie", "specifier": 0, "path": "src/ethereum/frontier/trie.py"}, "content": {"type": ["class"], "name": ["Trie"], "text": ["The Merkle Trie."]}}, {"source": {"identifier": "ethereum.frontier.trie.Trie.secured", "specifier": 0, "path": "src/ethereum/frontier/trie.py"}, "content": {"type": ["attribute"], "name": ["secured"]}}, {"source": {"identifier": "ethereum.frontier.trie.Trie.default", "specifier": 0, "path": "src/ethereum/frontier/trie.py"}, "content": {"type": ["attribute"], "name": ["default"]}}, {"source": {"identifier": "ethereum.frontier.trie.Trie._data", "specifier": 0, "path": "src/ethereum/frontier/trie.py"}, "content": {"type": ["attribute"], "name": ["_data"]}}, {"source": {"identifier": "ethereum.frontier.trie.copy_trie", "specifier": 0, "path": "src/ethereum/frontier/trie.py"}, "content": {"type": ["function"], "name": ["copy_trie"], "text": ["Create a copy of  trie . Since only frozen objects may be stored in tries, the contents are reused. Parameters trie:  Trie Trie to copy. Returns new_trie :  Trie[K, V] A copy of the trie."]}}, {"source": {"identifier": "ethereum.frontier.trie.trie_set", "specifier": 0, "path": "src/ethereum/frontier/trie.py"}, "content": {"type": ["function"], "name": ["trie_set"], "text": ["Stores an item in a Merkle Trie. This method deletes the key if  value == trie.default , because the Merkle Trie represents the default value by omitting it from the trie. Parameters trie:  Trie Trie to store in. key :  Bytes Key to lookup. value :  V Node to insert at  key ."]}}, {"source": {"identifier": "ethereum.frontier.trie.trie_get", "specifier": 0, "path": "src/ethereum/frontier/trie.py"}, "content": {"type": ["function"], "name": ["trie_get"], "text": ["Gets an item from the Merkle Trie. This method returns  trie.default  if the key is missing. Parameters trie: Trie to lookup in. key : Key to lookup. Returns node :  V Node at  key  in the trie."]}}, {"source": {"identifier": "ethereum.frontier.trie.common_prefix_length", "specifier": 0, "path": "src/ethereum/frontier/trie.py"}, "content": {"type": ["function"], "name": ["common_prefix_length"], "text": ["Find the longest common prefix of two sequences."]}}, {"source": {"identifier": "ethereum.frontier.trie.nibble_list_to_compact", "specifier": 0, "path": "src/ethereum/frontier/trie.py"}, "content": {"type": ["function"], "name": ["nibble_list_to_compact"], "text": ["Compresses nibble-list into a standard byte array with a flag. A nibble-list is a list of byte values no greater than  15 . The flag is encoded in high nibble of the highest byte. The flag nibble can be broken down into two two-bit flags. Highest nibble:: +---+---+----------+--------+\n| _ | _ | is_leaf | parity |\n+---+---+----------+--------+\n  3   2      1         0\n The lowest bit of the nibble encodes the parity of the length of the remaining nibbles --  0  when even and  1  when odd. The second lowest bit is used to distinguish leaf and extension nodes. The other two bits are not used. Parameters x : Array of nibbles. is_leaf : True if this is part of a leaf node, or false if it is an extension node. Returns compressed :  bytearray Compact byte array."]}}, {"source": {"identifier": "ethereum.frontier.trie.bytes_to_nibble_list", "specifier": 0, "path": "src/ethereum/frontier/trie.py"}, "content": {"type": ["function"], "name": ["bytes_to_nibble_list"], "text": ["Converts a  Bytes  into to a sequence of nibbles (bytes with value < 16). Parameters bytes_: The  Bytes  to convert. Returns nibble_list :  Bytes The  Bytes  in nibble-list format."]}}, {"source": {"identifier": "ethereum.frontier.trie._prepare_trie", "specifier": 0, "path": "src/ethereum/frontier/trie.py"}, "content": {"type": ["function"], "name": ["_prepare_trie"], "text": ["Prepares the trie for root calculation. Removes values that are empty, hashes the keys (if  secured == True ) and encodes all the nodes. Parameters trie : The  Trie  to prepare. get_storage_root : Function to get the storage root of an account. Needed to encode Account  objects. Returns out :  Mapping[ethereum.base_types.Bytes, Node] Object with keys mapped to nibble-byte form."]}}, {"source": {"identifier": "ethereum.frontier.trie.root", "specifier": 0, "path": "src/ethereum/frontier/trie.py"}, "content": {"type": ["function"], "name": ["root"], "text": ["Computes the root of a modified merkle patricia trie (MPT). Parameters trie : Trie  to get the root of. get_storage_root : Function to get the storage root of an account. Needed to encode Account  objects. Returns root :  .fork_types.Root MPT root of the underlying key-value pairs."]}}, {"source": {"identifier": "ethereum.frontier.trie.patricialize", "specifier": 0, "path": "src/ethereum/frontier/trie.py"}, "content": {"type": ["function"], "name": ["patricialize"], "text": ["Structural composition function. Used to recursively patricialize and merkleize a dictionary. Includes memoization of the tree structure and hashes. Parameters obj : Underlying trie key-value pairs, with keys in nibble-list format. level : Current trie level. Returns node :  ethereum.base_types.Bytes Root node of  obj ."]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.control_flow", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/control_flow.py"}, "content": {"type": ["module"], "name": ["ethereum.tangerine_whistle.vm.instructions.control_flow"], "text": ["Ethereum Virtual Machine (EVM) Control Flow Instructions ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementations of the EVM control flow instructions."]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.control_flow.stop", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/control_flow.py"}, "content": {"type": ["function"], "name": ["stop"], "text": ["Stop further execution of EVM code. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.control_flow.jump", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/control_flow.py"}, "content": {"type": ["function"], "name": ["jump"], "text": ["Alter the program counter to the location specified by the top of the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.control_flow.jumpi", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/control_flow.py"}, "content": {"type": ["function"], "name": ["jumpi"], "text": ["Alter the program counter to the specified location if and only if a condition is true. If the condition is not true, then the program counter would increase only by 1. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.control_flow.pc", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/control_flow.py"}, "content": {"type": ["function"], "name": ["pc"], "text": ["Push onto the stack the value of the program counter after reaching the current instruction and without increasing it for the next instruction. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.control_flow.gas_left", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/control_flow.py"}, "content": {"type": ["function"], "name": ["gas_left"], "text": ["Push the amount of available gas (including the corresponding reduction for the cost of this instruction) onto the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.control_flow.jumpdest", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/control_flow.py"}, "content": {"type": ["function"], "name": ["jumpdest"], "text": ["Mark a valid destination for jumps. This is a noop, present only to be used by  JUMP  and  JUMPI  opcodes to verify that their jump is valid. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.frontier.fork", "specifier": 0, "path": "src/ethereum/frontier/fork.py"}, "content": {"type": ["module"], "name": ["ethereum.frontier.fork"], "text": ["Ethereum Specification ^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Entry point for the Ethereum specification."]}}, {"source": {"identifier": "ethereum.frontier.fork.BLOCK_REWARD", "specifier": 0, "path": "src/ethereum/frontier/fork.py"}, "content": {"type": ["attribute"], "name": ["BLOCK_REWARD"]}}, {"source": {"identifier": "ethereum.frontier.fork.GAS_LIMIT_ADJUSTMENT_FACTOR", "specifier": 0, "path": "src/ethereum/frontier/fork.py"}, "content": {"type": ["attribute"], "name": ["GAS_LIMIT_ADJUSTMENT_FACTOR"]}}, {"source": {"identifier": "ethereum.frontier.fork.GAS_LIMIT_MINIMUM", "specifier": 0, "path": "src/ethereum/frontier/fork.py"}, "content": {"type": ["attribute"], "name": ["GAS_LIMIT_MINIMUM"]}}, {"source": {"identifier": "ethereum.frontier.fork.MINIMUM_DIFFICULTY", "specifier": 0, "path": "src/ethereum/frontier/fork.py"}, "content": {"type": ["attribute"], "name": ["MINIMUM_DIFFICULTY"]}}, {"source": {"identifier": "ethereum.frontier.fork.MAX_OMMER_DEPTH", "specifier": 0, "path": "src/ethereum/frontier/fork.py"}, "content": {"type": ["attribute"], "name": ["MAX_OMMER_DEPTH"]}}, {"source": {"identifier": "ethereum.frontier.fork.BlockChain", "specifier": 0, "path": "src/ethereum/frontier/fork.py"}, "content": {"type": ["class"], "name": ["BlockChain"], "text": ["History and current state of the block chain."]}}, {"source": {"identifier": "ethereum.frontier.fork.BlockChain.blocks", "specifier": 0, "path": "src/ethereum/frontier/fork.py"}, "content": {"type": ["attribute"], "name": ["blocks"]}}, {"source": {"identifier": "ethereum.frontier.fork.BlockChain.state", "specifier": 0, "path": "src/ethereum/frontier/fork.py"}, "content": {"type": ["attribute"], "name": ["state"]}}, {"source": {"identifier": "ethereum.frontier.fork.BlockChain.chain_id", "specifier": 0, "path": "src/ethereum/frontier/fork.py"}, "content": {"type": ["attribute"], "name": ["chain_id"]}}, {"source": {"identifier": "ethereum.frontier.fork.apply_fork", "specifier": 0, "path": "src/ethereum/frontier/fork.py"}, "content": {"type": ["function"], "name": ["apply_fork"], "text": ["Transforms the state from the previous hard fork ( old ) into the block chain object for this hard fork and returns it. When forks need to implement an irregular state transition, this function is used to handle the irregularity. See the :ref: DAO Fork <dao-fork>  for an example. Parameters old : Previous block chain object. Returns new :  BlockChain Upgraded block chain object for this hard fork."]}}, {"source": {"identifier": "ethereum.frontier.fork.get_last_256_block_hashes", "specifier": 0, "path": "src/ethereum/frontier/fork.py"}, "content": {"type": ["function"], "name": ["get_last_256_block_hashes"], "text": ["Obtain the list of hashes of the previous 256 blocks in order of increasing block number. This function will return less hashes for the first 256 blocks. The  BLOCKHASH  opcode needs to access the latest hashes on the chain, therefore this function retrieves them. Parameters chain : History and current state. Returns recent_block_hashes :  List[Hash32] Hashes of the recent 256 blocks in order of increasing block number."]}}, {"source": {"identifier": "ethereum.frontier.fork.state_transition", "specifier": 0, "path": "src/ethereum/frontier/fork.py"}, "content": {"type": ["function"], "name": ["state_transition"], "text": ["Attempts to apply a block to an existing block chain. All parts of the block's contents need to be verified before being added to the chain. Blocks are verified by ensuring that the contents of the block make logical sense with the contents of the parent block. The information in the block's header must also match the corresponding information in the block. To implement Ethereum, in theory clients are only required to store the most recent 255 blocks of the chain since as far as execution is concerned, only those blocks are accessed. Practically, however, clients should store more blocks to handle reorgs. Parameters chain : History and current state. block : Block to apply to  chain ."]}}, {"source": {"identifier": "ethereum.frontier.fork.validate_header", "specifier": 0, "path": "src/ethereum/frontier/fork.py"}, "content": {"type": ["function"], "name": ["validate_header"], "text": ["Verifies a block header. In order to consider a block's header valid, the logic for the quantities in the header should match the logic for the block itself. For example the header timestamp should be greater than the block's parent timestamp because the block was created  after  the parent block. Additionally, the block's number should be directly folowing the parent block's number since it is the next block in the sequence. Parameters header : Header to check for correctness. parent_header : Parent Header of the header to check for correctness"]}}, {"source": {"identifier": "ethereum.frontier.fork.generate_header_hash_for_pow", "specifier": 0, "path": "src/ethereum/frontier/fork.py"}, "content": {"type": ["function"], "name": ["generate_header_hash_for_pow"], "text": ["Generate rlp hash of the header which is to be used for Proof-of-Work verification. In other words, the PoW artefacts  mix_digest  and  nonce  are ignored while calculating this hash. A particular PoW is valid for a single hash, that hash is computed by this function. The  nonce  and  mix_digest  are omitted from this hash because they are being changed by miners in their search for a sufficient proof-of-work. Parameters header : The header object for which the hash is to be generated. Returns hash :  Hash32 The PoW valid rlp hash of the passed in header."]}}, {"source": {"identifier": "ethereum.frontier.fork.validate_proof_of_work", "specifier": 0, "path": "src/ethereum/frontier/fork.py"}, "content": {"type": ["function"], "name": ["validate_proof_of_work"], "text": ["Validates the Proof of Work constraints. In order to verify that a miner's proof-of-work is valid for a block, a mix-digest  and  result  are calculated using the  hashimoto_light hash function. The mix digest is a hash of the header and the nonce that is passed through and it confirms whether or not proof-of-work was done on the correct block. The result is the actual hash value of the block. Parameters header : Header of interest."]}}, {"source": {"identifier": "ethereum.frontier.fork.check_transaction", "specifier": 0, "path": "src/ethereum/frontier/fork.py"}, "content": {"type": ["function"], "name": ["check_transaction"], "text": ["Check if the transaction is includable in the block. Parameters tx : The transaction. gas_available : The gas remaining in the block. Returns sender_address : The sender of the transaction. Raises InvalidBlock : If the transaction is not includable."]}}, {"source": {"identifier": "ethereum.frontier.fork.make_receipt", "specifier": 0, "path": "src/ethereum/frontier/fork.py"}, "content": {"type": ["function"], "name": ["make_receipt"], "text": ["Make the receipt for a transaction that was executed. Parameters tx : The executed transaction. post_state : The state root immediately after this transaction. cumulative_gas_used : The total gas used so far in the block after the transaction was executed. logs : The logs produced by the transaction. Returns receipt : The receipt for the transaction."]}}, {"source": {"identifier": "ethereum.frontier.fork.apply_body", "specifier": 0, "path": "src/ethereum/frontier/fork.py"}, "content": {"type": ["function"], "name": ["apply_body"], "text": ["Executes a block. Many of the contents of a block are stored in data structures called tries. There is a transactions trie which is similar to a ledger of the transactions stored in the current block. There is also a receipts trie which stores the results of executing a transaction, like the post state and gas used. This function creates and executes the block that is to be added to the chain. Parameters state : Current account state. block_hashes : List of hashes of the previous 256 blocks in the order of increasing block number. coinbase : Address of account which receives block reward and transaction fees. block_number : Position of the block within the chain. block_gas_limit : Initial amount of gas available for execution in this block. block_time : Time the block was produced, measured in seconds since the epoch. block_difficulty : Difficulty of the block. transactions : Transactions included in the block. ommers : Headers of ancestor blocks which are not direct parents (formerly uncles.) Returns gas_available :  ethereum.base_types.Uint Remaining gas after all transactions have been executed. transactions_root :  ethereum.fork_types.Root Trie root of all the transactions in the block. receipt_root :  ethereum.fork_types.Root Trie root of all the receipts in the block. block_logs_bloom :  Bloom Logs bloom of all the logs included in all the transactions of the block. state :  ethereum.fork_types.State State after all transactions have been executed."]}}, {"source": {"identifier": "ethereum.frontier.fork.validate_ommers", "specifier": 0, "path": "src/ethereum/frontier/fork.py"}, "content": {"type": ["function"], "name": ["validate_ommers"], "text": ["Validates the ommers mentioned in the block. An ommer block is a block that wasn't canonically added to the blockchain because it wasn't validated as fast as the canonical block but was mined at the same time. To be considered valid, the ommers must adhere to the rules defined in the Ethereum protocol. The maximum amount of ommers is 2 per block and there cannot be duplicate ommers in a block. Many of the other ommer contraints are listed in the in-line comments of this function. Parameters ommers : List of ommers mentioned in the current block. block_header: The header of current block. chain : History and current state."]}}, {"source": {"identifier": "ethereum.frontier.fork.pay_rewards", "specifier": 0, "path": "src/ethereum/frontier/fork.py"}, "content": {"type": ["function"], "name": ["pay_rewards"], "text": ["Pay rewards to the block miner as well as the ommers miners. The miner of the canonical block is rewarded with the predetermined block reward,  BLOCK_REWARD , plus a variable award based off of the number of ommer blocks that were mined around the same time, and included in the canonical block's header. An ommer block is a block that wasn't added to the canonical blockchain because it wasn't validated as fast as the accepted block but was mined at the same time. Although not all blocks that are mined are added to the canonical chain, miners are still paid a reward for their efforts. This reward is called an ommer reward and is calculated based on the number associated with the ommer block that they mined. Parameters state : Current account state. block_number : Position of the block within the chain. coinbase : Address of account which receives block reward and transaction fees. ommers : List of ommers mentioned in the current block."]}}, {"source": {"identifier": "ethereum.frontier.fork.process_transaction", "specifier": 0, "path": "src/ethereum/frontier/fork.py"}, "content": {"type": ["function"], "name": ["process_transaction"], "text": ["Execute a transaction against the provided environment. This function processes the actions needed to execute a transaction. It decrements the sender's account after calculating the gas fee and refunds them the proper amount after execution. Calling contracts, deploying code, and incrementing nonces are all examples of actions that happen within this function or from a call made within this function. Accounts that are marked for deletion are processed and destroyed after execution. Parameters env : Environment for the Ethereum Virtual Machine. tx : Transaction to execute. Returns gas_left :  ethereum.base_types.U256 Remaining gas after execution. logs :  Tuple[ethereum.fork_types.Log, ...] Logs generated during execution."]}}, {"source": {"identifier": "ethereum.frontier.fork.validate_transaction", "specifier": 0, "path": "src/ethereum/frontier/fork.py"}, "content": {"type": ["function"], "name": ["validate_transaction"], "text": ["Verifies a transaction. The gas in a transaction gets used to pay for the intrinsic cost of operations, therefore if there is insufficient gas then it would not be possible to execute a transaction and it will be declared invalid. Additionally, the nonce of a transaction must not equal or exceed the limit defined in  EIP-2681 <https://eips.ethereum.org/EIPS/eip-2681> _. In practice, defining the limit as  2**64-1  has no impact because sending  2**64-1  transactions is improbable. It's not strictly impossible though,  2**64-1  transactions is the entire capacity of the Ethereum blockchain at 2022 gas limits for a little over 22 years. Parameters tx : Transaction to validate. Returns verified :  bool True if the transaction can be executed, or False otherwise."]}}, {"source": {"identifier": "ethereum.frontier.fork.calculate_intrinsic_cost", "specifier": 0, "path": "src/ethereum/frontier/fork.py"}, "content": {"type": ["function"], "name": ["calculate_intrinsic_cost"], "text": ["Calculates the gas that is charged before execution is started. The intrinsic cost of the transaction is charged before execution has begun. Functions/operations in the EVM cost money to execute so this intrinsic cost is for the operations that need to be paid for as part of the transaction. Data transfer, for example, is part of this intrinsic cost. It costs ether to send data over the wire and that ether is accounted for in the intrinsic cost calculated in this function. This intrinsic cost must be calculated and paid for before execution in order for all operations to be implemented. Parameters tx : Transaction to compute the intrinsic cost of. Returns verified :  ethereum.base_types.Uint The intrinsic cost of the transaction."]}}, {"source": {"identifier": "ethereum.frontier.fork.recover_sender", "specifier": 0, "path": "src/ethereum/frontier/fork.py"}, "content": {"type": ["function"], "name": ["recover_sender"], "text": ["Extracts the sender address from a transaction. The v, r, and s values are the three parts that make up the signature of a transaction. In order to recover the sender of a transaction the two components needed are the signature ( v ,  r , and  s ) and the signing hash of the transaction. The sender's public key can be obtained with these two values and therefore the sender address can be retrieved. Parameters tx : Transaction of interest. Returns sender :  ethereum.fork_types.Address The address of the account that signed the transaction."]}}, {"source": {"identifier": "ethereum.frontier.fork.signing_hash", "specifier": 0, "path": "src/ethereum/frontier/fork.py"}, "content": {"type": ["function"], "name": ["signing_hash"], "text": ["Compute the hash of a transaction used in the signature. The values that are used to compute the signing hash set the rules for a transaction. For example, signing over the gas sets a limit for the amount of money that is allowed to be pulled out of the sender's account. Parameters tx : Transaction of interest. Returns hash :  ethereum.crypto.hash.Hash32 Hash of the transaction."]}}, {"source": {"identifier": "ethereum.frontier.fork.compute_header_hash", "specifier": 0, "path": "src/ethereum/frontier/fork.py"}, "content": {"type": ["function"], "name": ["compute_header_hash"], "text": ["Computes the hash of a block header. The header hash of a block is the canonical hash that is used to refer to a specific block and completely distinguishes a block from another. keccak256  is a function that produces a 256 bit hash of any input. It also takes in any number of bytes as an input and produces a single hash for them. A hash is a completely unique output for a single input. So an input corresponds to one unique hash that can be used to identify the input exactly. Prior to using the  keccak256  hash function, the header must be encoded using the Recursive-Length Prefix. See :ref: rlp . RLP encoding the header converts it into a space-efficient format that allows for easy transfer of data between nodes. The purpose of RLP is to encode arbitrarily nested arrays of binary data, and RLP is the primary encoding method used to serialize objects in Ethereum's execution layer. The only purpose of RLP is to encode structure; encoding specific data types (e.g. strings, floats) is left up to higher-order protocols. Parameters header : Header of interest. Returns hash :  ethereum.crypto.hash.Hash32 Hash of the header."]}}, {"source": {"identifier": "ethereum.frontier.fork.check_gas_limit", "specifier": 0, "path": "src/ethereum/frontier/fork.py"}, "content": {"type": ["function"], "name": ["check_gas_limit"], "text": ["Validates the gas limit for a block. The bounds of the gas limit,  max_adjustment_delta , is set as the quotient of the parent block's gas limit and the GAS_LIMIT_ADJUSTMENT_FACTOR . Therefore, if the gas limit that is passed through as a parameter is greater than or equal to the  sum  of the parent's gas and the adjustment delta then the limit for gas is too high and fails this function's check. Similarly, if the limit is less than or equal to the  difference  of the parent's gas and the adjustment delta  or  the predefined  GAS_LIMIT_MINIMUM  then this function's check fails because the gas limit doesn't allow for a sufficient or reasonable amount of gas to be used on a block. Parameters gas_limit : Gas limit to validate. parent_gas_limit : Gas limit of the parent block. Returns check :  bool True if gas limit constraints are satisfied, False otherwise."]}}, {"source": {"identifier": "ethereum.frontier.fork.calculate_block_difficulty", "specifier": 0, "path": "src/ethereum/frontier/fork.py"}, "content": {"type": ["function"], "name": ["calculate_block_difficulty"], "text": ["Computes difficulty of a block using its header and parent header. The difficulty of a block is determined by the time the block was created after its parent. If a block's timestamp is more than 13 seconds after its parent block then its difficulty is set as the difference between the parent's difficulty and the max_adjustment_delta . Otherwise, if the time between parent and child blocks is too small (under 13 seconds) then, to avoid mass forking, the block's difficulty is set to the sum of the delta and the parent's difficulty. Parameters block_number : Block number of the block. block_timestamp : Timestamp of the block. parent_timestamp : Timestamp of the parent block. parent_difficulty : difficulty of the parent block. Returns difficulty :  ethereum.base_types.Uint Computed difficulty for a block."]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.comparison", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/comparison.py"}, "content": {"type": ["module"], "name": ["ethereum.tangerine_whistle.vm.instructions.comparison"], "text": ["Ethereum Virtual Machine (EVM) Comparison Instructions ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementations of the EVM Comparison instructions."]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.comparison.less_than", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/comparison.py"}, "content": {"type": ["function"], "name": ["less_than"], "text": ["Checks if the top element is less than the next top element. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.comparison.signed_less_than", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/comparison.py"}, "content": {"type": ["function"], "name": ["signed_less_than"], "text": ["Signed less-than comparison. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.comparison.greater_than", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/comparison.py"}, "content": {"type": ["function"], "name": ["greater_than"], "text": ["Checks if the top element is greater than the next top element. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.comparison.signed_greater_than", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/comparison.py"}, "content": {"type": ["function"], "name": ["signed_greater_than"], "text": ["Signed greater-than comparison. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.comparison.equal", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/comparison.py"}, "content": {"type": ["function"], "name": ["equal"], "text": ["Checks if the top element is equal to the next top element. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.comparison.is_zero", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/comparison.py"}, "content": {"type": ["function"], "name": ["is_zero"], "text": ["Checks if the top element is equal to 0. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.frontier.vm.memory", "specifier": 0, "path": "src/ethereum/frontier/vm/memory.py"}, "content": {"type": ["module"], "name": ["ethereum.frontier.vm.memory"], "text": ["Ethereum Virtual Machine (EVM) Memory ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction EVM memory operations."]}}, {"source": {"identifier": "ethereum.frontier.vm.memory.memory_write", "specifier": 0, "path": "src/ethereum/frontier/vm/memory.py"}, "content": {"type": ["function"], "name": ["memory_write"], "text": ["Writes to memory. Parameters memory : Memory contents of the EVM. start_position : Starting pointer to the memory. value : Data to write to memory."]}}, {"source": {"identifier": "ethereum.frontier.vm.memory.memory_read_bytes", "specifier": 0, "path": "src/ethereum/frontier/vm/memory.py"}, "content": {"type": ["function"], "name": ["memory_read_bytes"], "text": ["Read bytes from memory. Parameters memory : Memory contents of the EVM. start_position : Starting pointer to the memory. size : Size of the data that needs to be read from  start_position . Returns data_bytes : Data read from memory."]}}, {"source": {"identifier": "ethereum.frontier.vm.memory.buffer_read", "specifier": 0, "path": "src/ethereum/frontier/vm/memory.py"}, "content": {"type": ["function"], "name": ["buffer_read"], "text": ["Read bytes from a buffer. Padding with zeros if neccesary. Parameters buffer : Memory contents of the EVM. start_position : Starting pointer to the memory. size : Size of the data that needs to be read from  start_position . Returns data_bytes : Data read from memory."]}}, {"source": {"identifier": "ethereum.constantinople.vm.precompiled_contracts.modexp", "specifier": 0, "path": "src/ethereum/constantinople/vm/precompiled_contracts/modexp.py"}, "content": {"type": ["module"], "name": ["ethereum.constantinople.vm.precompiled_contracts.modexp"], "text": ["Ethereum Virtual Machine (EVM) MODEXP PRECOMPILED CONTRACT ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementation of the  MODEXP  precompiled contract."]}}, {"source": {"identifier": "ethereum.constantinople.vm.precompiled_contracts.modexp.GQUADDIVISOR", "specifier": 0, "path": "src/ethereum/constantinople/vm/precompiled_contracts/modexp.py"}, "content": {"type": ["attribute"], "name": ["GQUADDIVISOR"]}}, {"source": {"identifier": "ethereum.constantinople.vm.precompiled_contracts.modexp.modexp", "specifier": 0, "path": "src/ethereum/constantinople/vm/precompiled_contracts/modexp.py"}, "content": {"type": ["function"], "name": ["modexp"], "text": ["Calculates  (base**exp) % modulus  for arbitary sized  base ,  exp  and. modulus . The return value is the same length as the modulus."]}}, {"source": {"identifier": "ethereum.constantinople.vm.precompiled_contracts.modexp.get_mult_complexity", "specifier": 0, "path": "src/ethereum/constantinople/vm/precompiled_contracts/modexp.py"}, "content": {"type": ["function"], "name": ["get_mult_complexity"], "text": ["Estimate the complexity of performing Karatsuba multiplication."]}}, {"source": {"identifier": "ethereum.berlin.vm.precompiled_contracts.mapping", "specifier": 0, "path": "src/ethereum/berlin/vm/precompiled_contracts/mapping.py"}, "content": {"type": ["module"], "name": ["ethereum.berlin.vm.precompiled_contracts.mapping"], "text": ["Precompiled Contract Addresses ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Mapping of precompiled contracts their implementations."]}}, {"source": {"identifier": "ethereum.berlin.vm.precompiled_contracts.mapping.PRE_COMPILED_CONTRACTS", "specifier": 0, "path": "src/ethereum/berlin/vm/precompiled_contracts/mapping.py"}, "content": {"type": ["attribute"], "name": ["PRE_COMPILED_CONTRACTS"]}}, {"source": {"identifier": "ethereum.frontier.utils.hexadecimal", "specifier": 0, "path": "src/ethereum/frontier/utils/hexadecimal.py"}, "content": {"type": ["module"], "name": ["ethereum.frontier.utils.hexadecimal"], "text": ["Utility Functions For Hexadecimal Strings ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Hexadecimal utility functions used in this specification, specific to Frontier types."]}}, {"source": {"identifier": "ethereum.frontier.utils.hexadecimal.hex_to_root", "specifier": 0, "path": "src/ethereum/frontier/utils/hexadecimal.py"}, "content": {"type": ["function"], "name": ["hex_to_root"], "text": ["Convert hex string to trie root. Parameters hex_string : The hexadecimal string to be converted to trie root. Returns root :  Root Trie root obtained from the given hexadecimal string."]}}, {"source": {"identifier": "ethereum.frontier.utils.hexadecimal.hex_to_bloom", "specifier": 0, "path": "src/ethereum/frontier/utils/hexadecimal.py"}, "content": {"type": ["function"], "name": ["hex_to_bloom"], "text": ["Convert hex string to bloom. Parameters hex_string : The hexadecimal string to be converted to bloom. Returns bloom :  Bloom Bloom obtained from the given hexadecimal string."]}}, {"source": {"identifier": "ethereum.frontier.utils.hexadecimal.hex_to_address", "specifier": 0, "path": "src/ethereum/frontier/utils/hexadecimal.py"}, "content": {"type": ["function"], "name": ["hex_to_address"], "text": ["Convert hex string to Address (20 bytes). Parameters hex_string : The hexadecimal string to be converted to Address. Returns address :  Address The address obtained from the given hexadecimal string."]}}, {"source": {"identifier": "ethereum_spec_tools.evm_tools", "specifier": 0, "path": "src/ethereum_spec_tools/evm_tools/__main__.py"}, "content": {"type": ["module"], "name": ["ethereum_spec_tools.evm_tools"], "text": ["Entrypoint for the  evm-tools  command-line tool."]}}, {"source": {"identifier": "ethereum.dao_fork.state", "specifier": 0, "path": "src/ethereum/dao_fork/state.py"}, "content": {"type": ["module"], "name": ["ethereum.dao_fork.state"], "text": ["State ^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction The state contains all information that is preserved between transactions. It consists of a main account trie and storage tries for each contract. There is a distinction between an account that does not exist and EMPTY_ACCOUNT ."]}}, {"source": {"identifier": "ethereum.dao_fork.state.State", "specifier": 0, "path": "src/ethereum/dao_fork/state.py"}, "content": {"type": ["class"], "name": ["State"], "text": ["Contains all information that is preserved between transactions."]}}, {"source": {"identifier": "ethereum.dao_fork.state.State._main_trie", "specifier": 0, "path": "src/ethereum/dao_fork/state.py"}, "content": {"type": ["attribute"], "name": ["_main_trie"]}}, {"source": {"identifier": "ethereum.dao_fork.state.State._storage_tries", "specifier": 0, "path": "src/ethereum/dao_fork/state.py"}, "content": {"type": ["attribute"], "name": ["_storage_tries"]}}, {"source": {"identifier": "ethereum.dao_fork.state.State._snapshots", "specifier": 0, "path": "src/ethereum/dao_fork/state.py"}, "content": {"type": ["attribute"], "name": ["_snapshots"]}}, {"source": {"identifier": "ethereum.dao_fork.state.close_state", "specifier": 0, "path": "src/ethereum/dao_fork/state.py"}, "content": {"type": ["function"], "name": ["close_state"], "text": ["Free resources held by the state. Used by optimized implementations to release file descriptors."]}}, {"source": {"identifier": "ethereum.dao_fork.state.begin_transaction", "specifier": 0, "path": "src/ethereum/dao_fork/state.py"}, "content": {"type": ["function"], "name": ["begin_transaction"], "text": ["Start a state transaction. Transactions are entirely implicit and can be nested. It is not possible to calculate the state root during a transaction. Parameters state : State The state."]}}, {"source": {"identifier": "ethereum.dao_fork.state.commit_transaction", "specifier": 0, "path": "src/ethereum/dao_fork/state.py"}, "content": {"type": ["function"], "name": ["commit_transaction"], "text": ["Commit a state transaction. Parameters state : State The state."]}}, {"source": {"identifier": "ethereum.dao_fork.state.rollback_transaction", "specifier": 0, "path": "src/ethereum/dao_fork/state.py"}, "content": {"type": ["function"], "name": ["rollback_transaction"], "text": ["Rollback a state transaction, resetting the state to the point when the corresponding  start_transaction()  call was made. Parameters state : State The state."]}}, {"source": {"identifier": "ethereum.dao_fork.state.get_account", "specifier": 0, "path": "src/ethereum/dao_fork/state.py"}, "content": {"type": ["function"], "name": ["get_account"], "text": ["Get the  Account  object at an address. Returns  EMPTY_ACCOUNT  if there is no account at the address. Use  get_account_optional()  if you care about the difference between a non-existent account and  EMPTY_ACCOUNT . Parameters state:  State The state address :  Address Address to lookup. Returns account :  Account Account at address."]}}, {"source": {"identifier": "ethereum.dao_fork.state.get_account_optional", "specifier": 0, "path": "src/ethereum/dao_fork/state.py"}, "content": {"type": ["function"], "name": ["get_account_optional"], "text": ["Get the  Account  object at an address. Returns  None  (rather than EMPTY_ACCOUNT ) if there is no account at the address. Parameters state:  State The state address :  Address Address to lookup. Returns account :  Account Account at address."]}}, {"source": {"identifier": "ethereum.dao_fork.state.set_account", "specifier": 0, "path": "src/ethereum/dao_fork/state.py"}, "content": {"type": ["function"], "name": ["set_account"], "text": ["Set the  Account  object at an address. Setting to  None  deletes the account (but not its storage, see  destroy_account() ). Parameters state:  State The state address :  Address Address to set. account :  Account Account to set at address."]}}, {"source": {"identifier": "ethereum.dao_fork.state.destroy_account", "specifier": 0, "path": "src/ethereum/dao_fork/state.py"}, "content": {"type": ["function"], "name": ["destroy_account"], "text": ["Completely remove the account at  address  and all of its storage. This function is made available exclusively for the  SELFDESTRUCT opcode. It is expected that  SELFDESTRUCT  will be disabled in a future hardfork and this function will be removed. Parameters state:  State The state address :  Address Address of account to destroy."]}}, {"source": {"identifier": "ethereum.dao_fork.state.destroy_storage", "specifier": 0, "path": "src/ethereum/dao_fork/state.py"}, "content": {"type": ["function"], "name": ["destroy_storage"], "text": ["Completely remove the storage at  address . Parameters state:  State The state address :  Address Address of account whose storage is to be deleted."]}}, {"source": {"identifier": "ethereum.dao_fork.state.get_storage", "specifier": 0, "path": "src/ethereum/dao_fork/state.py"}, "content": {"type": ["function"], "name": ["get_storage"], "text": ["Get a value at a storage key on an account. Returns  U256(0)  if the storage key has not been set previously. Parameters state:  State The state address :  Address Address of the account. key :  Bytes Key to lookup. Returns value :  U256 Value at the key."]}}, {"source": {"identifier": "ethereum.dao_fork.state.set_storage", "specifier": 0, "path": "src/ethereum/dao_fork/state.py"}, "content": {"type": ["function"], "name": ["set_storage"], "text": ["Set a value at a storage key on an account. Setting to  U256(0)  deletes the key. Parameters state:  State The state address :  Address Address of the account. key :  Bytes Key to set. value :  U256 Value to set at the key."]}}, {"source": {"identifier": "ethereum.dao_fork.state.storage_root", "specifier": 0, "path": "src/ethereum/dao_fork/state.py"}, "content": {"type": ["function"], "name": ["storage_root"], "text": ["Calculate the storage root of an account. Parameters state: The state address : Address of the account. Returns root :  Root Storage root of the account."]}}, {"source": {"identifier": "ethereum.dao_fork.state.state_root", "specifier": 0, "path": "src/ethereum/dao_fork/state.py"}, "content": {"type": ["function"], "name": ["state_root"], "text": ["Calculate the state root. Parameters state: The current state. Returns root :  Root The state root."]}}, {"source": {"identifier": "ethereum.dao_fork.state.account_exists", "specifier": 0, "path": "src/ethereum/dao_fork/state.py"}, "content": {"type": ["function"], "name": ["account_exists"], "text": ["Checks if an account exists in the state trie Parameters state: The state address: Address of the account that needs to be checked. Returns account_exists :  bool True if account exists in the state trie, False otherwise"]}}, {"source": {"identifier": "ethereum.dao_fork.state.account_has_code_or_nonce", "specifier": 0, "path": "src/ethereum/dao_fork/state.py"}, "content": {"type": ["function"], "name": ["account_has_code_or_nonce"], "text": ["Checks if an account has non zero nonce or non empty code Parameters state: The state address: Address of the account that needs to be checked. Returns has_code_or_nonce :  bool True if if an account has non zero nonce or non empty code, False otherwise."]}}, {"source": {"identifier": "ethereum.dao_fork.state.modify_state", "specifier": 0, "path": "src/ethereum/dao_fork/state.py"}, "content": {"type": ["function"], "name": ["modify_state"], "text": ["Modify an  Account  in the  State ."]}}, {"source": {"identifier": "ethereum.dao_fork.state.move_ether", "specifier": 0, "path": "src/ethereum/dao_fork/state.py"}, "content": {"type": ["function"], "name": ["move_ether"], "text": ["Move funds between accounts."]}}, {"source": {"identifier": "ethereum.dao_fork.state.set_account_balance", "specifier": 0, "path": "src/ethereum/dao_fork/state.py"}, "content": {"type": ["function"], "name": ["set_account_balance"], "text": ["Sets the balance of an account. Parameters state: The current state. address: Address of the account whose nonce needs to be incremented. amount: The amount that needs to set in balance."]}}, {"source": {"identifier": "ethereum.dao_fork.state.touch_account", "specifier": 0, "path": "src/ethereum/dao_fork/state.py"}, "content": {"type": ["function"], "name": ["touch_account"], "text": ["Initializes an account to state. Parameters state: The current state. address: The address of the account that need to initialised."]}}, {"source": {"identifier": "ethereum.dao_fork.state.increment_nonce", "specifier": 0, "path": "src/ethereum/dao_fork/state.py"}, "content": {"type": ["function"], "name": ["increment_nonce"], "text": ["Increments the nonce of an account. Parameters state: The current state. address: Address of the account whose nonce needs to be incremented."]}}, {"source": {"identifier": "ethereum.dao_fork.state.set_code", "specifier": 0, "path": "src/ethereum/dao_fork/state.py"}, "content": {"type": ["function"], "name": ["set_code"], "text": ["Sets Account code. Parameters state: The current state. address: Address of the account whose code needs to be update. code: The bytecode that needs to be set."]}}, {"source": {"identifier": "ethereum.dao_fork.state.create_ether", "specifier": 0, "path": "src/ethereum/dao_fork/state.py"}, "content": {"type": ["function"], "name": ["create_ether"], "text": ["Add newly created ether to an account. Parameters state: The current state. address: Address of the account to which ether is added. amount: The amount of ether to be added to the account of interest."]}}, {"source": {"identifier": "ethereum.constantinople.vm.precompiled_contracts.ecrecover", "specifier": 0, "path": "src/ethereum/constantinople/vm/precompiled_contracts/ecrecover.py"}, "content": {"type": ["module"], "name": ["ethereum.constantinople.vm.precompiled_contracts.ecrecover"], "text": ["Ethereum Virtual Machine (EVM) ECRECOVER PRECOMPILED CONTRACT ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementation of the ECRECOVER precompiled contract."]}}, {"source": {"identifier": "ethereum.constantinople.vm.precompiled_contracts.ecrecover.ecrecover", "specifier": 0, "path": "src/ethereum/constantinople/vm/precompiled_contracts/ecrecover.py"}, "content": {"type": ["function"], "name": ["ecrecover"], "text": ["Decrypts the address using elliptic curve DSA recovery mechanism and writes the address to output. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.berlin.vm.precompiled_contracts", "specifier": 0, "path": "src/ethereum/berlin/vm/precompiled_contracts/__init__.py"}, "content": {"type": ["module"], "name": ["ethereum.berlin.vm.precompiled_contracts"], "text": ["Precompiled Contract Addresses ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Addresses of precompiled contracts and mappings to their implementations."]}}, {"source": {"identifier": "ethereum.berlin.vm.precompiled_contracts.__all__", "specifier": 0, "path": "src/ethereum/berlin/vm/precompiled_contracts/__init__.py"}, "content": {"type": ["attribute"], "name": ["__all__"]}}, {"source": {"identifier": "ethereum.berlin.vm.precompiled_contracts.ECRECOVER_ADDRESS", "specifier": 0, "path": "src/ethereum/berlin/vm/precompiled_contracts/__init__.py"}, "content": {"type": ["attribute"], "name": ["ECRECOVER_ADDRESS"]}}, {"source": {"identifier": "ethereum.berlin.vm.precompiled_contracts.SHA256_ADDRESS", "specifier": 0, "path": "src/ethereum/berlin/vm/precompiled_contracts/__init__.py"}, "content": {"type": ["attribute"], "name": ["SHA256_ADDRESS"]}}, {"source": {"identifier": "ethereum.berlin.vm.precompiled_contracts.RIPEMD160_ADDRESS", "specifier": 0, "path": "src/ethereum/berlin/vm/precompiled_contracts/__init__.py"}, "content": {"type": ["attribute"], "name": ["RIPEMD160_ADDRESS"]}}, {"source": {"identifier": "ethereum.berlin.vm.precompiled_contracts.IDENTITY_ADDRESS", "specifier": 0, "path": "src/ethereum/berlin/vm/precompiled_contracts/__init__.py"}, "content": {"type": ["attribute"], "name": ["IDENTITY_ADDRESS"]}}, {"source": {"identifier": "ethereum.berlin.vm.precompiled_contracts.MODEXP_ADDRESS", "specifier": 0, "path": "src/ethereum/berlin/vm/precompiled_contracts/__init__.py"}, "content": {"type": ["attribute"], "name": ["MODEXP_ADDRESS"]}}, {"source": {"identifier": "ethereum.berlin.vm.precompiled_contracts.ALT_BN128_ADD_ADDRESS", "specifier": 0, "path": "src/ethereum/berlin/vm/precompiled_contracts/__init__.py"}, "content": {"type": ["attribute"], "name": ["ALT_BN128_ADD_ADDRESS"]}}, {"source": {"identifier": "ethereum.berlin.vm.precompiled_contracts.ALT_BN128_MUL_ADDRESS", "specifier": 0, "path": "src/ethereum/berlin/vm/precompiled_contracts/__init__.py"}, "content": {"type": ["attribute"], "name": ["ALT_BN128_MUL_ADDRESS"]}}, {"source": {"identifier": "ethereum.berlin.vm.precompiled_contracts.ALT_BN128_PAIRING_CHECK_ADDRESS", "specifier": 0, "path": "src/ethereum/berlin/vm/precompiled_contracts/__init__.py"}, "content": {"type": ["attribute"], "name": ["ALT_BN128_PAIRING_CHECK_ADDRESS"]}}, {"source": {"identifier": "ethereum.berlin.vm.precompiled_contracts.BLAKE2F_ADDRESS", "specifier": 0, "path": "src/ethereum/berlin/vm/precompiled_contracts/__init__.py"}, "content": {"type": ["attribute"], "name": ["BLAKE2F_ADDRESS"]}}, {"source": {"identifier": "ethereum_spec_tools.evm_tools.t8n", "specifier": 0, "path": "src/ethereum_spec_tools/evm_tools/t8n/__init__.py"}, "content": {"type": ["module"], "name": ["ethereum_spec_tools.evm_tools.t8n"], "text": ["Create a transition tool for the given fork."]}}, {"source": {"identifier": "ethereum_spec_tools.evm_tools.t8n.t8n_arguments", "specifier": 0, "path": "src/ethereum_spec_tools/evm_tools/t8n/__init__.py"}, "content": {"type": ["function"], "name": ["t8n_arguments"], "text": ["Adds the arguments for the t8n tool subparser."]}}, {"source": {"identifier": "ethereum_spec_tools.evm_tools.t8n.T8N", "specifier": 0, "path": "src/ethereum_spec_tools/evm_tools/t8n/__init__.py"}, "content": {"type": ["class"], "name": ["T8N"], "text": ["The class that carries out the transition"]}}, {"source": {"identifier": "ethereum_spec_tools.evm_tools.t8n.T8N.__init__", "specifier": 0, "path": "src/ethereum_spec_tools/evm_tools/t8n/__init__.py"}, "content": {"type": ["function"], "name": ["__init__"]}}, {"source": {"identifier": "ethereum_spec_tools.evm_tools.t8n.T8N.fork", "specifier": 0, "path": "src/ethereum_spec_tools/evm_tools/t8n/__init__.py"}, "content": {"type": ["function"], "name": ["fork"], "text": ["The fork module of the given fork."]}}, {"source": {"identifier": "ethereum_spec_tools.evm_tools.t8n.T8N.fork_types", "specifier": 0, "path": "src/ethereum_spec_tools/evm_tools/t8n/__init__.py"}, "content": {"type": ["function"], "name": ["fork_types"], "text": ["The fork_types model of the given fork."]}}, {"source": {"identifier": "ethereum_spec_tools.evm_tools.t8n.T8N.state", "specifier": 0, "path": "src/ethereum_spec_tools/evm_tools/t8n/__init__.py"}, "content": {"type": ["function"], "name": ["state"], "text": ["The state module of the given fork."]}}, {"source": {"identifier": "ethereum_spec_tools.evm_tools.t8n.T8N.trie", "specifier": 0, "path": "src/ethereum_spec_tools/evm_tools/t8n/__init__.py"}, "content": {"type": ["function"], "name": ["trie"], "text": ["The trie module of the given fork."]}}, {"source": {"identifier": "ethereum_spec_tools.evm_tools.t8n.T8N.bloom", "specifier": 0, "path": "src/ethereum_spec_tools/evm_tools/t8n/__init__.py"}, "content": {"type": ["function"], "name": ["bloom"], "text": ["The bloom module of the given fork."]}}, {"source": {"identifier": "ethereum_spec_tools.evm_tools.t8n.T8N.vm", "specifier": 0, "path": "src/ethereum_spec_tools/evm_tools/t8n/__init__.py"}, "content": {"type": ["function"], "name": ["vm"], "text": ["The vm module of the given fork."]}}, {"source": {"identifier": "ethereum_spec_tools.evm_tools.t8n.T8N.BLOCK_REWARD", "specifier": 0, "path": "src/ethereum_spec_tools/evm_tools/t8n/__init__.py"}, "content": {"type": ["function"], "name": ["BLOCK_REWARD"], "text": ["For the t8n tool, the block reward is provided as a command line option"]}}, {"source": {"identifier": "ethereum_spec_tools.evm_tools.t8n.T8N.is_after_fork", "specifier": 0, "path": "src/ethereum_spec_tools/evm_tools/t8n/__init__.py"}, "content": {"type": ["function"], "name": ["is_after_fork"], "text": ["Check if the fork is after the target fork"]}}, {"source": {"identifier": "ethereum_spec_tools.evm_tools.t8n.T8N.check_transaction", "specifier": 0, "path": "src/ethereum_spec_tools/evm_tools/t8n/__init__.py"}, "content": {"type": ["function"], "name": ["check_transaction"], "text": ["Implements the check_transaction function of the fork. The arguments to be passed are adjusted according to the fork."]}}, {"source": {"identifier": "ethereum_spec_tools.evm_tools.t8n.T8N.environment", "specifier": 0, "path": "src/ethereum_spec_tools/evm_tools/t8n/__init__.py"}, "content": {"type": ["function"], "name": ["environment"], "text": ["Create the environment for the transaction. The keyword arguments are adjusted according to the fork."]}}, {"source": {"identifier": "ethereum_spec_tools.evm_tools.t8n.T8N.tx_trie_set", "specifier": 0, "path": "src/ethereum_spec_tools/evm_tools/t8n/__init__.py"}, "content": {"type": ["function"], "name": ["tx_trie_set"], "text": ["Add a transaction to the trie."]}}, {"source": {"identifier": "ethereum_spec_tools.evm_tools.t8n.T8N.make_receipt", "specifier": 0, "path": "src/ethereum_spec_tools/evm_tools/t8n/__init__.py"}, "content": {"type": ["function"], "name": ["make_receipt"], "text": ["Create a transaction receipt."]}}, {"source": {"identifier": "ethereum_spec_tools.evm_tools.t8n.T8N.pay_rewards", "specifier": 0, "path": "src/ethereum_spec_tools/evm_tools/t8n/__init__.py"}, "content": {"type": ["function"], "name": ["pay_rewards"], "text": ["Pay the miner and the ommers. This function is re-implemented since the uncle header might not be available in the t8n tool."]}}, {"source": {"identifier": "ethereum_spec_tools.evm_tools.t8n.T8N.backup_state", "specifier": 0, "path": "src/ethereum_spec_tools/evm_tools/t8n/__init__.py"}, "content": {"type": ["function"], "name": ["backup_state"], "text": ["Back up the state in order to restore in case of an error."]}}, {"source": {"identifier": "ethereum_spec_tools.evm_tools.t8n.T8N.restore_state", "specifier": 0, "path": "src/ethereum_spec_tools/evm_tools/t8n/__init__.py"}, "content": {"type": ["function"], "name": ["restore_state"], "text": ["Restore the state from the backup."]}}, {"source": {"identifier": "ethereum_spec_tools.evm_tools.t8n.T8N.apply_body", "specifier": 0, "path": "src/ethereum_spec_tools/evm_tools/t8n/__init__.py"}, "content": {"type": ["function"], "name": ["apply_body"], "text": ["The apply body function is seen as the entry point of the t8n tool into the designated fork. The function has been re-implemented here to account for the differences in the transaction processing between the forks. However, the general structure of the function is the same."]}}, {"source": {"identifier": "ethereum_spec_tools.evm_tools.t8n.T8N.run", "specifier": 0, "path": "src/ethereum_spec_tools/evm_tools/t8n/__init__.py"}, "content": {"type": ["function"], "name": ["run"], "text": ["Run the transition and provide the relevant outputs"]}}, {"source": {"identifier": "ethereum.dao_fork", "specifier": 0, "path": "src/ethereum/dao_fork/__init__.py"}, "content": {"type": ["module"], "name": ["ethereum.dao_fork"], "text": ["Ethereum Dao Hardfork ^^^^^^^^^^^^^^^^^^^^^^^^^^^ The third Ethereum hardfork."]}}, {"source": {"identifier": "ethereum.dao_fork.MAINNET_FORK_BLOCK", "specifier": 0, "path": "src/ethereum/dao_fork/__init__.py"}, "content": {"type": ["attribute"], "name": ["MAINNET_FORK_BLOCK"]}}, {"source": {"identifier": "ethereum.constantinople.vm.precompiled_contracts.identity", "specifier": 0, "path": "src/ethereum/constantinople/vm/precompiled_contracts/identity.py"}, "content": {"type": ["module"], "name": ["ethereum.constantinople.vm.precompiled_contracts.identity"], "text": ["Ethereum Virtual Machine (EVM) IDENTITY PRECOMPILED CONTRACT ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementation of the  IDENTITY  precompiled contract."]}}, {"source": {"identifier": "ethereum.constantinople.vm.precompiled_contracts.identity.identity", "specifier": 0, "path": "src/ethereum/constantinople/vm/precompiled_contracts/identity.py"}, "content": {"type": ["function"], "name": ["identity"], "text": ["Writes the message data to output. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.berlin.vm.precompiled_contracts.alt_bn128", "specifier": 0, "path": "src/ethereum/berlin/vm/precompiled_contracts/alt_bn128.py"}, "content": {"type": ["module"], "name": ["ethereum.berlin.vm.precompiled_contracts.alt_bn128"], "text": ["Ethereum Virtual Machine (EVM) ALT_BN128 CONTRACTS ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementation of the ALT_BN128 precompiled contracts."]}}, {"source": {"identifier": "ethereum.berlin.vm.precompiled_contracts.alt_bn128.alt_bn128_add", "specifier": 0, "path": "src/ethereum/berlin/vm/precompiled_contracts/alt_bn128.py"}, "content": {"type": ["function"], "name": ["alt_bn128_add"], "text": ["The ALT_BN128 addition precompiled contract. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.berlin.vm.precompiled_contracts.alt_bn128.alt_bn128_mul", "specifier": 0, "path": "src/ethereum/berlin/vm/precompiled_contracts/alt_bn128.py"}, "content": {"type": ["function"], "name": ["alt_bn128_mul"], "text": ["The ALT_BN128 multiplication precompiled contract. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.berlin.vm.precompiled_contracts.alt_bn128.alt_bn128_pairing_check", "specifier": 0, "path": "src/ethereum/berlin/vm/precompiled_contracts/alt_bn128.py"}, "content": {"type": ["function"], "name": ["alt_bn128_pairing_check"], "text": ["The ALT_BN128 pairing check precompiled contract. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.dao_fork.dao", "specifier": 0, "path": "src/ethereum/dao_fork/dao.py"}, "content": {"type": ["module"], "name": ["ethereum.dao_fork.dao"], "text": ["Dao Fork ^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction The Dao Fork was an irregular state change that moved all Ether from a large collection of accounts (The Dao and all its children) to a recovery contract. The recovery contract was previously created using normal contract deployment."]}}, {"source": {"identifier": "ethereum.dao_fork.dao.DAO_ACCOUNTS", "specifier": 0, "path": "src/ethereum/dao_fork/dao.py"}, "content": {"type": ["attribute"], "name": ["DAO_ACCOUNTS"]}}, {"source": {"identifier": "ethereum.dao_fork.dao.DAO_RECOVERY", "specifier": 0, "path": "src/ethereum/dao_fork/dao.py"}, "content": {"type": ["attribute"], "name": ["DAO_RECOVERY"]}}, {"source": {"identifier": "ethereum.dao_fork.dao.apply_dao", "specifier": 0, "path": "src/ethereum/dao_fork/dao.py"}, "content": {"type": ["function"], "name": ["apply_dao"], "text": ["Apply the dao fork to the state. Parameters state : State before applying the DAO Fork."]}}, {"source": {"identifier": "ethereum_spec_tools.evm_tools.t8n.t8n_types", "specifier": 0, "path": "src/ethereum_spec_tools/evm_tools/t8n/t8n_types.py"}, "content": {"type": ["module"], "name": ["ethereum_spec_tools.evm_tools.t8n.t8n_types"], "text": ["Define the types used by the t8n tool."]}}, {"source": {"identifier": "ethereum_spec_tools.evm_tools.t8n.t8n_types.Ommer", "specifier": 0, "path": "src/ethereum_spec_tools/evm_tools/t8n/t8n_types.py"}, "content": {"type": ["class"], "name": ["Ommer"], "text": ["The Ommer type for the t8n tool."]}}, {"source": {"identifier": "ethereum_spec_tools.evm_tools.t8n.t8n_types.Ommer.delta", "specifier": 0, "path": "src/ethereum_spec_tools/evm_tools/t8n/t8n_types.py"}, "content": {"type": ["attribute"], "name": ["delta"]}}, {"source": {"identifier": "ethereum_spec_tools.evm_tools.t8n.t8n_types.Ommer.address", "specifier": 0, "path": "src/ethereum_spec_tools/evm_tools/t8n/t8n_types.py"}, "content": {"type": ["attribute"], "name": ["address"]}}, {"source": {"identifier": "ethereum_spec_tools.evm_tools.t8n.t8n_types.Env", "specifier": 0, "path": "src/ethereum_spec_tools/evm_tools/t8n/t8n_types.py"}, "content": {"type": ["class"], "name": ["Env"], "text": ["The environment for the transition tool."]}}, {"source": {"identifier": "ethereum_spec_tools.evm_tools.t8n.t8n_types.Env.coinbase", "specifier": 0, "path": "src/ethereum_spec_tools/evm_tools/t8n/t8n_types.py"}, "content": {"type": ["attribute"], "name": ["coinbase"]}}, {"source": {"identifier": "ethereum_spec_tools.evm_tools.t8n.t8n_types.Env.block_gas_limit", "specifier": 0, "path": "src/ethereum_spec_tools/evm_tools/t8n/t8n_types.py"}, "content": {"type": ["attribute"], "name": ["block_gas_limit"]}}, {"source": {"identifier": "ethereum_spec_tools.evm_tools.t8n.t8n_types.Env.block_number", "specifier": 0, "path": "src/ethereum_spec_tools/evm_tools/t8n/t8n_types.py"}, "content": {"type": ["attribute"], "name": ["block_number"]}}, {"source": {"identifier": "ethereum_spec_tools.evm_tools.t8n.t8n_types.Env.block_timestamp", "specifier": 0, "path": "src/ethereum_spec_tools/evm_tools/t8n/t8n_types.py"}, "content": {"type": ["attribute"], "name": ["block_timestamp"]}}, {"source": {"identifier": "ethereum_spec_tools.evm_tools.t8n.t8n_types.Env.withdrawals", "specifier": 0, "path": "src/ethereum_spec_tools/evm_tools/t8n/t8n_types.py"}, "content": {"type": ["attribute"], "name": ["withdrawals"]}}, {"source": {"identifier": "ethereum_spec_tools.evm_tools.t8n.t8n_types.Env.block_difficulty", "specifier": 0, "path": "src/ethereum_spec_tools/evm_tools/t8n/t8n_types.py"}, "content": {"type": ["attribute"], "name": ["block_difficulty"]}}, {"source": {"identifier": "ethereum_spec_tools.evm_tools.t8n.t8n_types.Env.prev_randao", "specifier": 0, "path": "src/ethereum_spec_tools/evm_tools/t8n/t8n_types.py"}, "content": {"type": ["attribute"], "name": ["prev_randao"]}}, {"source": {"identifier": "ethereum_spec_tools.evm_tools.t8n.t8n_types.Env.parent_difficulty", "specifier": 0, "path": "src/ethereum_spec_tools/evm_tools/t8n/t8n_types.py"}, "content": {"type": ["attribute"], "name": ["parent_difficulty"]}}, {"source": {"identifier": "ethereum_spec_tools.evm_tools.t8n.t8n_types.Env.parent_timestamp", "specifier": 0, "path": "src/ethereum_spec_tools/evm_tools/t8n/t8n_types.py"}, "content": {"type": ["attribute"], "name": ["parent_timestamp"]}}, {"source": {"identifier": "ethereum_spec_tools.evm_tools.t8n.t8n_types.Env.base_fee_per_gas", "specifier": 0, "path": "src/ethereum_spec_tools/evm_tools/t8n/t8n_types.py"}, "content": {"type": ["attribute"], "name": ["base_fee_per_gas"]}}, {"source": {"identifier": "ethereum_spec_tools.evm_tools.t8n.t8n_types.Env.parent_gas_used", "specifier": 0, "path": "src/ethereum_spec_tools/evm_tools/t8n/t8n_types.py"}, "content": {"type": ["attribute"], "name": ["parent_gas_used"]}}, {"source": {"identifier": "ethereum_spec_tools.evm_tools.t8n.t8n_types.Env.parent_gas_limit", "specifier": 0, "path": "src/ethereum_spec_tools/evm_tools/t8n/t8n_types.py"}, "content": {"type": ["attribute"], "name": ["parent_gas_limit"]}}, {"source": {"identifier": "ethereum_spec_tools.evm_tools.t8n.t8n_types.Env.parent_base_fee_per_gas", "specifier": 0, "path": "src/ethereum_spec_tools/evm_tools/t8n/t8n_types.py"}, "content": {"type": ["attribute"], "name": ["parent_base_fee_per_gas"]}}, {"source": {"identifier": "ethereum_spec_tools.evm_tools.t8n.t8n_types.Env.block_hashes", "specifier": 0, "path": "src/ethereum_spec_tools/evm_tools/t8n/t8n_types.py"}, "content": {"type": ["attribute"], "name": ["block_hashes"]}}, {"source": {"identifier": "ethereum_spec_tools.evm_tools.t8n.t8n_types.Env.parent_ommers_hash", "specifier": 0, "path": "src/ethereum_spec_tools/evm_tools/t8n/t8n_types.py"}, "content": {"type": ["attribute"], "name": ["parent_ommers_hash"]}}, {"source": {"identifier": "ethereum_spec_tools.evm_tools.t8n.t8n_types.Env.ommers", "specifier": 0, "path": "src/ethereum_spec_tools/evm_tools/t8n/t8n_types.py"}, "content": {"type": ["attribute"], "name": ["ommers"]}}, {"source": {"identifier": "ethereum_spec_tools.evm_tools.t8n.t8n_types.Env.__init__", "specifier": 0, "path": "src/ethereum_spec_tools/evm_tools/t8n/t8n_types.py"}, "content": {"type": ["function"], "name": ["__init__"]}}, {"source": {"identifier": "ethereum_spec_tools.evm_tools.t8n.t8n_types.Env.read_base_fee_per_gas", "specifier": 0, "path": "src/ethereum_spec_tools/evm_tools/t8n/t8n_types.py"}, "content": {"type": ["function"], "name": ["read_base_fee_per_gas"], "text": ["Read the base_fee_per_gas from the data. If the base fee is not present, it is calculated from the parent block parameters."]}}, {"source": {"identifier": "ethereum_spec_tools.evm_tools.t8n.t8n_types.Env.read_randao", "specifier": 0, "path": "src/ethereum_spec_tools/evm_tools/t8n/t8n_types.py"}, "content": {"type": ["function"], "name": ["read_randao"], "text": ["Read the randao from the data."]}}, {"source": {"identifier": "ethereum_spec_tools.evm_tools.t8n.t8n_types.Env.read_withdrawals", "specifier": 0, "path": "src/ethereum_spec_tools/evm_tools/t8n/t8n_types.py"}, "content": {"type": ["function"], "name": ["read_withdrawals"], "text": ["Read the withdrawals from the data."]}}, {"source": {"identifier": "ethereum_spec_tools.evm_tools.t8n.t8n_types.Env.read_block_difficulty", "specifier": 0, "path": "src/ethereum_spec_tools/evm_tools/t8n/t8n_types.py"}, "content": {"type": ["function"], "name": ["read_block_difficulty"], "text": ["Read the block difficulty from the data. If  currentDifficulty  is present, it is used. Otherwise, the difficulty is calculated from the parent block."]}}, {"source": {"identifier": "ethereum_spec_tools.evm_tools.t8n.t8n_types.Env.read_block_hashes", "specifier": 0, "path": "src/ethereum_spec_tools/evm_tools/t8n/t8n_types.py"}, "content": {"type": ["function"], "name": ["read_block_hashes"], "text": ["Read the block hashes. Returns a maximum of 256 block hashes."]}}, {"source": {"identifier": "ethereum_spec_tools.evm_tools.t8n.t8n_types.Env.read_ommers", "specifier": 0, "path": "src/ethereum_spec_tools/evm_tools/t8n/t8n_types.py"}, "content": {"type": ["function"], "name": ["read_ommers"], "text": ["Read the ommers. The ommers data might not have all the details needed to obtain the Header."]}}, {"source": {"identifier": "ethereum_spec_tools.evm_tools.t8n.t8n_types.Alloc", "specifier": 0, "path": "src/ethereum_spec_tools/evm_tools/t8n/t8n_types.py"}, "content": {"type": ["class"], "name": ["Alloc"], "text": ["The alloc (state) type for the t8n tool."]}}, {"source": {"identifier": "ethereum_spec_tools.evm_tools.t8n.t8n_types.Alloc.state", "specifier": 0, "path": "src/ethereum_spec_tools/evm_tools/t8n/t8n_types.py"}, "content": {"type": ["attribute"], "name": ["state"]}}, {"source": {"identifier": "ethereum_spec_tools.evm_tools.t8n.t8n_types.Alloc.state_backup", "specifier": 0, "path": "src/ethereum_spec_tools/evm_tools/t8n/t8n_types.py"}, "content": {"type": ["attribute"], "name": ["state_backup"]}}, {"source": {"identifier": "ethereum_spec_tools.evm_tools.t8n.t8n_types.Alloc.__init__", "specifier": 0, "path": "src/ethereum_spec_tools/evm_tools/t8n/t8n_types.py"}, "content": {"type": ["function"], "name": ["__init__"], "text": ["Read the alloc file and return the state."]}}, {"source": {"identifier": "ethereum_spec_tools.evm_tools.t8n.t8n_types.Alloc.to_json", "specifier": 0, "path": "src/ethereum_spec_tools/evm_tools/t8n/t8n_types.py"}, "content": {"type": ["function"], "name": ["to_json"], "text": ["Encode the state to JSON"]}}, {"source": {"identifier": "ethereum_spec_tools.evm_tools.t8n.t8n_types.Txs", "specifier": 0, "path": "src/ethereum_spec_tools/evm_tools/t8n/t8n_types.py"}, "content": {"type": ["class"], "name": ["Txs"], "text": ["Read the transactions file, sort out the valid transactions and return a list of transactions."]}}, {"source": {"identifier": "ethereum_spec_tools.evm_tools.t8n.t8n_types.Txs.rejected_txs", "specifier": 0, "path": "src/ethereum_spec_tools/evm_tools/t8n/t8n_types.py"}, "content": {"type": ["attribute"], "name": ["rejected_txs"]}}, {"source": {"identifier": "ethereum_spec_tools.evm_tools.t8n.t8n_types.Txs.successful_txs", "specifier": 0, "path": "src/ethereum_spec_tools/evm_tools/t8n/t8n_types.py"}, "content": {"type": ["attribute"], "name": ["successful_txs"]}}, {"source": {"identifier": "ethereum_spec_tools.evm_tools.t8n.t8n_types.Txs.all_txs", "specifier": 0, "path": "src/ethereum_spec_tools/evm_tools/t8n/t8n_types.py"}, "content": {"type": ["attribute"], "name": ["all_txs"]}}, {"source": {"identifier": "ethereum_spec_tools.evm_tools.t8n.t8n_types.Txs.t8n", "specifier": 0, "path": "src/ethereum_spec_tools/evm_tools/t8n/t8n_types.py"}, "content": {"type": ["attribute"], "name": ["t8n"]}}, {"source": {"identifier": "ethereum_spec_tools.evm_tools.t8n.t8n_types.Txs.data", "specifier": 0, "path": "src/ethereum_spec_tools/evm_tools/t8n/t8n_types.py"}, "content": {"type": ["attribute"], "name": ["data"]}}, {"source": {"identifier": "ethereum_spec_tools.evm_tools.t8n.t8n_types.Txs.rlp_input", "specifier": 0, "path": "src/ethereum_spec_tools/evm_tools/t8n/t8n_types.py"}, "content": {"type": ["attribute"], "name": ["rlp_input"]}}, {"source": {"identifier": "ethereum_spec_tools.evm_tools.t8n.t8n_types.Txs.__init__", "specifier": 0, "path": "src/ethereum_spec_tools/evm_tools/t8n/t8n_types.py"}, "content": {"type": ["function"], "name": ["__init__"]}}, {"source": {"identifier": "ethereum_spec_tools.evm_tools.t8n.t8n_types.Txs.transactions", "specifier": 0, "path": "src/ethereum_spec_tools/evm_tools/t8n/t8n_types.py"}, "content": {"type": ["function"], "name": ["transactions"], "text": ["Read the transactions file and return a list of transactions. Can read from JSON or RLP."]}}, {"source": {"identifier": "ethereum_spec_tools.evm_tools.t8n.t8n_types.Txs.parse_rlp_tx", "specifier": 0, "path": "src/ethereum_spec_tools/evm_tools/t8n/t8n_types.py"}, "content": {"type": ["function"], "name": ["parse_rlp_tx"], "text": ["Read transactions from RLP."]}}, {"source": {"identifier": "ethereum_spec_tools.evm_tools.t8n.t8n_types.Txs.parse_json_tx", "specifier": 0, "path": "src/ethereum_spec_tools/evm_tools/t8n/t8n_types.py"}, "content": {"type": ["function"], "name": ["parse_json_tx"], "text": ["Read the transactions from json. If a transaction is unsigned but has a  secretKey  field, the transaction will be signed."]}}, {"source": {"identifier": "ethereum_spec_tools.evm_tools.t8n.t8n_types.Txs.add_transaction", "specifier": 0, "path": "src/ethereum_spec_tools/evm_tools/t8n/t8n_types.py"}, "content": {"type": ["function"], "name": ["add_transaction"], "text": ["Add a transaction to the list of successful transactions."]}}, {"source": {"identifier": "ethereum_spec_tools.evm_tools.t8n.t8n_types.Txs.sign_transaction", "specifier": 0, "path": "src/ethereum_spec_tools/evm_tools/t8n/t8n_types.py"}, "content": {"type": ["function"], "name": ["sign_transaction"], "text": ["Sign a transaction. This function will be invoked if a  secretKey is provided in the transaction. Post spurious dragon, the transaction is signed according to EIP-155 if the protected flag is missing or set to true."]}}, {"source": {"identifier": "ethereum_spec_tools.evm_tools.t8n.t8n_types.Result", "specifier": 0, "path": "src/ethereum_spec_tools/evm_tools/t8n/t8n_types.py"}, "content": {"type": ["class"], "name": ["Result"], "text": ["Type that represents the result of a transition execution"]}}, {"source": {"identifier": "ethereum_spec_tools.evm_tools.t8n.t8n_types.Result.difficulty", "specifier": 0, "path": "src/ethereum_spec_tools/evm_tools/t8n/t8n_types.py"}, "content": {"type": ["attribute"], "name": ["difficulty"]}}, {"source": {"identifier": "ethereum_spec_tools.evm_tools.t8n.t8n_types.Result.base_fee", "specifier": 0, "path": "src/ethereum_spec_tools/evm_tools/t8n/t8n_types.py"}, "content": {"type": ["attribute"], "name": ["base_fee"]}}, {"source": {"identifier": "ethereum_spec_tools.evm_tools.t8n.t8n_types.Result.state_root", "specifier": 0, "path": "src/ethereum_spec_tools/evm_tools/t8n/t8n_types.py"}, "content": {"type": ["attribute"], "name": ["state_root"]}}, {"source": {"identifier": "ethereum_spec_tools.evm_tools.t8n.t8n_types.Result.tx_root", "specifier": 0, "path": "src/ethereum_spec_tools/evm_tools/t8n/t8n_types.py"}, "content": {"type": ["attribute"], "name": ["tx_root"]}}, {"source": {"identifier": "ethereum_spec_tools.evm_tools.t8n.t8n_types.Result.receipt_root", "specifier": 0, "path": "src/ethereum_spec_tools/evm_tools/t8n/t8n_types.py"}, "content": {"type": ["attribute"], "name": ["receipt_root"]}}, {"source": {"identifier": "ethereum_spec_tools.evm_tools.t8n.t8n_types.Result.withdrawals_root", "specifier": 0, "path": "src/ethereum_spec_tools/evm_tools/t8n/t8n_types.py"}, "content": {"type": ["attribute"], "name": ["withdrawals_root"]}}, {"source": {"identifier": "ethereum_spec_tools.evm_tools.t8n.t8n_types.Result.logs_hash", "specifier": 0, "path": "src/ethereum_spec_tools/evm_tools/t8n/t8n_types.py"}, "content": {"type": ["attribute"], "name": ["logs_hash"]}}, {"source": {"identifier": "ethereum_spec_tools.evm_tools.t8n.t8n_types.Result.bloom", "specifier": 0, "path": "src/ethereum_spec_tools/evm_tools/t8n/t8n_types.py"}, "content": {"type": ["attribute"], "name": ["bloom"]}}, {"source": {"identifier": "ethereum_spec_tools.evm_tools.t8n.t8n_types.Result.rejected", "specifier": 0, "path": "src/ethereum_spec_tools/evm_tools/t8n/t8n_types.py"}, "content": {"type": ["attribute"], "name": ["rejected"]}}, {"source": {"identifier": "ethereum_spec_tools.evm_tools.t8n.t8n_types.Result.gas_used", "specifier": 0, "path": "src/ethereum_spec_tools/evm_tools/t8n/t8n_types.py"}, "content": {"type": ["attribute"], "name": ["gas_used"]}}, {"source": {"identifier": "ethereum_spec_tools.evm_tools.t8n.t8n_types.Result.to_json", "specifier": 0, "path": "src/ethereum_spec_tools/evm_tools/t8n/t8n_types.py"}, "content": {"type": ["function"], "name": ["to_json"], "text": ["Encode the result to JSON"]}}, {"source": {"identifier": "ethereum.dao_fork.bloom", "specifier": 0, "path": "src/ethereum/dao_fork/bloom.py"}, "content": {"type": ["module"], "name": ["ethereum.dao_fork.bloom"], "text": ["Ethereum Logs Bloom ^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction This modules defines functions for calculating bloom filters of logs. For the general theory of bloom filters see e.g.  Wikipedia <https://en.wikipedia.org/wiki/Bloom_filter> _. Bloom filters are used to allow for efficient searching of logs by address and/or topic, by rapidly eliminating blocks and reciepts from their search."]}}, {"source": {"identifier": "ethereum.dao_fork.bloom.add_to_bloom", "specifier": 0, "path": "src/ethereum/dao_fork/bloom.py"}, "content": {"type": ["function"], "name": ["add_to_bloom"], "text": ["Add a bloom entry to the bloom filter ( bloom ). The number of hash functions used is 3. They are calculated by taking the least significant 11 bits from the first 3 16-bit words of the keccak_256()  hash of  bloom_entry . Parameters bloom : The bloom filter. bloom_entry : An entry which is to be added to bloom filter."]}}, {"source": {"identifier": "ethereum.dao_fork.bloom.logs_bloom", "specifier": 0, "path": "src/ethereum/dao_fork/bloom.py"}, "content": {"type": ["function"], "name": ["logs_bloom"], "text": ["Obtain the logs bloom from a list of log entries. The address and each topic of a log are added to the bloom filter. Parameters logs : List of logs for which the logs bloom is to be obtained. Returns logs_bloom :  Bloom The logs bloom obtained which is 256 bytes with some bits set as per the caller address and the log topics."]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.memory", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/memory.py"}, "content": {"type": ["module"], "name": ["ethereum.constantinople.vm.instructions.memory"], "text": ["Ethereum Virtual Machine (EVM) Memory Instructions ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementations of the EVM Memory instructions."]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.memory.mstore", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/memory.py"}, "content": {"type": ["function"], "name": ["mstore"], "text": ["Stores a word to memory. This also expands the memory, if the memory is insufficient to store the word. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.memory.mstore8", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/memory.py"}, "content": {"type": ["function"], "name": ["mstore8"], "text": ["Stores a byte to memory. This also expands the memory, if the memory is insufficient to store the word. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.memory.mload", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/memory.py"}, "content": {"type": ["function"], "name": ["mload"], "text": ["Load word from memory. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.memory.msize", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/memory.py"}, "content": {"type": ["function"], "name": ["msize"], "text": ["Push the size of active memory in bytes onto the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.berlin.vm.precompiled_contracts.ripemd160", "specifier": 0, "path": "src/ethereum/berlin/vm/precompiled_contracts/ripemd160.py"}, "content": {"type": ["module"], "name": ["ethereum.berlin.vm.precompiled_contracts.ripemd160"], "text": ["Ethereum Virtual Machine (EVM) RIPEMD160 PRECOMPILED CONTRACT ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementation of the  RIPEMD160  precompiled contract."]}}, {"source": {"identifier": "ethereum.berlin.vm.precompiled_contracts.ripemd160.ripemd160", "specifier": 0, "path": "src/ethereum/berlin/vm/precompiled_contracts/ripemd160.py"}, "content": {"type": ["function"], "name": ["ripemd160"], "text": ["Writes the ripemd160 hash to output. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum_spec_tools.evm_tools.b11r", "specifier": 0, "path": "src/ethereum_spec_tools/evm_tools/b11r/__init__.py"}, "content": {"type": ["module"], "name": ["ethereum_spec_tools.evm_tools.b11r"], "text": ["Create a block builder tool for the given fork."]}}, {"source": {"identifier": "ethereum_spec_tools.evm_tools.b11r.b11r_arguments", "specifier": 0, "path": "src/ethereum_spec_tools/evm_tools/b11r/__init__.py"}, "content": {"type": ["function"], "name": ["b11r_arguments"], "text": ["Adds the arguments for the b11r tool subparser."]}}, {"source": {"identifier": "ethereum_spec_tools.evm_tools.b11r.B11R", "specifier": 0, "path": "src/ethereum_spec_tools/evm_tools/b11r/__init__.py"}, "content": {"type": ["class"], "name": ["B11R"], "text": ["Creates the b11r tool."]}}, {"source": {"identifier": "ethereum_spec_tools.evm_tools.b11r.B11R.__init__", "specifier": 0, "path": "src/ethereum_spec_tools/evm_tools/b11r/__init__.py"}, "content": {"type": ["function"], "name": ["__init__"], "text": ["Initializes the b11r tool."]}}, {"source": {"identifier": "ethereum_spec_tools.evm_tools.b11r.B11R.build_block", "specifier": 0, "path": "src/ethereum_spec_tools/evm_tools/b11r/__init__.py"}, "content": {"type": ["function"], "name": ["build_block"], "text": ["Builds the block."]}}, {"source": {"identifier": "ethereum_spec_tools.evm_tools.b11r.B11R.run", "specifier": 0, "path": "src/ethereum_spec_tools/evm_tools/b11r/__init__.py"}, "content": {"type": ["function"], "name": ["run"], "text": ["Runs the b11r tool."]}}, {"source": {"identifier": "ethereum.dao_fork.fork_types", "specifier": 0, "path": "src/ethereum/dao_fork/fork_types.py"}, "content": {"type": ["module"], "name": ["ethereum.dao_fork.fork_types"], "text": ["Ethereum Types ^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Types re-used throughout the specification, which are specific to Ethereum."]}}, {"source": {"identifier": "ethereum.dao_fork.fork_types.Address", "specifier": 0, "path": "src/ethereum/dao_fork/fork_types.py"}, "content": {"type": ["attribute"], "name": ["Address"]}}, {"source": {"identifier": "ethereum.dao_fork.fork_types.Root", "specifier": 0, "path": "src/ethereum/dao_fork/fork_types.py"}, "content": {"type": ["attribute"], "name": ["Root"]}}, {"source": {"identifier": "ethereum.dao_fork.fork_types.Bloom", "specifier": 0, "path": "src/ethereum/dao_fork/fork_types.py"}, "content": {"type": ["attribute"], "name": ["Bloom"]}}, {"source": {"identifier": "ethereum.dao_fork.fork_types.TX_BASE_COST", "specifier": 0, "path": "src/ethereum/dao_fork/fork_types.py"}, "content": {"type": ["attribute"], "name": ["TX_BASE_COST"]}}, {"source": {"identifier": "ethereum.dao_fork.fork_types.TX_DATA_COST_PER_NON_ZERO", "specifier": 0, "path": "src/ethereum/dao_fork/fork_types.py"}, "content": {"type": ["attribute"], "name": ["TX_DATA_COST_PER_NON_ZERO"]}}, {"source": {"identifier": "ethereum.dao_fork.fork_types.TX_DATA_COST_PER_ZERO", "specifier": 0, "path": "src/ethereum/dao_fork/fork_types.py"}, "content": {"type": ["attribute"], "name": ["TX_DATA_COST_PER_ZERO"]}}, {"source": {"identifier": "ethereum.dao_fork.fork_types.TX_CREATE_COST", "specifier": 0, "path": "src/ethereum/dao_fork/fork_types.py"}, "content": {"type": ["attribute"], "name": ["TX_CREATE_COST"]}}, {"source": {"identifier": "ethereum.dao_fork.fork_types.Transaction", "specifier": 0, "path": "src/ethereum/dao_fork/fork_types.py"}, "content": {"type": ["class"], "name": ["Transaction"], "text": ["Atomic operation performed on the block chain."]}}, {"source": {"identifier": "ethereum.dao_fork.fork_types.Transaction.nonce", "specifier": 0, "path": "src/ethereum/dao_fork/fork_types.py"}, "content": {"type": ["attribute"], "name": ["nonce"]}}, {"source": {"identifier": "ethereum.dao_fork.fork_types.Transaction.gas_price", "specifier": 0, "path": "src/ethereum/dao_fork/fork_types.py"}, "content": {"type": ["attribute"], "name": ["gas_price"]}}, {"source": {"identifier": "ethereum.dao_fork.fork_types.Transaction.gas", "specifier": 0, "path": "src/ethereum/dao_fork/fork_types.py"}, "content": {"type": ["attribute"], "name": ["gas"]}}, {"source": {"identifier": "ethereum.dao_fork.fork_types.Transaction.to", "specifier": 0, "path": "src/ethereum/dao_fork/fork_types.py"}, "content": {"type": ["attribute"], "name": ["to"]}}, {"source": {"identifier": "ethereum.dao_fork.fork_types.Transaction.value", "specifier": 0, "path": "src/ethereum/dao_fork/fork_types.py"}, "content": {"type": ["attribute"], "name": ["value"]}}, {"source": {"identifier": "ethereum.dao_fork.fork_types.Transaction.data", "specifier": 0, "path": "src/ethereum/dao_fork/fork_types.py"}, "content": {"type": ["attribute"], "name": ["data"]}}, {"source": {"identifier": "ethereum.dao_fork.fork_types.Transaction.v", "specifier": 0, "path": "src/ethereum/dao_fork/fork_types.py"}, "content": {"type": ["attribute"], "name": ["v"]}}, {"source": {"identifier": "ethereum.dao_fork.fork_types.Transaction.r", "specifier": 0, "path": "src/ethereum/dao_fork/fork_types.py"}, "content": {"type": ["attribute"], "name": ["r"]}}, {"source": {"identifier": "ethereum.dao_fork.fork_types.Transaction.s", "specifier": 0, "path": "src/ethereum/dao_fork/fork_types.py"}, "content": {"type": ["attribute"], "name": ["s"]}}, {"source": {"identifier": "ethereum.dao_fork.fork_types.Account", "specifier": 0, "path": "src/ethereum/dao_fork/fork_types.py"}, "content": {"type": ["class"], "name": ["Account"], "text": ["State associated with an address."]}}, {"source": {"identifier": "ethereum.dao_fork.fork_types.Account.nonce", "specifier": 0, "path": "src/ethereum/dao_fork/fork_types.py"}, "content": {"type": ["attribute"], "name": ["nonce"]}}, {"source": {"identifier": "ethereum.dao_fork.fork_types.Account.balance", "specifier": 0, "path": "src/ethereum/dao_fork/fork_types.py"}, "content": {"type": ["attribute"], "name": ["balance"]}}, {"source": {"identifier": "ethereum.dao_fork.fork_types.Account.code", "specifier": 0, "path": "src/ethereum/dao_fork/fork_types.py"}, "content": {"type": ["attribute"], "name": ["code"]}}, {"source": {"identifier": "ethereum.dao_fork.fork_types.EMPTY_ACCOUNT", "specifier": 0, "path": "src/ethereum/dao_fork/fork_types.py"}, "content": {"type": ["attribute"], "name": ["EMPTY_ACCOUNT"]}}, {"source": {"identifier": "ethereum.dao_fork.fork_types.encode_account", "specifier": 0, "path": "src/ethereum/dao_fork/fork_types.py"}, "content": {"type": ["function"], "name": ["encode_account"], "text": ["Encode  Account  dataclass. Storage is not stored in the  Account  dataclass, so  Accounts  cannot be encoded with providing a storage root."]}}, {"source": {"identifier": "ethereum.dao_fork.fork_types.Header", "specifier": 0, "path": "src/ethereum/dao_fork/fork_types.py"}, "content": {"type": ["class"], "name": ["Header"], "text": ["Header portion of a block on the chain."]}}, {"source": {"identifier": "ethereum.dao_fork.fork_types.Header.parent_hash", "specifier": 0, "path": "src/ethereum/dao_fork/fork_types.py"}, "content": {"type": ["attribute"], "name": ["parent_hash"]}}, {"source": {"identifier": "ethereum.dao_fork.fork_types.Header.ommers_hash", "specifier": 0, "path": "src/ethereum/dao_fork/fork_types.py"}, "content": {"type": ["attribute"], "name": ["ommers_hash"]}}, {"source": {"identifier": "ethereum.dao_fork.fork_types.Header.coinbase", "specifier": 0, "path": "src/ethereum/dao_fork/fork_types.py"}, "content": {"type": ["attribute"], "name": ["coinbase"]}}, {"source": {"identifier": "ethereum.dao_fork.fork_types.Header.state_root", "specifier": 0, "path": "src/ethereum/dao_fork/fork_types.py"}, "content": {"type": ["attribute"], "name": ["state_root"]}}, {"source": {"identifier": "ethereum.dao_fork.fork_types.Header.transactions_root", "specifier": 0, "path": "src/ethereum/dao_fork/fork_types.py"}, "content": {"type": ["attribute"], "name": ["transactions_root"]}}, {"source": {"identifier": "ethereum.dao_fork.fork_types.Header.receipt_root", "specifier": 0, "path": "src/ethereum/dao_fork/fork_types.py"}, "content": {"type": ["attribute"], "name": ["receipt_root"]}}, {"source": {"identifier": "ethereum.dao_fork.fork_types.Header.bloom", "specifier": 0, "path": "src/ethereum/dao_fork/fork_types.py"}, "content": {"type": ["attribute"], "name": ["bloom"]}}, {"source": {"identifier": "ethereum.dao_fork.fork_types.Header.difficulty", "specifier": 0, "path": "src/ethereum/dao_fork/fork_types.py"}, "content": {"type": ["attribute"], "name": ["difficulty"]}}, {"source": {"identifier": "ethereum.dao_fork.fork_types.Header.number", "specifier": 0, "path": "src/ethereum/dao_fork/fork_types.py"}, "content": {"type": ["attribute"], "name": ["number"]}}, {"source": {"identifier": "ethereum.dao_fork.fork_types.Header.gas_limit", "specifier": 0, "path": "src/ethereum/dao_fork/fork_types.py"}, "content": {"type": ["attribute"], "name": ["gas_limit"]}}, {"source": {"identifier": "ethereum.dao_fork.fork_types.Header.gas_used", "specifier": 0, "path": "src/ethereum/dao_fork/fork_types.py"}, "content": {"type": ["attribute"], "name": ["gas_used"]}}, {"source": {"identifier": "ethereum.dao_fork.fork_types.Header.timestamp", "specifier": 0, "path": "src/ethereum/dao_fork/fork_types.py"}, "content": {"type": ["attribute"], "name": ["timestamp"]}}, {"source": {"identifier": "ethereum.dao_fork.fork_types.Header.extra_data", "specifier": 0, "path": "src/ethereum/dao_fork/fork_types.py"}, "content": {"type": ["attribute"], "name": ["extra_data"]}}, {"source": {"identifier": "ethereum.dao_fork.fork_types.Header.mix_digest", "specifier": 0, "path": "src/ethereum/dao_fork/fork_types.py"}, "content": {"type": ["attribute"], "name": ["mix_digest"]}}, {"source": {"identifier": "ethereum.dao_fork.fork_types.Header.nonce", "specifier": 0, "path": "src/ethereum/dao_fork/fork_types.py"}, "content": {"type": ["attribute"], "name": ["nonce"]}}, {"source": {"identifier": "ethereum.dao_fork.fork_types.Block", "specifier": 0, "path": "src/ethereum/dao_fork/fork_types.py"}, "content": {"type": ["class"], "name": ["Block"], "text": ["A complete block."]}}, {"source": {"identifier": "ethereum.dao_fork.fork_types.Block.header", "specifier": 0, "path": "src/ethereum/dao_fork/fork_types.py"}, "content": {"type": ["attribute"], "name": ["header"]}}, {"source": {"identifier": "ethereum.dao_fork.fork_types.Block.transactions", "specifier": 0, "path": "src/ethereum/dao_fork/fork_types.py"}, "content": {"type": ["attribute"], "name": ["transactions"]}}, {"source": {"identifier": "ethereum.dao_fork.fork_types.Block.ommers", "specifier": 0, "path": "src/ethereum/dao_fork/fork_types.py"}, "content": {"type": ["attribute"], "name": ["ommers"]}}, {"source": {"identifier": "ethereum.dao_fork.fork_types.Log", "specifier": 0, "path": "src/ethereum/dao_fork/fork_types.py"}, "content": {"type": ["class"], "name": ["Log"], "text": ["Data record produced during the execution of a transaction."]}}, {"source": {"identifier": "ethereum.dao_fork.fork_types.Log.address", "specifier": 0, "path": "src/ethereum/dao_fork/fork_types.py"}, "content": {"type": ["attribute"], "name": ["address"]}}, {"source": {"identifier": "ethereum.dao_fork.fork_types.Log.topics", "specifier": 0, "path": "src/ethereum/dao_fork/fork_types.py"}, "content": {"type": ["attribute"], "name": ["topics"]}}, {"source": {"identifier": "ethereum.dao_fork.fork_types.Log.data", "specifier": 0, "path": "src/ethereum/dao_fork/fork_types.py"}, "content": {"type": ["attribute"], "name": ["data"]}}, {"source": {"identifier": "ethereum.dao_fork.fork_types.Receipt", "specifier": 0, "path": "src/ethereum/dao_fork/fork_types.py"}, "content": {"type": ["class"], "name": ["Receipt"], "text": ["Result of a transaction."]}}, {"source": {"identifier": "ethereum.dao_fork.fork_types.Receipt.post_state", "specifier": 0, "path": "src/ethereum/dao_fork/fork_types.py"}, "content": {"type": ["attribute"], "name": ["post_state"]}}, {"source": {"identifier": "ethereum.dao_fork.fork_types.Receipt.cumulative_gas_used", "specifier": 0, "path": "src/ethereum/dao_fork/fork_types.py"}, "content": {"type": ["attribute"], "name": ["cumulative_gas_used"]}}, {"source": {"identifier": "ethereum.dao_fork.fork_types.Receipt.bloom", "specifier": 0, "path": "src/ethereum/dao_fork/fork_types.py"}, "content": {"type": ["attribute"], "name": ["bloom"]}}, {"source": {"identifier": "ethereum.dao_fork.fork_types.Receipt.logs", "specifier": 0, "path": "src/ethereum/dao_fork/fork_types.py"}, "content": {"type": ["attribute"], "name": ["logs"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.system", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/system.py"}, "content": {"type": ["module"], "name": ["ethereum.constantinople.vm.instructions.system"], "text": ["Ethereum Virtual Machine (EVM) System Instructions ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementations of the EVM system related instructions."]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.system.generic_create", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/system.py"}, "content": {"type": ["function"], "name": ["generic_create"], "text": ["Core logic used by the  CREATE*  family of opcodes."]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.system.create", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/system.py"}, "content": {"type": ["function"], "name": ["create"], "text": ["Creates a new account with associated code. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.system.create2", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/system.py"}, "content": {"type": ["function"], "name": ["create2"], "text": ["Creates a new account with associated code. It's similar to CREATE opcode except that the address of new account depends on the init_code instead of the nonce of sender. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.system.return_", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/system.py"}, "content": {"type": ["function"], "name": ["return_"], "text": ["Halts execution returning output data. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.system.generic_call", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/system.py"}, "content": {"type": ["function"], "name": ["generic_call"], "text": ["Perform the core logic of the  CALL*  family of opcodes."]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.system.call", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/system.py"}, "content": {"type": ["function"], "name": ["call"], "text": ["Message-call into an account. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.system.callcode", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/system.py"}, "content": {"type": ["function"], "name": ["callcode"], "text": ["Message-call into this account with alternative account\u2019s code. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.system.selfdestruct", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/system.py"}, "content": {"type": ["function"], "name": ["selfdestruct"], "text": ["Halt execution and register account for later deletion. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.system.delegatecall", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/system.py"}, "content": {"type": ["function"], "name": ["delegatecall"], "text": ["Message-call into an account. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.system.staticcall", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/system.py"}, "content": {"type": ["function"], "name": ["staticcall"], "text": ["Message-call into an account. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.system.revert", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/system.py"}, "content": {"type": ["function"], "name": ["revert"], "text": ["Stop execution and revert state changes, without consuming all provided gas and also has the ability to return a reason Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.berlin.vm.precompiled_contracts.sha256", "specifier": 0, "path": "src/ethereum/berlin/vm/precompiled_contracts/sha256.py"}, "content": {"type": ["module"], "name": ["ethereum.berlin.vm.precompiled_contracts.sha256"], "text": ["Ethereum Virtual Machine (EVM) SHA256 PRECOMPILED CONTRACT ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementation of the  SHA256  precompiled contract."]}}, {"source": {"identifier": "ethereum.berlin.vm.precompiled_contracts.sha256.sha256", "specifier": 0, "path": "src/ethereum/berlin/vm/precompiled_contracts/sha256.py"}, "content": {"type": ["function"], "name": ["sha256"], "text": ["Writes the sha256 hash to output. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.dao_fork.trie", "specifier": 0, "path": "src/ethereum/dao_fork/trie.py"}, "content": {"type": ["module"], "name": ["ethereum.dao_fork.trie"], "text": ["State Trie ^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction The state trie is the structure responsible for storing .fork_types.Account  objects."]}}, {"source": {"identifier": "ethereum.dao_fork.trie.EMPTY_TRIE_ROOT", "specifier": 0, "path": "src/ethereum/dao_fork/trie.py"}, "content": {"type": ["attribute"], "name": ["EMPTY_TRIE_ROOT"]}}, {"source": {"identifier": "ethereum.dao_fork.trie.Node", "specifier": 0, "path": "src/ethereum/dao_fork/trie.py"}, "content": {"type": ["attribute"], "name": ["Node"]}}, {"source": {"identifier": "ethereum.dao_fork.trie.K", "specifier": 0, "path": "src/ethereum/dao_fork/trie.py"}, "content": {"type": ["attribute"], "name": ["K"]}}, {"source": {"identifier": "ethereum.dao_fork.trie.V", "specifier": 0, "path": "src/ethereum/dao_fork/trie.py"}, "content": {"type": ["attribute"], "name": ["V"]}}, {"source": {"identifier": "ethereum.dao_fork.trie.LeafNode", "specifier": 0, "path": "src/ethereum/dao_fork/trie.py"}, "content": {"type": ["class"], "name": ["LeafNode"], "text": ["Leaf node in the Merkle Trie"]}}, {"source": {"identifier": "ethereum.dao_fork.trie.LeafNode.rest_of_key", "specifier": 0, "path": "src/ethereum/dao_fork/trie.py"}, "content": {"type": ["attribute"], "name": ["rest_of_key"]}}, {"source": {"identifier": "ethereum.dao_fork.trie.LeafNode.value", "specifier": 0, "path": "src/ethereum/dao_fork/trie.py"}, "content": {"type": ["attribute"], "name": ["value"]}}, {"source": {"identifier": "ethereum.dao_fork.trie.ExtensionNode", "specifier": 0, "path": "src/ethereum/dao_fork/trie.py"}, "content": {"type": ["class"], "name": ["ExtensionNode"], "text": ["Extension node in the Merkle Trie"]}}, {"source": {"identifier": "ethereum.dao_fork.trie.ExtensionNode.key_segment", "specifier": 0, "path": "src/ethereum/dao_fork/trie.py"}, "content": {"type": ["attribute"], "name": ["key_segment"]}}, {"source": {"identifier": "ethereum.dao_fork.trie.ExtensionNode.subnode", "specifier": 0, "path": "src/ethereum/dao_fork/trie.py"}, "content": {"type": ["attribute"], "name": ["subnode"]}}, {"source": {"identifier": "ethereum.dao_fork.trie.BranchNode", "specifier": 0, "path": "src/ethereum/dao_fork/trie.py"}, "content": {"type": ["class"], "name": ["BranchNode"], "text": ["Branch node in the Merkle Trie"]}}, {"source": {"identifier": "ethereum.dao_fork.trie.BranchNode.subnodes", "specifier": 0, "path": "src/ethereum/dao_fork/trie.py"}, "content": {"type": ["attribute"], "name": ["subnodes"]}}, {"source": {"identifier": "ethereum.dao_fork.trie.BranchNode.value", "specifier": 0, "path": "src/ethereum/dao_fork/trie.py"}, "content": {"type": ["attribute"], "name": ["value"]}}, {"source": {"identifier": "ethereum.dao_fork.trie.InternalNode", "specifier": 0, "path": "src/ethereum/dao_fork/trie.py"}, "content": {"type": ["attribute"], "name": ["InternalNode"]}}, {"source": {"identifier": "ethereum.dao_fork.trie.encode_internal_node", "specifier": 0, "path": "src/ethereum/dao_fork/trie.py"}, "content": {"type": ["function"], "name": ["encode_internal_node"], "text": ["Encodes a Merkle Trie node into its RLP form. The RLP will then be serialized into a  Bytes  and hashed unless it is less that 32 bytes when serialized. This function also accepts  None , representing the absence of a node, which is encoded to  b\"\" . Parameters node : Optional[InternalNode] The node to encode. Returns encoded :  rlp.RLP The node encoded as RLP."]}}, {"source": {"identifier": "ethereum.dao_fork.trie.encode_node", "specifier": 0, "path": "src/ethereum/dao_fork/trie.py"}, "content": {"type": ["function"], "name": ["encode_node"], "text": ["Encode a Node for storage in the Merkle Trie. Currently mostly an unimplemented stub."]}}, {"source": {"identifier": "ethereum.dao_fork.trie.Trie", "specifier": 0, "path": "src/ethereum/dao_fork/trie.py"}, "content": {"type": ["class"], "name": ["Trie"], "text": ["The Merkle Trie."]}}, {"source": {"identifier": "ethereum.dao_fork.trie.Trie.secured", "specifier": 0, "path": "src/ethereum/dao_fork/trie.py"}, "content": {"type": ["attribute"], "name": ["secured"]}}, {"source": {"identifier": "ethereum.dao_fork.trie.Trie.default", "specifier": 0, "path": "src/ethereum/dao_fork/trie.py"}, "content": {"type": ["attribute"], "name": ["default"]}}, {"source": {"identifier": "ethereum.dao_fork.trie.Trie._data", "specifier": 0, "path": "src/ethereum/dao_fork/trie.py"}, "content": {"type": ["attribute"], "name": ["_data"]}}, {"source": {"identifier": "ethereum.dao_fork.trie.copy_trie", "specifier": 0, "path": "src/ethereum/dao_fork/trie.py"}, "content": {"type": ["function"], "name": ["copy_trie"], "text": ["Create a copy of  trie . Since only frozen objects may be stored in tries, the contents are reused. Parameters trie:  Trie Trie to copy. Returns new_trie :  Trie[K, V] A copy of the trie."]}}, {"source": {"identifier": "ethereum.dao_fork.trie.trie_set", "specifier": 0, "path": "src/ethereum/dao_fork/trie.py"}, "content": {"type": ["function"], "name": ["trie_set"], "text": ["Stores an item in a Merkle Trie. This method deletes the key if  value == trie.default , because the Merkle Trie represents the default value by omitting it from the trie. Parameters trie:  Trie Trie to store in. key :  Bytes Key to lookup. value :  V Node to insert at  key ."]}}, {"source": {"identifier": "ethereum.dao_fork.trie.trie_get", "specifier": 0, "path": "src/ethereum/dao_fork/trie.py"}, "content": {"type": ["function"], "name": ["trie_get"], "text": ["Gets an item from the Merkle Trie. This method returns  trie.default  if the key is missing. Parameters trie: Trie to lookup in. key : Key to lookup. Returns node :  V Node at  key  in the trie."]}}, {"source": {"identifier": "ethereum.dao_fork.trie.common_prefix_length", "specifier": 0, "path": "src/ethereum/dao_fork/trie.py"}, "content": {"type": ["function"], "name": ["common_prefix_length"], "text": ["Find the longest common prefix of two sequences."]}}, {"source": {"identifier": "ethereum.dao_fork.trie.nibble_list_to_compact", "specifier": 0, "path": "src/ethereum/dao_fork/trie.py"}, "content": {"type": ["function"], "name": ["nibble_list_to_compact"], "text": ["Compresses nibble-list into a standard byte array with a flag. A nibble-list is a list of byte values no greater than  15 . The flag is encoded in high nibble of the highest byte. The flag nibble can be broken down into two two-bit flags. Highest nibble:: +---+---+----------+--------+\n| _ | _ | is_leaf | parity |\n+---+---+----------+--------+\n  3   2      1         0\n The lowest bit of the nibble encodes the parity of the length of the remaining nibbles --  0  when even and  1  when odd. The second lowest bit is used to distinguish leaf and extension nodes. The other two bits are not used. Parameters x : Array of nibbles. is_leaf : True if this is part of a leaf node, or false if it is an extension node. Returns compressed :  bytearray Compact byte array."]}}, {"source": {"identifier": "ethereum.dao_fork.trie.bytes_to_nibble_list", "specifier": 0, "path": "src/ethereum/dao_fork/trie.py"}, "content": {"type": ["function"], "name": ["bytes_to_nibble_list"], "text": ["Converts a  Bytes  into to a sequence of nibbles (bytes with value < 16). Parameters bytes_: The  Bytes  to convert. Returns nibble_list :  Bytes The  Bytes  in nibble-list format."]}}, {"source": {"identifier": "ethereum.dao_fork.trie._prepare_trie", "specifier": 0, "path": "src/ethereum/dao_fork/trie.py"}, "content": {"type": ["function"], "name": ["_prepare_trie"], "text": ["Prepares the trie for root calculation. Removes values that are empty, hashes the keys (if  secured == True ) and encodes all the nodes. Parameters trie : The  Trie  to prepare. get_storage_root : Function to get the storage root of an account. Needed to encode Account  objects. Returns out :  Mapping[ethereum.base_types.Bytes, Node] Object with keys mapped to nibble-byte form."]}}, {"source": {"identifier": "ethereum.dao_fork.trie.root", "specifier": 0, "path": "src/ethereum/dao_fork/trie.py"}, "content": {"type": ["function"], "name": ["root"], "text": ["Computes the root of a modified merkle patricia trie (MPT). Parameters trie : Trie  to get the root of. get_storage_root : Function to get the storage root of an account. Needed to encode Account  objects. Returns root :  .fork_types.Root MPT root of the underlying key-value pairs."]}}, {"source": {"identifier": "ethereum.dao_fork.trie.patricialize", "specifier": 0, "path": "src/ethereum/dao_fork/trie.py"}, "content": {"type": ["function"], "name": ["patricialize"], "text": ["Structural composition function. Used to recursively patricialize and merkleize a dictionary. Includes memoization of the tree structure and hashes. Parameters obj : Underlying trie key-value pairs, with keys in nibble-list format. level : Current trie level. Returns node :  ethereum.base_types.Bytes Root node of  obj ."]}}, {"source": {"identifier": "ethereum_spec_tools.evm_tools.b11r.b11r_types", "specifier": 0, "path": "src/ethereum_spec_tools/evm_tools/b11r/b11r_types.py"}, "content": {"type": ["module"], "name": ["ethereum_spec_tools.evm_tools.b11r.b11r_types"], "text": ["Define the types used by the b11r tool."]}}, {"source": {"identifier": "ethereum_spec_tools.evm_tools.b11r.b11r_types.DEFAULT_TRIE_ROOT", "specifier": 0, "path": "src/ethereum_spec_tools/evm_tools/b11r/b11r_types.py"}, "content": {"type": ["attribute"], "name": ["DEFAULT_TRIE_ROOT"]}}, {"source": {"identifier": "ethereum_spec_tools.evm_tools.b11r.b11r_types.DEFAULT_COINBASE", "specifier": 0, "path": "src/ethereum_spec_tools/evm_tools/b11r/b11r_types.py"}, "content": {"type": ["attribute"], "name": ["DEFAULT_COINBASE"]}}, {"source": {"identifier": "ethereum_spec_tools.evm_tools.b11r.b11r_types.Body", "specifier": 0, "path": "src/ethereum_spec_tools/evm_tools/b11r/b11r_types.py"}, "content": {"type": ["class"], "name": ["Body"], "text": ["A class representing a block body."]}}, {"source": {"identifier": "ethereum_spec_tools.evm_tools.b11r.b11r_types.Body.transactions", "specifier": 0, "path": "src/ethereum_spec_tools/evm_tools/b11r/b11r_types.py"}, "content": {"type": ["attribute"], "name": ["transactions"]}}, {"source": {"identifier": "ethereum_spec_tools.evm_tools.b11r.b11r_types.Body.ommers", "specifier": 0, "path": "src/ethereum_spec_tools/evm_tools/b11r/b11r_types.py"}, "content": {"type": ["attribute"], "name": ["ommers"]}}, {"source": {"identifier": "ethereum_spec_tools.evm_tools.b11r.b11r_types.Body.withdrawals", "specifier": 0, "path": "src/ethereum_spec_tools/evm_tools/b11r/b11r_types.py"}, "content": {"type": ["attribute"], "name": ["withdrawals"]}}, {"source": {"identifier": "ethereum_spec_tools.evm_tools.b11r.b11r_types.Body.__init__", "specifier": 0, "path": "src/ethereum_spec_tools/evm_tools/b11r/b11r_types.py"}, "content": {"type": ["function"], "name": ["__init__"]}}, {"source": {"identifier": "ethereum_spec_tools.evm_tools.b11r.b11r_types.Header", "specifier": 0, "path": "src/ethereum_spec_tools/evm_tools/b11r/b11r_types.py"}, "content": {"type": ["class"], "name": ["Header"], "text": ["A class representing a block header."]}}, {"source": {"identifier": "ethereum_spec_tools.evm_tools.b11r.b11r_types.Header.parent_hash", "specifier": 0, "path": "src/ethereum_spec_tools/evm_tools/b11r/b11r_types.py"}, "content": {"type": ["attribute"], "name": ["parent_hash"]}}, {"source": {"identifier": "ethereum_spec_tools.evm_tools.b11r.b11r_types.Header.ommers_hash", "specifier": 0, "path": "src/ethereum_spec_tools/evm_tools/b11r/b11r_types.py"}, "content": {"type": ["attribute"], "name": ["ommers_hash"]}}, {"source": {"identifier": "ethereum_spec_tools.evm_tools.b11r.b11r_types.Header.coinbase", "specifier": 0, "path": "src/ethereum_spec_tools/evm_tools/b11r/b11r_types.py"}, "content": {"type": ["attribute"], "name": ["coinbase"]}}, {"source": {"identifier": "ethereum_spec_tools.evm_tools.b11r.b11r_types.Header.state_root", "specifier": 0, "path": "src/ethereum_spec_tools/evm_tools/b11r/b11r_types.py"}, "content": {"type": ["attribute"], "name": ["state_root"]}}, {"source": {"identifier": "ethereum_spec_tools.evm_tools.b11r.b11r_types.Header.transactions_root", "specifier": 0, "path": "src/ethereum_spec_tools/evm_tools/b11r/b11r_types.py"}, "content": {"type": ["attribute"], "name": ["transactions_root"]}}, {"source": {"identifier": "ethereum_spec_tools.evm_tools.b11r.b11r_types.Header.receipt_root", "specifier": 0, "path": "src/ethereum_spec_tools/evm_tools/b11r/b11r_types.py"}, "content": {"type": ["attribute"], "name": ["receipt_root"]}}, {"source": {"identifier": "ethereum_spec_tools.evm_tools.b11r.b11r_types.Header.bloom", "specifier": 0, "path": "src/ethereum_spec_tools/evm_tools/b11r/b11r_types.py"}, "content": {"type": ["attribute"], "name": ["bloom"]}}, {"source": {"identifier": "ethereum_spec_tools.evm_tools.b11r.b11r_types.Header.difficulty", "specifier": 0, "path": "src/ethereum_spec_tools/evm_tools/b11r/b11r_types.py"}, "content": {"type": ["attribute"], "name": ["difficulty"]}}, {"source": {"identifier": "ethereum_spec_tools.evm_tools.b11r.b11r_types.Header.number", "specifier": 0, "path": "src/ethereum_spec_tools/evm_tools/b11r/b11r_types.py"}, "content": {"type": ["attribute"], "name": ["number"]}}, {"source": {"identifier": "ethereum_spec_tools.evm_tools.b11r.b11r_types.Header.gas_limit", "specifier": 0, "path": "src/ethereum_spec_tools/evm_tools/b11r/b11r_types.py"}, "content": {"type": ["attribute"], "name": ["gas_limit"]}}, {"source": {"identifier": "ethereum_spec_tools.evm_tools.b11r.b11r_types.Header.gas_used", "specifier": 0, "path": "src/ethereum_spec_tools/evm_tools/b11r/b11r_types.py"}, "content": {"type": ["attribute"], "name": ["gas_used"]}}, {"source": {"identifier": "ethereum_spec_tools.evm_tools.b11r.b11r_types.Header.timestamp", "specifier": 0, "path": "src/ethereum_spec_tools/evm_tools/b11r/b11r_types.py"}, "content": {"type": ["attribute"], "name": ["timestamp"]}}, {"source": {"identifier": "ethereum_spec_tools.evm_tools.b11r.b11r_types.Header.extra_data", "specifier": 0, "path": "src/ethereum_spec_tools/evm_tools/b11r/b11r_types.py"}, "content": {"type": ["attribute"], "name": ["extra_data"]}}, {"source": {"identifier": "ethereum_spec_tools.evm_tools.b11r.b11r_types.Header.mix_digest", "specifier": 0, "path": "src/ethereum_spec_tools/evm_tools/b11r/b11r_types.py"}, "content": {"type": ["attribute"], "name": ["mix_digest"]}}, {"source": {"identifier": "ethereum_spec_tools.evm_tools.b11r.b11r_types.Header.nonce", "specifier": 0, "path": "src/ethereum_spec_tools/evm_tools/b11r/b11r_types.py"}, "content": {"type": ["attribute"], "name": ["nonce"]}}, {"source": {"identifier": "ethereum_spec_tools.evm_tools.b11r.b11r_types.Header.base_fee_per_gas", "specifier": 0, "path": "src/ethereum_spec_tools/evm_tools/b11r/b11r_types.py"}, "content": {"type": ["attribute"], "name": ["base_fee_per_gas"]}}, {"source": {"identifier": "ethereum_spec_tools.evm_tools.b11r.b11r_types.Header.withdrawals_root", "specifier": 0, "path": "src/ethereum_spec_tools/evm_tools/b11r/b11r_types.py"}, "content": {"type": ["attribute"], "name": ["withdrawals_root"]}}, {"source": {"identifier": "ethereum_spec_tools.evm_tools.b11r.b11r_types.Header.__init__", "specifier": 0, "path": "src/ethereum_spec_tools/evm_tools/b11r/b11r_types.py"}, "content": {"type": ["function"], "name": ["__init__"]}}, {"source": {"identifier": "ethereum.dao_fork.fork", "specifier": 0, "path": "src/ethereum/dao_fork/fork.py"}, "content": {"type": ["module"], "name": ["ethereum.dao_fork.fork"], "text": [".. _dao-fork: Ethereum Specification ^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Entry point for the Ethereum specification."]}}, {"source": {"identifier": "ethereum.dao_fork.fork.BLOCK_REWARD", "specifier": 0, "path": "src/ethereum/dao_fork/fork.py"}, "content": {"type": ["attribute"], "name": ["BLOCK_REWARD"]}}, {"source": {"identifier": "ethereum.dao_fork.fork.GAS_LIMIT_ADJUSTMENT_FACTOR", "specifier": 0, "path": "src/ethereum/dao_fork/fork.py"}, "content": {"type": ["attribute"], "name": ["GAS_LIMIT_ADJUSTMENT_FACTOR"]}}, {"source": {"identifier": "ethereum.dao_fork.fork.GAS_LIMIT_MINIMUM", "specifier": 0, "path": "src/ethereum/dao_fork/fork.py"}, "content": {"type": ["attribute"], "name": ["GAS_LIMIT_MINIMUM"]}}, {"source": {"identifier": "ethereum.dao_fork.fork.MINIMUM_DIFFICULTY", "specifier": 0, "path": "src/ethereum/dao_fork/fork.py"}, "content": {"type": ["attribute"], "name": ["MINIMUM_DIFFICULTY"]}}, {"source": {"identifier": "ethereum.dao_fork.fork.MAX_OMMER_DEPTH", "specifier": 0, "path": "src/ethereum/dao_fork/fork.py"}, "content": {"type": ["attribute"], "name": ["MAX_OMMER_DEPTH"]}}, {"source": {"identifier": "ethereum.dao_fork.fork.BlockChain", "specifier": 0, "path": "src/ethereum/dao_fork/fork.py"}, "content": {"type": ["class"], "name": ["BlockChain"], "text": ["History and current state of the block chain."]}}, {"source": {"identifier": "ethereum.dao_fork.fork.BlockChain.blocks", "specifier": 0, "path": "src/ethereum/dao_fork/fork.py"}, "content": {"type": ["attribute"], "name": ["blocks"]}}, {"source": {"identifier": "ethereum.dao_fork.fork.BlockChain.state", "specifier": 0, "path": "src/ethereum/dao_fork/fork.py"}, "content": {"type": ["attribute"], "name": ["state"]}}, {"source": {"identifier": "ethereum.dao_fork.fork.BlockChain.chain_id", "specifier": 0, "path": "src/ethereum/dao_fork/fork.py"}, "content": {"type": ["attribute"], "name": ["chain_id"]}}, {"source": {"identifier": "ethereum.dao_fork.fork.apply_fork", "specifier": 0, "path": "src/ethereum/dao_fork/fork.py"}, "content": {"type": ["function"], "name": ["apply_fork"], "text": ["Transforms the state from the previous hard fork ( old ) into the block chain object for this hard fork and returns it. When forks need to implement an irregular state transition, this function is used to handle the irregularity. The DAO-Fork occured as a result of the  2016 DAO Hacks <https://www.gemini.com/cryptopedia/the-dao-hack-makerdao> _ in which an unknown entity managed to drain more than 3.6 million ether causing the price of ether to drop by nearly 35%. This fork was the solution to the hacks and manually reset the affected parties' accounts to their state prior to the attack. This fork essentially rewrote the history of the Ethereum network. Parameters old : Previous block chain object. Returns new :  BlockChain Upgraded block chain object for this hard fork."]}}, {"source": {"identifier": "ethereum.dao_fork.fork.get_last_256_block_hashes", "specifier": 0, "path": "src/ethereum/dao_fork/fork.py"}, "content": {"type": ["function"], "name": ["get_last_256_block_hashes"], "text": ["Obtain the list of hashes of the previous 256 blocks in order of increasing block number. This function will return less hashes for the first 256 blocks. The  BLOCKHASH  opcode needs to access the latest hashes on the chain, therefore this function retrieves them. Parameters chain : History and current state. Returns recent_block_hashes :  List[Hash32] Hashes of the recent 256 blocks in order of increasing block number."]}}, {"source": {"identifier": "ethereum.dao_fork.fork.state_transition", "specifier": 0, "path": "src/ethereum/dao_fork/fork.py"}, "content": {"type": ["function"], "name": ["state_transition"], "text": ["Attempts to apply a block to an existing block chain. All parts of the block's contents need to be verified before being added to the chain. Blocks are verified by ensuring that the contents of the block make logical sense with the contents of the parent block. The information in the block's header must also match the corresponding information in the block. To implement Ethereum, in theory clients are only required to store the most recent 255 blocks of the chain since as far as execution is concerned, only those blocks are accessed. Practically, however, clients should store more blocks to handle reorgs. Parameters chain : History and current state. block : Block to apply to  chain ."]}}, {"source": {"identifier": "ethereum.dao_fork.fork.validate_header", "specifier": 0, "path": "src/ethereum/dao_fork/fork.py"}, "content": {"type": ["function"], "name": ["validate_header"], "text": ["Verifies a block header. In order to consider a block's header valid, the logic for the quantities in the header should match the logic for the block itself. For example the header timestamp should be greater than the block's parent timestamp because the block was created  after  the parent block. Additionally, the block's number should be directly folowing the parent block's number since it is the next block in the sequence. Parameters header : Header to check for correctness. parent_header : Parent Header of the header to check for correctness"]}}, {"source": {"identifier": "ethereum.dao_fork.fork.generate_header_hash_for_pow", "specifier": 0, "path": "src/ethereum/dao_fork/fork.py"}, "content": {"type": ["function"], "name": ["generate_header_hash_for_pow"], "text": ["Generate rlp hash of the header which is to be used for Proof-of-Work verification. In other words, the PoW artefacts  mix_digest  and  nonce  are ignored while calculating this hash. A particular PoW is valid for a single hash, that hash is computed by this function. The  nonce  and  mix_digest  are omitted from this hash because they are being changed by miners in their search for a sufficient proof-of-work. Parameters header : The header object for which the hash is to be generated. Returns hash :  Hash32 The PoW valid rlp hash of the passed in header."]}}, {"source": {"identifier": "ethereum.dao_fork.fork.validate_proof_of_work", "specifier": 0, "path": "src/ethereum/dao_fork/fork.py"}, "content": {"type": ["function"], "name": ["validate_proof_of_work"], "text": ["Validates the Proof of Work constraints. In order to verify that a miner's proof-of-work is valid for a block, a mix-digest  and  result  are calculated using the  hashimoto_light hash function. The mix digest is a hash of the header and the nonce that is passed through and it confirms whether or not proof-of-work was done on the correct block. The result is the actual hash value of the block. Parameters header : Header of interest."]}}, {"source": {"identifier": "ethereum.dao_fork.fork.check_transaction", "specifier": 0, "path": "src/ethereum/dao_fork/fork.py"}, "content": {"type": ["function"], "name": ["check_transaction"], "text": ["Check if the transaction is includable in the block. Parameters tx : The transaction. gas_available : The gas remaining in the block. Returns sender_address : The sender of the transaction. Raises InvalidBlock : If the transaction is not includable."]}}, {"source": {"identifier": "ethereum.dao_fork.fork.make_receipt", "specifier": 0, "path": "src/ethereum/dao_fork/fork.py"}, "content": {"type": ["function"], "name": ["make_receipt"], "text": ["Make the receipt for a transaction that was executed. Parameters tx : The executed transaction. post_state : The state root immediately after this transaction. cumulative_gas_used : The total gas used so far in the block after the transaction was executed. logs : The logs produced by the transaction. Returns receipt : The receipt for the transaction."]}}, {"source": {"identifier": "ethereum.dao_fork.fork.apply_body", "specifier": 0, "path": "src/ethereum/dao_fork/fork.py"}, "content": {"type": ["function"], "name": ["apply_body"], "text": ["Executes a block. Many of the contents of a block are stored in data structures called tries. There is a transactions trie which is similar to a ledger of the transactions stored in the current block. There is also a receipts trie which stores the results of executing a transaction, like the post state and gas used. This function creates and executes the block that is to be added to the chain. Parameters state : Current account state. block_hashes : List of hashes of the previous 256 blocks in the order of increasing block number. coinbase : Address of account which receives block reward and transaction fees. block_number : Position of the block within the chain. block_gas_limit : Initial amount of gas available for execution in this block. block_time : Time the block was produced, measured in seconds since the epoch. block_difficulty : Difficulty of the block. transactions : Transactions included in the block. ommers : Headers of ancestor blocks which are not direct parents (formerly uncles.) Returns gas_available :  ethereum.base_types.Uint Remaining gas after all transactions have been executed. transactions_root :  ethereum.fork_types.Root Trie root of all the transactions in the block. receipt_root :  ethereum.fork_types.Root Trie root of all the receipts in the block. block_logs_bloom :  Bloom Logs bloom of all the logs included in all the transactions of the block. state :  ethereum.fork_types.State State after all transactions have been executed."]}}, {"source": {"identifier": "ethereum.dao_fork.fork.validate_ommers", "specifier": 0, "path": "src/ethereum/dao_fork/fork.py"}, "content": {"type": ["function"], "name": ["validate_ommers"], "text": ["Validates the ommers mentioned in the block. An ommer block is a block that wasn't canonically added to the blockchain because it wasn't validated as fast as the canonical block but was mined at the same time. To be considered valid, the ommers must adhere to the rules defined in the Ethereum protocol. The maximum amount of ommers is 2 per block and there cannot be duplicate ommers in a block. Many of the other ommer contraints are listed in the in-line comments of this function. Parameters ommers : List of ommers mentioned in the current block. block_header: The header of current block. chain : History and current state."]}}, {"source": {"identifier": "ethereum.dao_fork.fork.pay_rewards", "specifier": 0, "path": "src/ethereum/dao_fork/fork.py"}, "content": {"type": ["function"], "name": ["pay_rewards"], "text": ["Pay rewards to the block miner as well as the ommers miners. The miner of the canonical block is rewarded with the predetermined block reward,  BLOCK_REWARD , plus a variable award based off of the number of ommer blocks that were mined around the same time, and included in the canonical block's header. An ommer block is a block that wasn't added to the canonical blockchain because it wasn't validated as fast as the accepted block but was mined at the same time. Although not all blocks that are mined are added to the canonical chain, miners are still paid a reward for their efforts. This reward is called an ommer reward and is calculated based on the number associated with the ommer block that they mined. Parameters state : Current account state. block_number : Position of the block within the chain. coinbase : Address of account which receives block reward and transaction fees. ommers : List of ommers mentioned in the current block."]}}, {"source": {"identifier": "ethereum.dao_fork.fork.process_transaction", "specifier": 0, "path": "src/ethereum/dao_fork/fork.py"}, "content": {"type": ["function"], "name": ["process_transaction"], "text": ["Execute a transaction against the provided environment. This function processes the actions needed to execute a transaction. It decrements the sender's account after calculating the gas fee and refunds them the proper amount after execution. Calling contracts, deploying code, and incrementing nonces are all examples of actions that happen within this function or from a call made within this function. Accounts that are marked for deletion are processed and destroyed after execution. Parameters env : Environment for the Ethereum Virtual Machine. tx : Transaction to execute. Returns gas_left :  ethereum.base_types.U256 Remaining gas after execution. logs :  Tuple[ethereum.fork_types.Log, ...] Logs generated during execution."]}}, {"source": {"identifier": "ethereum.dao_fork.fork.validate_transaction", "specifier": 0, "path": "src/ethereum/dao_fork/fork.py"}, "content": {"type": ["function"], "name": ["validate_transaction"], "text": ["Verifies a transaction. The gas in a transaction gets used to pay for the intrinsic cost of operations, therefore if there is insufficient gas then it would not be possible to execute a transaction and it will be declared invalid. Additionally, the nonce of a transaction must not equal or exceed the limit defined in  EIP-2681 <https://eips.ethereum.org/EIPS/eip-2681> _. In practice, defining the limit as  2**64-1  has no impact because sending  2**64-1  transactions is improbable. It's not strictly impossible though,  2**64-1  transactions is the entire capacity of the Ethereum blockchain at 2022 gas limits for a little over 22 years. Parameters tx : Transaction to validate. Returns verified :  bool True if the transaction can be executed, or False otherwise."]}}, {"source": {"identifier": "ethereum.dao_fork.fork.calculate_intrinsic_cost", "specifier": 0, "path": "src/ethereum/dao_fork/fork.py"}, "content": {"type": ["function"], "name": ["calculate_intrinsic_cost"], "text": ["Calculates the gas that is charged before execution is started. The intrinsic cost of the transaction is charged before execution has begun. Functions/operations in the EVM cost money to execute so this intrinsic cost is for the operations that need to be paid for as part of the transaction. Data transfer, for example, is part of this intrinsic cost. It costs ether to send data over the wire and that ether is accounted for in the intrinsic cost calculated in this function. This intrinsic cost must be calculated and paid for before execution in order for all operations to be implemented. Parameters tx : Transaction to compute the intrinsic cost of. Returns verified :  ethereum.base_types.Uint The intrinsic cost of the transaction."]}}, {"source": {"identifier": "ethereum.dao_fork.fork.recover_sender", "specifier": 0, "path": "src/ethereum/dao_fork/fork.py"}, "content": {"type": ["function"], "name": ["recover_sender"], "text": ["Extracts the sender address from a transaction. The v, r, and s values are the three parts that make up the signature of a transaction. In order to recover the sender of a transaction the two components needed are the signature ( v ,  r , and  s ) and the signing hash of the transaction. The sender's public key can be obtained with these two values and therefore the sender address can be retrieved. Parameters tx : Transaction of interest. Returns sender :  ethereum.fork_types.Address The address of the account that signed the transaction."]}}, {"source": {"identifier": "ethereum.dao_fork.fork.signing_hash", "specifier": 0, "path": "src/ethereum/dao_fork/fork.py"}, "content": {"type": ["function"], "name": ["signing_hash"], "text": ["Compute the hash of a transaction used in the signature. The values that are used to compute the signing hash set the rules for a transaction. For example, signing over the gas sets a limit for the amount of money that is allowed to be pulled out of the sender's account. Parameters tx : Transaction of interest. Returns hash :  ethereum.crypto.hash.Hash32 Hash of the transaction."]}}, {"source": {"identifier": "ethereum.dao_fork.fork.compute_header_hash", "specifier": 0, "path": "src/ethereum/dao_fork/fork.py"}, "content": {"type": ["function"], "name": ["compute_header_hash"], "text": ["Computes the hash of a block header. The header hash of a block is the canonical hash that is used to refer to a specific block and completely distinguishes a block from another. keccak256  is a function that produces a 256 bit hash of any input. It also takes in any number of bytes as an input and produces a single hash for them. A hash is a completely unique output for a single input. So an input corresponds to one unique hash that can be used to identify the input exactly. Prior to using the  keccak256  hash function, the header must be encoded using the Recursive-Length Prefix. See :ref: rlp . RLP encoding the header converts it into a space-efficient format that allows for easy transfer of data between nodes. The purpose of RLP is to encode arbitrarily nested arrays of binary data, and RLP is the primary encoding method used to serialize objects in Ethereum's execution layer. The only purpose of RLP is to encode structure; encoding specific data types (e.g. strings, floats) is left up to higher-order protocols. Parameters header : Header of interest. Returns hash :  ethereum.crypto.hash.Hash32 Hash of the header."]}}, {"source": {"identifier": "ethereum.dao_fork.fork.check_gas_limit", "specifier": 0, "path": "src/ethereum/dao_fork/fork.py"}, "content": {"type": ["function"], "name": ["check_gas_limit"], "text": ["Validates the gas limit for a block. The bounds of the gas limit,  max_adjustment_delta , is set as the quotient of the parent block's gas limit and the GAS_LIMIT_ADJUSTMENT_FACTOR . Therefore, if the gas limit that is passed through as a parameter is greater than or equal to the  sum  of the parent's gas and the adjustment delta then the limit for gas is too high and fails this function's check. Similarly, if the limit is less than or equal to the  difference  of the parent's gas and the adjustment delta  or  the predefined  GAS_LIMIT_MINIMUM  then this function's check fails because the gas limit doesn't allow for a sufficient or reasonable amount of gas to be used on a block. Parameters gas_limit : Gas limit to validate. parent_gas_limit : Gas limit of the parent block. Returns check :  bool True if gas limit constraints are satisfied, False otherwise."]}}, {"source": {"identifier": "ethereum.dao_fork.fork.calculate_block_difficulty", "specifier": 0, "path": "src/ethereum/dao_fork/fork.py"}, "content": {"type": ["function"], "name": ["calculate_block_difficulty"], "text": ["Computes difficulty of a block using its header and parent header. The difficulty is determined by the time the block was created after its parent. The  offset  is calculated using the parent block's difficulty, parent_difficulty , and the timestamp between blocks. This offset is then added to the parent difficulty and is stored as the  difficulty variable. If the time between the block and its parent is too short, the offset will result in a positive number thus making the sum of parent_difficulty  and  offset  to be a greater value in order to avoid mass forking. But, if the time is long enough, then the offset results in a negative value making the block less difficult than its parent. The base standard for a block's difficulty is the predefined value set for the genesis block since it has no parent. So, a block can't be less difficult than the genesis block, therefore each block's difficulty is set to the maximum value between the calculated difficulty and the  GENESIS_DIFFICULTY . Parameters block_number : Block number of the block. block_timestamp : Timestamp of the block. parent_timestamp : Timestamp of the parent block. parent_difficulty : difficulty of the parent block. Returns difficulty :  ethereum.base_types.Uint Computed difficulty for a block."]}}, {"source": {"identifier": "ethereum_spec_tools.lint", "specifier": 0, "path": "src/ethereum_spec_tools/lint/__init__.py"}, "content": {"type": ["module"], "name": ["ethereum_spec_tools.lint"], "text": ["Lints ^^^^^ Checks specific to the Ethereum specification source code."]}}, {"source": {"identifier": "ethereum_spec_tools.lint.compare_ast", "specifier": 0, "path": "src/ethereum_spec_tools/lint/__init__.py"}, "content": {"type": ["function"], "name": ["compare_ast"], "text": ["Check if two nodes are the equal."]}}, {"source": {"identifier": "ethereum_spec_tools.lint.walk_sources", "specifier": 0, "path": "src/ethereum_spec_tools/lint/__init__.py"}, "content": {"type": ["function"], "name": ["walk_sources"], "text": ["Import the modules specifying a hardfork, and retrieve their source code."]}}, {"source": {"identifier": "ethereum_spec_tools.lint.Diagnostic", "specifier": 0, "path": "src/ethereum_spec_tools/lint/__init__.py"}, "content": {"type": ["class"], "name": ["Diagnostic"], "text": ["A diagnostic message generated while checking the specifications."]}}, {"source": {"identifier": "ethereum_spec_tools.lint.Diagnostic.message", "specifier": 0, "path": "src/ethereum_spec_tools/lint/__init__.py"}, "content": {"type": ["attribute"], "name": ["message"]}}, {"source": {"identifier": "ethereum_spec_tools.lint.Lint", "specifier": 0, "path": "src/ethereum_spec_tools/lint/__init__.py"}, "content": {"type": ["class"], "name": ["Lint"], "text": ["A single check which may be performed against the specifications."]}}, {"source": {"identifier": "ethereum_spec_tools.lint.Lint.lint", "specifier": 0, "path": "src/ethereum_spec_tools/lint/__init__.py"}, "content": {"type": ["function"], "name": ["lint"], "text": ["Runs the check against the given forks, at the given position. Parameters forks : All known hardforks. position : The particular hardfork to lint."]}}, {"source": {"identifier": "ethereum_spec_tools.lint.Lint._parse", "specifier": 0, "path": "src/ethereum_spec_tools/lint/__init__.py"}, "content": {"type": ["function"], "name": ["_parse"], "text": ["Walks the source string and extracts a sequence of identifiers."]}}, {"source": {"identifier": "ethereum_spec_tools.lint.Linter", "specifier": 0, "path": "src/ethereum_spec_tools/lint/__init__.py"}, "content": {"type": ["class"], "name": ["Linter"], "text": ["Checks the specification for style guideline violations."]}}, {"source": {"identifier": "ethereum_spec_tools.lint.Linter.lints", "specifier": 0, "path": "src/ethereum_spec_tools/lint/__init__.py"}, "content": {"type": ["attribute"], "name": ["lints"]}}, {"source": {"identifier": "ethereum_spec_tools.lint.Linter.discover_lints", "specifier": 0, "path": "src/ethereum_spec_tools/lint/__init__.py"}, "content": {"type": ["function"], "name": ["discover_lints"], "text": ["Discover subclasses of Lint."]}}, {"source": {"identifier": "ethereum_spec_tools.lint.Linter.__init__", "specifier": 0, "path": "src/ethereum_spec_tools/lint/__init__.py"}, "content": {"type": ["function"], "name": ["__init__"]}}, {"source": {"identifier": "ethereum_spec_tools.lint.Linter.run", "specifier": 0, "path": "src/ethereum_spec_tools/lint/__init__.py"}, "content": {"type": ["function"], "name": ["run"], "text": ["Runs all enabled lints."]}}, {"source": {"identifier": "ethereum_spec_tools.lint.main", "specifier": 0, "path": "src/ethereum_spec_tools/lint/__init__.py"}, "content": {"type": ["function"], "name": ["main"], "text": ["ethereum-spec-lint  checks for style and formatting issues specific to the Ethereum specification."]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/__init__.py"}, "content": {"type": ["module"], "name": ["ethereum.constantinople.vm.instructions"], "text": ["EVM Instruction Encoding (Opcodes) ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Machine readable representations of EVM instructions, and a mapping to their implementations."]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.Ops", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/__init__.py"}, "content": {"type": ["class"], "name": ["Ops"], "text": ["Enum for EVM Opcodes"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.Ops.ADD", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["ADD"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.Ops.MUL", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["MUL"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.Ops.SUB", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SUB"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.Ops.DIV", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DIV"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.Ops.SDIV", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SDIV"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.Ops.MOD", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["MOD"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.Ops.SMOD", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SMOD"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.Ops.ADDMOD", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["ADDMOD"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.Ops.MULMOD", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["MULMOD"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.Ops.EXP", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["EXP"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.Ops.SIGNEXTEND", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SIGNEXTEND"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.Ops.LT", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["LT"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.Ops.GT", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["GT"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.Ops.SLT", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SLT"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.Ops.SGT", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SGT"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.Ops.EQ", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["EQ"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.Ops.ISZERO", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["ISZERO"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.Ops.AND", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["AND"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.Ops.OR", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["OR"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.Ops.XOR", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["XOR"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.Ops.NOT", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["NOT"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.Ops.BYTE", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["BYTE"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.Ops.SHL", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SHL"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.Ops.SHR", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SHR"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.Ops.SAR", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SAR"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.Ops.KECCAK", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["KECCAK"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.Ops.ADDRESS", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["ADDRESS"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.Ops.BALANCE", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["BALANCE"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.Ops.ORIGIN", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["ORIGIN"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.Ops.CALLER", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["CALLER"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.Ops.CALLVALUE", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["CALLVALUE"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.Ops.CALLDATALOAD", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["CALLDATALOAD"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.Ops.CALLDATASIZE", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["CALLDATASIZE"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.Ops.CALLDATACOPY", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["CALLDATACOPY"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.Ops.CODESIZE", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["CODESIZE"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.Ops.CODECOPY", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["CODECOPY"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.Ops.GASPRICE", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["GASPRICE"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.Ops.EXTCODESIZE", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["EXTCODESIZE"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.Ops.EXTCODECOPY", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["EXTCODECOPY"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.Ops.RETURNDATASIZE", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["RETURNDATASIZE"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.Ops.RETURNDATACOPY", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["RETURNDATACOPY"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.Ops.EXTCODEHASH", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["EXTCODEHASH"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.Ops.BLOCKHASH", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["BLOCKHASH"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.Ops.COINBASE", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["COINBASE"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.Ops.TIMESTAMP", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["TIMESTAMP"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.Ops.NUMBER", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["NUMBER"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.Ops.DIFFICULTY", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DIFFICULTY"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.Ops.GASLIMIT", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["GASLIMIT"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.Ops.STOP", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["STOP"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.Ops.JUMP", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["JUMP"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.Ops.JUMPI", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["JUMPI"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.Ops.PC", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PC"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.Ops.GAS", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["GAS"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.Ops.JUMPDEST", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["JUMPDEST"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.Ops.SLOAD", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SLOAD"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.Ops.SSTORE", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SSTORE"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.Ops.POP", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["POP"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.Ops.PUSH1", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH1"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.Ops.PUSH2", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH2"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.Ops.PUSH3", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH3"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.Ops.PUSH4", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH4"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.Ops.PUSH5", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH5"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.Ops.PUSH6", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH6"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.Ops.PUSH7", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH7"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.Ops.PUSH8", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH8"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.Ops.PUSH9", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH9"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.Ops.PUSH10", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH10"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.Ops.PUSH11", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH11"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.Ops.PUSH12", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH12"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.Ops.PUSH13", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH13"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.Ops.PUSH14", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH14"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.Ops.PUSH15", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH15"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.Ops.PUSH16", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH16"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.Ops.PUSH17", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH17"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.Ops.PUSH18", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH18"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.Ops.PUSH19", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH19"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.Ops.PUSH20", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH20"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.Ops.PUSH21", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH21"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.Ops.PUSH22", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH22"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.Ops.PUSH23", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH23"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.Ops.PUSH24", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH24"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.Ops.PUSH25", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH25"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.Ops.PUSH26", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH26"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.Ops.PUSH27", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH27"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.Ops.PUSH28", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH28"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.Ops.PUSH29", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH29"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.Ops.PUSH30", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH30"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.Ops.PUSH31", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH31"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.Ops.PUSH32", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH32"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.Ops.DUP1", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP1"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.Ops.DUP2", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP2"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.Ops.DUP3", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP3"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.Ops.DUP4", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP4"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.Ops.DUP5", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP5"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.Ops.DUP6", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP6"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.Ops.DUP7", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP7"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.Ops.DUP8", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP8"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.Ops.DUP9", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP9"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.Ops.DUP10", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP10"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.Ops.DUP11", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP11"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.Ops.DUP12", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP12"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.Ops.DUP13", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP13"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.Ops.DUP14", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP14"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.Ops.DUP15", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP15"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.Ops.DUP16", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP16"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.Ops.SWAP1", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP1"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.Ops.SWAP2", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP2"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.Ops.SWAP3", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP3"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.Ops.SWAP4", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP4"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.Ops.SWAP5", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP5"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.Ops.SWAP6", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP6"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.Ops.SWAP7", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP7"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.Ops.SWAP8", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP8"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.Ops.SWAP9", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP9"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.Ops.SWAP10", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP10"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.Ops.SWAP11", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP11"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.Ops.SWAP12", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP12"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.Ops.SWAP13", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP13"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.Ops.SWAP14", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP14"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.Ops.SWAP15", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP15"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.Ops.SWAP16", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP16"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.Ops.MLOAD", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["MLOAD"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.Ops.MSTORE", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["MSTORE"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.Ops.MSTORE8", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["MSTORE8"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.Ops.MSIZE", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["MSIZE"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.Ops.LOG0", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["LOG0"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.Ops.LOG1", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["LOG1"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.Ops.LOG2", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["LOG2"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.Ops.LOG3", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["LOG3"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.Ops.LOG4", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["LOG4"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.Ops.CREATE", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["CREATE"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.Ops.RETURN", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["RETURN"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.Ops.CALL", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["CALL"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.Ops.CALLCODE", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["CALLCODE"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.Ops.DELEGATECALL", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DELEGATECALL"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.Ops.STATICCALL", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["STATICCALL"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.Ops.REVERT", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["REVERT"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.Ops.SELFDESTRUCT", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SELFDESTRUCT"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.Ops.CREATE2", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["CREATE2"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.op_implementation", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["op_implementation"]}}, {"source": {"identifier": "ethereum.berlin.vm.precompiled_contracts.modexp", "specifier": 0, "path": "src/ethereum/berlin/vm/precompiled_contracts/modexp.py"}, "content": {"type": ["module"], "name": ["ethereum.berlin.vm.precompiled_contracts.modexp"], "text": ["Ethereum Virtual Machine (EVM) MODEXP PRECOMPILED CONTRACT ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementation of the  MODEXP  precompiled contract."]}}, {"source": {"identifier": "ethereum.berlin.vm.precompiled_contracts.modexp.GQUADDIVISOR", "specifier": 0, "path": "src/ethereum/berlin/vm/precompiled_contracts/modexp.py"}, "content": {"type": ["attribute"], "name": ["GQUADDIVISOR"]}}, {"source": {"identifier": "ethereum.berlin.vm.precompiled_contracts.modexp.modexp", "specifier": 0, "path": "src/ethereum/berlin/vm/precompiled_contracts/modexp.py"}, "content": {"type": ["function"], "name": ["modexp"], "text": ["Calculates  (base**exp) % modulus  for arbitary sized  base ,  exp  and. modulus . The return value is the same length as the modulus."]}}, {"source": {"identifier": "ethereum.berlin.vm.precompiled_contracts.modexp.complexity", "specifier": 0, "path": "src/ethereum/berlin/vm/precompiled_contracts/modexp.py"}, "content": {"type": ["function"], "name": ["complexity"], "text": ["Estimate the complexity of performing a modular exponentiation. Parameters base_length : Length of the array representing the base integer. modulus_length : Length of the array representing the modulus integer. Returns complexity :  Uint Complexity of performing the operation."]}}, {"source": {"identifier": "ethereum.berlin.vm.precompiled_contracts.modexp.iterations", "specifier": 0, "path": "src/ethereum/berlin/vm/precompiled_contracts/modexp.py"}, "content": {"type": ["function"], "name": ["iterations"], "text": ["Calculate the number of iterations required to perform a modular exponentiation. Parameters exponent_length : Length of the array representing the exponent integer. exponent_head : First 32 bytes of the exponent (with leading zero padding if it is shorter than 32 bytes), as an unsigned integer. Returns iterations :  Uint Number of iterations."]}}, {"source": {"identifier": "ethereum.berlin.vm.precompiled_contracts.modexp.gas_cost", "specifier": 0, "path": "src/ethereum/berlin/vm/precompiled_contracts/modexp.py"}, "content": {"type": ["function"], "name": ["gas_cost"], "text": ["Calculate the gas cost of performing a modular exponentiation. Parameters base_length : Length of the array representing the base integer. modulus_length : Length of the array representing the modulus integer. exponent_length : Length of the array representing the exponent integer. exponent_head : First 32 bytes of the exponent (with leading zero padding if it is shorter than 32 bytes), as an unsigned integer. Returns gas_cost :  Uint Gas required for performing the operation."]}}, {"source": {"identifier": "ethereum_spec_tools.lint", "specifier": 1, "path": "src/ethereum_spec_tools/lint/__main__.py"}, "content": {"type": ["module"], "name": ["ethereum_spec_tools.lint"], "text": ["Linter Entry Point ^^^^^^^^^^^^^^^^^^ Main entry point for the ethereum spec lint tool."]}}, {"source": {"identifier": "ethereum.dao_fork.vm.memory", "specifier": 0, "path": "src/ethereum/dao_fork/vm/memory.py"}, "content": {"type": ["module"], "name": ["ethereum.dao_fork.vm.memory"], "text": ["Ethereum Virtual Machine (EVM) Memory ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction EVM memory operations."]}}, {"source": {"identifier": "ethereum.dao_fork.vm.memory.memory_write", "specifier": 0, "path": "src/ethereum/dao_fork/vm/memory.py"}, "content": {"type": ["function"], "name": ["memory_write"], "text": ["Writes to memory. Parameters memory : Memory contents of the EVM. start_position : Starting pointer to the memory. value : Data to write to memory."]}}, {"source": {"identifier": "ethereum.dao_fork.vm.memory.memory_read_bytes", "specifier": 0, "path": "src/ethereum/dao_fork/vm/memory.py"}, "content": {"type": ["function"], "name": ["memory_read_bytes"], "text": ["Read bytes from memory. Parameters memory : Memory contents of the EVM. start_position : Starting pointer to the memory. size : Size of the data that needs to be read from  start_position . Returns data_bytes : Data read from memory."]}}, {"source": {"identifier": "ethereum.dao_fork.vm.memory.buffer_read", "specifier": 0, "path": "src/ethereum/dao_fork/vm/memory.py"}, "content": {"type": ["function"], "name": ["buffer_read"], "text": ["Read bytes from a buffer. Padding with zeros if neccesary. Parameters buffer : Memory contents of the EVM. start_position : Starting pointer to the memory. size : Size of the data that needs to be read from  start_position . Returns data_bytes : Data read from memory."]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.control_flow", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/control_flow.py"}, "content": {"type": ["module"], "name": ["ethereum.constantinople.vm.instructions.control_flow"], "text": ["Ethereum Virtual Machine (EVM) Control Flow Instructions ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementations of the EVM control flow instructions."]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.control_flow.stop", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/control_flow.py"}, "content": {"type": ["function"], "name": ["stop"], "text": ["Stop further execution of EVM code. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.control_flow.jump", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/control_flow.py"}, "content": {"type": ["function"], "name": ["jump"], "text": ["Alter the program counter to the location specified by the top of the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.control_flow.jumpi", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/control_flow.py"}, "content": {"type": ["function"], "name": ["jumpi"], "text": ["Alter the program counter to the specified location if and only if a condition is true. If the condition is not true, then the program counter would increase only by 1. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.control_flow.pc", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/control_flow.py"}, "content": {"type": ["function"], "name": ["pc"], "text": ["Push onto the stack the value of the program counter after reaching the current instruction and without increasing it for the next instruction. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.control_flow.gas_left", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/control_flow.py"}, "content": {"type": ["function"], "name": ["gas_left"], "text": ["Push the amount of available gas (including the corresponding reduction for the cost of this instruction) onto the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.control_flow.jumpdest", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/control_flow.py"}, "content": {"type": ["function"], "name": ["jumpdest"], "text": ["Mark a valid destination for jumps. This is a noop, present only to be used by  JUMP  and  JUMPI  opcodes to verify that their jump is valid. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.berlin.vm.precompiled_contracts.ecrecover", "specifier": 0, "path": "src/ethereum/berlin/vm/precompiled_contracts/ecrecover.py"}, "content": {"type": ["module"], "name": ["ethereum.berlin.vm.precompiled_contracts.ecrecover"], "text": ["Ethereum Virtual Machine (EVM) ECRECOVER PRECOMPILED CONTRACT ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementation of the ECRECOVER precompiled contract."]}}, {"source": {"identifier": "ethereum.berlin.vm.precompiled_contracts.ecrecover.ecrecover", "specifier": 0, "path": "src/ethereum/berlin/vm/precompiled_contracts/ecrecover.py"}, "content": {"type": ["function"], "name": ["ecrecover"], "text": ["Decrypts the address using elliptic curve DSA recovery mechanism and writes the address to output. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum_spec_tools.lint.lints.import_hygiene", "specifier": 0, "path": "src/ethereum_spec_tools/lint/lints/import_hygiene.py"}, "content": {"type": ["module"], "name": ["ethereum_spec_tools.lint.lints.import_hygiene"], "text": ["Import Hygiene Lint ^^^^^^^^^^^^^^^^^^^ Ensures that the import statements follow the relevant rules."]}}, {"source": {"identifier": "ethereum_spec_tools.lint.lints.import_hygiene.ImportHygiene", "specifier": 0, "path": "src/ethereum_spec_tools/lint/lints/import_hygiene.py"}, "content": {"type": ["class"], "name": ["ImportHygiene"], "text": ["Ensures that the import statements follow the relevant rules. The rules when inside a hard fork file: Deny absolute imports from within the active fork. Deny absolute imports from future forks. Deny absolute imports from active-minus-two and earlier hard forks. Allow relative imports from the active hard fork. Allow absolute imports from the active-minus-one hard fork. Allow absolute imports of non-fork specific things."]}}, {"source": {"identifier": "ethereum_spec_tools.lint.lints.import_hygiene.ImportHygiene.lint", "specifier": 0, "path": "src/ethereum_spec_tools/lint/lints/import_hygiene.py"}, "content": {"type": ["function"], "name": ["lint"], "text": ["Walks the sources for each hardfork and emits Diagnostic messages."]}}, {"source": {"identifier": "ethereum_spec_tools.lint.lints.import_hygiene.ImportHygiene.check_import", "specifier": 0, "path": "src/ethereum_spec_tools/lint/lints/import_hygiene.py"}, "content": {"type": ["function"], "name": ["check_import"], "text": ["Checks a Python source and emits diagnostic messages if there are any invalid imports."]}}, {"source": {"identifier": "ethereum_spec_tools.lint.lints.import_hygiene._Visitor", "specifier": 0, "path": "src/ethereum_spec_tools/lint/lints/import_hygiene.py"}, "content": {"type": ["class"], "name": ["_Visitor"], "text": ["Visits nodes in a syntax tree and collects functions, classes, and assignments."]}}, {"source": {"identifier": "ethereum_spec_tools.lint.lints.import_hygiene._Visitor.item_imports", "specifier": 0, "path": "src/ethereum_spec_tools/lint/lints/import_hygiene.py"}, "content": {"type": ["attribute"], "name": ["item_imports"]}}, {"source": {"identifier": "ethereum_spec_tools.lint.lints.import_hygiene._Visitor.__init__", "specifier": 0, "path": "src/ethereum_spec_tools/lint/lints/import_hygiene.py"}, "content": {"type": ["function"], "name": ["__init__"]}}, {"source": {"identifier": "ethereum_spec_tools.lint.lints.import_hygiene._Visitor.visit_Import", "specifier": 0, "path": "src/ethereum_spec_tools/lint/lints/import_hygiene.py"}, "content": {"type": ["function"], "name": ["visit_Import"], "text": ["Visit an Import."]}}, {"source": {"identifier": "ethereum_spec_tools.lint.lints.import_hygiene._Visitor.visit_ImportFrom", "specifier": 0, "path": "src/ethereum_spec_tools/lint/lints/import_hygiene.py"}, "content": {"type": ["function"], "name": ["visit_ImportFrom"], "text": ["Visit an ImportFrom."]}}, {"source": {"identifier": "ethereum.dao_fork.vm.exceptions", "specifier": 0, "path": "src/ethereum/dao_fork/vm/exceptions.py"}, "content": {"type": ["module"], "name": ["ethereum.dao_fork.vm.exceptions"], "text": ["Ethereum Virtual Machine (EVM) Exceptions ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Exceptions which cause the EVM to halt exceptionally."]}}, {"source": {"identifier": "ethereum.dao_fork.vm.exceptions.ExceptionalHalt", "specifier": 0, "path": "src/ethereum/dao_fork/vm/exceptions.py"}, "content": {"type": ["class"], "name": ["ExceptionalHalt"], "text": ["Indicates that the EVM has experienced an exceptional halt. This causes execution to immediately end with all gas being consumed."]}}, {"source": {"identifier": "ethereum.dao_fork.vm.exceptions.StackUnderflowError", "specifier": 0, "path": "src/ethereum/dao_fork/vm/exceptions.py"}, "content": {"type": ["class"], "name": ["StackUnderflowError"], "text": ["Occurs when a pop is executed on an empty stack."]}}, {"source": {"identifier": "ethereum.dao_fork.vm.exceptions.StackOverflowError", "specifier": 0, "path": "src/ethereum/dao_fork/vm/exceptions.py"}, "content": {"type": ["class"], "name": ["StackOverflowError"], "text": ["Occurs when a push is executed on a stack at max capacity."]}}, {"source": {"identifier": "ethereum.dao_fork.vm.exceptions.OutOfGasError", "specifier": 0, "path": "src/ethereum/dao_fork/vm/exceptions.py"}, "content": {"type": ["class"], "name": ["OutOfGasError"], "text": ["Occurs when an operation costs more than the amount of gas left in the frame."]}}, {"source": {"identifier": "ethereum.dao_fork.vm.exceptions.InvalidOpcode", "specifier": 0, "path": "src/ethereum/dao_fork/vm/exceptions.py"}, "content": {"type": ["class"], "name": ["InvalidOpcode"], "text": ["Raised when an invalid opcode is encountered."]}}, {"source": {"identifier": "ethereum.dao_fork.vm.exceptions.InvalidJumpDestError", "specifier": 0, "path": "src/ethereum/dao_fork/vm/exceptions.py"}, "content": {"type": ["class"], "name": ["InvalidJumpDestError"], "text": ["Occurs when the destination of a jump operation doesn't meet any of the following criteria: The jump destination is less than the length of the code. The jump destination should have the  JUMPDEST  opcode (0x5B). The jump destination shouldn't be part of the data corresponding to PUSH-N  opcodes."]}}, {"source": {"identifier": "ethereum.dao_fork.vm.exceptions.StackDepthLimitError", "specifier": 0, "path": "src/ethereum/dao_fork/vm/exceptions.py"}, "content": {"type": ["class"], "name": ["StackDepthLimitError"], "text": ["Raised when the message depth is greater than  1024"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.comparison", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/comparison.py"}, "content": {"type": ["module"], "name": ["ethereum.constantinople.vm.instructions.comparison"], "text": ["Ethereum Virtual Machine (EVM) Comparison Instructions ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementations of the EVM Comparison instructions."]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.comparison.less_than", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/comparison.py"}, "content": {"type": ["function"], "name": ["less_than"], "text": ["Checks if the top element is less than the next top element. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.comparison.signed_less_than", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/comparison.py"}, "content": {"type": ["function"], "name": ["signed_less_than"], "text": ["Signed less-than comparison. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.comparison.greater_than", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/comparison.py"}, "content": {"type": ["function"], "name": ["greater_than"], "text": ["Checks if the top element is greater than the next top element. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.comparison.signed_greater_than", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/comparison.py"}, "content": {"type": ["function"], "name": ["signed_greater_than"], "text": ["Signed greater-than comparison. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.comparison.equal", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/comparison.py"}, "content": {"type": ["function"], "name": ["equal"], "text": ["Checks if the top element is equal to the next top element. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.comparison.is_zero", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/comparison.py"}, "content": {"type": ["function"], "name": ["is_zero"], "text": ["Checks if the top element is equal to 0. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.berlin.vm.precompiled_contracts.identity", "specifier": 0, "path": "src/ethereum/berlin/vm/precompiled_contracts/identity.py"}, "content": {"type": ["module"], "name": ["ethereum.berlin.vm.precompiled_contracts.identity"], "text": ["Ethereum Virtual Machine (EVM) IDENTITY PRECOMPILED CONTRACT ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementation of the  IDENTITY  precompiled contract."]}}, {"source": {"identifier": "ethereum.berlin.vm.precompiled_contracts.identity.identity", "specifier": 0, "path": "src/ethereum/berlin/vm/precompiled_contracts/identity.py"}, "content": {"type": ["function"], "name": ["identity"], "text": ["Writes the message data to output. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum_spec_tools.lint.lints.glacier_forks_hygiene", "specifier": 0, "path": "src/ethereum_spec_tools/lint/lints/glacier_forks_hygiene.py"}, "content": {"type": ["module"], "name": ["ethereum_spec_tools.lint.lints.glacier_forks_hygiene"], "text": ["Glacier Fork Hygiene Lint ^^^^^^^^^^^^^^^^^^^^^^^^^ Ensures that the glacier forks have changes only in BOMB_DELAY_BLOCKS."]}}, {"source": {"identifier": "ethereum_spec_tools.lint.lints.glacier_forks_hygiene.EXCEPTIONAL_DIFFS", "specifier": 0, "path": "src/ethereum_spec_tools/lint/lints/glacier_forks_hygiene.py"}, "content": {"type": ["attribute"], "name": ["EXCEPTIONAL_DIFFS"]}}, {"source": {"identifier": "ethereum_spec_tools.lint.lints.glacier_forks_hygiene.add_diagnostic", "specifier": 0, "path": "src/ethereum_spec_tools/lint/lints/glacier_forks_hygiene.py"}, "content": {"type": ["function"], "name": ["add_diagnostic"], "text": ["Adds a new diagnostic message."]}}, {"source": {"identifier": "ethereum_spec_tools.lint.lints.glacier_forks_hygiene.GlacierForksHygiene", "specifier": 0, "path": "src/ethereum_spec_tools/lint/lints/glacier_forks_hygiene.py"}, "content": {"type": ["class"], "name": ["GlacierForksHygiene"], "text": ["Ensures that the glacier forks have changes only in BOMB_DELAY_BLOCKS."]}}, {"source": {"identifier": "ethereum_spec_tools.lint.lints.glacier_forks_hygiene.GlacierForksHygiene.__init__", "specifier": 0, "path": "src/ethereum_spec_tools/lint/lints/glacier_forks_hygiene.py"}, "content": {"type": ["function"], "name": ["__init__"]}}, {"source": {"identifier": "ethereum_spec_tools.lint.lints.glacier_forks_hygiene.GlacierForksHygiene.lint", "specifier": 0, "path": "src/ethereum_spec_tools/lint/lints/glacier_forks_hygiene.py"}, "content": {"type": ["function"], "name": ["lint"], "text": ["Walks the sources for each hardfork and emits Diagnostic messages."]}}, {"source": {"identifier": "ethereum_spec_tools.lint.lints.glacier_forks_hygiene.GlacierForksHygiene.compare", "specifier": 0, "path": "src/ethereum_spec_tools/lint/lints/glacier_forks_hygiene.py"}, "content": {"type": ["function"], "name": ["compare"], "text": ["Compare nodes from two different modules for changes and emit diagnostics."]}}, {"source": {"identifier": "ethereum_spec_tools.lint.lints.glacier_forks_hygiene._Visitor", "specifier": 0, "path": "src/ethereum_spec_tools/lint/lints/glacier_forks_hygiene.py"}, "content": {"type": ["class"], "name": ["_Visitor"], "text": ["Visits nodes in a syntax tree and collects functions, classes, and assignments."]}}, {"source": {"identifier": "ethereum_spec_tools.lint.lints.glacier_forks_hygiene._Visitor.path", "specifier": 0, "path": "src/ethereum_spec_tools/lint/lints/glacier_forks_hygiene.py"}, "content": {"type": ["attribute"], "name": ["path"]}}, {"source": {"identifier": "ethereum_spec_tools.lint.lints.glacier_forks_hygiene._Visitor._items", "specifier": 0, "path": "src/ethereum_spec_tools/lint/lints/glacier_forks_hygiene.py"}, "content": {"type": ["attribute"], "name": ["_items"]}}, {"source": {"identifier": "ethereum_spec_tools.lint.lints.glacier_forks_hygiene._Visitor.__init__", "specifier": 0, "path": "src/ethereum_spec_tools/lint/lints/glacier_forks_hygiene.py"}, "content": {"type": ["function"], "name": ["__init__"]}}, {"source": {"identifier": "ethereum_spec_tools.lint.lints.glacier_forks_hygiene._Visitor.generic_visit", "specifier": 0, "path": "src/ethereum_spec_tools/lint/lints/glacier_forks_hygiene.py"}, "content": {"type": ["function"], "name": ["generic_visit"], "text": ["Called if no explicit visitor function exists for a node. Do not visit any child nodes."]}}, {"source": {"identifier": "ethereum_spec_tools.lint.lints.glacier_forks_hygiene._Visitor._insert", "specifier": 0, "path": "src/ethereum_spec_tools/lint/lints/glacier_forks_hygiene.py"}, "content": {"type": ["function"], "name": ["_insert"]}}, {"source": {"identifier": "ethereum_spec_tools.lint.lints.glacier_forks_hygiene._Visitor.items", "specifier": 0, "path": "src/ethereum_spec_tools/lint/lints/glacier_forks_hygiene.py"}, "content": {"type": ["function"], "name": ["items"], "text": ["Sequence of all identifiers found while visiting the source."]}}, {"source": {"identifier": "ethereum_spec_tools.lint.lints.glacier_forks_hygiene._Visitor.visit_Module", "specifier": 0, "path": "src/ethereum_spec_tools/lint/lints/glacier_forks_hygiene.py"}, "content": {"type": ["function"], "name": ["visit_Module"], "text": ["Visit a python module."]}}, {"source": {"identifier": "ethereum_spec_tools.lint.lints.glacier_forks_hygiene._Visitor.visit_Import", "specifier": 0, "path": "src/ethereum_spec_tools/lint/lints/glacier_forks_hygiene.py"}, "content": {"type": ["function"], "name": ["visit_Import"], "text": ["Visit an Import"]}}, {"source": {"identifier": "ethereum_spec_tools.lint.lints.glacier_forks_hygiene._Visitor.visit_ImportFrom", "specifier": 0, "path": "src/ethereum_spec_tools/lint/lints/glacier_forks_hygiene.py"}, "content": {"type": ["function"], "name": ["visit_ImportFrom"], "text": ["Visit an Import From"]}}, {"source": {"identifier": "ethereum_spec_tools.lint.lints.glacier_forks_hygiene._Visitor.visit_Expr", "specifier": 0, "path": "src/ethereum_spec_tools/lint/lints/glacier_forks_hygiene.py"}, "content": {"type": ["function"], "name": ["visit_Expr"], "text": ["Visit an Expression"]}}, {"source": {"identifier": "ethereum_spec_tools.lint.lints.glacier_forks_hygiene._Visitor.visit_AsyncFunctionDef", "specifier": 0, "path": "src/ethereum_spec_tools/lint/lints/glacier_forks_hygiene.py"}, "content": {"type": ["function"], "name": ["visit_AsyncFunctionDef"], "text": ["Visit an asynchronous function."]}}, {"source": {"identifier": "ethereum_spec_tools.lint.lints.glacier_forks_hygiene._Visitor.visit_FunctionDef", "specifier": 0, "path": "src/ethereum_spec_tools/lint/lints/glacier_forks_hygiene.py"}, "content": {"type": ["function"], "name": ["visit_FunctionDef"], "text": ["Visit a function."]}}, {"source": {"identifier": "ethereum_spec_tools.lint.lints.glacier_forks_hygiene._Visitor.visit_ClassDef", "specifier": 0, "path": "src/ethereum_spec_tools/lint/lints/glacier_forks_hygiene.py"}, "content": {"type": ["function"], "name": ["visit_ClassDef"], "text": ["Visit a class."]}}, {"source": {"identifier": "ethereum_spec_tools.lint.lints.glacier_forks_hygiene._Visitor.visit_Assign", "specifier": 0, "path": "src/ethereum_spec_tools/lint/lints/glacier_forks_hygiene.py"}, "content": {"type": ["function"], "name": ["visit_Assign"], "text": ["Visit an assignment."]}}, {"source": {"identifier": "ethereum_spec_tools.lint.lints.glacier_forks_hygiene._Visitor.visit_AnnAssign", "specifier": 0, "path": "src/ethereum_spec_tools/lint/lints/glacier_forks_hygiene.py"}, "content": {"type": ["function"], "name": ["visit_AnnAssign"], "text": ["Visit an annotated assignment."]}}, {"source": {"identifier": "ethereum.dao_fork.vm", "specifier": 0, "path": "src/ethereum/dao_fork/vm/__init__.py"}, "content": {"type": ["module"], "name": ["ethereum.dao_fork.vm"], "text": ["Ethereum Virtual Machine (EVM) ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction The abstract computer which runs the code stored in an .fork_types.Account ."]}}, {"source": {"identifier": "ethereum.dao_fork.vm.__all__", "specifier": 0, "path": "src/ethereum/dao_fork/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["__all__"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.Environment", "specifier": 0, "path": "src/ethereum/dao_fork/vm/__init__.py"}, "content": {"type": ["class"], "name": ["Environment"], "text": ["Items external to the virtual machine itself, provided by the environment."]}}, {"source": {"identifier": "ethereum.dao_fork.vm.Environment.caller", "specifier": 0, "path": "src/ethereum/dao_fork/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["caller"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.Environment.block_hashes", "specifier": 0, "path": "src/ethereum/dao_fork/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["block_hashes"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.Environment.origin", "specifier": 0, "path": "src/ethereum/dao_fork/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["origin"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.Environment.coinbase", "specifier": 0, "path": "src/ethereum/dao_fork/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["coinbase"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.Environment.number", "specifier": 0, "path": "src/ethereum/dao_fork/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["number"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.Environment.gas_limit", "specifier": 0, "path": "src/ethereum/dao_fork/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["gas_limit"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.Environment.gas_price", "specifier": 0, "path": "src/ethereum/dao_fork/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["gas_price"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.Environment.time", "specifier": 0, "path": "src/ethereum/dao_fork/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["time"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.Environment.difficulty", "specifier": 0, "path": "src/ethereum/dao_fork/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["difficulty"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.Environment.state", "specifier": 0, "path": "src/ethereum/dao_fork/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["state"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.Message", "specifier": 0, "path": "src/ethereum/dao_fork/vm/__init__.py"}, "content": {"type": ["class"], "name": ["Message"], "text": ["Items that are used by contract creation or message call."]}}, {"source": {"identifier": "ethereum.dao_fork.vm.Message.caller", "specifier": 0, "path": "src/ethereum/dao_fork/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["caller"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.Message.target", "specifier": 0, "path": "src/ethereum/dao_fork/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["target"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.Message.current_target", "specifier": 0, "path": "src/ethereum/dao_fork/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["current_target"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.Message.gas", "specifier": 0, "path": "src/ethereum/dao_fork/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["gas"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.Message.value", "specifier": 0, "path": "src/ethereum/dao_fork/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["value"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.Message.data", "specifier": 0, "path": "src/ethereum/dao_fork/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["data"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.Message.code_address", "specifier": 0, "path": "src/ethereum/dao_fork/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["code_address"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.Message.code", "specifier": 0, "path": "src/ethereum/dao_fork/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["code"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.Message.depth", "specifier": 0, "path": "src/ethereum/dao_fork/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["depth"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.Message.should_transfer_value", "specifier": 0, "path": "src/ethereum/dao_fork/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["should_transfer_value"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.Evm", "specifier": 0, "path": "src/ethereum/dao_fork/vm/__init__.py"}, "content": {"type": ["class"], "name": ["Evm"], "text": ["The internal state of the virtual machine."]}}, {"source": {"identifier": "ethereum.dao_fork.vm.Evm.pc", "specifier": 0, "path": "src/ethereum/dao_fork/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["pc"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.Evm.stack", "specifier": 0, "path": "src/ethereum/dao_fork/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["stack"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.Evm.memory", "specifier": 0, "path": "src/ethereum/dao_fork/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["memory"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.Evm.code", "specifier": 0, "path": "src/ethereum/dao_fork/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["code"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.Evm.gas_left", "specifier": 0, "path": "src/ethereum/dao_fork/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["gas_left"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.Evm.env", "specifier": 0, "path": "src/ethereum/dao_fork/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["env"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.Evm.valid_jump_destinations", "specifier": 0, "path": "src/ethereum/dao_fork/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["valid_jump_destinations"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.Evm.logs", "specifier": 0, "path": "src/ethereum/dao_fork/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["logs"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.Evm.refund_counter", "specifier": 0, "path": "src/ethereum/dao_fork/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["refund_counter"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.Evm.running", "specifier": 0, "path": "src/ethereum/dao_fork/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["running"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.Evm.message", "specifier": 0, "path": "src/ethereum/dao_fork/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["message"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.Evm.output", "specifier": 0, "path": "src/ethereum/dao_fork/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["output"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.Evm.accounts_to_delete", "specifier": 0, "path": "src/ethereum/dao_fork/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["accounts_to_delete"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.Evm.has_erred", "specifier": 0, "path": "src/ethereum/dao_fork/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["has_erred"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.Evm.children", "specifier": 0, "path": "src/ethereum/dao_fork/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["children"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.log", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/log.py"}, "content": {"type": ["module"], "name": ["ethereum.constantinople.vm.instructions.log"], "text": ["Ethereum Virtual Machine (EVM) Logging Instructions ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementations of the EVM logging instructions."]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.log.log_n", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/log.py"}, "content": {"type": ["function"], "name": ["log_n"], "text": ["Appends a log entry, having  num_topics  topics, to the evm logs. This will also expand the memory if the data (required by the log entry) corresponding to the memory is not accessible. Parameters evm : The current EVM frame. num_topics : The number of topics to be included in the log entry."]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.log.log0", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/log.py"}, "content": {"type": ["attribute"], "name": ["log0"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.log.log1", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/log.py"}, "content": {"type": ["attribute"], "name": ["log1"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.log.log2", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/log.py"}, "content": {"type": ["attribute"], "name": ["log2"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.log.log3", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/log.py"}, "content": {"type": ["attribute"], "name": ["log3"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.log.log4", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/log.py"}, "content": {"type": ["attribute"], "name": ["log4"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.memory", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/memory.py"}, "content": {"type": ["module"], "name": ["ethereum.berlin.vm.instructions.memory"], "text": ["Ethereum Virtual Machine (EVM) Memory Instructions ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementations of the EVM Memory instructions."]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.memory.mstore", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/memory.py"}, "content": {"type": ["function"], "name": ["mstore"], "text": ["Stores a word to memory. This also expands the memory, if the memory is insufficient to store the word. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.memory.mstore8", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/memory.py"}, "content": {"type": ["function"], "name": ["mstore8"], "text": ["Stores a byte to memory. This also expands the memory, if the memory is insufficient to store the word. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.memory.mload", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/memory.py"}, "content": {"type": ["function"], "name": ["mload"], "text": ["Load word from memory. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.memory.msize", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/memory.py"}, "content": {"type": ["function"], "name": ["msize"], "text": ["Push the size of active memory in bytes onto the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum_spec_tools.lint.lints.patch_hygiene", "specifier": 0, "path": "src/ethereum_spec_tools/lint/lints/patch_hygiene.py"}, "content": {"type": ["module"], "name": ["ethereum_spec_tools.lint.lints.patch_hygiene"], "text": ["Patch Hygiene Lint ^^^^^^^^^^^^^^^^^^ Ensures that the order of identifiers between each hardfork is consistent."]}}, {"source": {"identifier": "ethereum_spec_tools.lint.lints.patch_hygiene.PatchHygiene", "specifier": 0, "path": "src/ethereum_spec_tools/lint/lints/patch_hygiene.py"}, "content": {"type": ["class"], "name": ["PatchHygiene"], "text": ["Ensures that the order of identifiers between each hardfork is consistent."]}}, {"source": {"identifier": "ethereum_spec_tools.lint.lints.patch_hygiene.PatchHygiene.lint", "specifier": 0, "path": "src/ethereum_spec_tools/lint/lints/patch_hygiene.py"}, "content": {"type": ["function"], "name": ["lint"], "text": ["Walks the sources for each hardfork and emits Diagnostic messages."]}}, {"source": {"identifier": "ethereum_spec_tools.lint.lints.patch_hygiene.PatchHygiene.compare", "specifier": 0, "path": "src/ethereum_spec_tools/lint/lints/patch_hygiene.py"}, "content": {"type": ["function"], "name": ["compare"], "text": ["Compares two strings containing Python source and emits diagnostic messages if any identifiers have changed relative positions."]}}, {"source": {"identifier": "ethereum_spec_tools.lint.lints.patch_hygiene._Visitor", "specifier": 0, "path": "src/ethereum_spec_tools/lint/lints/patch_hygiene.py"}, "content": {"type": ["class"], "name": ["_Visitor"], "text": ["Visits nodes in a syntax tree and collects functions, classes, and assignments."]}}, {"source": {"identifier": "ethereum_spec_tools.lint.lints.patch_hygiene._Visitor.path", "specifier": 0, "path": "src/ethereum_spec_tools/lint/lints/patch_hygiene.py"}, "content": {"type": ["attribute"], "name": ["path"]}}, {"source": {"identifier": "ethereum_spec_tools.lint.lints.patch_hygiene._Visitor._items", "specifier": 0, "path": "src/ethereum_spec_tools/lint/lints/patch_hygiene.py"}, "content": {"type": ["attribute"], "name": ["_items"]}}, {"source": {"identifier": "ethereum_spec_tools.lint.lints.patch_hygiene._Visitor.in_assign", "specifier": 0, "path": "src/ethereum_spec_tools/lint/lints/patch_hygiene.py"}, "content": {"type": ["attribute"], "name": ["in_assign"]}}, {"source": {"identifier": "ethereum_spec_tools.lint.lints.patch_hygiene._Visitor.__init__", "specifier": 0, "path": "src/ethereum_spec_tools/lint/lints/patch_hygiene.py"}, "content": {"type": ["function"], "name": ["__init__"]}}, {"source": {"identifier": "ethereum_spec_tools.lint.lints.patch_hygiene._Visitor._insert", "specifier": 0, "path": "src/ethereum_spec_tools/lint/lints/patch_hygiene.py"}, "content": {"type": ["function"], "name": ["_insert"]}}, {"source": {"identifier": "ethereum_spec_tools.lint.lints.patch_hygiene._Visitor.items", "specifier": 0, "path": "src/ethereum_spec_tools/lint/lints/patch_hygiene.py"}, "content": {"type": ["function"], "name": ["items"], "text": ["Sequence of all identifiers found while visiting the source."]}}, {"source": {"identifier": "ethereum_spec_tools.lint.lints.patch_hygiene._Visitor.visit_AsyncFunctionDef", "specifier": 0, "path": "src/ethereum_spec_tools/lint/lints/patch_hygiene.py"}, "content": {"type": ["function"], "name": ["visit_AsyncFunctionDef"], "text": ["Visit an asynchronous function."]}}, {"source": {"identifier": "ethereum_spec_tools.lint.lints.patch_hygiene._Visitor.visit_FunctionDef", "specifier": 0, "path": "src/ethereum_spec_tools/lint/lints/patch_hygiene.py"}, "content": {"type": ["function"], "name": ["visit_FunctionDef"], "text": ["Visit a function."]}}, {"source": {"identifier": "ethereum_spec_tools.lint.lints.patch_hygiene._Visitor.visit_ClassDef", "specifier": 0, "path": "src/ethereum_spec_tools/lint/lints/patch_hygiene.py"}, "content": {"type": ["function"], "name": ["visit_ClassDef"], "text": ["Visit a class."]}}, {"source": {"identifier": "ethereum_spec_tools.lint.lints.patch_hygiene._Visitor.visit_Assign", "specifier": 0, "path": "src/ethereum_spec_tools/lint/lints/patch_hygiene.py"}, "content": {"type": ["function"], "name": ["visit_Assign"], "text": ["Visit an assignment."]}}, {"source": {"identifier": "ethereum_spec_tools.lint.lints.patch_hygiene._Visitor.visit_AnnAssign", "specifier": 0, "path": "src/ethereum_spec_tools/lint/lints/patch_hygiene.py"}, "content": {"type": ["function"], "name": ["visit_AnnAssign"], "text": ["Visit an annotated assignment."]}}, {"source": {"identifier": "ethereum_spec_tools.lint.lints.patch_hygiene._Visitor.visit_Name", "specifier": 0, "path": "src/ethereum_spec_tools/lint/lints/patch_hygiene.py"}, "content": {"type": ["function"], "name": ["visit_Name"], "text": ["Visit an identifier."]}}, {"source": {"identifier": "ethereum.dao_fork.vm.runtime", "specifier": 0, "path": "src/ethereum/dao_fork/vm/runtime.py"}, "content": {"type": ["module"], "name": ["ethereum.dao_fork.vm.runtime"], "text": ["Ethereum Virtual Machine (EVM) Runtime Operations ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Runtime related operations used while executing EVM code."]}}, {"source": {"identifier": "ethereum.dao_fork.vm.runtime.get_valid_jump_destinations", "specifier": 0, "path": "src/ethereum/dao_fork/vm/runtime.py"}, "content": {"type": ["function"], "name": ["get_valid_jump_destinations"], "text": ["Analyze the evm code to obtain the set of valid jump destinations. Valid jump destinations are defined as follows: * The jump destination is less than the length of the code. * The jump destination should have the  JUMPDEST  opcode (0x5B). * The jump destination shouldn't be part of the data corresponding to PUSH-N  opcodes. Note - Jump destinations are 0-indexed. Parameters code : The EVM code which is to be executed. Returns valid_jump_destinations:  Set[Uint] The set of valid jump destinations in the code."]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.storage", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/storage.py"}, "content": {"type": ["module"], "name": ["ethereum.constantinople.vm.instructions.storage"], "text": ["Ethereum Virtual Machine (EVM) Storage Instructions ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementations of the EVM storage related instructions."]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.storage.sload", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/storage.py"}, "content": {"type": ["function"], "name": ["sload"], "text": ["Loads to the stack, the value corresponding to a certain key from the storage of the current account. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.storage.sstore", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/storage.py"}, "content": {"type": ["function"], "name": ["sstore"], "text": ["Stores a value at a certain key in the current context's storage. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.system", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/system.py"}, "content": {"type": ["module"], "name": ["ethereum.berlin.vm.instructions.system"], "text": ["Ethereum Virtual Machine (EVM) System Instructions ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementations of the EVM system related instructions."]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.system.generic_create", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/system.py"}, "content": {"type": ["function"], "name": ["generic_create"], "text": ["Core logic used by the  CREATE*  family of opcodes."]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.system.create", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/system.py"}, "content": {"type": ["function"], "name": ["create"], "text": ["Creates a new account with associated code. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.system.create2", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/system.py"}, "content": {"type": ["function"], "name": ["create2"], "text": ["Creates a new account with associated code. It's similar to CREATE opcode except that the address of new account depends on the init_code instead of the nonce of sender. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.system.return_", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/system.py"}, "content": {"type": ["function"], "name": ["return_"], "text": ["Halts execution returning output data. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.system.generic_call", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/system.py"}, "content": {"type": ["function"], "name": ["generic_call"], "text": ["Perform the core logic of the  CALL*  family of opcodes."]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.system.call", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/system.py"}, "content": {"type": ["function"], "name": ["call"], "text": ["Message-call into an account. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.system.callcode", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/system.py"}, "content": {"type": ["function"], "name": ["callcode"], "text": ["Message-call into this account with alternative account\u2019s code. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.system.selfdestruct", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/system.py"}, "content": {"type": ["function"], "name": ["selfdestruct"], "text": ["Halt execution and register account for later deletion. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.system.delegatecall", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/system.py"}, "content": {"type": ["function"], "name": ["delegatecall"], "text": ["Message-call into an account. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.system.staticcall", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/system.py"}, "content": {"type": ["function"], "name": ["staticcall"], "text": ["Message-call into an account. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.system.revert", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/system.py"}, "content": {"type": ["function"], "name": ["revert"], "text": ["Stop execution and revert state changes, without consuming all provided gas and also has the ability to return a reason Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.dao_fork.vm.interpreter", "specifier": 0, "path": "src/ethereum/dao_fork/vm/interpreter.py"}, "content": {"type": ["module"], "name": ["ethereum.dao_fork.vm.interpreter"], "text": ["Ethereum Virtual Machine (EVM) Interpreter ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction A straightforward interpreter that executes EVM code."]}}, {"source": {"identifier": "ethereum.dao_fork.vm.interpreter.STACK_DEPTH_LIMIT", "specifier": 0, "path": "src/ethereum/dao_fork/vm/interpreter.py"}, "content": {"type": ["attribute"], "name": ["STACK_DEPTH_LIMIT"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.interpreter.MessageCallOutput", "specifier": 0, "path": "src/ethereum/dao_fork/vm/interpreter.py"}, "content": {"type": ["class"], "name": ["MessageCallOutput"], "text": ["Output of a particular message call Contains the following:   1. `gas_left`: remaining gas after execution.\n  2. `refund_counter`: gas to refund after execution.\n  3. `logs`: list of `Log` generated during execution.\n  4. `accounts_to_delete`: Contracts which have self-destructed.\n  5. `has_erred`: True if execution has caused an error.\n"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.interpreter.MessageCallOutput.gas_left", "specifier": 0, "path": "src/ethereum/dao_fork/vm/interpreter.py"}, "content": {"type": ["attribute"], "name": ["gas_left"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.interpreter.MessageCallOutput.refund_counter", "specifier": 0, "path": "src/ethereum/dao_fork/vm/interpreter.py"}, "content": {"type": ["attribute"], "name": ["refund_counter"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.interpreter.MessageCallOutput.logs", "specifier": 0, "path": "src/ethereum/dao_fork/vm/interpreter.py"}, "content": {"type": ["attribute"], "name": ["logs"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.interpreter.MessageCallOutput.accounts_to_delete", "specifier": 0, "path": "src/ethereum/dao_fork/vm/interpreter.py"}, "content": {"type": ["attribute"], "name": ["accounts_to_delete"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.interpreter.MessageCallOutput.has_erred", "specifier": 0, "path": "src/ethereum/dao_fork/vm/interpreter.py"}, "content": {"type": ["attribute"], "name": ["has_erred"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.interpreter.process_message_call", "specifier": 0, "path": "src/ethereum/dao_fork/vm/interpreter.py"}, "content": {"type": ["function"], "name": ["process_message_call"], "text": ["If  message.current  is empty then it creates a smart contract else it executes a call from the  message.caller  to the  message.target . Parameters message : Transaction specific items. env : External items required for EVM execution. Returns output :  MessageCallOutput Output of the message call"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.interpreter.process_create_message", "specifier": 0, "path": "src/ethereum/dao_fork/vm/interpreter.py"}, "content": {"type": ["function"], "name": ["process_create_message"], "text": ["Executes a call to create a smart contract. Parameters message : Transaction specific items. env : External items required for EVM execution. Returns evm: :py:class: ~ethereum.dao_fork.vm.Evm Items containing execution specific objects."]}}, {"source": {"identifier": "ethereum.dao_fork.vm.interpreter.process_message", "specifier": 0, "path": "src/ethereum/dao_fork/vm/interpreter.py"}, "content": {"type": ["function"], "name": ["process_message"], "text": ["Executes a call to create a smart contract. Parameters message : Transaction specific items. env : External items required for EVM execution. Returns evm: :py:class: ~ethereum.dao_fork.vm.Evm Items containing execution specific objects"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.interpreter.execute_code", "specifier": 0, "path": "src/ethereum/dao_fork/vm/interpreter.py"}, "content": {"type": ["function"], "name": ["execute_code"], "text": ["Executes bytecode present in the  message . Parameters message : Transaction specific items. env : External items required for EVM execution. Returns evm:  ethereum.vm.EVM Items containing execution specific objects"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.interpreter.collect_accounts_to_delete", "specifier": 0, "path": "src/ethereum/dao_fork/vm/interpreter.py"}, "content": {"type": ["function"], "name": ["collect_accounts_to_delete"], "text": ["Collects all the accounts that were marked for deletion by the SELFDESTRUCT  opcode. Parameters evm : The current EVM frame. Returns accounts_to_delete:  set returns all the accounts need marked for deletion by the SELFDESTRUCT  opcode."]}}, {"source": {"identifier": "ethereum.dao_fork.vm.interpreter.calculate_gas_refund", "specifier": 0, "path": "src/ethereum/dao_fork/vm/interpreter.py"}, "content": {"type": ["function"], "name": ["calculate_gas_refund"], "text": ["Adds up the gas that was refunded in each execution frame during the message call. Parameters evm : The current EVM frame. Returns gas_refund:  ethereum.base_types.U256 returns the total gas that needs to be refunded after executing the message call."]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.block", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/block.py"}, "content": {"type": ["module"], "name": ["ethereum.constantinople.vm.instructions.block"], "text": ["Ethereum Virtual Machine (EVM) Block Instructions ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementations of the EVM block instructions."]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.block.block_hash", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/block.py"}, "content": {"type": ["function"], "name": ["block_hash"], "text": ["Push the hash of one of the 256 most recent complete blocks onto the stack. The block number to hash is present at the top of the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.block.coinbase", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/block.py"}, "content": {"type": ["function"], "name": ["coinbase"], "text": ["Push the current block's beneficiary address (address of the block miner) onto the stack. Here the current block refers to the block in which the currently executing transaction/call resides. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.block.timestamp", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/block.py"}, "content": {"type": ["function"], "name": ["timestamp"], "text": ["Push the current block's timestamp onto the stack. Here the timestamp being referred is actually the unix timestamp in seconds. Here the current block refers to the block in which the currently executing transaction/call resides. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.block.number", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/block.py"}, "content": {"type": ["function"], "name": ["number"], "text": ["Push the current block's number onto the stack. Here the current block refers to the block in which the currently executing transaction/call resides. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.block.difficulty", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/block.py"}, "content": {"type": ["function"], "name": ["difficulty"], "text": ["Push the current block's difficulty onto the stack. Here the current block refers to the block in which the currently executing transaction/call resides. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.block.gas_limit", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/block.py"}, "content": {"type": ["function"], "name": ["gas_limit"], "text": ["Push the current block's gas limit onto the stack. Here the current block refers to the block in which the currently executing transaction/call resides. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/__init__.py"}, "content": {"type": ["module"], "name": ["ethereum.berlin.vm.instructions"], "text": ["EVM Instruction Encoding (Opcodes) ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Machine readable representations of EVM instructions, and a mapping to their implementations."]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.Ops", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/__init__.py"}, "content": {"type": ["class"], "name": ["Ops"], "text": ["Enum for EVM Opcodes"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.Ops.ADD", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["ADD"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.Ops.MUL", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["MUL"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.Ops.SUB", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SUB"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.Ops.DIV", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DIV"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.Ops.SDIV", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SDIV"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.Ops.MOD", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["MOD"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.Ops.SMOD", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SMOD"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.Ops.ADDMOD", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["ADDMOD"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.Ops.MULMOD", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["MULMOD"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.Ops.EXP", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["EXP"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.Ops.SIGNEXTEND", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SIGNEXTEND"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.Ops.LT", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["LT"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.Ops.GT", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["GT"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.Ops.SLT", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SLT"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.Ops.SGT", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SGT"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.Ops.EQ", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["EQ"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.Ops.ISZERO", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["ISZERO"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.Ops.AND", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["AND"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.Ops.OR", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["OR"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.Ops.XOR", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["XOR"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.Ops.NOT", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["NOT"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.Ops.BYTE", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["BYTE"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.Ops.SHL", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SHL"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.Ops.SHR", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SHR"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.Ops.SAR", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SAR"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.Ops.KECCAK", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["KECCAK"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.Ops.ADDRESS", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["ADDRESS"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.Ops.BALANCE", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["BALANCE"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.Ops.ORIGIN", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["ORIGIN"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.Ops.CALLER", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["CALLER"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.Ops.CALLVALUE", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["CALLVALUE"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.Ops.CALLDATALOAD", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["CALLDATALOAD"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.Ops.CALLDATASIZE", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["CALLDATASIZE"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.Ops.CALLDATACOPY", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["CALLDATACOPY"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.Ops.CODESIZE", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["CODESIZE"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.Ops.CODECOPY", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["CODECOPY"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.Ops.GASPRICE", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["GASPRICE"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.Ops.EXTCODESIZE", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["EXTCODESIZE"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.Ops.EXTCODECOPY", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["EXTCODECOPY"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.Ops.RETURNDATASIZE", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["RETURNDATASIZE"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.Ops.RETURNDATACOPY", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["RETURNDATACOPY"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.Ops.EXTCODEHASH", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["EXTCODEHASH"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.Ops.BLOCKHASH", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["BLOCKHASH"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.Ops.COINBASE", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["COINBASE"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.Ops.TIMESTAMP", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["TIMESTAMP"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.Ops.NUMBER", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["NUMBER"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.Ops.DIFFICULTY", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DIFFICULTY"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.Ops.GASLIMIT", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["GASLIMIT"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.Ops.CHAINID", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["CHAINID"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.Ops.SELFBALANCE", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SELFBALANCE"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.Ops.STOP", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["STOP"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.Ops.JUMP", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["JUMP"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.Ops.JUMPI", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["JUMPI"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.Ops.PC", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PC"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.Ops.GAS", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["GAS"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.Ops.JUMPDEST", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["JUMPDEST"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.Ops.SLOAD", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SLOAD"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.Ops.SSTORE", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SSTORE"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.Ops.POP", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["POP"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.Ops.PUSH1", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH1"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.Ops.PUSH2", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH2"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.Ops.PUSH3", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH3"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.Ops.PUSH4", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH4"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.Ops.PUSH5", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH5"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.Ops.PUSH6", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH6"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.Ops.PUSH7", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH7"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.Ops.PUSH8", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH8"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.Ops.PUSH9", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH9"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.Ops.PUSH10", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH10"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.Ops.PUSH11", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH11"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.Ops.PUSH12", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH12"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.Ops.PUSH13", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH13"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.Ops.PUSH14", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH14"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.Ops.PUSH15", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH15"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.Ops.PUSH16", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH16"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.Ops.PUSH17", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH17"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.Ops.PUSH18", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH18"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.Ops.PUSH19", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH19"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.Ops.PUSH20", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH20"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.Ops.PUSH21", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH21"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.Ops.PUSH22", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH22"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.Ops.PUSH23", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH23"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.Ops.PUSH24", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH24"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.Ops.PUSH25", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH25"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.Ops.PUSH26", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH26"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.Ops.PUSH27", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH27"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.Ops.PUSH28", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH28"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.Ops.PUSH29", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH29"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.Ops.PUSH30", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH30"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.Ops.PUSH31", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH31"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.Ops.PUSH32", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH32"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.Ops.DUP1", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP1"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.Ops.DUP2", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP2"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.Ops.DUP3", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP3"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.Ops.DUP4", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP4"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.Ops.DUP5", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP5"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.Ops.DUP6", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP6"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.Ops.DUP7", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP7"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.Ops.DUP8", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP8"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.Ops.DUP9", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP9"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.Ops.DUP10", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP10"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.Ops.DUP11", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP11"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.Ops.DUP12", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP12"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.Ops.DUP13", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP13"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.Ops.DUP14", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP14"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.Ops.DUP15", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP15"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.Ops.DUP16", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP16"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.Ops.SWAP1", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP1"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.Ops.SWAP2", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP2"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.Ops.SWAP3", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP3"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.Ops.SWAP4", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP4"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.Ops.SWAP5", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP5"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.Ops.SWAP6", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP6"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.Ops.SWAP7", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP7"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.Ops.SWAP8", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP8"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.Ops.SWAP9", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP9"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.Ops.SWAP10", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP10"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.Ops.SWAP11", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP11"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.Ops.SWAP12", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP12"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.Ops.SWAP13", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP13"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.Ops.SWAP14", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP14"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.Ops.SWAP15", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP15"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.Ops.SWAP16", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP16"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.Ops.MLOAD", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["MLOAD"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.Ops.MSTORE", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["MSTORE"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.Ops.MSTORE8", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["MSTORE8"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.Ops.MSIZE", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["MSIZE"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.Ops.LOG0", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["LOG0"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.Ops.LOG1", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["LOG1"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.Ops.LOG2", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["LOG2"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.Ops.LOG3", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["LOG3"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.Ops.LOG4", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["LOG4"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.Ops.CREATE", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["CREATE"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.Ops.RETURN", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["RETURN"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.Ops.CALL", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["CALL"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.Ops.CALLCODE", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["CALLCODE"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.Ops.DELEGATECALL", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DELEGATECALL"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.Ops.STATICCALL", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["STATICCALL"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.Ops.REVERT", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["REVERT"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.Ops.SELFDESTRUCT", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SELFDESTRUCT"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.Ops.CREATE2", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["CREATE2"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.op_implementation", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["op_implementation"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.stack", "specifier": 0, "path": "src/ethereum/dao_fork/vm/stack.py"}, "content": {"type": ["module"], "name": ["ethereum.dao_fork.vm.stack"], "text": ["Ethereum Virtual Machine (EVM) Stack ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementation of the stack operators for the EVM."]}}, {"source": {"identifier": "ethereum.dao_fork.vm.stack.pop", "specifier": 0, "path": "src/ethereum/dao_fork/vm/stack.py"}, "content": {"type": ["function"], "name": ["pop"], "text": ["Pops the top item off of  stack . Parameters stack : EVM stack. Returns value :  U256 The top element on the stack."]}}, {"source": {"identifier": "ethereum.dao_fork.vm.stack.push", "specifier": 0, "path": "src/ethereum/dao_fork/vm/stack.py"}, "content": {"type": ["function"], "name": ["push"], "text": ["Pushes  value  onto  stack . Parameters stack : EVM stack. value : Item to be pushed onto  stack ."]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.arithmetic", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/arithmetic.py"}, "content": {"type": ["module"], "name": ["ethereum.constantinople.vm.instructions.arithmetic"], "text": ["Ethereum Virtual Machine (EVM) Arithmetic Instructions ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementations of the EVM Arithmetic instructions."]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.arithmetic.add", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/arithmetic.py"}, "content": {"type": ["function"], "name": ["add"], "text": ["Adds the top two elements of the stack together, and pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.arithmetic.sub", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/arithmetic.py"}, "content": {"type": ["function"], "name": ["sub"], "text": ["Subtracts the top two elements of the stack, and pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.arithmetic.mul", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/arithmetic.py"}, "content": {"type": ["function"], "name": ["mul"], "text": ["Multiply the top two elements of the stack, and pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.arithmetic.div", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/arithmetic.py"}, "content": {"type": ["function"], "name": ["div"], "text": ["Integer division of the top two elements of the stack. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.arithmetic.sdiv", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/arithmetic.py"}, "content": {"type": ["function"], "name": ["sdiv"], "text": ["Signed integer division of the top two elements of the stack. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.arithmetic.mod", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/arithmetic.py"}, "content": {"type": ["function"], "name": ["mod"], "text": ["Modulo remainder of the top two elements of the stack. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.arithmetic.smod", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/arithmetic.py"}, "content": {"type": ["function"], "name": ["smod"], "text": ["Signed modulo remainder of the top two elements of the stack. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.arithmetic.addmod", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/arithmetic.py"}, "content": {"type": ["function"], "name": ["addmod"], "text": ["Modulo addition of the top 2 elements with the 3rd element. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.arithmetic.mulmod", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/arithmetic.py"}, "content": {"type": ["function"], "name": ["mulmod"], "text": ["Modulo multiplication of the top 2 elements with the 3rd element. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.arithmetic.exp", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/arithmetic.py"}, "content": {"type": ["function"], "name": ["exp"], "text": ["Exponential operation of the top 2 elements. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.arithmetic.signextend", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/arithmetic.py"}, "content": {"type": ["function"], "name": ["signextend"], "text": ["Sign extend operation. In other words, extend a signed number which fits in N bytes to 32 bytes. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.control_flow", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/control_flow.py"}, "content": {"type": ["module"], "name": ["ethereum.berlin.vm.instructions.control_flow"], "text": ["Ethereum Virtual Machine (EVM) Control Flow Instructions ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementations of the EVM control flow instructions."]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.control_flow.stop", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/control_flow.py"}, "content": {"type": ["function"], "name": ["stop"], "text": ["Stop further execution of EVM code. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.control_flow.jump", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/control_flow.py"}, "content": {"type": ["function"], "name": ["jump"], "text": ["Alter the program counter to the location specified by the top of the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.control_flow.jumpi", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/control_flow.py"}, "content": {"type": ["function"], "name": ["jumpi"], "text": ["Alter the program counter to the specified location if and only if a condition is true. If the condition is not true, then the program counter would increase only by 1. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.control_flow.pc", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/control_flow.py"}, "content": {"type": ["function"], "name": ["pc"], "text": ["Push onto the stack the value of the program counter after reaching the current instruction and without increasing it for the next instruction. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.control_flow.gas_left", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/control_flow.py"}, "content": {"type": ["function"], "name": ["gas_left"], "text": ["Push the amount of available gas (including the corresponding reduction for the cost of this instruction) onto the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.control_flow.jumpdest", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/control_flow.py"}, "content": {"type": ["function"], "name": ["jumpdest"], "text": ["Mark a valid destination for jumps. This is a noop, present only to be used by  JUMP  and  JUMPI  opcodes to verify that their jump is valid. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.dao_fork.vm.gas", "specifier": 0, "path": "src/ethereum/dao_fork/vm/gas.py"}, "content": {"type": ["module"], "name": ["ethereum.dao_fork.vm.gas"], "text": ["Ethereum Virtual Machine (EVM) Gas ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction EVM gas constants and calculators."]}}, {"source": {"identifier": "ethereum.dao_fork.vm.gas.GAS_JUMPDEST", "specifier": 0, "path": "src/ethereum/dao_fork/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_JUMPDEST"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.gas.GAS_BASE", "specifier": 0, "path": "src/ethereum/dao_fork/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_BASE"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.gas.GAS_VERY_LOW", "specifier": 0, "path": "src/ethereum/dao_fork/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_VERY_LOW"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.gas.GAS_SLOAD", "specifier": 0, "path": "src/ethereum/dao_fork/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_SLOAD"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.gas.GAS_STORAGE_SET", "specifier": 0, "path": "src/ethereum/dao_fork/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_STORAGE_SET"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.gas.GAS_STORAGE_UPDATE", "specifier": 0, "path": "src/ethereum/dao_fork/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_STORAGE_UPDATE"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.gas.GAS_STORAGE_CLEAR_REFUND", "specifier": 0, "path": "src/ethereum/dao_fork/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_STORAGE_CLEAR_REFUND"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.gas.GAS_LOW", "specifier": 0, "path": "src/ethereum/dao_fork/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_LOW"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.gas.GAS_MID", "specifier": 0, "path": "src/ethereum/dao_fork/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_MID"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.gas.GAS_HIGH", "specifier": 0, "path": "src/ethereum/dao_fork/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_HIGH"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.gas.GAS_EXPONENTIATION", "specifier": 0, "path": "src/ethereum/dao_fork/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_EXPONENTIATION"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.gas.GAS_EXPONENTIATION_PER_BYTE", "specifier": 0, "path": "src/ethereum/dao_fork/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_EXPONENTIATION_PER_BYTE"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.gas.GAS_MEMORY", "specifier": 0, "path": "src/ethereum/dao_fork/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_MEMORY"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.gas.GAS_KECCAK256", "specifier": 0, "path": "src/ethereum/dao_fork/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_KECCAK256"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.gas.GAS_KECCAK256_WORD", "specifier": 0, "path": "src/ethereum/dao_fork/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_KECCAK256_WORD"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.gas.GAS_COPY", "specifier": 0, "path": "src/ethereum/dao_fork/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_COPY"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.gas.GAS_BLOCK_HASH", "specifier": 0, "path": "src/ethereum/dao_fork/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_BLOCK_HASH"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.gas.GAS_EXTERNAL", "specifier": 0, "path": "src/ethereum/dao_fork/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_EXTERNAL"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.gas.GAS_BALANCE", "specifier": 0, "path": "src/ethereum/dao_fork/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_BALANCE"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.gas.GAS_LOG", "specifier": 0, "path": "src/ethereum/dao_fork/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_LOG"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.gas.GAS_LOG_DATA", "specifier": 0, "path": "src/ethereum/dao_fork/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_LOG_DATA"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.gas.GAS_LOG_TOPIC", "specifier": 0, "path": "src/ethereum/dao_fork/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_LOG_TOPIC"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.gas.GAS_CREATE", "specifier": 0, "path": "src/ethereum/dao_fork/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_CREATE"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.gas.GAS_CODE_DEPOSIT", "specifier": 0, "path": "src/ethereum/dao_fork/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_CODE_DEPOSIT"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.gas.GAS_ZERO", "specifier": 0, "path": "src/ethereum/dao_fork/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_ZERO"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.gas.GAS_CALL", "specifier": 0, "path": "src/ethereum/dao_fork/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_CALL"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.gas.GAS_NEW_ACCOUNT", "specifier": 0, "path": "src/ethereum/dao_fork/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_NEW_ACCOUNT"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.gas.GAS_CALL_VALUE", "specifier": 0, "path": "src/ethereum/dao_fork/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_CALL_VALUE"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.gas.GAS_CALL_STIPEND", "specifier": 0, "path": "src/ethereum/dao_fork/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_CALL_STIPEND"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.gas.REFUND_SELF_DESTRUCT", "specifier": 0, "path": "src/ethereum/dao_fork/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["REFUND_SELF_DESTRUCT"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.gas.GAS_ECRECOVER", "specifier": 0, "path": "src/ethereum/dao_fork/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_ECRECOVER"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.gas.GAS_SHA256", "specifier": 0, "path": "src/ethereum/dao_fork/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_SHA256"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.gas.GAS_SHA256_WORD", "specifier": 0, "path": "src/ethereum/dao_fork/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_SHA256_WORD"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.gas.GAS_RIPEMD160", "specifier": 0, "path": "src/ethereum/dao_fork/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_RIPEMD160"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.gas.GAS_RIPEMD160_WORD", "specifier": 0, "path": "src/ethereum/dao_fork/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_RIPEMD160_WORD"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.gas.GAS_IDENTITY", "specifier": 0, "path": "src/ethereum/dao_fork/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_IDENTITY"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.gas.GAS_IDENTITY_WORD", "specifier": 0, "path": "src/ethereum/dao_fork/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_IDENTITY_WORD"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.gas.ExtendMemory", "specifier": 0, "path": "src/ethereum/dao_fork/vm/gas.py"}, "content": {"type": ["class"], "name": ["ExtendMemory"], "text": ["Define the parameters for memory extension in opcodes cost :  ethereum.base_types.Uint The gas required to perform the extension expand_by :  ethereum.base_types.Uint The size by which the memory will be extended"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.gas.ExtendMemory.cost", "specifier": 0, "path": "src/ethereum/dao_fork/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["cost"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.gas.ExtendMemory.expand_by", "specifier": 0, "path": "src/ethereum/dao_fork/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["expand_by"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.gas.MessageCallGas", "specifier": 0, "path": "src/ethereum/dao_fork/vm/gas.py"}, "content": {"type": ["class"], "name": ["MessageCallGas"], "text": ["Define the gas cost and stipend for executing the call opcodes. cost :  ethereum.base_types.Uint The non-refundable portion of gas reserved for executing the call opcode. stipend :  ethereum.base_types.Uint The portion of gas available to sub-calls that is refundable if not consumed"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.gas.MessageCallGas.cost", "specifier": 0, "path": "src/ethereum/dao_fork/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["cost"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.gas.MessageCallGas.stipend", "specifier": 0, "path": "src/ethereum/dao_fork/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["stipend"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.gas.charge_gas", "specifier": 0, "path": "src/ethereum/dao_fork/vm/gas.py"}, "content": {"type": ["function"], "name": ["charge_gas"], "text": ["Subtracts  amount  from  evm.gas_left . Parameters evm : The current EVM. amount : The amount of gas the current operation requires."]}}, {"source": {"identifier": "ethereum.dao_fork.vm.gas.calculate_memory_gas_cost", "specifier": 0, "path": "src/ethereum/dao_fork/vm/gas.py"}, "content": {"type": ["function"], "name": ["calculate_memory_gas_cost"], "text": ["Calculates the gas cost for allocating memory to the smallest multiple of 32 bytes, such that the allocated size is at least as big as the given size. Parameters size_in_bytes : The size of the data in bytes. Returns total_gas_cost :  ethereum.base_types.Uint The gas cost for storing data in memory."]}}, {"source": {"identifier": "ethereum.dao_fork.vm.gas.calculate_gas_extend_memory", "specifier": 0, "path": "src/ethereum/dao_fork/vm/gas.py"}, "content": {"type": ["function"], "name": ["calculate_gas_extend_memory"], "text": ["Calculates the gas amount to extend memory Parameters memory : Memory contents of the EVM. extensions: List of extensions to be made to the memory. Consists of a tuple of start position and size. Returns extend_memory:  ExtendMemory"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.gas.calculate_message_call_gas", "specifier": 0, "path": "src/ethereum/dao_fork/vm/gas.py"}, "content": {"type": ["function"], "name": ["calculate_message_call_gas"], "text": ["Calculates the gas amount for executing Opcodes  CALL  and  CALLCODE . Parameters state : The current state. gas : The amount of gas provided to the message-call. to: The address of the recipient account. value: The amount of  ETH  that needs to be transferred. Returns message_call_gas:  MessageCallGas"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.keccak", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/keccak.py"}, "content": {"type": ["module"], "name": ["ethereum.constantinople.vm.instructions.keccak"], "text": ["Ethereum Virtual Machine (EVM) Keccak Instructions ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementations of the EVM keccak instructions."]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.keccak.keccak", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/keccak.py"}, "content": {"type": ["function"], "name": ["keccak"], "text": ["Pushes to the stack the Keccak-256 hash of a region of memory. This also expands the memory, in case the memory is insufficient to access the data's memory location. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.comparison", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/comparison.py"}, "content": {"type": ["module"], "name": ["ethereum.berlin.vm.instructions.comparison"], "text": ["Ethereum Virtual Machine (EVM) Comparison Instructions ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementations of the EVM Comparison instructions."]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.comparison.less_than", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/comparison.py"}, "content": {"type": ["function"], "name": ["less_than"], "text": ["Checks if the top element is less than the next top element. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.comparison.signed_less_than", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/comparison.py"}, "content": {"type": ["function"], "name": ["signed_less_than"], "text": ["Signed less-than comparison. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.comparison.greater_than", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/comparison.py"}, "content": {"type": ["function"], "name": ["greater_than"], "text": ["Checks if the top element is greater than the next top element. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.comparison.signed_greater_than", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/comparison.py"}, "content": {"type": ["function"], "name": ["signed_greater_than"], "text": ["Signed greater-than comparison. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.comparison.equal", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/comparison.py"}, "content": {"type": ["function"], "name": ["equal"], "text": ["Checks if the top element is equal to the next top element. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.comparison.is_zero", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/comparison.py"}, "content": {"type": ["function"], "name": ["is_zero"], "text": ["Checks if the top element is equal to 0. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.dao_fork.vm.precompiled_contracts.mapping", "specifier": 0, "path": "src/ethereum/dao_fork/vm/precompiled_contracts/mapping.py"}, "content": {"type": ["module"], "name": ["ethereum.dao_fork.vm.precompiled_contracts.mapping"], "text": ["Precompiled Contract Addresses ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Mapping of precompiled contracts their implementations."]}}, {"source": {"identifier": "ethereum.dao_fork.vm.precompiled_contracts.mapping.PRE_COMPILED_CONTRACTS", "specifier": 0, "path": "src/ethereum/dao_fork/vm/precompiled_contracts/mapping.py"}, "content": {"type": ["attribute"], "name": ["PRE_COMPILED_CONTRACTS"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.bitwise", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/bitwise.py"}, "content": {"type": ["module"], "name": ["ethereum.constantinople.vm.instructions.bitwise"], "text": ["Ethereum Virtual Machine (EVM) Bitwise Instructions ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementations of the EVM bitwise instructions."]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.bitwise.bitwise_and", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/bitwise.py"}, "content": {"type": ["function"], "name": ["bitwise_and"], "text": ["Bitwise AND operation of the top 2 elements of the stack. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.bitwise.bitwise_or", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/bitwise.py"}, "content": {"type": ["function"], "name": ["bitwise_or"], "text": ["Bitwise OR operation of the top 2 elements of the stack. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.bitwise.bitwise_xor", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/bitwise.py"}, "content": {"type": ["function"], "name": ["bitwise_xor"], "text": ["Bitwise XOR operation of the top 2 elements of the stack. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.bitwise.bitwise_not", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/bitwise.py"}, "content": {"type": ["function"], "name": ["bitwise_not"], "text": ["Bitwise NOT operation of the top element of the stack. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.bitwise.get_byte", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/bitwise.py"}, "content": {"type": ["function"], "name": ["get_byte"], "text": ["For a word (defined by next top element of the stack), retrieve the Nth byte (0-indexed and defined by top element of stack) from the left (most significant) to right (least significant). Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.bitwise.bitwise_shl", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/bitwise.py"}, "content": {"type": ["function"], "name": ["bitwise_shl"], "text": ["Logical shift left (SHL) operation of the top 2 elements of the stack. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.bitwise.bitwise_shr", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/bitwise.py"}, "content": {"type": ["function"], "name": ["bitwise_shr"], "text": ["Logical shift right (SHR) operation of the top 2 elements of the stack. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.bitwise.bitwise_sar", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/bitwise.py"}, "content": {"type": ["function"], "name": ["bitwise_sar"], "text": ["Arithmetic shift right (SAR) operation of the top 2 elements of the stack. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.log", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/log.py"}, "content": {"type": ["module"], "name": ["ethereum.berlin.vm.instructions.log"], "text": ["Ethereum Virtual Machine (EVM) Logging Instructions ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementations of the EVM logging instructions."]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.log.log_n", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/log.py"}, "content": {"type": ["function"], "name": ["log_n"], "text": ["Appends a log entry, having  num_topics  topics, to the evm logs. This will also expand the memory if the data (required by the log entry) corresponding to the memory is not accessible. Parameters evm : The current EVM frame. num_topics : The number of topics to be included in the log entry."]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.log.log0", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/log.py"}, "content": {"type": ["attribute"], "name": ["log0"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.log.log1", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/log.py"}, "content": {"type": ["attribute"], "name": ["log1"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.log.log2", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/log.py"}, "content": {"type": ["attribute"], "name": ["log2"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.log.log3", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/log.py"}, "content": {"type": ["attribute"], "name": ["log3"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.log.log4", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/log.py"}, "content": {"type": ["attribute"], "name": ["log4"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.precompiled_contracts", "specifier": 0, "path": "src/ethereum/dao_fork/vm/precompiled_contracts/__init__.py"}, "content": {"type": ["module"], "name": ["ethereum.dao_fork.vm.precompiled_contracts"], "text": ["Precompiled Contract Addresses ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Addresses of precompiled contracts and mappings to their implementations."]}}, {"source": {"identifier": "ethereum.dao_fork.vm.precompiled_contracts.__all__", "specifier": 0, "path": "src/ethereum/dao_fork/vm/precompiled_contracts/__init__.py"}, "content": {"type": ["attribute"], "name": ["__all__"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.precompiled_contracts.ECRECOVER_ADDRESS", "specifier": 0, "path": "src/ethereum/dao_fork/vm/precompiled_contracts/__init__.py"}, "content": {"type": ["attribute"], "name": ["ECRECOVER_ADDRESS"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.precompiled_contracts.SHA256_ADDRESS", "specifier": 0, "path": "src/ethereum/dao_fork/vm/precompiled_contracts/__init__.py"}, "content": {"type": ["attribute"], "name": ["SHA256_ADDRESS"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.precompiled_contracts.RIPEMD160_ADDRESS", "specifier": 0, "path": "src/ethereum/dao_fork/vm/precompiled_contracts/__init__.py"}, "content": {"type": ["attribute"], "name": ["RIPEMD160_ADDRESS"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.precompiled_contracts.IDENTITY_ADDRESS", "specifier": 0, "path": "src/ethereum/dao_fork/vm/precompiled_contracts/__init__.py"}, "content": {"type": ["attribute"], "name": ["IDENTITY_ADDRESS"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.environment", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/environment.py"}, "content": {"type": ["module"], "name": ["ethereum.constantinople.vm.instructions.environment"], "text": ["Ethereum Virtual Machine (EVM) Environmental Instructions ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementations of the EVM environment related instructions."]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.environment.address", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["address"], "text": ["Pushes the address of the current executing account to the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.environment.balance", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["balance"], "text": ["Pushes the balance of the given account onto the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.environment.origin", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["origin"], "text": ["Pushes the address of the original transaction sender to the stack. The origin address can only be an EOA. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.environment.caller", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["caller"], "text": ["Pushes the address of the caller onto the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.environment.callvalue", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["callvalue"], "text": ["Push the value (in wei) sent with the call onto the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.environment.calldataload", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["calldataload"], "text": ["Push a word (32 bytes) of the input data belonging to the current environment onto the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.environment.calldatasize", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["calldatasize"], "text": ["Push the size of input data in current environment onto the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.environment.calldatacopy", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["calldatacopy"], "text": ["Copy a portion of the input data in current environment to memory. This will also expand the memory, in case that the memory is insufficient to store the data. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.environment.codesize", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["codesize"], "text": ["Push the size of code running in current environment onto the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.environment.codecopy", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["codecopy"], "text": ["Copy a portion of the code in current environment to memory. This will also expand the memory, in case that the memory is insufficient to store the data. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.environment.gasprice", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["gasprice"], "text": ["Push the gas price used in current environment onto the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.environment.extcodesize", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["extcodesize"], "text": ["Push the code size of a given account onto the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.environment.extcodecopy", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["extcodecopy"], "text": ["Copy a portion of an account's code to memory. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.environment.returndatasize", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["returndatasize"], "text": ["Pushes the size of the return data buffer onto the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.environment.returndatacopy", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["returndatacopy"], "text": ["Copies data from the return data buffer code to memory Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.environment.extcodehash", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["extcodehash"], "text": ["Returns the keccak256 hash of a contract\u2019s bytecode Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.storage", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/storage.py"}, "content": {"type": ["module"], "name": ["ethereum.berlin.vm.instructions.storage"], "text": ["Ethereum Virtual Machine (EVM) Storage Instructions ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementations of the EVM storage related instructions."]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.storage.sload", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/storage.py"}, "content": {"type": ["function"], "name": ["sload"], "text": ["Loads to the stack, the value corresponding to a certain key from the storage of the current account. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.storage.sstore", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/storage.py"}, "content": {"type": ["function"], "name": ["sstore"], "text": ["Stores a value at a certain key in the current context's storage. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.dao_fork.vm.precompiled_contracts.ripemd160", "specifier": 0, "path": "src/ethereum/dao_fork/vm/precompiled_contracts/ripemd160.py"}, "content": {"type": ["module"], "name": ["ethereum.dao_fork.vm.precompiled_contracts.ripemd160"], "text": ["Ethereum Virtual Machine (EVM) RIPEMD160 PRECOMPILED CONTRACT ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementation of the  RIPEMD160  precompiled contract."]}}, {"source": {"identifier": "ethereum.dao_fork.vm.precompiled_contracts.ripemd160.ripemd160", "specifier": 0, "path": "src/ethereum/dao_fork/vm/precompiled_contracts/ripemd160.py"}, "content": {"type": ["function"], "name": ["ripemd160"], "text": ["Writes the ripemd160 hash to output. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.block", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/block.py"}, "content": {"type": ["module"], "name": ["ethereum.berlin.vm.instructions.block"], "text": ["Ethereum Virtual Machine (EVM) Block Instructions ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementations of the EVM block instructions."]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.block.block_hash", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/block.py"}, "content": {"type": ["function"], "name": ["block_hash"], "text": ["Push the hash of one of the 256 most recent complete blocks onto the stack. The block number to hash is present at the top of the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.block.coinbase", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/block.py"}, "content": {"type": ["function"], "name": ["coinbase"], "text": ["Push the current block's beneficiary address (address of the block miner) onto the stack. Here the current block refers to the block in which the currently executing transaction/call resides. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.block.timestamp", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/block.py"}, "content": {"type": ["function"], "name": ["timestamp"], "text": ["Push the current block's timestamp onto the stack. Here the timestamp being referred is actually the unix timestamp in seconds. Here the current block refers to the block in which the currently executing transaction/call resides. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.block.number", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/block.py"}, "content": {"type": ["function"], "name": ["number"], "text": ["Push the current block's number onto the stack. Here the current block refers to the block in which the currently executing transaction/call resides. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.block.difficulty", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/block.py"}, "content": {"type": ["function"], "name": ["difficulty"], "text": ["Push the current block's difficulty onto the stack. Here the current block refers to the block in which the currently executing transaction/call resides. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.block.gas_limit", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/block.py"}, "content": {"type": ["function"], "name": ["gas_limit"], "text": ["Push the current block's gas limit onto the stack. Here the current block refers to the block in which the currently executing transaction/call resides. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.block.chain_id", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/block.py"}, "content": {"type": ["function"], "name": ["chain_id"], "text": ["Push the chain id onto the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.stack", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/stack.py"}, "content": {"type": ["module"], "name": ["ethereum.constantinople.vm.instructions.stack"], "text": ["Ethereum Virtual Machine (EVM) Stack Instructions ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementations of the EVM stack related instructions."]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.stack.pop", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/stack.py"}, "content": {"type": ["function"], "name": ["pop"], "text": ["Remove item from stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.stack.push_n", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/stack.py"}, "content": {"type": ["function"], "name": ["push_n"], "text": ["Pushes a N-byte immediate onto the stack. Parameters evm : The current EVM frame. num_bytes : The number of immediate bytes to be read from the code and pushed to the stack."]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.stack.dup_n", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/stack.py"}, "content": {"type": ["function"], "name": ["dup_n"], "text": ["Duplicate the Nth stack item (from top of the stack) to the top of stack. Parameters evm : The current EVM frame. item_number : The stack item number (0-indexed from top of stack) to be duplicated to the top of stack."]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.stack.swap_n", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/stack.py"}, "content": {"type": ["function"], "name": ["swap_n"], "text": ["Swap the top and the  item_number  element of the stack, where the top of the stack is position zero. If  item_number  is zero, this function does nothing (which should not be possible, since there is no  SWAP0  instruction). Parameters evm : The current EVM frame. item_number : The stack item number (0-indexed from top of stack) to be swapped with the top of stack element."]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.stack.push1", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push1"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.stack.push2", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push2"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.stack.push3", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push3"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.stack.push4", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push4"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.stack.push5", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push5"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.stack.push6", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push6"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.stack.push7", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push7"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.stack.push8", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push8"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.stack.push9", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push9"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.stack.push10", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push10"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.stack.push11", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push11"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.stack.push12", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push12"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.stack.push13", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push13"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.stack.push14", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push14"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.stack.push15", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push15"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.stack.push16", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push16"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.stack.push17", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push17"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.stack.push18", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push18"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.stack.push19", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push19"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.stack.push20", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push20"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.stack.push21", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push21"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.stack.push22", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push22"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.stack.push23", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push23"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.stack.push24", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push24"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.stack.push25", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push25"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.stack.push26", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push26"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.stack.push27", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push27"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.stack.push28", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push28"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.stack.push29", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push29"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.stack.push30", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push30"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.stack.push31", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push31"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.stack.push32", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push32"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.stack.dup1", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup1"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.stack.dup2", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup2"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.stack.dup3", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup3"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.stack.dup4", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup4"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.stack.dup5", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup5"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.stack.dup6", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup6"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.stack.dup7", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup7"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.stack.dup8", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup8"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.stack.dup9", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup9"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.stack.dup10", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup10"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.stack.dup11", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup11"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.stack.dup12", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup12"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.stack.dup13", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup13"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.stack.dup14", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup14"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.stack.dup15", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup15"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.stack.dup16", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup16"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.stack.swap1", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap1"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.stack.swap2", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap2"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.stack.swap3", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap3"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.stack.swap4", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap4"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.stack.swap5", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap5"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.stack.swap6", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap6"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.stack.swap7", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap7"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.stack.swap8", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap8"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.stack.swap9", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap9"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.stack.swap10", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap10"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.stack.swap11", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap11"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.stack.swap12", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap12"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.stack.swap13", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap13"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.stack.swap14", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap14"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.stack.swap15", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap15"]}}, {"source": {"identifier": "ethereum.constantinople.vm.instructions.stack.swap16", "specifier": 0, "path": "src/ethereum/constantinople/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap16"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.precompiled_contracts.sha256", "specifier": 0, "path": "src/ethereum/dao_fork/vm/precompiled_contracts/sha256.py"}, "content": {"type": ["module"], "name": ["ethereum.dao_fork.vm.precompiled_contracts.sha256"], "text": ["Ethereum Virtual Machine (EVM) SHA256 PRECOMPILED CONTRACT ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementation of the  SHA256  precompiled contract."]}}, {"source": {"identifier": "ethereum.dao_fork.vm.precompiled_contracts.sha256.sha256", "specifier": 0, "path": "src/ethereum/dao_fork/vm/precompiled_contracts/sha256.py"}, "content": {"type": ["function"], "name": ["sha256"], "text": ["Writes the sha256 hash to output. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.arithmetic", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/arithmetic.py"}, "content": {"type": ["module"], "name": ["ethereum.berlin.vm.instructions.arithmetic"], "text": ["Ethereum Virtual Machine (EVM) Arithmetic Instructions ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementations of the EVM Arithmetic instructions."]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.arithmetic.add", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/arithmetic.py"}, "content": {"type": ["function"], "name": ["add"], "text": ["Adds the top two elements of the stack together, and pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.arithmetic.sub", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/arithmetic.py"}, "content": {"type": ["function"], "name": ["sub"], "text": ["Subtracts the top two elements of the stack, and pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.arithmetic.mul", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/arithmetic.py"}, "content": {"type": ["function"], "name": ["mul"], "text": ["Multiply the top two elements of the stack, and pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.arithmetic.div", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/arithmetic.py"}, "content": {"type": ["function"], "name": ["div"], "text": ["Integer division of the top two elements of the stack. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.arithmetic.sdiv", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/arithmetic.py"}, "content": {"type": ["function"], "name": ["sdiv"], "text": ["Signed integer division of the top two elements of the stack. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.arithmetic.mod", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/arithmetic.py"}, "content": {"type": ["function"], "name": ["mod"], "text": ["Modulo remainder of the top two elements of the stack. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.arithmetic.smod", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/arithmetic.py"}, "content": {"type": ["function"], "name": ["smod"], "text": ["Signed modulo remainder of the top two elements of the stack. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.arithmetic.addmod", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/arithmetic.py"}, "content": {"type": ["function"], "name": ["addmod"], "text": ["Modulo addition of the top 2 elements with the 3rd element. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.arithmetic.mulmod", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/arithmetic.py"}, "content": {"type": ["function"], "name": ["mulmod"], "text": ["Modulo multiplication of the top 2 elements with the 3rd element. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.arithmetic.exp", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/arithmetic.py"}, "content": {"type": ["function"], "name": ["exp"], "text": ["Exponential operation of the top 2 elements. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.arithmetic.signextend", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/arithmetic.py"}, "content": {"type": ["function"], "name": ["signextend"], "text": ["Sign extend operation. In other words, extend a signed number which fits in N bytes to 32 bytes. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.constantinople.utils", "specifier": 0, "path": "src/ethereum/constantinople/utils/__init__.py"}, "content": {"type": ["module"], "name": ["ethereum.constantinople.utils"], "text": ["Hardfork Utility Functions ^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Utility functions used in this constantinople version of specification."]}}, {"source": {"identifier": "ethereum.dao_fork.vm.precompiled_contracts.ecrecover", "specifier": 0, "path": "src/ethereum/dao_fork/vm/precompiled_contracts/ecrecover.py"}, "content": {"type": ["module"], "name": ["ethereum.dao_fork.vm.precompiled_contracts.ecrecover"], "text": ["Ethereum Virtual Machine (EVM) ECRECOVER PRECOMPILED CONTRACT ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementation of the ECRECOVER precompiled contract."]}}, {"source": {"identifier": "ethereum.dao_fork.vm.precompiled_contracts.ecrecover.ecrecover", "specifier": 0, "path": "src/ethereum/dao_fork/vm/precompiled_contracts/ecrecover.py"}, "content": {"type": ["function"], "name": ["ecrecover"], "text": ["Decrypts the address using elliptic curve DSA recovery mechanism and writes the address to output. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.keccak", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/keccak.py"}, "content": {"type": ["module"], "name": ["ethereum.berlin.vm.instructions.keccak"], "text": ["Ethereum Virtual Machine (EVM) Keccak Instructions ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementations of the EVM keccak instructions."]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.keccak.keccak", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/keccak.py"}, "content": {"type": ["function"], "name": ["keccak"], "text": ["Pushes to the stack the Keccak-256 hash of a region of memory. This also expands the memory, in case the memory is insufficient to access the data's memory location. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.constantinople.utils.address", "specifier": 0, "path": "src/ethereum/constantinople/utils/address.py"}, "content": {"type": ["module"], "name": ["ethereum.constantinople.utils.address"], "text": ["Hardfork Utility Functions For Addresses ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Address specific functions used in this constantinople version of specification."]}}, {"source": {"identifier": "ethereum.constantinople.utils.address.to_address", "specifier": 0, "path": "src/ethereum/constantinople/utils/address.py"}, "content": {"type": ["function"], "name": ["to_address"], "text": ["Convert a Uint or U256 value to a valid address (20 bytes). Parameters data : The string to be converted to bytes. Returns address :  Address The obtained address."]}}, {"source": {"identifier": "ethereum.constantinople.utils.address.compute_contract_address", "specifier": 0, "path": "src/ethereum/constantinople/utils/address.py"}, "content": {"type": ["function"], "name": ["compute_contract_address"], "text": ["Computes address of the new account that needs to be created. Parameters address : The address of the account that wants to create the new account. nonce : The transaction count of the account that wants to create the new account. Returns address:  Address The computed address of the new account."]}}, {"source": {"identifier": "ethereum.constantinople.utils.address.compute_create2_contract_address", "specifier": 0, "path": "src/ethereum/constantinople/utils/address.py"}, "content": {"type": ["function"], "name": ["compute_create2_contract_address"], "text": ["Computes address of the new account that needs to be created, which is based on the sender address, salt and the call data as well. Parameters address : The address of the account that wants to create the new account. salt : Address generation salt. call_data : The code of the new account which is to be created. Returns address:  ethereum.constantinople.fork_types.Address The computed address of the new account."]}}, {"source": {"identifier": "ethereum.dao_fork.vm.precompiled_contracts.identity", "specifier": 0, "path": "src/ethereum/dao_fork/vm/precompiled_contracts/identity.py"}, "content": {"type": ["module"], "name": ["ethereum.dao_fork.vm.precompiled_contracts.identity"], "text": ["Ethereum Virtual Machine (EVM) IDENTITY PRECOMPILED CONTRACT ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementation of the  IDENTITY  precompiled contract."]}}, {"source": {"identifier": "ethereum.dao_fork.vm.precompiled_contracts.identity.identity", "specifier": 0, "path": "src/ethereum/dao_fork/vm/precompiled_contracts/identity.py"}, "content": {"type": ["function"], "name": ["identity"], "text": ["Writes the message data to output. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.bitwise", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/bitwise.py"}, "content": {"type": ["module"], "name": ["ethereum.berlin.vm.instructions.bitwise"], "text": ["Ethereum Virtual Machine (EVM) Bitwise Instructions ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementations of the EVM bitwise instructions."]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.bitwise.bitwise_and", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/bitwise.py"}, "content": {"type": ["function"], "name": ["bitwise_and"], "text": ["Bitwise AND operation of the top 2 elements of the stack. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.bitwise.bitwise_or", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/bitwise.py"}, "content": {"type": ["function"], "name": ["bitwise_or"], "text": ["Bitwise OR operation of the top 2 elements of the stack. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.bitwise.bitwise_xor", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/bitwise.py"}, "content": {"type": ["function"], "name": ["bitwise_xor"], "text": ["Bitwise XOR operation of the top 2 elements of the stack. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.bitwise.bitwise_not", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/bitwise.py"}, "content": {"type": ["function"], "name": ["bitwise_not"], "text": ["Bitwise NOT operation of the top element of the stack. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.bitwise.get_byte", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/bitwise.py"}, "content": {"type": ["function"], "name": ["get_byte"], "text": ["For a word (defined by next top element of the stack), retrieve the Nth byte (0-indexed and defined by top element of stack) from the left (most significant) to right (least significant). Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.bitwise.bitwise_shl", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/bitwise.py"}, "content": {"type": ["function"], "name": ["bitwise_shl"], "text": ["Logical shift left (SHL) operation of the top 2 elements of the stack. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.bitwise.bitwise_shr", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/bitwise.py"}, "content": {"type": ["function"], "name": ["bitwise_shr"], "text": ["Logical shift right (SHR) operation of the top 2 elements of the stack. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.bitwise.bitwise_sar", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/bitwise.py"}, "content": {"type": ["function"], "name": ["bitwise_sar"], "text": ["Arithmetic shift right (SAR) operation of the top 2 elements of the stack. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.constantinople.utils.message", "specifier": 0, "path": "src/ethereum/constantinople/utils/message.py"}, "content": {"type": ["module"], "name": ["ethereum.constantinople.utils.message"], "text": ["Hardfork Utility Functions For The Message Data-structure ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Message specific functions used in this constantinople version of specification."]}}, {"source": {"identifier": "ethereum.constantinople.utils.message.prepare_message", "specifier": 0, "path": "src/ethereum/constantinople/utils/message.py"}, "content": {"type": ["function"], "name": ["prepare_message"], "text": ["Execute a transaction against the provided environment. Parameters caller : Address which initiated the transaction target : Address whose code will be executed value : Value to be transferred. data : Array of bytes provided to the code in  target . gas : Gas provided for the code in  target . env : Environment for the Ethereum Virtual Machine. code_address : This is usually same as the  target  address except when an alternative accounts code needs to be executed. eg.  CALLCODE  calling a precompile. should_transfer_value : if True ETH should be transferred while executing a message call. is_static: if True then it prevents all state-changing operations from being executed. Returns message:  ethereum.constantinople.vm.Message Items containing contract creation or message call specific data."]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.memory", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/memory.py"}, "content": {"type": ["module"], "name": ["ethereum.dao_fork.vm.instructions.memory"], "text": ["Ethereum Virtual Machine (EVM) Memory Instructions ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementations of the EVM Memory instructions."]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.memory.mstore", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/memory.py"}, "content": {"type": ["function"], "name": ["mstore"], "text": ["Stores a word to memory. This also expands the memory, if the memory is insufficient to store the word. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.memory.mstore8", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/memory.py"}, "content": {"type": ["function"], "name": ["mstore8"], "text": ["Stores a byte to memory. This also expands the memory, if the memory is insufficient to store the word. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.memory.mload", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/memory.py"}, "content": {"type": ["function"], "name": ["mload"], "text": ["Load word from memory. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.memory.msize", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/memory.py"}, "content": {"type": ["function"], "name": ["msize"], "text": ["Push the size of active memory in bytes onto the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.environment", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/environment.py"}, "content": {"type": ["module"], "name": ["ethereum.berlin.vm.instructions.environment"], "text": ["Ethereum Virtual Machine (EVM) Environmental Instructions ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementations of the EVM environment related instructions."]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.environment.address", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["address"], "text": ["Pushes the address of the current executing account to the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.environment.balance", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["balance"], "text": ["Pushes the balance of the given account onto the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.environment.origin", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["origin"], "text": ["Pushes the address of the original transaction sender to the stack. The origin address can only be an EOA. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.environment.caller", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["caller"], "text": ["Pushes the address of the caller onto the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.environment.callvalue", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["callvalue"], "text": ["Push the value (in wei) sent with the call onto the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.environment.calldataload", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["calldataload"], "text": ["Push a word (32 bytes) of the input data belonging to the current environment onto the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.environment.calldatasize", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["calldatasize"], "text": ["Push the size of input data in current environment onto the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.environment.calldatacopy", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["calldatacopy"], "text": ["Copy a portion of the input data in current environment to memory. This will also expand the memory, in case that the memory is insufficient to store the data. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.environment.codesize", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["codesize"], "text": ["Push the size of code running in current environment onto the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.environment.codecopy", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["codecopy"], "text": ["Copy a portion of the code in current environment to memory. This will also expand the memory, in case that the memory is insufficient to store the data. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.environment.gasprice", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["gasprice"], "text": ["Push the gas price used in current environment onto the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.environment.extcodesize", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["extcodesize"], "text": ["Push the code size of a given account onto the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.environment.extcodecopy", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["extcodecopy"], "text": ["Copy a portion of an account's code to memory. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.environment.returndatasize", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["returndatasize"], "text": ["Pushes the size of the return data buffer onto the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.environment.returndatacopy", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["returndatacopy"], "text": ["Copies data from the return data buffer code to memory Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.environment.extcodehash", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["extcodehash"], "text": ["Returns the keccak256 hash of a contract\u2019s bytecode Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.environment.self_balance", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["self_balance"], "text": ["Pushes the balance of the current address to the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.constantinople.utils.hexadecimal", "specifier": 0, "path": "src/ethereum/constantinople/utils/hexadecimal.py"}, "content": {"type": ["module"], "name": ["ethereum.constantinople.utils.hexadecimal"], "text": ["Utility Functions For Hexadecimal Strings ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Hexadecimal utility functions used in this specification, specific to Constantinople types."]}}, {"source": {"identifier": "ethereum.constantinople.utils.hexadecimal.hex_to_root", "specifier": 0, "path": "src/ethereum/constantinople/utils/hexadecimal.py"}, "content": {"type": ["function"], "name": ["hex_to_root"], "text": ["Convert hex string to trie root. Parameters hex_string : The hexadecimal string to be converted to trie root. Returns root :  Root Trie root obtained from the given hexadecimal string."]}}, {"source": {"identifier": "ethereum.constantinople.utils.hexadecimal.hex_to_bloom", "specifier": 0, "path": "src/ethereum/constantinople/utils/hexadecimal.py"}, "content": {"type": ["function"], "name": ["hex_to_bloom"], "text": ["Convert hex string to bloom. Parameters hex_string : The hexadecimal string to be converted to bloom. Returns bloom :  Bloom Bloom obtained from the given hexadecimal string."]}}, {"source": {"identifier": "ethereum.constantinople.utils.hexadecimal.hex_to_address", "specifier": 0, "path": "src/ethereum/constantinople/utils/hexadecimal.py"}, "content": {"type": ["function"], "name": ["hex_to_address"], "text": ["Convert hex string to Address (20 bytes). Parameters hex_string : The hexadecimal string to be converted to Address. Returns address :  Address The address obtained from the given hexadecimal string."]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.system", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/system.py"}, "content": {"type": ["module"], "name": ["ethereum.dao_fork.vm.instructions.system"], "text": ["Ethereum Virtual Machine (EVM) System Instructions ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementations of the EVM system related instructions."]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.system.create", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/system.py"}, "content": {"type": ["function"], "name": ["create"], "text": ["Creates a new account with associated code. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.system.return_", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/system.py"}, "content": {"type": ["function"], "name": ["return_"], "text": ["Halts execution returning output data. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.system.generic_call", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/system.py"}, "content": {"type": ["function"], "name": ["generic_call"], "text": ["Perform the core logic of the  CALL*  family of opcodes."]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.system.call", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/system.py"}, "content": {"type": ["function"], "name": ["call"], "text": ["Message-call into an account. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.system.callcode", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/system.py"}, "content": {"type": ["function"], "name": ["callcode"], "text": ["Message-call into this account with alternative account\u2019s code. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.system.selfdestruct", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/system.py"}, "content": {"type": ["function"], "name": ["selfdestruct"], "text": ["Halt execution and register account for later deletion. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.system.delegatecall", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/system.py"}, "content": {"type": ["function"], "name": ["delegatecall"], "text": ["Message-call into an account. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.shanghai.state", "specifier": 0, "path": "src/ethereum/shanghai/state.py"}, "content": {"type": ["module"], "name": ["ethereum.shanghai.state"], "text": ["State ^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction The state contains all information that is preserved between transactions. It consists of a main account trie and storage tries for each contract. There is a distinction between an account that does not exist and EMPTY_ACCOUNT ."]}}, {"source": {"identifier": "ethereum.shanghai.state.State", "specifier": 0, "path": "src/ethereum/shanghai/state.py"}, "content": {"type": ["class"], "name": ["State"], "text": ["Contains all information that is preserved between transactions."]}}, {"source": {"identifier": "ethereum.shanghai.state.State._main_trie", "specifier": 0, "path": "src/ethereum/shanghai/state.py"}, "content": {"type": ["attribute"], "name": ["_main_trie"]}}, {"source": {"identifier": "ethereum.shanghai.state.State._storage_tries", "specifier": 0, "path": "src/ethereum/shanghai/state.py"}, "content": {"type": ["attribute"], "name": ["_storage_tries"]}}, {"source": {"identifier": "ethereum.shanghai.state.State._snapshots", "specifier": 0, "path": "src/ethereum/shanghai/state.py"}, "content": {"type": ["attribute"], "name": ["_snapshots"]}}, {"source": {"identifier": "ethereum.shanghai.state.close_state", "specifier": 0, "path": "src/ethereum/shanghai/state.py"}, "content": {"type": ["function"], "name": ["close_state"], "text": ["Free resources held by the state. Used by optimized implementations to release file descriptors."]}}, {"source": {"identifier": "ethereum.shanghai.state.begin_transaction", "specifier": 0, "path": "src/ethereum/shanghai/state.py"}, "content": {"type": ["function"], "name": ["begin_transaction"], "text": ["Start a state transaction. Transactions are entirely implicit and can be nested. It is not possible to calculate the state root during a transaction. Parameters state : State The state."]}}, {"source": {"identifier": "ethereum.shanghai.state.commit_transaction", "specifier": 0, "path": "src/ethereum/shanghai/state.py"}, "content": {"type": ["function"], "name": ["commit_transaction"], "text": ["Commit a state transaction. Parameters state : State The state."]}}, {"source": {"identifier": "ethereum.shanghai.state.rollback_transaction", "specifier": 0, "path": "src/ethereum/shanghai/state.py"}, "content": {"type": ["function"], "name": ["rollback_transaction"], "text": ["Rollback a state transaction, resetting the state to the point when the corresponding  start_transaction()  call was made. Parameters state : State The state."]}}, {"source": {"identifier": "ethereum.shanghai.state.get_account", "specifier": 0, "path": "src/ethereum/shanghai/state.py"}, "content": {"type": ["function"], "name": ["get_account"], "text": ["Get the  Account  object at an address. Returns  EMPTY_ACCOUNT  if there is no account at the address. Use  get_account_optional()  if you care about the difference between a non-existent account and  EMPTY_ACCOUNT . Parameters state:  State The state address :  Address Address to lookup. Returns account :  Account Account at address."]}}, {"source": {"identifier": "ethereum.shanghai.state.get_account_optional", "specifier": 0, "path": "src/ethereum/shanghai/state.py"}, "content": {"type": ["function"], "name": ["get_account_optional"], "text": ["Get the  Account  object at an address. Returns  None  (rather than EMPTY_ACCOUNT ) if there is no account at the address. Parameters state:  State The state address :  Address Address to lookup. Returns account :  Account Account at address."]}}, {"source": {"identifier": "ethereum.shanghai.state.set_account", "specifier": 0, "path": "src/ethereum/shanghai/state.py"}, "content": {"type": ["function"], "name": ["set_account"], "text": ["Set the  Account  object at an address. Setting to  None  deletes the account (but not its storage, see  destroy_account() ). Parameters state:  State The state address :  Address Address to set. account :  Account Account to set at address."]}}, {"source": {"identifier": "ethereum.shanghai.state.destroy_account", "specifier": 0, "path": "src/ethereum/shanghai/state.py"}, "content": {"type": ["function"], "name": ["destroy_account"], "text": ["Completely remove the account at  address  and all of its storage. This function is made available exclusively for the  SELFDESTRUCT opcode. It is expected that  SELFDESTRUCT  will be disabled in a future hardfork and this function will be removed. Parameters state:  State The state address :  Address Address of account to destroy."]}}, {"source": {"identifier": "ethereum.shanghai.state.destroy_storage", "specifier": 0, "path": "src/ethereum/shanghai/state.py"}, "content": {"type": ["function"], "name": ["destroy_storage"], "text": ["Completely remove the storage at  address . Parameters state:  State The state address :  Address Address of account whose storage is to be deleted."]}}, {"source": {"identifier": "ethereum.shanghai.state.get_storage", "specifier": 0, "path": "src/ethereum/shanghai/state.py"}, "content": {"type": ["function"], "name": ["get_storage"], "text": ["Get a value at a storage key on an account. Returns  U256(0)  if the storage key has not been set previously. Parameters state:  State The state address :  Address Address of the account. key :  Bytes Key to lookup. Returns value :  U256 Value at the key."]}}, {"source": {"identifier": "ethereum.shanghai.state.set_storage", "specifier": 0, "path": "src/ethereum/shanghai/state.py"}, "content": {"type": ["function"], "name": ["set_storage"], "text": ["Set a value at a storage key on an account. Setting to  U256(0)  deletes the key. Parameters state:  State The state address :  Address Address of the account. key :  Bytes Key to set. value :  U256 Value to set at the key."]}}, {"source": {"identifier": "ethereum.shanghai.state.storage_root", "specifier": 0, "path": "src/ethereum/shanghai/state.py"}, "content": {"type": ["function"], "name": ["storage_root"], "text": ["Calculate the storage root of an account. Parameters state: The state address : Address of the account. Returns root :  Root Storage root of the account."]}}, {"source": {"identifier": "ethereum.shanghai.state.state_root", "specifier": 0, "path": "src/ethereum/shanghai/state.py"}, "content": {"type": ["function"], "name": ["state_root"], "text": ["Calculate the state root. Parameters state: The current state. Returns root :  Root The state root."]}}, {"source": {"identifier": "ethereum.shanghai.state.account_exists", "specifier": 0, "path": "src/ethereum/shanghai/state.py"}, "content": {"type": ["function"], "name": ["account_exists"], "text": ["Checks if an account exists in the state trie Parameters state: The state address: Address of the account that needs to be checked. Returns account_exists :  bool True if account exists in the state trie, False otherwise"]}}, {"source": {"identifier": "ethereum.shanghai.state.account_has_code_or_nonce", "specifier": 0, "path": "src/ethereum/shanghai/state.py"}, "content": {"type": ["function"], "name": ["account_has_code_or_nonce"], "text": ["Checks if an account has non zero nonce or non empty code Parameters state: The state address: Address of the account that needs to be checked. Returns has_code_or_nonce :  bool True if if an account has non zero nonce or non empty code, False otherwise."]}}, {"source": {"identifier": "ethereum.shanghai.state.is_account_empty", "specifier": 0, "path": "src/ethereum/shanghai/state.py"}, "content": {"type": ["function"], "name": ["is_account_empty"], "text": ["Checks if an account has zero nonce, empty code and zero balance. Parameters state: The state address: Address of the account that needs to be checked. Returns is_empty :  bool True if if an account has zero nonce, empty code and zero balance, False otherwise."]}}, {"source": {"identifier": "ethereum.shanghai.state.account_exists_and_is_empty", "specifier": 0, "path": "src/ethereum/shanghai/state.py"}, "content": {"type": ["function"], "name": ["account_exists_and_is_empty"], "text": ["Checks if an account exists and has zero nonce, empty code and zero balance. Parameters state: The state address: Address of the account that needs to be checked. Returns exists_and_is_empty :  bool True if an account exists and has zero nonce, empty code and zero balance, False otherwise."]}}, {"source": {"identifier": "ethereum.shanghai.state.is_account_alive", "specifier": 0, "path": "src/ethereum/shanghai/state.py"}, "content": {"type": ["function"], "name": ["is_account_alive"], "text": ["Check whether is an account is both in the state and non empty. Parameters state: The state address: Address of the account that needs to be checked. Returns is_alive :  bool True if the account is alive."]}}, {"source": {"identifier": "ethereum.shanghai.state.modify_state", "specifier": 0, "path": "src/ethereum/shanghai/state.py"}, "content": {"type": ["function"], "name": ["modify_state"], "text": ["Modify an  Account  in the  State ."]}}, {"source": {"identifier": "ethereum.shanghai.state.move_ether", "specifier": 0, "path": "src/ethereum/shanghai/state.py"}, "content": {"type": ["function"], "name": ["move_ether"], "text": ["Move funds between accounts."]}}, {"source": {"identifier": "ethereum.shanghai.state.process_withdrawal", "specifier": 0, "path": "src/ethereum/shanghai/state.py"}, "content": {"type": ["function"], "name": ["process_withdrawal"], "text": ["Increase the balance of the withdrawing account."]}}, {"source": {"identifier": "ethereum.shanghai.state.set_account_balance", "specifier": 0, "path": "src/ethereum/shanghai/state.py"}, "content": {"type": ["function"], "name": ["set_account_balance"], "text": ["Sets the balance of an account. Parameters state: The current state. address: Address of the account whose nonce needs to be incremented. amount: The amount that needs to set in balance."]}}, {"source": {"identifier": "ethereum.shanghai.state.touch_account", "specifier": 0, "path": "src/ethereum/shanghai/state.py"}, "content": {"type": ["function"], "name": ["touch_account"], "text": ["Initializes an account to state. Parameters state: The current state. address: The address of the account that need to initialised."]}}, {"source": {"identifier": "ethereum.shanghai.state.increment_nonce", "specifier": 0, "path": "src/ethereum/shanghai/state.py"}, "content": {"type": ["function"], "name": ["increment_nonce"], "text": ["Increments the nonce of an account. Parameters state: The current state. address: Address of the account whose nonce needs to be incremented."]}}, {"source": {"identifier": "ethereum.shanghai.state.set_code", "specifier": 0, "path": "src/ethereum/shanghai/state.py"}, "content": {"type": ["function"], "name": ["set_code"], "text": ["Sets Account code. Parameters state: The current state. address: Address of the account whose code needs to be update. code: The bytecode that needs to be set."]}}, {"source": {"identifier": "ethereum.shanghai.state.get_storage_original", "specifier": 0, "path": "src/ethereum/shanghai/state.py"}, "content": {"type": ["function"], "name": ["get_storage_original"], "text": ["Get the original value in a storage slot i.e. the value before the current transaction began. This function reads the value from the snapshots taken before executing the transaction. Parameters state: The current state. address: Address of the account to read the value from. key: Key of the storage slot."]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.stack", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/stack.py"}, "content": {"type": ["module"], "name": ["ethereum.berlin.vm.instructions.stack"], "text": ["Ethereum Virtual Machine (EVM) Stack Instructions ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementations of the EVM stack related instructions."]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.stack.pop", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/stack.py"}, "content": {"type": ["function"], "name": ["pop"], "text": ["Remove item from stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.stack.push_n", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/stack.py"}, "content": {"type": ["function"], "name": ["push_n"], "text": ["Pushes a N-byte immediate onto the stack. Parameters evm : The current EVM frame. num_bytes : The number of immediate bytes to be read from the code and pushed to the stack."]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.stack.dup_n", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/stack.py"}, "content": {"type": ["function"], "name": ["dup_n"], "text": ["Duplicate the Nth stack item (from top of the stack) to the top of stack. Parameters evm : The current EVM frame. item_number : The stack item number (0-indexed from top of stack) to be duplicated to the top of stack."]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.stack.swap_n", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/stack.py"}, "content": {"type": ["function"], "name": ["swap_n"], "text": ["Swap the top and the  item_number  element of the stack, where the top of the stack is position zero. If  item_number  is zero, this function does nothing (which should not be possible, since there is no  SWAP0  instruction). Parameters evm : The current EVM frame. item_number : The stack item number (0-indexed from top of stack) to be swapped with the top of stack element."]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.stack.push1", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push1"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.stack.push2", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push2"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.stack.push3", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push3"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.stack.push4", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push4"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.stack.push5", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push5"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.stack.push6", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push6"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.stack.push7", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push7"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.stack.push8", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push8"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.stack.push9", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push9"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.stack.push10", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push10"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.stack.push11", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push11"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.stack.push12", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push12"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.stack.push13", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push13"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.stack.push14", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push14"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.stack.push15", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push15"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.stack.push16", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push16"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.stack.push17", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push17"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.stack.push18", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push18"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.stack.push19", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push19"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.stack.push20", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push20"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.stack.push21", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push21"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.stack.push22", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push22"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.stack.push23", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push23"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.stack.push24", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push24"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.stack.push25", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push25"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.stack.push26", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push26"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.stack.push27", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push27"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.stack.push28", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push28"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.stack.push29", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push29"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.stack.push30", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push30"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.stack.push31", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push31"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.stack.push32", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push32"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.stack.dup1", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup1"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.stack.dup2", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup2"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.stack.dup3", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup3"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.stack.dup4", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup4"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.stack.dup5", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup5"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.stack.dup6", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup6"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.stack.dup7", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup7"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.stack.dup8", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup8"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.stack.dup9", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup9"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.stack.dup10", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup10"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.stack.dup11", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup11"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.stack.dup12", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup12"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.stack.dup13", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup13"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.stack.dup14", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup14"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.stack.dup15", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup15"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.stack.dup16", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup16"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.stack.swap1", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap1"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.stack.swap2", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap2"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.stack.swap3", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap3"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.stack.swap4", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap4"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.stack.swap5", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap5"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.stack.swap6", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap6"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.stack.swap7", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap7"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.stack.swap8", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap8"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.stack.swap9", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap9"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.stack.swap10", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap10"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.stack.swap11", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap11"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.stack.swap12", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap12"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.stack.swap13", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap13"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.stack.swap14", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap14"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.stack.swap15", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap15"]}}, {"source": {"identifier": "ethereum.berlin.vm.instructions.stack.swap16", "specifier": 0, "path": "src/ethereum/berlin/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap16"]}}, {"source": {"identifier": "ethereum.shanghai", "specifier": 0, "path": "src/ethereum/shanghai/__init__.py"}, "content": {"type": ["module"], "name": ["ethereum.shanghai"], "text": ["Ethereum Shanghai Hardfork ^^^^^^^^^^^^^^^^^^^^^^^^^^ The Fourteenth Ethereum hardfork."]}}, {"source": {"identifier": "ethereum.shanghai.MAINNET_FORK_BLOCK", "specifier": 0, "path": "src/ethereum/shanghai/__init__.py"}, "content": {"type": ["attribute"], "name": ["MAINNET_FORK_BLOCK"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/__init__.py"}, "content": {"type": ["module"], "name": ["ethereum.dao_fork.vm.instructions"], "text": ["EVM Instruction Encoding (Opcodes) ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Machine readable representations of EVM instructions, and a mapping to their implementations."]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.Ops", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/__init__.py"}, "content": {"type": ["class"], "name": ["Ops"], "text": ["Enum for EVM Opcodes"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.Ops.ADD", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["ADD"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.Ops.MUL", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["MUL"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.Ops.SUB", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SUB"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.Ops.DIV", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DIV"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.Ops.SDIV", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SDIV"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.Ops.MOD", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["MOD"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.Ops.SMOD", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SMOD"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.Ops.ADDMOD", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["ADDMOD"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.Ops.MULMOD", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["MULMOD"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.Ops.EXP", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["EXP"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.Ops.SIGNEXTEND", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SIGNEXTEND"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.Ops.LT", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["LT"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.Ops.GT", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["GT"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.Ops.SLT", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SLT"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.Ops.SGT", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SGT"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.Ops.EQ", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["EQ"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.Ops.ISZERO", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["ISZERO"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.Ops.AND", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["AND"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.Ops.OR", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["OR"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.Ops.XOR", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["XOR"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.Ops.NOT", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["NOT"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.Ops.BYTE", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["BYTE"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.Ops.KECCAK", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["KECCAK"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.Ops.ADDRESS", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["ADDRESS"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.Ops.BALANCE", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["BALANCE"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.Ops.ORIGIN", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["ORIGIN"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.Ops.CALLER", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["CALLER"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.Ops.CALLVALUE", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["CALLVALUE"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.Ops.CALLDATALOAD", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["CALLDATALOAD"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.Ops.CALLDATASIZE", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["CALLDATASIZE"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.Ops.CALLDATACOPY", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["CALLDATACOPY"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.Ops.CODESIZE", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["CODESIZE"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.Ops.CODECOPY", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["CODECOPY"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.Ops.GASPRICE", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["GASPRICE"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.Ops.EXTCODESIZE", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["EXTCODESIZE"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.Ops.EXTCODECOPY", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["EXTCODECOPY"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.Ops.BLOCKHASH", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["BLOCKHASH"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.Ops.COINBASE", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["COINBASE"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.Ops.TIMESTAMP", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["TIMESTAMP"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.Ops.NUMBER", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["NUMBER"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.Ops.DIFFICULTY", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DIFFICULTY"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.Ops.GASLIMIT", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["GASLIMIT"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.Ops.STOP", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["STOP"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.Ops.JUMP", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["JUMP"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.Ops.JUMPI", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["JUMPI"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.Ops.PC", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PC"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.Ops.GAS", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["GAS"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.Ops.JUMPDEST", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["JUMPDEST"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.Ops.SLOAD", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SLOAD"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.Ops.SSTORE", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SSTORE"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.Ops.POP", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["POP"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.Ops.PUSH1", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH1"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.Ops.PUSH2", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH2"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.Ops.PUSH3", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH3"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.Ops.PUSH4", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH4"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.Ops.PUSH5", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH5"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.Ops.PUSH6", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH6"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.Ops.PUSH7", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH7"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.Ops.PUSH8", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH8"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.Ops.PUSH9", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH9"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.Ops.PUSH10", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH10"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.Ops.PUSH11", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH11"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.Ops.PUSH12", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH12"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.Ops.PUSH13", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH13"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.Ops.PUSH14", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH14"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.Ops.PUSH15", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH15"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.Ops.PUSH16", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH16"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.Ops.PUSH17", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH17"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.Ops.PUSH18", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH18"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.Ops.PUSH19", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH19"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.Ops.PUSH20", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH20"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.Ops.PUSH21", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH21"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.Ops.PUSH22", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH22"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.Ops.PUSH23", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH23"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.Ops.PUSH24", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH24"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.Ops.PUSH25", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH25"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.Ops.PUSH26", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH26"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.Ops.PUSH27", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH27"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.Ops.PUSH28", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH28"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.Ops.PUSH29", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH29"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.Ops.PUSH30", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH30"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.Ops.PUSH31", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH31"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.Ops.PUSH32", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH32"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.Ops.DUP1", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP1"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.Ops.DUP2", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP2"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.Ops.DUP3", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP3"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.Ops.DUP4", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP4"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.Ops.DUP5", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP5"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.Ops.DUP6", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP6"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.Ops.DUP7", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP7"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.Ops.DUP8", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP8"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.Ops.DUP9", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP9"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.Ops.DUP10", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP10"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.Ops.DUP11", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP11"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.Ops.DUP12", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP12"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.Ops.DUP13", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP13"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.Ops.DUP14", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP14"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.Ops.DUP15", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP15"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.Ops.DUP16", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP16"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.Ops.SWAP1", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP1"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.Ops.SWAP2", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP2"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.Ops.SWAP3", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP3"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.Ops.SWAP4", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP4"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.Ops.SWAP5", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP5"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.Ops.SWAP6", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP6"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.Ops.SWAP7", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP7"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.Ops.SWAP8", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP8"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.Ops.SWAP9", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP9"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.Ops.SWAP10", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP10"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.Ops.SWAP11", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP11"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.Ops.SWAP12", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP12"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.Ops.SWAP13", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP13"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.Ops.SWAP14", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP14"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.Ops.SWAP15", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP15"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.Ops.SWAP16", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP16"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.Ops.MLOAD", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["MLOAD"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.Ops.MSTORE", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["MSTORE"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.Ops.MSTORE8", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["MSTORE8"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.Ops.MSIZE", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["MSIZE"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.Ops.LOG0", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["LOG0"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.Ops.LOG1", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["LOG1"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.Ops.LOG2", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["LOG2"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.Ops.LOG3", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["LOG3"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.Ops.LOG4", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["LOG4"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.Ops.CREATE", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["CREATE"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.Ops.RETURN", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["RETURN"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.Ops.CALL", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["CALL"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.Ops.CALLCODE", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["CALLCODE"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.Ops.DELEGATECALL", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DELEGATECALL"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.Ops.SELFDESTRUCT", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SELFDESTRUCT"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.op_implementation", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["op_implementation"]}}, {"source": {"identifier": "ethereum.berlin.utils", "specifier": 0, "path": "src/ethereum/berlin/utils/__init__.py"}, "content": {"type": ["module"], "name": ["ethereum.berlin.utils"], "text": ["Hardfork Utility Functions ^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Utility functions used in this berlin version of specification."]}}, {"source": {"identifier": "ethereum.shanghai.bloom", "specifier": 0, "path": "src/ethereum/shanghai/bloom.py"}, "content": {"type": ["module"], "name": ["ethereum.shanghai.bloom"], "text": ["Ethereum Logs Bloom ^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction This modules defines functions for calculating bloom filters of logs. For the general theory of bloom filters see e.g.  Wikipedia <https://en.wikipedia.org/wiki/Bloom_filter> _. Bloom filters are used to allow for efficient searching of logs by address and/or topic, by rapidly eliminating blocks and reciepts from their search."]}}, {"source": {"identifier": "ethereum.shanghai.bloom.add_to_bloom", "specifier": 0, "path": "src/ethereum/shanghai/bloom.py"}, "content": {"type": ["function"], "name": ["add_to_bloom"], "text": ["Add a bloom entry to the bloom filter ( bloom ). The number of hash functions used is 3. They are calculated by taking the least significant 11 bits from the first 3 16-bit words of the keccak_256()  hash of  bloom_entry . Parameters bloom : The bloom filter. bloom_entry : An entry which is to be added to bloom filter."]}}, {"source": {"identifier": "ethereum.shanghai.bloom.logs_bloom", "specifier": 0, "path": "src/ethereum/shanghai/bloom.py"}, "content": {"type": ["function"], "name": ["logs_bloom"], "text": ["Obtain the logs bloom from a list of log entries. The address and each topic of a log are added to the bloom filter. Parameters logs : List of logs for which the logs bloom is to be obtained. Returns logs_bloom :  Bloom The logs bloom obtained which is 256 bytes with some bits set as per the caller address and the log topics."]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.control_flow", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/control_flow.py"}, "content": {"type": ["module"], "name": ["ethereum.dao_fork.vm.instructions.control_flow"], "text": ["Ethereum Virtual Machine (EVM) Control Flow Instructions ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementations of the EVM control flow instructions."]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.control_flow.stop", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/control_flow.py"}, "content": {"type": ["function"], "name": ["stop"], "text": ["Stop further execution of EVM code. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.control_flow.jump", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/control_flow.py"}, "content": {"type": ["function"], "name": ["jump"], "text": ["Alter the program counter to the location specified by the top of the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.control_flow.jumpi", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/control_flow.py"}, "content": {"type": ["function"], "name": ["jumpi"], "text": ["Alter the program counter to the specified location if and only if a condition is true. If the condition is not true, then the program counter would increase only by 1. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.control_flow.pc", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/control_flow.py"}, "content": {"type": ["function"], "name": ["pc"], "text": ["Push onto the stack the value of the program counter after reaching the current instruction and without increasing it for the next instruction. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.control_flow.gas_left", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/control_flow.py"}, "content": {"type": ["function"], "name": ["gas_left"], "text": ["Push the amount of available gas (including the corresponding reduction for the cost of this instruction) onto the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.control_flow.jumpdest", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/control_flow.py"}, "content": {"type": ["function"], "name": ["jumpdest"], "text": ["Mark a valid destination for jumps. This is a noop, present only to be used by  JUMP  and  JUMPI  opcodes to verify that their jump is valid. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.shanghai.fork_types", "specifier": 0, "path": "src/ethereum/shanghai/fork_types.py"}, "content": {"type": ["module"], "name": ["ethereum.shanghai.fork_types"], "text": ["Ethereum Types ^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Types re-used throughout the specification, which are specific to Ethereum."]}}, {"source": {"identifier": "ethereum.shanghai.fork_types.Address", "specifier": 0, "path": "src/ethereum/shanghai/fork_types.py"}, "content": {"type": ["attribute"], "name": ["Address"]}}, {"source": {"identifier": "ethereum.shanghai.fork_types.Root", "specifier": 0, "path": "src/ethereum/shanghai/fork_types.py"}, "content": {"type": ["attribute"], "name": ["Root"]}}, {"source": {"identifier": "ethereum.shanghai.fork_types.Bloom", "specifier": 0, "path": "src/ethereum/shanghai/fork_types.py"}, "content": {"type": ["attribute"], "name": ["Bloom"]}}, {"source": {"identifier": "ethereum.shanghai.fork_types.TX_BASE_COST", "specifier": 0, "path": "src/ethereum/shanghai/fork_types.py"}, "content": {"type": ["attribute"], "name": ["TX_BASE_COST"]}}, {"source": {"identifier": "ethereum.shanghai.fork_types.TX_DATA_COST_PER_NON_ZERO", "specifier": 0, "path": "src/ethereum/shanghai/fork_types.py"}, "content": {"type": ["attribute"], "name": ["TX_DATA_COST_PER_NON_ZERO"]}}, {"source": {"identifier": "ethereum.shanghai.fork_types.TX_DATA_COST_PER_ZERO", "specifier": 0, "path": "src/ethereum/shanghai/fork_types.py"}, "content": {"type": ["attribute"], "name": ["TX_DATA_COST_PER_ZERO"]}}, {"source": {"identifier": "ethereum.shanghai.fork_types.TX_CREATE_COST", "specifier": 0, "path": "src/ethereum/shanghai/fork_types.py"}, "content": {"type": ["attribute"], "name": ["TX_CREATE_COST"]}}, {"source": {"identifier": "ethereum.shanghai.fork_types.TX_ACCESS_LIST_ADDRESS_COST", "specifier": 0, "path": "src/ethereum/shanghai/fork_types.py"}, "content": {"type": ["attribute"], "name": ["TX_ACCESS_LIST_ADDRESS_COST"]}}, {"source": {"identifier": "ethereum.shanghai.fork_types.TX_ACCESS_LIST_STORAGE_KEY_COST", "specifier": 0, "path": "src/ethereum/shanghai/fork_types.py"}, "content": {"type": ["attribute"], "name": ["TX_ACCESS_LIST_STORAGE_KEY_COST"]}}, {"source": {"identifier": "ethereum.shanghai.fork_types.LegacyTransaction", "specifier": 0, "path": "src/ethereum/shanghai/fork_types.py"}, "content": {"type": ["class"], "name": ["LegacyTransaction"], "text": ["Atomic operation performed on the block chain."]}}, {"source": {"identifier": "ethereum.shanghai.fork_types.LegacyTransaction.nonce", "specifier": 0, "path": "src/ethereum/shanghai/fork_types.py"}, "content": {"type": ["attribute"], "name": ["nonce"]}}, {"source": {"identifier": "ethereum.shanghai.fork_types.LegacyTransaction.gas_price", "specifier": 0, "path": "src/ethereum/shanghai/fork_types.py"}, "content": {"type": ["attribute"], "name": ["gas_price"]}}, {"source": {"identifier": "ethereum.shanghai.fork_types.LegacyTransaction.gas", "specifier": 0, "path": "src/ethereum/shanghai/fork_types.py"}, "content": {"type": ["attribute"], "name": ["gas"]}}, {"source": {"identifier": "ethereum.shanghai.fork_types.LegacyTransaction.to", "specifier": 0, "path": "src/ethereum/shanghai/fork_types.py"}, "content": {"type": ["attribute"], "name": ["to"]}}, {"source": {"identifier": "ethereum.shanghai.fork_types.LegacyTransaction.value", "specifier": 0, "path": "src/ethereum/shanghai/fork_types.py"}, "content": {"type": ["attribute"], "name": ["value"]}}, {"source": {"identifier": "ethereum.shanghai.fork_types.LegacyTransaction.data", "specifier": 0, "path": "src/ethereum/shanghai/fork_types.py"}, "content": {"type": ["attribute"], "name": ["data"]}}, {"source": {"identifier": "ethereum.shanghai.fork_types.LegacyTransaction.v", "specifier": 0, "path": "src/ethereum/shanghai/fork_types.py"}, "content": {"type": ["attribute"], "name": ["v"]}}, {"source": {"identifier": "ethereum.shanghai.fork_types.LegacyTransaction.r", "specifier": 0, "path": "src/ethereum/shanghai/fork_types.py"}, "content": {"type": ["attribute"], "name": ["r"]}}, {"source": {"identifier": "ethereum.shanghai.fork_types.LegacyTransaction.s", "specifier": 0, "path": "src/ethereum/shanghai/fork_types.py"}, "content": {"type": ["attribute"], "name": ["s"]}}, {"source": {"identifier": "ethereum.shanghai.fork_types.AccessListTransaction", "specifier": 0, "path": "src/ethereum/shanghai/fork_types.py"}, "content": {"type": ["class"], "name": ["AccessListTransaction"], "text": ["The transaction type added in EIP-2930 to support access lists."]}}, {"source": {"identifier": "ethereum.shanghai.fork_types.AccessListTransaction.chain_id", "specifier": 0, "path": "src/ethereum/shanghai/fork_types.py"}, "content": {"type": ["attribute"], "name": ["chain_id"]}}, {"source": {"identifier": "ethereum.shanghai.fork_types.AccessListTransaction.nonce", "specifier": 0, "path": "src/ethereum/shanghai/fork_types.py"}, "content": {"type": ["attribute"], "name": ["nonce"]}}, {"source": {"identifier": "ethereum.shanghai.fork_types.AccessListTransaction.gas_price", "specifier": 0, "path": "src/ethereum/shanghai/fork_types.py"}, "content": {"type": ["attribute"], "name": ["gas_price"]}}, {"source": {"identifier": "ethereum.shanghai.fork_types.AccessListTransaction.gas", "specifier": 0, "path": "src/ethereum/shanghai/fork_types.py"}, "content": {"type": ["attribute"], "name": ["gas"]}}, {"source": {"identifier": "ethereum.shanghai.fork_types.AccessListTransaction.to", "specifier": 0, "path": "src/ethereum/shanghai/fork_types.py"}, "content": {"type": ["attribute"], "name": ["to"]}}, {"source": {"identifier": "ethereum.shanghai.fork_types.AccessListTransaction.value", "specifier": 0, "path": "src/ethereum/shanghai/fork_types.py"}, "content": {"type": ["attribute"], "name": ["value"]}}, {"source": {"identifier": "ethereum.shanghai.fork_types.AccessListTransaction.data", "specifier": 0, "path": "src/ethereum/shanghai/fork_types.py"}, "content": {"type": ["attribute"], "name": ["data"]}}, {"source": {"identifier": "ethereum.shanghai.fork_types.AccessListTransaction.access_list", "specifier": 0, "path": "src/ethereum/shanghai/fork_types.py"}, "content": {"type": ["attribute"], "name": ["access_list"]}}, {"source": {"identifier": "ethereum.shanghai.fork_types.AccessListTransaction.v", "specifier": 0, "path": "src/ethereum/shanghai/fork_types.py"}, "content": {"type": ["attribute"], "name": ["v"]}}, {"source": {"identifier": "ethereum.shanghai.fork_types.AccessListTransaction.r", "specifier": 0, "path": "src/ethereum/shanghai/fork_types.py"}, "content": {"type": ["attribute"], "name": ["r"]}}, {"source": {"identifier": "ethereum.shanghai.fork_types.AccessListTransaction.s", "specifier": 0, "path": "src/ethereum/shanghai/fork_types.py"}, "content": {"type": ["attribute"], "name": ["s"]}}, {"source": {"identifier": "ethereum.shanghai.fork_types.FeeMarketTransaction", "specifier": 0, "path": "src/ethereum/shanghai/fork_types.py"}, "content": {"type": ["class"], "name": ["FeeMarketTransaction"], "text": ["The transaction type added in EIP-1559."]}}, {"source": {"identifier": "ethereum.shanghai.fork_types.FeeMarketTransaction.chain_id", "specifier": 0, "path": "src/ethereum/shanghai/fork_types.py"}, "content": {"type": ["attribute"], "name": ["chain_id"]}}, {"source": {"identifier": "ethereum.shanghai.fork_types.FeeMarketTransaction.nonce", "specifier": 0, "path": "src/ethereum/shanghai/fork_types.py"}, "content": {"type": ["attribute"], "name": ["nonce"]}}, {"source": {"identifier": "ethereum.shanghai.fork_types.FeeMarketTransaction.max_priority_fee_per_gas", "specifier": 0, "path": "src/ethereum/shanghai/fork_types.py"}, "content": {"type": ["attribute"], "name": ["max_priority_fee_per_gas"]}}, {"source": {"identifier": "ethereum.shanghai.fork_types.FeeMarketTransaction.max_fee_per_gas", "specifier": 0, "path": "src/ethereum/shanghai/fork_types.py"}, "content": {"type": ["attribute"], "name": ["max_fee_per_gas"]}}, {"source": {"identifier": "ethereum.shanghai.fork_types.FeeMarketTransaction.gas", "specifier": 0, "path": "src/ethereum/shanghai/fork_types.py"}, "content": {"type": ["attribute"], "name": ["gas"]}}, {"source": {"identifier": "ethereum.shanghai.fork_types.FeeMarketTransaction.to", "specifier": 0, "path": "src/ethereum/shanghai/fork_types.py"}, "content": {"type": ["attribute"], "name": ["to"]}}, {"source": {"identifier": "ethereum.shanghai.fork_types.FeeMarketTransaction.value", "specifier": 0, "path": "src/ethereum/shanghai/fork_types.py"}, "content": {"type": ["attribute"], "name": ["value"]}}, {"source": {"identifier": "ethereum.shanghai.fork_types.FeeMarketTransaction.data", "specifier": 0, "path": "src/ethereum/shanghai/fork_types.py"}, "content": {"type": ["attribute"], "name": ["data"]}}, {"source": {"identifier": "ethereum.shanghai.fork_types.FeeMarketTransaction.access_list", "specifier": 0, "path": "src/ethereum/shanghai/fork_types.py"}, "content": {"type": ["attribute"], "name": ["access_list"]}}, {"source": {"identifier": "ethereum.shanghai.fork_types.FeeMarketTransaction.v", "specifier": 0, "path": "src/ethereum/shanghai/fork_types.py"}, "content": {"type": ["attribute"], "name": ["v"]}}, {"source": {"identifier": "ethereum.shanghai.fork_types.FeeMarketTransaction.r", "specifier": 0, "path": "src/ethereum/shanghai/fork_types.py"}, "content": {"type": ["attribute"], "name": ["r"]}}, {"source": {"identifier": "ethereum.shanghai.fork_types.FeeMarketTransaction.s", "specifier": 0, "path": "src/ethereum/shanghai/fork_types.py"}, "content": {"type": ["attribute"], "name": ["s"]}}, {"source": {"identifier": "ethereum.shanghai.fork_types.Transaction", "specifier": 0, "path": "src/ethereum/shanghai/fork_types.py"}, "content": {"type": ["attribute"], "name": ["Transaction"]}}, {"source": {"identifier": "ethereum.shanghai.fork_types.encode_transaction", "specifier": 0, "path": "src/ethereum/shanghai/fork_types.py"}, "content": {"type": ["function"], "name": ["encode_transaction"], "text": ["Encode a transaction. Needed because non-legacy transactions aren't RLP."]}}, {"source": {"identifier": "ethereum.shanghai.fork_types.decode_transaction", "specifier": 0, "path": "src/ethereum/shanghai/fork_types.py"}, "content": {"type": ["function"], "name": ["decode_transaction"], "text": ["Decode a transaction. Needed because non-legacy transactions aren't RLP."]}}, {"source": {"identifier": "ethereum.shanghai.fork_types.Account", "specifier": 0, "path": "src/ethereum/shanghai/fork_types.py"}, "content": {"type": ["class"], "name": ["Account"], "text": ["State associated with an address."]}}, {"source": {"identifier": "ethereum.shanghai.fork_types.Account.nonce", "specifier": 0, "path": "src/ethereum/shanghai/fork_types.py"}, "content": {"type": ["attribute"], "name": ["nonce"]}}, {"source": {"identifier": "ethereum.shanghai.fork_types.Account.balance", "specifier": 0, "path": "src/ethereum/shanghai/fork_types.py"}, "content": {"type": ["attribute"], "name": ["balance"]}}, {"source": {"identifier": "ethereum.shanghai.fork_types.Account.code", "specifier": 0, "path": "src/ethereum/shanghai/fork_types.py"}, "content": {"type": ["attribute"], "name": ["code"]}}, {"source": {"identifier": "ethereum.shanghai.fork_types.EMPTY_ACCOUNT", "specifier": 0, "path": "src/ethereum/shanghai/fork_types.py"}, "content": {"type": ["attribute"], "name": ["EMPTY_ACCOUNT"]}}, {"source": {"identifier": "ethereum.shanghai.fork_types.encode_account", "specifier": 0, "path": "src/ethereum/shanghai/fork_types.py"}, "content": {"type": ["function"], "name": ["encode_account"], "text": ["Encode  Account  dataclass. Storage is not stored in the  Account  dataclass, so  Accounts  cannot be encoded with providing a storage root."]}}, {"source": {"identifier": "ethereum.shanghai.fork_types.Withdrawal", "specifier": 0, "path": "src/ethereum/shanghai/fork_types.py"}, "content": {"type": ["class"], "name": ["Withdrawal"], "text": ["Withdrawals that have been validated on the consensus layer."]}}, {"source": {"identifier": "ethereum.shanghai.fork_types.Withdrawal.index", "specifier": 0, "path": "src/ethereum/shanghai/fork_types.py"}, "content": {"type": ["attribute"], "name": ["index"]}}, {"source": {"identifier": "ethereum.shanghai.fork_types.Withdrawal.validator_index", "specifier": 0, "path": "src/ethereum/shanghai/fork_types.py"}, "content": {"type": ["attribute"], "name": ["validator_index"]}}, {"source": {"identifier": "ethereum.shanghai.fork_types.Withdrawal.address", "specifier": 0, "path": "src/ethereum/shanghai/fork_types.py"}, "content": {"type": ["attribute"], "name": ["address"]}}, {"source": {"identifier": "ethereum.shanghai.fork_types.Withdrawal.amount", "specifier": 0, "path": "src/ethereum/shanghai/fork_types.py"}, "content": {"type": ["attribute"], "name": ["amount"]}}, {"source": {"identifier": "ethereum.shanghai.fork_types.Header", "specifier": 0, "path": "src/ethereum/shanghai/fork_types.py"}, "content": {"type": ["class"], "name": ["Header"], "text": ["Header portion of a block on the chain."]}}, {"source": {"identifier": "ethereum.shanghai.fork_types.Header.parent_hash", "specifier": 0, "path": "src/ethereum/shanghai/fork_types.py"}, "content": {"type": ["attribute"], "name": ["parent_hash"]}}, {"source": {"identifier": "ethereum.shanghai.fork_types.Header.ommers_hash", "specifier": 0, "path": "src/ethereum/shanghai/fork_types.py"}, "content": {"type": ["attribute"], "name": ["ommers_hash"]}}, {"source": {"identifier": "ethereum.shanghai.fork_types.Header.coinbase", "specifier": 0, "path": "src/ethereum/shanghai/fork_types.py"}, "content": {"type": ["attribute"], "name": ["coinbase"]}}, {"source": {"identifier": "ethereum.shanghai.fork_types.Header.state_root", "specifier": 0, "path": "src/ethereum/shanghai/fork_types.py"}, "content": {"type": ["attribute"], "name": ["state_root"]}}, {"source": {"identifier": "ethereum.shanghai.fork_types.Header.transactions_root", "specifier": 0, "path": "src/ethereum/shanghai/fork_types.py"}, "content": {"type": ["attribute"], "name": ["transactions_root"]}}, {"source": {"identifier": "ethereum.shanghai.fork_types.Header.receipt_root", "specifier": 0, "path": "src/ethereum/shanghai/fork_types.py"}, "content": {"type": ["attribute"], "name": ["receipt_root"]}}, {"source": {"identifier": "ethereum.shanghai.fork_types.Header.bloom", "specifier": 0, "path": "src/ethereum/shanghai/fork_types.py"}, "content": {"type": ["attribute"], "name": ["bloom"]}}, {"source": {"identifier": "ethereum.shanghai.fork_types.Header.difficulty", "specifier": 0, "path": "src/ethereum/shanghai/fork_types.py"}, "content": {"type": ["attribute"], "name": ["difficulty"]}}, {"source": {"identifier": "ethereum.shanghai.fork_types.Header.number", "specifier": 0, "path": "src/ethereum/shanghai/fork_types.py"}, "content": {"type": ["attribute"], "name": ["number"]}}, {"source": {"identifier": "ethereum.shanghai.fork_types.Header.gas_limit", "specifier": 0, "path": "src/ethereum/shanghai/fork_types.py"}, "content": {"type": ["attribute"], "name": ["gas_limit"]}}, {"source": {"identifier": "ethereum.shanghai.fork_types.Header.gas_used", "specifier": 0, "path": "src/ethereum/shanghai/fork_types.py"}, "content": {"type": ["attribute"], "name": ["gas_used"]}}, {"source": {"identifier": "ethereum.shanghai.fork_types.Header.timestamp", "specifier": 0, "path": "src/ethereum/shanghai/fork_types.py"}, "content": {"type": ["attribute"], "name": ["timestamp"]}}, {"source": {"identifier": "ethereum.shanghai.fork_types.Header.extra_data", "specifier": 0, "path": "src/ethereum/shanghai/fork_types.py"}, "content": {"type": ["attribute"], "name": ["extra_data"]}}, {"source": {"identifier": "ethereum.shanghai.fork_types.Header.prev_randao", "specifier": 0, "path": "src/ethereum/shanghai/fork_types.py"}, "content": {"type": ["attribute"], "name": ["prev_randao"]}}, {"source": {"identifier": "ethereum.shanghai.fork_types.Header.nonce", "specifier": 0, "path": "src/ethereum/shanghai/fork_types.py"}, "content": {"type": ["attribute"], "name": ["nonce"]}}, {"source": {"identifier": "ethereum.shanghai.fork_types.Header.base_fee_per_gas", "specifier": 0, "path": "src/ethereum/shanghai/fork_types.py"}, "content": {"type": ["attribute"], "name": ["base_fee_per_gas"]}}, {"source": {"identifier": "ethereum.shanghai.fork_types.Header.withdrawals_root", "specifier": 0, "path": "src/ethereum/shanghai/fork_types.py"}, "content": {"type": ["attribute"], "name": ["withdrawals_root"]}}, {"source": {"identifier": "ethereum.shanghai.fork_types.Block", "specifier": 0, "path": "src/ethereum/shanghai/fork_types.py"}, "content": {"type": ["class"], "name": ["Block"], "text": ["A complete block."]}}, {"source": {"identifier": "ethereum.shanghai.fork_types.Block.header", "specifier": 0, "path": "src/ethereum/shanghai/fork_types.py"}, "content": {"type": ["attribute"], "name": ["header"]}}, {"source": {"identifier": "ethereum.shanghai.fork_types.Block.transactions", "specifier": 0, "path": "src/ethereum/shanghai/fork_types.py"}, "content": {"type": ["attribute"], "name": ["transactions"]}}, {"source": {"identifier": "ethereum.shanghai.fork_types.Block.ommers", "specifier": 0, "path": "src/ethereum/shanghai/fork_types.py"}, "content": {"type": ["attribute"], "name": ["ommers"]}}, {"source": {"identifier": "ethereum.shanghai.fork_types.Block.withdrawals", "specifier": 0, "path": "src/ethereum/shanghai/fork_types.py"}, "content": {"type": ["attribute"], "name": ["withdrawals"]}}, {"source": {"identifier": "ethereum.shanghai.fork_types.Log", "specifier": 0, "path": "src/ethereum/shanghai/fork_types.py"}, "content": {"type": ["class"], "name": ["Log"], "text": ["Data record produced during the execution of a transaction."]}}, {"source": {"identifier": "ethereum.shanghai.fork_types.Log.address", "specifier": 0, "path": "src/ethereum/shanghai/fork_types.py"}, "content": {"type": ["attribute"], "name": ["address"]}}, {"source": {"identifier": "ethereum.shanghai.fork_types.Log.topics", "specifier": 0, "path": "src/ethereum/shanghai/fork_types.py"}, "content": {"type": ["attribute"], "name": ["topics"]}}, {"source": {"identifier": "ethereum.shanghai.fork_types.Log.data", "specifier": 0, "path": "src/ethereum/shanghai/fork_types.py"}, "content": {"type": ["attribute"], "name": ["data"]}}, {"source": {"identifier": "ethereum.shanghai.fork_types.Receipt", "specifier": 0, "path": "src/ethereum/shanghai/fork_types.py"}, "content": {"type": ["class"], "name": ["Receipt"], "text": ["Result of a transaction."]}}, {"source": {"identifier": "ethereum.shanghai.fork_types.Receipt.succeeded", "specifier": 0, "path": "src/ethereum/shanghai/fork_types.py"}, "content": {"type": ["attribute"], "name": ["succeeded"]}}, {"source": {"identifier": "ethereum.shanghai.fork_types.Receipt.cumulative_gas_used", "specifier": 0, "path": "src/ethereum/shanghai/fork_types.py"}, "content": {"type": ["attribute"], "name": ["cumulative_gas_used"]}}, {"source": {"identifier": "ethereum.shanghai.fork_types.Receipt.bloom", "specifier": 0, "path": "src/ethereum/shanghai/fork_types.py"}, "content": {"type": ["attribute"], "name": ["bloom"]}}, {"source": {"identifier": "ethereum.shanghai.fork_types.Receipt.logs", "specifier": 0, "path": "src/ethereum/shanghai/fork_types.py"}, "content": {"type": ["attribute"], "name": ["logs"]}}, {"source": {"identifier": "ethereum.berlin.utils.address", "specifier": 0, "path": "src/ethereum/berlin/utils/address.py"}, "content": {"type": ["module"], "name": ["ethereum.berlin.utils.address"], "text": ["Hardfork Utility Functions For Addresses ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Address specific functions used in this berlin version of specification."]}}, {"source": {"identifier": "ethereum.berlin.utils.address.to_address", "specifier": 0, "path": "src/ethereum/berlin/utils/address.py"}, "content": {"type": ["function"], "name": ["to_address"], "text": ["Convert a Uint or U256 value to a valid address (20 bytes). Parameters data : The string to be converted to bytes. Returns address :  Address The obtained address."]}}, {"source": {"identifier": "ethereum.berlin.utils.address.compute_contract_address", "specifier": 0, "path": "src/ethereum/berlin/utils/address.py"}, "content": {"type": ["function"], "name": ["compute_contract_address"], "text": ["Computes address of the new account that needs to be created. Parameters address : The address of the account that wants to create the new account. nonce : The transaction count of the account that wants to create the new account. Returns address:  Address The computed address of the new account."]}}, {"source": {"identifier": "ethereum.berlin.utils.address.compute_create2_contract_address", "specifier": 0, "path": "src/ethereum/berlin/utils/address.py"}, "content": {"type": ["function"], "name": ["compute_create2_contract_address"], "text": ["Computes address of the new account that needs to be created, which is based on the sender address, salt and the call data as well. Parameters address : The address of the account that wants to create the new account. salt : Address generation salt. call_data : The code of the new account which is to be created. Returns address:  ethereum.berlin.fork_types.Address The computed address of the new account."]}}, {"source": {"identifier": "ethereum.shanghai.trie", "specifier": 0, "path": "src/ethereum/shanghai/trie.py"}, "content": {"type": ["module"], "name": ["ethereum.shanghai.trie"], "text": ["State Trie ^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction The state trie is the structure responsible for storing .fork_types.Account  objects."]}}, {"source": {"identifier": "ethereum.shanghai.trie.EMPTY_TRIE_ROOT", "specifier": 0, "path": "src/ethereum/shanghai/trie.py"}, "content": {"type": ["attribute"], "name": ["EMPTY_TRIE_ROOT"]}}, {"source": {"identifier": "ethereum.shanghai.trie.Node", "specifier": 0, "path": "src/ethereum/shanghai/trie.py"}, "content": {"type": ["attribute"], "name": ["Node"]}}, {"source": {"identifier": "ethereum.shanghai.trie.K", "specifier": 0, "path": "src/ethereum/shanghai/trie.py"}, "content": {"type": ["attribute"], "name": ["K"]}}, {"source": {"identifier": "ethereum.shanghai.trie.V", "specifier": 0, "path": "src/ethereum/shanghai/trie.py"}, "content": {"type": ["attribute"], "name": ["V"]}}, {"source": {"identifier": "ethereum.shanghai.trie.LeafNode", "specifier": 0, "path": "src/ethereum/shanghai/trie.py"}, "content": {"type": ["class"], "name": ["LeafNode"], "text": ["Leaf node in the Merkle Trie"]}}, {"source": {"identifier": "ethereum.shanghai.trie.LeafNode.rest_of_key", "specifier": 0, "path": "src/ethereum/shanghai/trie.py"}, "content": {"type": ["attribute"], "name": ["rest_of_key"]}}, {"source": {"identifier": "ethereum.shanghai.trie.LeafNode.value", "specifier": 0, "path": "src/ethereum/shanghai/trie.py"}, "content": {"type": ["attribute"], "name": ["value"]}}, {"source": {"identifier": "ethereum.shanghai.trie.ExtensionNode", "specifier": 0, "path": "src/ethereum/shanghai/trie.py"}, "content": {"type": ["class"], "name": ["ExtensionNode"], "text": ["Extension node in the Merkle Trie"]}}, {"source": {"identifier": "ethereum.shanghai.trie.ExtensionNode.key_segment", "specifier": 0, "path": "src/ethereum/shanghai/trie.py"}, "content": {"type": ["attribute"], "name": ["key_segment"]}}, {"source": {"identifier": "ethereum.shanghai.trie.ExtensionNode.subnode", "specifier": 0, "path": "src/ethereum/shanghai/trie.py"}, "content": {"type": ["attribute"], "name": ["subnode"]}}, {"source": {"identifier": "ethereum.shanghai.trie.BranchNode", "specifier": 0, "path": "src/ethereum/shanghai/trie.py"}, "content": {"type": ["class"], "name": ["BranchNode"], "text": ["Branch node in the Merkle Trie"]}}, {"source": {"identifier": "ethereum.shanghai.trie.BranchNode.subnodes", "specifier": 0, "path": "src/ethereum/shanghai/trie.py"}, "content": {"type": ["attribute"], "name": ["subnodes"]}}, {"source": {"identifier": "ethereum.shanghai.trie.BranchNode.value", "specifier": 0, "path": "src/ethereum/shanghai/trie.py"}, "content": {"type": ["attribute"], "name": ["value"]}}, {"source": {"identifier": "ethereum.shanghai.trie.InternalNode", "specifier": 0, "path": "src/ethereum/shanghai/trie.py"}, "content": {"type": ["attribute"], "name": ["InternalNode"]}}, {"source": {"identifier": "ethereum.shanghai.trie.encode_internal_node", "specifier": 0, "path": "src/ethereum/shanghai/trie.py"}, "content": {"type": ["function"], "name": ["encode_internal_node"], "text": ["Encodes a Merkle Trie node into its RLP form. The RLP will then be serialized into a  Bytes  and hashed unless it is less that 32 bytes when serialized. This function also accepts  None , representing the absence of a node, which is encoded to  b\"\" . Parameters node : Optional[InternalNode] The node to encode. Returns encoded :  rlp.RLP The node encoded as RLP."]}}, {"source": {"identifier": "ethereum.shanghai.trie.encode_node", "specifier": 0, "path": "src/ethereum/shanghai/trie.py"}, "content": {"type": ["function"], "name": ["encode_node"], "text": ["Encode a Node for storage in the Merkle Trie. Currently mostly an unimplemented stub."]}}, {"source": {"identifier": "ethereum.shanghai.trie.Trie", "specifier": 0, "path": "src/ethereum/shanghai/trie.py"}, "content": {"type": ["class"], "name": ["Trie"], "text": ["The Merkle Trie."]}}, {"source": {"identifier": "ethereum.shanghai.trie.Trie.secured", "specifier": 0, "path": "src/ethereum/shanghai/trie.py"}, "content": {"type": ["attribute"], "name": ["secured"]}}, {"source": {"identifier": "ethereum.shanghai.trie.Trie.default", "specifier": 0, "path": "src/ethereum/shanghai/trie.py"}, "content": {"type": ["attribute"], "name": ["default"]}}, {"source": {"identifier": "ethereum.shanghai.trie.Trie._data", "specifier": 0, "path": "src/ethereum/shanghai/trie.py"}, "content": {"type": ["attribute"], "name": ["_data"]}}, {"source": {"identifier": "ethereum.shanghai.trie.copy_trie", "specifier": 0, "path": "src/ethereum/shanghai/trie.py"}, "content": {"type": ["function"], "name": ["copy_trie"], "text": ["Create a copy of  trie . Since only frozen objects may be stored in tries, the contents are reused. Parameters trie:  Trie Trie to copy. Returns new_trie :  Trie[K, V] A copy of the trie."]}}, {"source": {"identifier": "ethereum.shanghai.trie.trie_set", "specifier": 0, "path": "src/ethereum/shanghai/trie.py"}, "content": {"type": ["function"], "name": ["trie_set"], "text": ["Stores an item in a Merkle Trie. This method deletes the key if  value == trie.default , because the Merkle Trie represents the default value by omitting it from the trie. Parameters trie:  Trie Trie to store in. key :  Bytes Key to lookup. value :  V Node to insert at  key ."]}}, {"source": {"identifier": "ethereum.shanghai.trie.trie_get", "specifier": 0, "path": "src/ethereum/shanghai/trie.py"}, "content": {"type": ["function"], "name": ["trie_get"], "text": ["Gets an item from the Merkle Trie. This method returns  trie.default  if the key is missing. Parameters trie: Trie to lookup in. key : Key to lookup. Returns node :  V Node at  key  in the trie."]}}, {"source": {"identifier": "ethereum.shanghai.trie.common_prefix_length", "specifier": 0, "path": "src/ethereum/shanghai/trie.py"}, "content": {"type": ["function"], "name": ["common_prefix_length"], "text": ["Find the longest common prefix of two sequences."]}}, {"source": {"identifier": "ethereum.shanghai.trie.nibble_list_to_compact", "specifier": 0, "path": "src/ethereum/shanghai/trie.py"}, "content": {"type": ["function"], "name": ["nibble_list_to_compact"], "text": ["Compresses nibble-list into a standard byte array with a flag. A nibble-list is a list of byte values no greater than  15 . The flag is encoded in high nibble of the highest byte. The flag nibble can be broken down into two two-bit flags. Highest nibble:: +---+---+----------+--------+\n| _ | _ | is_leaf | parity |\n+---+---+----------+--------+\n  3   2      1         0\n The lowest bit of the nibble encodes the parity of the length of the remaining nibbles --  0  when even and  1  when odd. The second lowest bit is used to distinguish leaf and extension nodes. The other two bits are not used. Parameters x : Array of nibbles. is_leaf : True if this is part of a leaf node, or false if it is an extension node. Returns compressed :  bytearray Compact byte array."]}}, {"source": {"identifier": "ethereum.shanghai.trie.bytes_to_nibble_list", "specifier": 0, "path": "src/ethereum/shanghai/trie.py"}, "content": {"type": ["function"], "name": ["bytes_to_nibble_list"], "text": ["Converts a  Bytes  into to a sequence of nibbles (bytes with value < 16). Parameters bytes_: The  Bytes  to convert. Returns nibble_list :  Bytes The  Bytes  in nibble-list format."]}}, {"source": {"identifier": "ethereum.shanghai.trie._prepare_trie", "specifier": 0, "path": "src/ethereum/shanghai/trie.py"}, "content": {"type": ["function"], "name": ["_prepare_trie"], "text": ["Prepares the trie for root calculation. Removes values that are empty, hashes the keys (if  secured == True ) and encodes all the nodes. Parameters trie : The  Trie  to prepare. get_storage_root : Function to get the storage root of an account. Needed to encode Account  objects. Returns out :  Mapping[ethereum.base_types.Bytes, Node] Object with keys mapped to nibble-byte form."]}}, {"source": {"identifier": "ethereum.shanghai.trie.root", "specifier": 0, "path": "src/ethereum/shanghai/trie.py"}, "content": {"type": ["function"], "name": ["root"], "text": ["Computes the root of a modified merkle patricia trie (MPT). Parameters trie : Trie  to get the root of. get_storage_root : Function to get the storage root of an account. Needed to encode Account  objects. Returns root :  .fork_types.Root MPT root of the underlying key-value pairs."]}}, {"source": {"identifier": "ethereum.shanghai.trie.patricialize", "specifier": 0, "path": "src/ethereum/shanghai/trie.py"}, "content": {"type": ["function"], "name": ["patricialize"], "text": ["Structural composition function. Used to recursively patricialize and merkleize a dictionary. Includes memoization of the tree structure and hashes. Parameters obj : Underlying trie key-value pairs, with keys in nibble-list format. level : Current trie level. Returns node :  ethereum.base_types.Bytes Root node of  obj ."]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.comparison", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/comparison.py"}, "content": {"type": ["module"], "name": ["ethereum.dao_fork.vm.instructions.comparison"], "text": ["Ethereum Virtual Machine (EVM) Comparison Instructions ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementations of the EVM Comparison instructions."]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.comparison.less_than", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/comparison.py"}, "content": {"type": ["function"], "name": ["less_than"], "text": ["Checks if the top element is less than the next top element. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.comparison.signed_less_than", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/comparison.py"}, "content": {"type": ["function"], "name": ["signed_less_than"], "text": ["Signed less-than comparison. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.comparison.greater_than", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/comparison.py"}, "content": {"type": ["function"], "name": ["greater_than"], "text": ["Checks if the top element is greater than the next top element. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.comparison.signed_greater_than", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/comparison.py"}, "content": {"type": ["function"], "name": ["signed_greater_than"], "text": ["Signed greater-than comparison. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.comparison.equal", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/comparison.py"}, "content": {"type": ["function"], "name": ["equal"], "text": ["Checks if the top element is equal to the next top element. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.comparison.is_zero", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/comparison.py"}, "content": {"type": ["function"], "name": ["is_zero"], "text": ["Checks if the top element is equal to 0. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.berlin.utils.message", "specifier": 0, "path": "src/ethereum/berlin/utils/message.py"}, "content": {"type": ["module"], "name": ["ethereum.berlin.utils.message"], "text": ["Hardfork Utility Functions For The Message Data-structure ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Message specific functions used in this berlin version of specification."]}}, {"source": {"identifier": "ethereum.berlin.utils.message.prepare_message", "specifier": 0, "path": "src/ethereum/berlin/utils/message.py"}, "content": {"type": ["function"], "name": ["prepare_message"], "text": ["Execute a transaction against the provided environment. Parameters caller : Address which initiated the transaction target : Address whose code will be executed value : Value to be transferred. data : Array of bytes provided to the code in  target . gas : Gas provided for the code in  target . env : Environment for the Ethereum Virtual Machine. code_address : This is usually same as the  target  address except when an alternative accounts code needs to be executed. eg.  CALLCODE  calling a precompile. should_transfer_value : if True ETH should be transferred while executing a message call. is_static: if True then it prevents all state-changing operations from being executed. preaccessed_addresses: Addresses that should be marked as accessed prior to the message call preaccessed_storage_keys: Storage keys that should be marked as accessed prior to the message call Returns message:  ethereum.berlin.vm.Message Items containing contract creation or message call specific data."]}}, {"source": {"identifier": "ethereum.shanghai.fork", "specifier": 0, "path": "src/ethereum/shanghai/fork.py"}, "content": {"type": ["module"], "name": ["ethereum.shanghai.fork"], "text": ["Ethereum Specification ^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Entry point for the Ethereum specification."]}}, {"source": {"identifier": "ethereum.shanghai.fork.BASE_FEE_MAX_CHANGE_DENOMINATOR", "specifier": 0, "path": "src/ethereum/shanghai/fork.py"}, "content": {"type": ["attribute"], "name": ["BASE_FEE_MAX_CHANGE_DENOMINATOR"]}}, {"source": {"identifier": "ethereum.shanghai.fork.ELASTICITY_MULTIPLIER", "specifier": 0, "path": "src/ethereum/shanghai/fork.py"}, "content": {"type": ["attribute"], "name": ["ELASTICITY_MULTIPLIER"]}}, {"source": {"identifier": "ethereum.shanghai.fork.GAS_LIMIT_ADJUSTMENT_FACTOR", "specifier": 0, "path": "src/ethereum/shanghai/fork.py"}, "content": {"type": ["attribute"], "name": ["GAS_LIMIT_ADJUSTMENT_FACTOR"]}}, {"source": {"identifier": "ethereum.shanghai.fork.GAS_LIMIT_MINIMUM", "specifier": 0, "path": "src/ethereum/shanghai/fork.py"}, "content": {"type": ["attribute"], "name": ["GAS_LIMIT_MINIMUM"]}}, {"source": {"identifier": "ethereum.shanghai.fork.EMPTY_OMMER_HASH", "specifier": 0, "path": "src/ethereum/shanghai/fork.py"}, "content": {"type": ["attribute"], "name": ["EMPTY_OMMER_HASH"]}}, {"source": {"identifier": "ethereum.shanghai.fork.BlockChain", "specifier": 0, "path": "src/ethereum/shanghai/fork.py"}, "content": {"type": ["class"], "name": ["BlockChain"], "text": ["History and current state of the block chain."]}}, {"source": {"identifier": "ethereum.shanghai.fork.BlockChain.blocks", "specifier": 0, "path": "src/ethereum/shanghai/fork.py"}, "content": {"type": ["attribute"], "name": ["blocks"]}}, {"source": {"identifier": "ethereum.shanghai.fork.BlockChain.state", "specifier": 0, "path": "src/ethereum/shanghai/fork.py"}, "content": {"type": ["attribute"], "name": ["state"]}}, {"source": {"identifier": "ethereum.shanghai.fork.BlockChain.chain_id", "specifier": 0, "path": "src/ethereum/shanghai/fork.py"}, "content": {"type": ["attribute"], "name": ["chain_id"]}}, {"source": {"identifier": "ethereum.shanghai.fork.apply_fork", "specifier": 0, "path": "src/ethereum/shanghai/fork.py"}, "content": {"type": ["function"], "name": ["apply_fork"], "text": ["Transforms the state from the previous hard fork ( old ) into the block chain object for this hard fork and returns it. When forks need to implement an irregular state transition, this function is used to handle the irregularity. See the :ref: DAO Fork <dao-fork>  for an example. Parameters old : Previous block chain object. Returns new :  BlockChain Upgraded block chain object for this hard fork."]}}, {"source": {"identifier": "ethereum.shanghai.fork.get_last_256_block_hashes", "specifier": 0, "path": "src/ethereum/shanghai/fork.py"}, "content": {"type": ["function"], "name": ["get_last_256_block_hashes"], "text": ["Obtain the list of hashes of the previous 256 blocks in order of increasing block number. This function will return less hashes for the first 256 blocks. The  BLOCKHASH  opcode needs to access the latest hashes on the chain, therefore this function retrieves them. Parameters chain : History and current state. Returns recent_block_hashes :  List[Hash32] Hashes of the recent 256 blocks in order of increasing block number."]}}, {"source": {"identifier": "ethereum.shanghai.fork.state_transition", "specifier": 0, "path": "src/ethereum/shanghai/fork.py"}, "content": {"type": ["function"], "name": ["state_transition"], "text": ["Attempts to apply a block to an existing block chain. All parts of the block's contents need to be verified before being added to the chain. Blocks are verified by ensuring that the contents of the block make logical sense with the contents of the parent block. The information in the block's header must also match the corresponding information in the block. To implement Ethereum, in theory clients are only required to store the most recent 255 blocks of the chain since as far as execution is concerned, only those blocks are accessed. Practically, however, clients should store more blocks to handle reorgs. Parameters chain : History and current state. block : Block to apply to  chain ."]}}, {"source": {"identifier": "ethereum.shanghai.fork.calculate_base_fee_per_gas", "specifier": 0, "path": "src/ethereum/shanghai/fork.py"}, "content": {"type": ["function"], "name": ["calculate_base_fee_per_gas"], "text": ["Calculates the base fee per gas for the block. Parameters block_gas_limit : Gas limit of the block for which the base fee is being calculated. parent_gas_limit : Gas limit of the parent block. parent_gas_used : Gas used in the parent block. parent_base_fee_per_gas : Base fee per gas of the parent block. Returns base_fee_per_gas :  Uint Base fee per gas for the block."]}}, {"source": {"identifier": "ethereum.shanghai.fork.validate_header", "specifier": 0, "path": "src/ethereum/shanghai/fork.py"}, "content": {"type": ["function"], "name": ["validate_header"], "text": ["Verifies a block header. In order to consider a block's header valid, the logic for the quantities in the header should match the logic for the block itself. For example the header timestamp should be greater than the block's parent timestamp because the block was created  after  the parent block. Additionally, the block's number should be directly folowing the parent block's number since it is the next block in the sequence. Parameters header : Header to check for correctness. parent_header : Parent Header of the header to check for correctness"]}}, {"source": {"identifier": "ethereum.shanghai.fork.check_transaction", "specifier": 0, "path": "src/ethereum/shanghai/fork.py"}, "content": {"type": ["function"], "name": ["check_transaction"], "text": ["Check if the transaction is includable in the block. Parameters tx : The transaction. base_fee_per_gas : The block base fee. gas_available : The gas remaining in the block. chain_id : The ID of the current chain. Returns sender_address : The sender of the transaction. effective_gas_price : The price to charge for gas when the transaction is executed. Raises InvalidBlock : If the transaction is not includable."]}}, {"source": {"identifier": "ethereum.shanghai.fork.make_receipt", "specifier": 0, "path": "src/ethereum/shanghai/fork.py"}, "content": {"type": ["function"], "name": ["make_receipt"], "text": ["Make the receipt for a transaction that was executed. Parameters tx : The executed transaction. has_erred : Whether the top level frame of the transaction exited with an error. cumulative_gas_used : The total gas used so far in the block after the transaction was executed. logs : The logs produced by the transaction. Returns receipt : The receipt for the transaction."]}}, {"source": {"identifier": "ethereum.shanghai.fork.apply_body", "specifier": 0, "path": "src/ethereum/shanghai/fork.py"}, "content": {"type": ["function"], "name": ["apply_body"], "text": ["Executes a block. Many of the contents of a block are stored in data structures called tries. There is a transactions trie which is similar to a ledger of the transactions stored in the current block. There is also a receipts trie which stores the results of executing a transaction, like the post state and gas used. This function creates and executes the block that is to be added to the chain. Parameters state : Current account state. block_hashes : List of hashes of the previous 256 blocks in the order of increasing block number. coinbase : Address of account which receives block reward and transaction fees. block_number : Position of the block within the chain. base_fee_per_gas : Base fee per gas of within the block. block_gas_limit : Initial amount of gas available for execution in this block. block_time : Time the block was produced, measured in seconds since the epoch. prev_randao : The previous randao from the beacon chain. transactions : Transactions included in the block. ommers : Headers of ancestor blocks which are not direct parents (formerly uncles.) chain_id : ID of the executing chain. withdrawals : Withdrawals to be processed in the current block. Returns gas_available :  ethereum.base_types.Uint Remaining gas after all transactions have been executed. transactions_root :  ethereum.fork_types.Root Trie root of all the transactions in the block. receipt_root :  ethereum.fork_types.Root Trie root of all the receipts in the block. block_logs_bloom :  Bloom Logs bloom of all the logs included in all the transactions of the block. state :  ethereum.fork_types.State State after all transactions have been executed."]}}, {"source": {"identifier": "ethereum.shanghai.fork.process_transaction", "specifier": 0, "path": "src/ethereum/shanghai/fork.py"}, "content": {"type": ["function"], "name": ["process_transaction"], "text": ["Execute a transaction against the provided environment. This function processes the actions needed to execute a transaction. It decrements the sender's account after calculating the gas fee and refunds them the proper amount after execution. Calling contracts, deploying code, and incrementing nonces are all examples of actions that happen within this function or from a call made within this function. Accounts that are marked for deletion are processed and destroyed after execution. Parameters env : Environment for the Ethereum Virtual Machine. tx : Transaction to execute. Returns gas_left :  ethereum.base_types.U256 Remaining gas after execution. logs :  Tuple[ethereum.fork_types.Log, ...] Logs generated during execution."]}}, {"source": {"identifier": "ethereum.shanghai.fork.validate_transaction", "specifier": 0, "path": "src/ethereum/shanghai/fork.py"}, "content": {"type": ["function"], "name": ["validate_transaction"], "text": ["Verifies a transaction. The gas in a transaction gets used to pay for the intrinsic cost of operations, therefore if there is insufficient gas then it would not be possible to execute a transaction and it will be declared invalid. Additionally, the nonce of a transaction must not equal or exceed the limit defined in  EIP-2681 <https://eips.ethereum.org/EIPS/eip-2681> _. In practice, defining the limit as  2**64-1  has no impact because sending  2**64-1  transactions is improbable. It's not strictly impossible though,  2**64-1  transactions is the entire capacity of the Ethereum blockchain at 2022 gas limits for a little over 22 years. Parameters tx : Transaction to validate. Returns verified :  bool True if the transaction can be executed, or False otherwise."]}}, {"source": {"identifier": "ethereum.shanghai.fork.calculate_intrinsic_cost", "specifier": 0, "path": "src/ethereum/shanghai/fork.py"}, "content": {"type": ["function"], "name": ["calculate_intrinsic_cost"], "text": ["Calculates the gas that is charged before execution is started. The intrinsic cost of the transaction is charged before execution has begun. Functions/operations in the EVM cost money to execute so this intrinsic cost is for the operations that need to be paid for as part of the transaction. Data transfer, for example, is part of this intrinsic cost. It costs ether to send data over the wire and that ether is accounted for in the intrinsic cost calculated in this function. This intrinsic cost must be calculated and paid for before execution in order for all operations to be implemented. Parameters tx : Transaction to compute the intrinsic cost of. Returns verified :  ethereum.base_types.Uint The intrinsic cost of the transaction."]}}, {"source": {"identifier": "ethereum.shanghai.fork.recover_sender", "specifier": 0, "path": "src/ethereum/shanghai/fork.py"}, "content": {"type": ["function"], "name": ["recover_sender"], "text": ["Extracts the sender address from a transaction. The v, r, and s values are the three parts that make up the signature of a transaction. In order to recover the sender of a transaction the two components needed are the signature ( v ,  r , and  s ) and the signing hash of the transaction. The sender's public key can be obtained with these two values and therefore the sender address can be retrieved. Parameters tx : Transaction of interest. chain_id : ID of the executing chain. Returns sender :  ethereum.fork_types.Address The address of the account that signed the transaction."]}}, {"source": {"identifier": "ethereum.shanghai.fork.signing_hash_pre155", "specifier": 0, "path": "src/ethereum/shanghai/fork.py"}, "content": {"type": ["function"], "name": ["signing_hash_pre155"], "text": ["Compute the hash of a transaction used in a legacy (pre EIP 155) signature. Parameters tx : Transaction of interest. Returns hash :  ethereum.crypto.hash.Hash32 Hash of the transaction."]}}, {"source": {"identifier": "ethereum.shanghai.fork.signing_hash_155", "specifier": 0, "path": "src/ethereum/shanghai/fork.py"}, "content": {"type": ["function"], "name": ["signing_hash_155"], "text": ["Compute the hash of a transaction used in a EIP 155 signature. Parameters tx : Transaction of interest. Returns hash :  ethereum.crypto.hash.Hash32 Hash of the transaction."]}}, {"source": {"identifier": "ethereum.shanghai.fork.signing_hash_2930", "specifier": 0, "path": "src/ethereum/shanghai/fork.py"}, "content": {"type": ["function"], "name": ["signing_hash_2930"], "text": ["Compute the hash of a transaction used in a EIP 2930 signature. Parameters tx : Transaction of interest. Returns hash :  ethereum.crypto.hash.Hash32 Hash of the transaction."]}}, {"source": {"identifier": "ethereum.shanghai.fork.signing_hash_1559", "specifier": 0, "path": "src/ethereum/shanghai/fork.py"}, "content": {"type": ["function"], "name": ["signing_hash_1559"], "text": ["Compute the hash of a transaction used in a EIP 1559 signature. Parameters tx : Transaction of interest. Returns hash :  ethereum.crypto.hash.Hash32 Hash of the transaction."]}}, {"source": {"identifier": "ethereum.shanghai.fork.compute_header_hash", "specifier": 0, "path": "src/ethereum/shanghai/fork.py"}, "content": {"type": ["function"], "name": ["compute_header_hash"], "text": ["Computes the hash of a block header. The header hash of a block is the canonical hash that is used to refer to a specific block and completely distinguishes a block from another. keccak256  is a function that produces a 256 bit hash of any input. It also takes in any number of bytes as an input and produces a single hash for them. A hash is a completely unique output for a single input. So an input corresponds to one unique hash that can be used to identify the input exactly. Prior to using the  keccak256  hash function, the header must be encoded using the Recursive-Length Prefix. See :ref: rlp . RLP encoding the header converts it into a space-efficient format that allows for easy transfer of data between nodes. The purpose of RLP is to encode arbitrarily nested arrays of binary data, and RLP is the primary encoding method used to serialize objects in Ethereum's execution layer. The only purpose of RLP is to encode structure; encoding specific data types (e.g. strings, floats) is left up to higher-order protocols. Parameters header : Header of interest. Returns hash :  ethereum.crypto.hash.Hash32 Hash of the header."]}}, {"source": {"identifier": "ethereum.shanghai.fork.check_gas_limit", "specifier": 0, "path": "src/ethereum/shanghai/fork.py"}, "content": {"type": ["function"], "name": ["check_gas_limit"], "text": ["Validates the gas limit for a block. The bounds of the gas limit,  max_adjustment_delta , is set as the quotient of the parent block's gas limit and the GAS_LIMIT_ADJUSTMENT_FACTOR . Therefore, if the gas limit that is passed through as a parameter is greater than or equal to the  sum  of the parent's gas and the adjustment delta then the limit for gas is too high and fails this function's check. Similarly, if the limit is less than or equal to the  difference  of the parent's gas and the adjustment delta  or  the predefined  GAS_LIMIT_MINIMUM  then this function's check fails because the gas limit doesn't allow for a sufficient or reasonable amount of gas to be used on a block. Parameters gas_limit : Gas limit to validate. parent_gas_limit : Gas limit of the parent block. Returns check :  bool True if gas limit constraints are satisfied, False otherwise."]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.log", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/log.py"}, "content": {"type": ["module"], "name": ["ethereum.dao_fork.vm.instructions.log"], "text": ["Ethereum Virtual Machine (EVM) Logging Instructions ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementations of the EVM logging instructions."]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.log.log_n", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/log.py"}, "content": {"type": ["function"], "name": ["log_n"], "text": ["Appends a log entry, having  num_topics  topics, to the evm logs. This will also expand the memory if the data (required by the log entry) corresponding to the memory is not accessible. Parameters evm : The current EVM frame. num_topics : The number of topics to be included in the log entry."]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.log.log0", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/log.py"}, "content": {"type": ["attribute"], "name": ["log0"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.log.log1", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/log.py"}, "content": {"type": ["attribute"], "name": ["log1"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.log.log2", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/log.py"}, "content": {"type": ["attribute"], "name": ["log2"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.log.log3", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/log.py"}, "content": {"type": ["attribute"], "name": ["log3"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.log.log4", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/log.py"}, "content": {"type": ["attribute"], "name": ["log4"]}}, {"source": {"identifier": "ethereum.berlin.utils.hexadecimal", "specifier": 0, "path": "src/ethereum/berlin/utils/hexadecimal.py"}, "content": {"type": ["module"], "name": ["ethereum.berlin.utils.hexadecimal"], "text": ["Utility Functions For Hexadecimal Strings ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Hexadecimal utility functions used in this specification, specific to Berlin types."]}}, {"source": {"identifier": "ethereum.berlin.utils.hexadecimal.hex_to_root", "specifier": 0, "path": "src/ethereum/berlin/utils/hexadecimal.py"}, "content": {"type": ["function"], "name": ["hex_to_root"], "text": ["Convert hex string to trie root. Parameters hex_string : The hexadecimal string to be converted to trie root. Returns root :  Root Trie root obtained from the given hexadecimal string."]}}, {"source": {"identifier": "ethereum.berlin.utils.hexadecimal.hex_to_bloom", "specifier": 0, "path": "src/ethereum/berlin/utils/hexadecimal.py"}, "content": {"type": ["function"], "name": ["hex_to_bloom"], "text": ["Convert hex string to bloom. Parameters hex_string : The hexadecimal string to be converted to bloom. Returns bloom :  Bloom Bloom obtained from the given hexadecimal string."]}}, {"source": {"identifier": "ethereum.berlin.utils.hexadecimal.hex_to_address", "specifier": 0, "path": "src/ethereum/berlin/utils/hexadecimal.py"}, "content": {"type": ["function"], "name": ["hex_to_address"], "text": ["Convert hex string to Address (20 bytes). Parameters hex_string : The hexadecimal string to be converted to Address. Returns address :  Address The address obtained from the given hexadecimal string."]}}, {"source": {"identifier": "ethereum.shanghai.vm.memory", "specifier": 0, "path": "src/ethereum/shanghai/vm/memory.py"}, "content": {"type": ["module"], "name": ["ethereum.shanghai.vm.memory"], "text": ["Ethereum Virtual Machine (EVM) Memory ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction EVM memory operations."]}}, {"source": {"identifier": "ethereum.shanghai.vm.memory.memory_write", "specifier": 0, "path": "src/ethereum/shanghai/vm/memory.py"}, "content": {"type": ["function"], "name": ["memory_write"], "text": ["Writes to memory. Parameters memory : Memory contents of the EVM. start_position : Starting pointer to the memory. value : Data to write to memory."]}}, {"source": {"identifier": "ethereum.shanghai.vm.memory.memory_read_bytes", "specifier": 0, "path": "src/ethereum/shanghai/vm/memory.py"}, "content": {"type": ["function"], "name": ["memory_read_bytes"], "text": ["Read bytes from memory. Parameters memory : Memory contents of the EVM. start_position : Starting pointer to the memory. size : Size of the data that needs to be read from  start_position . Returns data_bytes : Data read from memory."]}}, {"source": {"identifier": "ethereum.shanghai.vm.memory.buffer_read", "specifier": 0, "path": "src/ethereum/shanghai/vm/memory.py"}, "content": {"type": ["function"], "name": ["buffer_read"], "text": ["Read bytes from a buffer. Padding with zeros if neccesary. Parameters buffer : Memory contents of the EVM. start_position : Starting pointer to the memory. size : Size of the data that needs to be read from  start_position . Returns data_bytes : Data read from memory."]}}, {"source": {"identifier": "ethereum.muir_glacier.state", "specifier": 0, "path": "src/ethereum/muir_glacier/state.py"}, "content": {"type": ["module"], "name": ["ethereum.muir_glacier.state"], "text": ["State ^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction The state contains all information that is preserved between transactions. It consists of a main account trie and storage tries for each contract. There is a distinction between an account that does not exist and EMPTY_ACCOUNT ."]}}, {"source": {"identifier": "ethereum.muir_glacier.state.State", "specifier": 0, "path": "src/ethereum/muir_glacier/state.py"}, "content": {"type": ["class"], "name": ["State"], "text": ["Contains all information that is preserved between transactions."]}}, {"source": {"identifier": "ethereum.muir_glacier.state.State._main_trie", "specifier": 0, "path": "src/ethereum/muir_glacier/state.py"}, "content": {"type": ["attribute"], "name": ["_main_trie"]}}, {"source": {"identifier": "ethereum.muir_glacier.state.State._storage_tries", "specifier": 0, "path": "src/ethereum/muir_glacier/state.py"}, "content": {"type": ["attribute"], "name": ["_storage_tries"]}}, {"source": {"identifier": "ethereum.muir_glacier.state.State._snapshots", "specifier": 0, "path": "src/ethereum/muir_glacier/state.py"}, "content": {"type": ["attribute"], "name": ["_snapshots"]}}, {"source": {"identifier": "ethereum.muir_glacier.state.close_state", "specifier": 0, "path": "src/ethereum/muir_glacier/state.py"}, "content": {"type": ["function"], "name": ["close_state"], "text": ["Free resources held by the state. Used by optimized implementations to release file descriptors."]}}, {"source": {"identifier": "ethereum.muir_glacier.state.begin_transaction", "specifier": 0, "path": "src/ethereum/muir_glacier/state.py"}, "content": {"type": ["function"], "name": ["begin_transaction"], "text": ["Start a state transaction. Transactions are entirely implicit and can be nested. It is not possible to calculate the state root during a transaction. Parameters state : State The state."]}}, {"source": {"identifier": "ethereum.muir_glacier.state.commit_transaction", "specifier": 0, "path": "src/ethereum/muir_glacier/state.py"}, "content": {"type": ["function"], "name": ["commit_transaction"], "text": ["Commit a state transaction. Parameters state : State The state."]}}, {"source": {"identifier": "ethereum.muir_glacier.state.rollback_transaction", "specifier": 0, "path": "src/ethereum/muir_glacier/state.py"}, "content": {"type": ["function"], "name": ["rollback_transaction"], "text": ["Rollback a state transaction, resetting the state to the point when the corresponding  start_transaction()  call was made. Parameters state : State The state."]}}, {"source": {"identifier": "ethereum.muir_glacier.state.get_account", "specifier": 0, "path": "src/ethereum/muir_glacier/state.py"}, "content": {"type": ["function"], "name": ["get_account"], "text": ["Get the  Account  object at an address. Returns  EMPTY_ACCOUNT  if there is no account at the address. Use  get_account_optional()  if you care about the difference between a non-existent account and  EMPTY_ACCOUNT . Parameters state:  State The state address :  Address Address to lookup. Returns account :  Account Account at address."]}}, {"source": {"identifier": "ethereum.muir_glacier.state.get_account_optional", "specifier": 0, "path": "src/ethereum/muir_glacier/state.py"}, "content": {"type": ["function"], "name": ["get_account_optional"], "text": ["Get the  Account  object at an address. Returns  None  (rather than EMPTY_ACCOUNT ) if there is no account at the address. Parameters state:  State The state address :  Address Address to lookup. Returns account :  Account Account at address."]}}, {"source": {"identifier": "ethereum.muir_glacier.state.set_account", "specifier": 0, "path": "src/ethereum/muir_glacier/state.py"}, "content": {"type": ["function"], "name": ["set_account"], "text": ["Set the  Account  object at an address. Setting to  None  deletes the account (but not its storage, see  destroy_account() ). Parameters state:  State The state address :  Address Address to set. account :  Account Account to set at address."]}}, {"source": {"identifier": "ethereum.muir_glacier.state.destroy_account", "specifier": 0, "path": "src/ethereum/muir_glacier/state.py"}, "content": {"type": ["function"], "name": ["destroy_account"], "text": ["Completely remove the account at  address  and all of its storage. This function is made available exclusively for the  SELFDESTRUCT opcode. It is expected that  SELFDESTRUCT  will be disabled in a future hardfork and this function will be removed. Parameters state:  State The state address :  Address Address of account to destroy."]}}, {"source": {"identifier": "ethereum.muir_glacier.state.destroy_storage", "specifier": 0, "path": "src/ethereum/muir_glacier/state.py"}, "content": {"type": ["function"], "name": ["destroy_storage"], "text": ["Completely remove the storage at  address . Parameters state:  State The state address :  Address Address of account whose storage is to be deleted."]}}, {"source": {"identifier": "ethereum.muir_glacier.state.get_storage", "specifier": 0, "path": "src/ethereum/muir_glacier/state.py"}, "content": {"type": ["function"], "name": ["get_storage"], "text": ["Get a value at a storage key on an account. Returns  U256(0)  if the storage key has not been set previously. Parameters state:  State The state address :  Address Address of the account. key :  Bytes Key to lookup. Returns value :  U256 Value at the key."]}}, {"source": {"identifier": "ethereum.muir_glacier.state.set_storage", "specifier": 0, "path": "src/ethereum/muir_glacier/state.py"}, "content": {"type": ["function"], "name": ["set_storage"], "text": ["Set a value at a storage key on an account. Setting to  U256(0)  deletes the key. Parameters state:  State The state address :  Address Address of the account. key :  Bytes Key to set. value :  U256 Value to set at the key."]}}, {"source": {"identifier": "ethereum.muir_glacier.state.storage_root", "specifier": 0, "path": "src/ethereum/muir_glacier/state.py"}, "content": {"type": ["function"], "name": ["storage_root"], "text": ["Calculate the storage root of an account. Parameters state: The state address : Address of the account. Returns root :  Root Storage root of the account."]}}, {"source": {"identifier": "ethereum.muir_glacier.state.state_root", "specifier": 0, "path": "src/ethereum/muir_glacier/state.py"}, "content": {"type": ["function"], "name": ["state_root"], "text": ["Calculate the state root. Parameters state: The current state. Returns root :  Root The state root."]}}, {"source": {"identifier": "ethereum.muir_glacier.state.account_exists", "specifier": 0, "path": "src/ethereum/muir_glacier/state.py"}, "content": {"type": ["function"], "name": ["account_exists"], "text": ["Checks if an account exists in the state trie Parameters state: The state address: Address of the account that needs to be checked. Returns account_exists :  bool True if account exists in the state trie, False otherwise"]}}, {"source": {"identifier": "ethereum.muir_glacier.state.account_has_code_or_nonce", "specifier": 0, "path": "src/ethereum/muir_glacier/state.py"}, "content": {"type": ["function"], "name": ["account_has_code_or_nonce"], "text": ["Checks if an account has non zero nonce or non empty code Parameters state: The state address: Address of the account that needs to be checked. Returns has_code_or_nonce :  bool True if if an account has non zero nonce or non empty code, False otherwise."]}}, {"source": {"identifier": "ethereum.muir_glacier.state.is_account_empty", "specifier": 0, "path": "src/ethereum/muir_glacier/state.py"}, "content": {"type": ["function"], "name": ["is_account_empty"], "text": ["Checks if an account has zero nonce, empty code and zero balance. Parameters state: The state address: Address of the account that needs to be checked. Returns is_empty :  bool True if if an account has zero nonce, empty code and zero balance, False otherwise."]}}, {"source": {"identifier": "ethereum.muir_glacier.state.account_exists_and_is_empty", "specifier": 0, "path": "src/ethereum/muir_glacier/state.py"}, "content": {"type": ["function"], "name": ["account_exists_and_is_empty"], "text": ["Checks if an account exists and has zero nonce, empty code and zero balance. Parameters state: The state address: Address of the account that needs to be checked. Returns exists_and_is_empty :  bool True if an account exists and has zero nonce, empty code and zero balance, False otherwise."]}}, {"source": {"identifier": "ethereum.muir_glacier.state.is_account_alive", "specifier": 0, "path": "src/ethereum/muir_glacier/state.py"}, "content": {"type": ["function"], "name": ["is_account_alive"], "text": ["Check whether is an account is both in the state and non empty. Parameters state: The state address: Address of the account that needs to be checked. Returns is_alive :  bool True if the account is alive."]}}, {"source": {"identifier": "ethereum.muir_glacier.state.modify_state", "specifier": 0, "path": "src/ethereum/muir_glacier/state.py"}, "content": {"type": ["function"], "name": ["modify_state"], "text": ["Modify an  Account  in the  State ."]}}, {"source": {"identifier": "ethereum.muir_glacier.state.move_ether", "specifier": 0, "path": "src/ethereum/muir_glacier/state.py"}, "content": {"type": ["function"], "name": ["move_ether"], "text": ["Move funds between accounts."]}}, {"source": {"identifier": "ethereum.muir_glacier.state.set_account_balance", "specifier": 0, "path": "src/ethereum/muir_glacier/state.py"}, "content": {"type": ["function"], "name": ["set_account_balance"], "text": ["Sets the balance of an account. Parameters state: The current state. address: Address of the account whose nonce needs to be incremented. amount: The amount that needs to set in balance."]}}, {"source": {"identifier": "ethereum.muir_glacier.state.touch_account", "specifier": 0, "path": "src/ethereum/muir_glacier/state.py"}, "content": {"type": ["function"], "name": ["touch_account"], "text": ["Initializes an account to state. Parameters state: The current state. address: The address of the account that need to initialised."]}}, {"source": {"identifier": "ethereum.muir_glacier.state.increment_nonce", "specifier": 0, "path": "src/ethereum/muir_glacier/state.py"}, "content": {"type": ["function"], "name": ["increment_nonce"], "text": ["Increments the nonce of an account. Parameters state: The current state. address: Address of the account whose nonce needs to be incremented."]}}, {"source": {"identifier": "ethereum.muir_glacier.state.set_code", "specifier": 0, "path": "src/ethereum/muir_glacier/state.py"}, "content": {"type": ["function"], "name": ["set_code"], "text": ["Sets Account code. Parameters state: The current state. address: Address of the account whose code needs to be update. code: The bytecode that needs to be set."]}}, {"source": {"identifier": "ethereum.muir_glacier.state.create_ether", "specifier": 0, "path": "src/ethereum/muir_glacier/state.py"}, "content": {"type": ["function"], "name": ["create_ether"], "text": ["Add newly created ether to an account. Parameters state: The current state. address: Address of the account to which ether is added. amount: The amount of ether to be added to the account of interest."]}}, {"source": {"identifier": "ethereum.muir_glacier.state.get_storage_original", "specifier": 0, "path": "src/ethereum/muir_glacier/state.py"}, "content": {"type": ["function"], "name": ["get_storage_original"], "text": ["Get the original value in a storage slot i.e. the value before the current transaction began. This function reads the value from the snapshots taken before executing the transaction. Parameters state: The current state. address: Address of the account to read the value from. key: Key of the storage slot."]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.storage", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/storage.py"}, "content": {"type": ["module"], "name": ["ethereum.dao_fork.vm.instructions.storage"], "text": ["Ethereum Virtual Machine (EVM) Storage Instructions ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementations of the EVM storage related instructions."]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.storage.sload", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/storage.py"}, "content": {"type": ["function"], "name": ["sload"], "text": ["Loads to the stack, the value corresponding to a certain key from the storage of the current account. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.storage.sstore", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/storage.py"}, "content": {"type": ["function"], "name": ["sstore"], "text": ["Stores a value at a certain key in the current context's storage. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.shanghai.vm.exceptions", "specifier": 0, "path": "src/ethereum/shanghai/vm/exceptions.py"}, "content": {"type": ["module"], "name": ["ethereum.shanghai.vm.exceptions"], "text": ["Ethereum Virtual Machine (EVM) Exceptions ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Exceptions which cause the EVM to halt exceptionally."]}}, {"source": {"identifier": "ethereum.shanghai.vm.exceptions.ExceptionalHalt", "specifier": 0, "path": "src/ethereum/shanghai/vm/exceptions.py"}, "content": {"type": ["class"], "name": ["ExceptionalHalt"], "text": ["Indicates that the EVM has experienced an exceptional halt. This causes execution to immediately end with all gas being consumed."]}}, {"source": {"identifier": "ethereum.shanghai.vm.exceptions.Revert", "specifier": 0, "path": "src/ethereum/shanghai/vm/exceptions.py"}, "content": {"type": ["class"], "name": ["Revert"], "text": ["Raised by the  REVERT  opcode. Unlike other EVM exceptions this does not result in the consumption of all gas."]}}, {"source": {"identifier": "ethereum.shanghai.vm.exceptions.StackUnderflowError", "specifier": 0, "path": "src/ethereum/shanghai/vm/exceptions.py"}, "content": {"type": ["class"], "name": ["StackUnderflowError"], "text": ["Occurs when a pop is executed on an empty stack."]}}, {"source": {"identifier": "ethereum.shanghai.vm.exceptions.StackOverflowError", "specifier": 0, "path": "src/ethereum/shanghai/vm/exceptions.py"}, "content": {"type": ["class"], "name": ["StackOverflowError"], "text": ["Occurs when a push is executed on a stack at max capacity."]}}, {"source": {"identifier": "ethereum.shanghai.vm.exceptions.OutOfGasError", "specifier": 0, "path": "src/ethereum/shanghai/vm/exceptions.py"}, "content": {"type": ["class"], "name": ["OutOfGasError"], "text": ["Occurs when an operation costs more than the amount of gas left in the frame."]}}, {"source": {"identifier": "ethereum.shanghai.vm.exceptions.InvalidOpcode", "specifier": 0, "path": "src/ethereum/shanghai/vm/exceptions.py"}, "content": {"type": ["class"], "name": ["InvalidOpcode"], "text": ["Raised when an invalid opcode is encountered."]}}, {"source": {"identifier": "ethereum.shanghai.vm.exceptions.InvalidJumpDestError", "specifier": 0, "path": "src/ethereum/shanghai/vm/exceptions.py"}, "content": {"type": ["class"], "name": ["InvalidJumpDestError"], "text": ["Occurs when the destination of a jump operation doesn't meet any of the following criteria: The jump destination is less than the length of the code. The jump destination should have the  JUMPDEST  opcode (0x5B). The jump destination shouldn't be part of the data corresponding to PUSH-N  opcodes."]}}, {"source": {"identifier": "ethereum.shanghai.vm.exceptions.StackDepthLimitError", "specifier": 0, "path": "src/ethereum/shanghai/vm/exceptions.py"}, "content": {"type": ["class"], "name": ["StackDepthLimitError"], "text": ["Raised when the message depth is greater than  1024"]}}, {"source": {"identifier": "ethereum.shanghai.vm.exceptions.WriteInStaticContext", "specifier": 0, "path": "src/ethereum/shanghai/vm/exceptions.py"}, "content": {"type": ["class"], "name": ["WriteInStaticContext"], "text": ["Raised when an attempt is made to modify the state while operating inside of a STATICCALL context."]}}, {"source": {"identifier": "ethereum.shanghai.vm.exceptions.OutOfBoundsRead", "specifier": 0, "path": "src/ethereum/shanghai/vm/exceptions.py"}, "content": {"type": ["class"], "name": ["OutOfBoundsRead"], "text": ["Raised when an attempt was made to read data beyond the boundaries of the buffer."]}}, {"source": {"identifier": "ethereum.shanghai.vm.exceptions.InvalidParameter", "specifier": 0, "path": "src/ethereum/shanghai/vm/exceptions.py"}, "content": {"type": ["class"], "name": ["InvalidParameter"], "text": ["Raised when invalid parameters are passed."]}}, {"source": {"identifier": "ethereum.shanghai.vm.exceptions.InvalidContractPrefix", "specifier": 0, "path": "src/ethereum/shanghai/vm/exceptions.py"}, "content": {"type": ["class"], "name": ["InvalidContractPrefix"], "text": ["Raised when the new contract code starts with 0xEF."]}}, {"source": {"identifier": "ethereum.muir_glacier", "specifier": 0, "path": "src/ethereum/muir_glacier/__init__.py"}, "content": {"type": ["module"], "name": ["ethereum.muir_glacier"], "text": ["Ethereum Muir Glacier Hardfork ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ The Ninth Ethereum hardfork."]}}, {"source": {"identifier": "ethereum.muir_glacier.MAINNET_FORK_BLOCK", "specifier": 0, "path": "src/ethereum/muir_glacier/__init__.py"}, "content": {"type": ["attribute"], "name": ["MAINNET_FORK_BLOCK"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.block", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/block.py"}, "content": {"type": ["module"], "name": ["ethereum.dao_fork.vm.instructions.block"], "text": ["Ethereum Virtual Machine (EVM) Block Instructions ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementations of the EVM block instructions."]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.block.block_hash", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/block.py"}, "content": {"type": ["function"], "name": ["block_hash"], "text": ["Push the hash of one of the 256 most recent complete blocks onto the stack. The block number to hash is present at the top of the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.block.coinbase", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/block.py"}, "content": {"type": ["function"], "name": ["coinbase"], "text": ["Push the current block's beneficiary address (address of the block miner) onto the stack. Here the current block refers to the block in which the currently executing transaction/call resides. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.block.timestamp", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/block.py"}, "content": {"type": ["function"], "name": ["timestamp"], "text": ["Push the current block's timestamp onto the stack. Here the timestamp being referred is actually the unix timestamp in seconds. Here the current block refers to the block in which the currently executing transaction/call resides. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.block.number", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/block.py"}, "content": {"type": ["function"], "name": ["number"], "text": ["Push the current block's number onto the stack. Here the current block refers to the block in which the currently executing transaction/call resides. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.block.difficulty", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/block.py"}, "content": {"type": ["function"], "name": ["difficulty"], "text": ["Push the current block's difficulty onto the stack. Here the current block refers to the block in which the currently executing transaction/call resides. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.block.gas_limit", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/block.py"}, "content": {"type": ["function"], "name": ["gas_limit"], "text": ["Push the current block's gas limit onto the stack. Here the current block refers to the block in which the currently executing transaction/call resides. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.muir_glacier.bloom", "specifier": 0, "path": "src/ethereum/muir_glacier/bloom.py"}, "content": {"type": ["module"], "name": ["ethereum.muir_glacier.bloom"], "text": ["Ethereum Logs Bloom ^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction This modules defines functions for calculating bloom filters of logs. For the general theory of bloom filters see e.g.  Wikipedia <https://en.wikipedia.org/wiki/Bloom_filter> _. Bloom filters are used to allow for efficient searching of logs by address and/or topic, by rapidly eliminating blocks and reciepts from their search."]}}, {"source": {"identifier": "ethereum.muir_glacier.bloom.add_to_bloom", "specifier": 0, "path": "src/ethereum/muir_glacier/bloom.py"}, "content": {"type": ["function"], "name": ["add_to_bloom"], "text": ["Add a bloom entry to the bloom filter ( bloom ). The number of hash functions used is 3. They are calculated by taking the least significant 11 bits from the first 3 16-bit words of the keccak_256()  hash of  bloom_entry . Parameters bloom : The bloom filter. bloom_entry : An entry which is to be added to bloom filter."]}}, {"source": {"identifier": "ethereum.muir_glacier.bloom.logs_bloom", "specifier": 0, "path": "src/ethereum/muir_glacier/bloom.py"}, "content": {"type": ["function"], "name": ["logs_bloom"], "text": ["Obtain the logs bloom from a list of log entries. The address and each topic of a log are added to the bloom filter. Parameters logs : List of logs for which the logs bloom is to be obtained. Returns logs_bloom :  Bloom The logs bloom obtained which is 256 bytes with some bits set as per the caller address and the log topics."]}}, {"source": {"identifier": "ethereum.shanghai.vm", "specifier": 0, "path": "src/ethereum/shanghai/vm/__init__.py"}, "content": {"type": ["module"], "name": ["ethereum.shanghai.vm"], "text": ["Ethereum Virtual Machine (EVM) ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction The abstract computer which runs the code stored in an .fork_types.Account ."]}}, {"source": {"identifier": "ethereum.shanghai.vm.__all__", "specifier": 0, "path": "src/ethereum/shanghai/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["__all__"]}}, {"source": {"identifier": "ethereum.shanghai.vm.Environment", "specifier": 0, "path": "src/ethereum/shanghai/vm/__init__.py"}, "content": {"type": ["class"], "name": ["Environment"], "text": ["Items external to the virtual machine itself, provided by the environment."]}}, {"source": {"identifier": "ethereum.shanghai.vm.Environment.caller", "specifier": 0, "path": "src/ethereum/shanghai/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["caller"]}}, {"source": {"identifier": "ethereum.shanghai.vm.Environment.block_hashes", "specifier": 0, "path": "src/ethereum/shanghai/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["block_hashes"]}}, {"source": {"identifier": "ethereum.shanghai.vm.Environment.origin", "specifier": 0, "path": "src/ethereum/shanghai/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["origin"]}}, {"source": {"identifier": "ethereum.shanghai.vm.Environment.coinbase", "specifier": 0, "path": "src/ethereum/shanghai/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["coinbase"]}}, {"source": {"identifier": "ethereum.shanghai.vm.Environment.number", "specifier": 0, "path": "src/ethereum/shanghai/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["number"]}}, {"source": {"identifier": "ethereum.shanghai.vm.Environment.base_fee_per_gas", "specifier": 0, "path": "src/ethereum/shanghai/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["base_fee_per_gas"]}}, {"source": {"identifier": "ethereum.shanghai.vm.Environment.gas_limit", "specifier": 0, "path": "src/ethereum/shanghai/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["gas_limit"]}}, {"source": {"identifier": "ethereum.shanghai.vm.Environment.gas_price", "specifier": 0, "path": "src/ethereum/shanghai/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["gas_price"]}}, {"source": {"identifier": "ethereum.shanghai.vm.Environment.time", "specifier": 0, "path": "src/ethereum/shanghai/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["time"]}}, {"source": {"identifier": "ethereum.shanghai.vm.Environment.prev_randao", "specifier": 0, "path": "src/ethereum/shanghai/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["prev_randao"]}}, {"source": {"identifier": "ethereum.shanghai.vm.Environment.state", "specifier": 0, "path": "src/ethereum/shanghai/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["state"]}}, {"source": {"identifier": "ethereum.shanghai.vm.Environment.chain_id", "specifier": 0, "path": "src/ethereum/shanghai/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["chain_id"]}}, {"source": {"identifier": "ethereum.shanghai.vm.Message", "specifier": 0, "path": "src/ethereum/shanghai/vm/__init__.py"}, "content": {"type": ["class"], "name": ["Message"], "text": ["Items that are used by contract creation or message call."]}}, {"source": {"identifier": "ethereum.shanghai.vm.Message.caller", "specifier": 0, "path": "src/ethereum/shanghai/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["caller"]}}, {"source": {"identifier": "ethereum.shanghai.vm.Message.target", "specifier": 0, "path": "src/ethereum/shanghai/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["target"]}}, {"source": {"identifier": "ethereum.shanghai.vm.Message.current_target", "specifier": 0, "path": "src/ethereum/shanghai/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["current_target"]}}, {"source": {"identifier": "ethereum.shanghai.vm.Message.gas", "specifier": 0, "path": "src/ethereum/shanghai/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["gas"]}}, {"source": {"identifier": "ethereum.shanghai.vm.Message.value", "specifier": 0, "path": "src/ethereum/shanghai/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["value"]}}, {"source": {"identifier": "ethereum.shanghai.vm.Message.data", "specifier": 0, "path": "src/ethereum/shanghai/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["data"]}}, {"source": {"identifier": "ethereum.shanghai.vm.Message.code_address", "specifier": 0, "path": "src/ethereum/shanghai/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["code_address"]}}, {"source": {"identifier": "ethereum.shanghai.vm.Message.code", "specifier": 0, "path": "src/ethereum/shanghai/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["code"]}}, {"source": {"identifier": "ethereum.shanghai.vm.Message.depth", "specifier": 0, "path": "src/ethereum/shanghai/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["depth"]}}, {"source": {"identifier": "ethereum.shanghai.vm.Message.should_transfer_value", "specifier": 0, "path": "src/ethereum/shanghai/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["should_transfer_value"]}}, {"source": {"identifier": "ethereum.shanghai.vm.Message.is_static", "specifier": 0, "path": "src/ethereum/shanghai/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["is_static"]}}, {"source": {"identifier": "ethereum.shanghai.vm.Message.accessed_addresses", "specifier": 0, "path": "src/ethereum/shanghai/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["accessed_addresses"]}}, {"source": {"identifier": "ethereum.shanghai.vm.Message.accessed_storage_keys", "specifier": 0, "path": "src/ethereum/shanghai/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["accessed_storage_keys"]}}, {"source": {"identifier": "ethereum.shanghai.vm.Evm", "specifier": 0, "path": "src/ethereum/shanghai/vm/__init__.py"}, "content": {"type": ["class"], "name": ["Evm"], "text": ["The internal state of the virtual machine."]}}, {"source": {"identifier": "ethereum.shanghai.vm.Evm.pc", "specifier": 0, "path": "src/ethereum/shanghai/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["pc"]}}, {"source": {"identifier": "ethereum.shanghai.vm.Evm.stack", "specifier": 0, "path": "src/ethereum/shanghai/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["stack"]}}, {"source": {"identifier": "ethereum.shanghai.vm.Evm.memory", "specifier": 0, "path": "src/ethereum/shanghai/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["memory"]}}, {"source": {"identifier": "ethereum.shanghai.vm.Evm.code", "specifier": 0, "path": "src/ethereum/shanghai/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["code"]}}, {"source": {"identifier": "ethereum.shanghai.vm.Evm.gas_left", "specifier": 0, "path": "src/ethereum/shanghai/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["gas_left"]}}, {"source": {"identifier": "ethereum.shanghai.vm.Evm.env", "specifier": 0, "path": "src/ethereum/shanghai/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["env"]}}, {"source": {"identifier": "ethereum.shanghai.vm.Evm.valid_jump_destinations", "specifier": 0, "path": "src/ethereum/shanghai/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["valid_jump_destinations"]}}, {"source": {"identifier": "ethereum.shanghai.vm.Evm.logs", "specifier": 0, "path": "src/ethereum/shanghai/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["logs"]}}, {"source": {"identifier": "ethereum.shanghai.vm.Evm.refund_counter", "specifier": 0, "path": "src/ethereum/shanghai/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["refund_counter"]}}, {"source": {"identifier": "ethereum.shanghai.vm.Evm.running", "specifier": 0, "path": "src/ethereum/shanghai/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["running"]}}, {"source": {"identifier": "ethereum.shanghai.vm.Evm.message", "specifier": 0, "path": "src/ethereum/shanghai/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["message"]}}, {"source": {"identifier": "ethereum.shanghai.vm.Evm.output", "specifier": 0, "path": "src/ethereum/shanghai/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["output"]}}, {"source": {"identifier": "ethereum.shanghai.vm.Evm.accounts_to_delete", "specifier": 0, "path": "src/ethereum/shanghai/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["accounts_to_delete"]}}, {"source": {"identifier": "ethereum.shanghai.vm.Evm.touched_accounts", "specifier": 0, "path": "src/ethereum/shanghai/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["touched_accounts"]}}, {"source": {"identifier": "ethereum.shanghai.vm.Evm.has_erred", "specifier": 0, "path": "src/ethereum/shanghai/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["has_erred"]}}, {"source": {"identifier": "ethereum.shanghai.vm.Evm.return_data", "specifier": 0, "path": "src/ethereum/shanghai/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["return_data"]}}, {"source": {"identifier": "ethereum.shanghai.vm.Evm.error", "specifier": 0, "path": "src/ethereum/shanghai/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["error"]}}, {"source": {"identifier": "ethereum.shanghai.vm.Evm.accessed_addresses", "specifier": 0, "path": "src/ethereum/shanghai/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["accessed_addresses"]}}, {"source": {"identifier": "ethereum.shanghai.vm.Evm.accessed_storage_keys", "specifier": 0, "path": "src/ethereum/shanghai/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["accessed_storage_keys"]}}, {"source": {"identifier": "ethereum.shanghai.vm.incorporate_child_on_success", "specifier": 0, "path": "src/ethereum/shanghai/vm/__init__.py"}, "content": {"type": ["function"], "name": ["incorporate_child_on_success"], "text": ["Incorporate the state of a successful  child_evm  into the parent  evm . Parameters evm : The parent  EVM . child_evm : The child evm to incorporate."]}}, {"source": {"identifier": "ethereum.shanghai.vm.incorporate_child_on_error", "specifier": 0, "path": "src/ethereum/shanghai/vm/__init__.py"}, "content": {"type": ["function"], "name": ["incorporate_child_on_error"], "text": ["Incorporate the state of an unsuccessful  child_evm  into the parent  evm . Parameters evm : The parent  EVM . child_evm : The child evm to incorporate."]}}, {"source": {"identifier": "ethereum.muir_glacier.fork_types", "specifier": 0, "path": "src/ethereum/muir_glacier/fork_types.py"}, "content": {"type": ["module"], "name": ["ethereum.muir_glacier.fork_types"], "text": ["Ethereum Types ^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Types re-used throughout the specification, which are specific to Ethereum."]}}, {"source": {"identifier": "ethereum.muir_glacier.fork_types.Address", "specifier": 0, "path": "src/ethereum/muir_glacier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["Address"]}}, {"source": {"identifier": "ethereum.muir_glacier.fork_types.Root", "specifier": 0, "path": "src/ethereum/muir_glacier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["Root"]}}, {"source": {"identifier": "ethereum.muir_glacier.fork_types.Bloom", "specifier": 0, "path": "src/ethereum/muir_glacier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["Bloom"]}}, {"source": {"identifier": "ethereum.muir_glacier.fork_types.TX_BASE_COST", "specifier": 0, "path": "src/ethereum/muir_glacier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["TX_BASE_COST"]}}, {"source": {"identifier": "ethereum.muir_glacier.fork_types.TX_DATA_COST_PER_NON_ZERO", "specifier": 0, "path": "src/ethereum/muir_glacier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["TX_DATA_COST_PER_NON_ZERO"]}}, {"source": {"identifier": "ethereum.muir_glacier.fork_types.TX_DATA_COST_PER_ZERO", "specifier": 0, "path": "src/ethereum/muir_glacier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["TX_DATA_COST_PER_ZERO"]}}, {"source": {"identifier": "ethereum.muir_glacier.fork_types.TX_CREATE_COST", "specifier": 0, "path": "src/ethereum/muir_glacier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["TX_CREATE_COST"]}}, {"source": {"identifier": "ethereum.muir_glacier.fork_types.Transaction", "specifier": 0, "path": "src/ethereum/muir_glacier/fork_types.py"}, "content": {"type": ["class"], "name": ["Transaction"], "text": ["Atomic operation performed on the block chain."]}}, {"source": {"identifier": "ethereum.muir_glacier.fork_types.Transaction.nonce", "specifier": 0, "path": "src/ethereum/muir_glacier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["nonce"]}}, {"source": {"identifier": "ethereum.muir_glacier.fork_types.Transaction.gas_price", "specifier": 0, "path": "src/ethereum/muir_glacier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["gas_price"]}}, {"source": {"identifier": "ethereum.muir_glacier.fork_types.Transaction.gas", "specifier": 0, "path": "src/ethereum/muir_glacier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["gas"]}}, {"source": {"identifier": "ethereum.muir_glacier.fork_types.Transaction.to", "specifier": 0, "path": "src/ethereum/muir_glacier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["to"]}}, {"source": {"identifier": "ethereum.muir_glacier.fork_types.Transaction.value", "specifier": 0, "path": "src/ethereum/muir_glacier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["value"]}}, {"source": {"identifier": "ethereum.muir_glacier.fork_types.Transaction.data", "specifier": 0, "path": "src/ethereum/muir_glacier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["data"]}}, {"source": {"identifier": "ethereum.muir_glacier.fork_types.Transaction.v", "specifier": 0, "path": "src/ethereum/muir_glacier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["v"]}}, {"source": {"identifier": "ethereum.muir_glacier.fork_types.Transaction.r", "specifier": 0, "path": "src/ethereum/muir_glacier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["r"]}}, {"source": {"identifier": "ethereum.muir_glacier.fork_types.Transaction.s", "specifier": 0, "path": "src/ethereum/muir_glacier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["s"]}}, {"source": {"identifier": "ethereum.muir_glacier.fork_types.Account", "specifier": 0, "path": "src/ethereum/muir_glacier/fork_types.py"}, "content": {"type": ["class"], "name": ["Account"], "text": ["State associated with an address."]}}, {"source": {"identifier": "ethereum.muir_glacier.fork_types.Account.nonce", "specifier": 0, "path": "src/ethereum/muir_glacier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["nonce"]}}, {"source": {"identifier": "ethereum.muir_glacier.fork_types.Account.balance", "specifier": 0, "path": "src/ethereum/muir_glacier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["balance"]}}, {"source": {"identifier": "ethereum.muir_glacier.fork_types.Account.code", "specifier": 0, "path": "src/ethereum/muir_glacier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["code"]}}, {"source": {"identifier": "ethereum.muir_glacier.fork_types.EMPTY_ACCOUNT", "specifier": 0, "path": "src/ethereum/muir_glacier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["EMPTY_ACCOUNT"]}}, {"source": {"identifier": "ethereum.muir_glacier.fork_types.encode_account", "specifier": 0, "path": "src/ethereum/muir_glacier/fork_types.py"}, "content": {"type": ["function"], "name": ["encode_account"], "text": ["Encode  Account  dataclass. Storage is not stored in the  Account  dataclass, so  Accounts  cannot be encoded with providing a storage root."]}}, {"source": {"identifier": "ethereum.muir_glacier.fork_types.Header", "specifier": 0, "path": "src/ethereum/muir_glacier/fork_types.py"}, "content": {"type": ["class"], "name": ["Header"], "text": ["Header portion of a block on the chain."]}}, {"source": {"identifier": "ethereum.muir_glacier.fork_types.Header.parent_hash", "specifier": 0, "path": "src/ethereum/muir_glacier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["parent_hash"]}}, {"source": {"identifier": "ethereum.muir_glacier.fork_types.Header.ommers_hash", "specifier": 0, "path": "src/ethereum/muir_glacier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["ommers_hash"]}}, {"source": {"identifier": "ethereum.muir_glacier.fork_types.Header.coinbase", "specifier": 0, "path": "src/ethereum/muir_glacier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["coinbase"]}}, {"source": {"identifier": "ethereum.muir_glacier.fork_types.Header.state_root", "specifier": 0, "path": "src/ethereum/muir_glacier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["state_root"]}}, {"source": {"identifier": "ethereum.muir_glacier.fork_types.Header.transactions_root", "specifier": 0, "path": "src/ethereum/muir_glacier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["transactions_root"]}}, {"source": {"identifier": "ethereum.muir_glacier.fork_types.Header.receipt_root", "specifier": 0, "path": "src/ethereum/muir_glacier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["receipt_root"]}}, {"source": {"identifier": "ethereum.muir_glacier.fork_types.Header.bloom", "specifier": 0, "path": "src/ethereum/muir_glacier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["bloom"]}}, {"source": {"identifier": "ethereum.muir_glacier.fork_types.Header.difficulty", "specifier": 0, "path": "src/ethereum/muir_glacier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["difficulty"]}}, {"source": {"identifier": "ethereum.muir_glacier.fork_types.Header.number", "specifier": 0, "path": "src/ethereum/muir_glacier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["number"]}}, {"source": {"identifier": "ethereum.muir_glacier.fork_types.Header.gas_limit", "specifier": 0, "path": "src/ethereum/muir_glacier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["gas_limit"]}}, {"source": {"identifier": "ethereum.muir_glacier.fork_types.Header.gas_used", "specifier": 0, "path": "src/ethereum/muir_glacier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["gas_used"]}}, {"source": {"identifier": "ethereum.muir_glacier.fork_types.Header.timestamp", "specifier": 0, "path": "src/ethereum/muir_glacier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["timestamp"]}}, {"source": {"identifier": "ethereum.muir_glacier.fork_types.Header.extra_data", "specifier": 0, "path": "src/ethereum/muir_glacier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["extra_data"]}}, {"source": {"identifier": "ethereum.muir_glacier.fork_types.Header.mix_digest", "specifier": 0, "path": "src/ethereum/muir_glacier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["mix_digest"]}}, {"source": {"identifier": "ethereum.muir_glacier.fork_types.Header.nonce", "specifier": 0, "path": "src/ethereum/muir_glacier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["nonce"]}}, {"source": {"identifier": "ethereum.muir_glacier.fork_types.Block", "specifier": 0, "path": "src/ethereum/muir_glacier/fork_types.py"}, "content": {"type": ["class"], "name": ["Block"], "text": ["A complete block."]}}, {"source": {"identifier": "ethereum.muir_glacier.fork_types.Block.header", "specifier": 0, "path": "src/ethereum/muir_glacier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["header"]}}, {"source": {"identifier": "ethereum.muir_glacier.fork_types.Block.transactions", "specifier": 0, "path": "src/ethereum/muir_glacier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["transactions"]}}, {"source": {"identifier": "ethereum.muir_glacier.fork_types.Block.ommers", "specifier": 0, "path": "src/ethereum/muir_glacier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["ommers"]}}, {"source": {"identifier": "ethereum.muir_glacier.fork_types.Log", "specifier": 0, "path": "src/ethereum/muir_glacier/fork_types.py"}, "content": {"type": ["class"], "name": ["Log"], "text": ["Data record produced during the execution of a transaction."]}}, {"source": {"identifier": "ethereum.muir_glacier.fork_types.Log.address", "specifier": 0, "path": "src/ethereum/muir_glacier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["address"]}}, {"source": {"identifier": "ethereum.muir_glacier.fork_types.Log.topics", "specifier": 0, "path": "src/ethereum/muir_glacier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["topics"]}}, {"source": {"identifier": "ethereum.muir_glacier.fork_types.Log.data", "specifier": 0, "path": "src/ethereum/muir_glacier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["data"]}}, {"source": {"identifier": "ethereum.muir_glacier.fork_types.Receipt", "specifier": 0, "path": "src/ethereum/muir_glacier/fork_types.py"}, "content": {"type": ["class"], "name": ["Receipt"], "text": ["Result of a transaction."]}}, {"source": {"identifier": "ethereum.muir_glacier.fork_types.Receipt.succeeded", "specifier": 0, "path": "src/ethereum/muir_glacier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["succeeded"]}}, {"source": {"identifier": "ethereum.muir_glacier.fork_types.Receipt.cumulative_gas_used", "specifier": 0, "path": "src/ethereum/muir_glacier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["cumulative_gas_used"]}}, {"source": {"identifier": "ethereum.muir_glacier.fork_types.Receipt.bloom", "specifier": 0, "path": "src/ethereum/muir_glacier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["bloom"]}}, {"source": {"identifier": "ethereum.muir_glacier.fork_types.Receipt.logs", "specifier": 0, "path": "src/ethereum/muir_glacier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["logs"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.arithmetic", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/arithmetic.py"}, "content": {"type": ["module"], "name": ["ethereum.dao_fork.vm.instructions.arithmetic"], "text": ["Ethereum Virtual Machine (EVM) Arithmetic Instructions ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementations of the EVM Arithmetic instructions."]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.arithmetic.add", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/arithmetic.py"}, "content": {"type": ["function"], "name": ["add"], "text": ["Adds the top two elements of the stack together, and pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.arithmetic.sub", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/arithmetic.py"}, "content": {"type": ["function"], "name": ["sub"], "text": ["Subtracts the top two elements of the stack, and pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.arithmetic.mul", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/arithmetic.py"}, "content": {"type": ["function"], "name": ["mul"], "text": ["Multiply the top two elements of the stack, and pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.arithmetic.div", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/arithmetic.py"}, "content": {"type": ["function"], "name": ["div"], "text": ["Integer division of the top two elements of the stack. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.arithmetic.sdiv", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/arithmetic.py"}, "content": {"type": ["function"], "name": ["sdiv"], "text": ["Signed integer division of the top two elements of the stack. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.arithmetic.mod", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/arithmetic.py"}, "content": {"type": ["function"], "name": ["mod"], "text": ["Modulo remainder of the top two elements of the stack. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.arithmetic.smod", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/arithmetic.py"}, "content": {"type": ["function"], "name": ["smod"], "text": ["Signed modulo remainder of the top two elements of the stack. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.arithmetic.addmod", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/arithmetic.py"}, "content": {"type": ["function"], "name": ["addmod"], "text": ["Modulo addition of the top 2 elements with the 3rd element. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.arithmetic.mulmod", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/arithmetic.py"}, "content": {"type": ["function"], "name": ["mulmod"], "text": ["Modulo multiplication of the top 2 elements with the 3rd element. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.arithmetic.exp", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/arithmetic.py"}, "content": {"type": ["function"], "name": ["exp"], "text": ["Exponential operation of the top 2 elements. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.arithmetic.signextend", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/arithmetic.py"}, "content": {"type": ["function"], "name": ["signextend"], "text": ["Sign extend operation. In other words, extend a signed number which fits in N bytes to 32 bytes. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.muir_glacier.trie", "specifier": 0, "path": "src/ethereum/muir_glacier/trie.py"}, "content": {"type": ["module"], "name": ["ethereum.muir_glacier.trie"], "text": ["State Trie ^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction The state trie is the structure responsible for storing .fork_types.Account  objects."]}}, {"source": {"identifier": "ethereum.muir_glacier.trie.EMPTY_TRIE_ROOT", "specifier": 0, "path": "src/ethereum/muir_glacier/trie.py"}, "content": {"type": ["attribute"], "name": ["EMPTY_TRIE_ROOT"]}}, {"source": {"identifier": "ethereum.muir_glacier.trie.Node", "specifier": 0, "path": "src/ethereum/muir_glacier/trie.py"}, "content": {"type": ["attribute"], "name": ["Node"]}}, {"source": {"identifier": "ethereum.muir_glacier.trie.K", "specifier": 0, "path": "src/ethereum/muir_glacier/trie.py"}, "content": {"type": ["attribute"], "name": ["K"]}}, {"source": {"identifier": "ethereum.muir_glacier.trie.V", "specifier": 0, "path": "src/ethereum/muir_glacier/trie.py"}, "content": {"type": ["attribute"], "name": ["V"]}}, {"source": {"identifier": "ethereum.muir_glacier.trie.LeafNode", "specifier": 0, "path": "src/ethereum/muir_glacier/trie.py"}, "content": {"type": ["class"], "name": ["LeafNode"], "text": ["Leaf node in the Merkle Trie"]}}, {"source": {"identifier": "ethereum.muir_glacier.trie.LeafNode.rest_of_key", "specifier": 0, "path": "src/ethereum/muir_glacier/trie.py"}, "content": {"type": ["attribute"], "name": ["rest_of_key"]}}, {"source": {"identifier": "ethereum.muir_glacier.trie.LeafNode.value", "specifier": 0, "path": "src/ethereum/muir_glacier/trie.py"}, "content": {"type": ["attribute"], "name": ["value"]}}, {"source": {"identifier": "ethereum.muir_glacier.trie.ExtensionNode", "specifier": 0, "path": "src/ethereum/muir_glacier/trie.py"}, "content": {"type": ["class"], "name": ["ExtensionNode"], "text": ["Extension node in the Merkle Trie"]}}, {"source": {"identifier": "ethereum.muir_glacier.trie.ExtensionNode.key_segment", "specifier": 0, "path": "src/ethereum/muir_glacier/trie.py"}, "content": {"type": ["attribute"], "name": ["key_segment"]}}, {"source": {"identifier": "ethereum.muir_glacier.trie.ExtensionNode.subnode", "specifier": 0, "path": "src/ethereum/muir_glacier/trie.py"}, "content": {"type": ["attribute"], "name": ["subnode"]}}, {"source": {"identifier": "ethereum.muir_glacier.trie.BranchNode", "specifier": 0, "path": "src/ethereum/muir_glacier/trie.py"}, "content": {"type": ["class"], "name": ["BranchNode"], "text": ["Branch node in the Merkle Trie"]}}, {"source": {"identifier": "ethereum.muir_glacier.trie.BranchNode.subnodes", "specifier": 0, "path": "src/ethereum/muir_glacier/trie.py"}, "content": {"type": ["attribute"], "name": ["subnodes"]}}, {"source": {"identifier": "ethereum.muir_glacier.trie.BranchNode.value", "specifier": 0, "path": "src/ethereum/muir_glacier/trie.py"}, "content": {"type": ["attribute"], "name": ["value"]}}, {"source": {"identifier": "ethereum.muir_glacier.trie.InternalNode", "specifier": 0, "path": "src/ethereum/muir_glacier/trie.py"}, "content": {"type": ["attribute"], "name": ["InternalNode"]}}, {"source": {"identifier": "ethereum.muir_glacier.trie.encode_internal_node", "specifier": 0, "path": "src/ethereum/muir_glacier/trie.py"}, "content": {"type": ["function"], "name": ["encode_internal_node"], "text": ["Encodes a Merkle Trie node into its RLP form. The RLP will then be serialized into a  Bytes  and hashed unless it is less that 32 bytes when serialized. This function also accepts  None , representing the absence of a node, which is encoded to  b\"\" . Parameters node : Optional[InternalNode] The node to encode. Returns encoded :  rlp.RLP The node encoded as RLP."]}}, {"source": {"identifier": "ethereum.muir_glacier.trie.encode_node", "specifier": 0, "path": "src/ethereum/muir_glacier/trie.py"}, "content": {"type": ["function"], "name": ["encode_node"], "text": ["Encode a Node for storage in the Merkle Trie. Currently mostly an unimplemented stub."]}}, {"source": {"identifier": "ethereum.muir_glacier.trie.Trie", "specifier": 0, "path": "src/ethereum/muir_glacier/trie.py"}, "content": {"type": ["class"], "name": ["Trie"], "text": ["The Merkle Trie."]}}, {"source": {"identifier": "ethereum.muir_glacier.trie.Trie.secured", "specifier": 0, "path": "src/ethereum/muir_glacier/trie.py"}, "content": {"type": ["attribute"], "name": ["secured"]}}, {"source": {"identifier": "ethereum.muir_glacier.trie.Trie.default", "specifier": 0, "path": "src/ethereum/muir_glacier/trie.py"}, "content": {"type": ["attribute"], "name": ["default"]}}, {"source": {"identifier": "ethereum.muir_glacier.trie.Trie._data", "specifier": 0, "path": "src/ethereum/muir_glacier/trie.py"}, "content": {"type": ["attribute"], "name": ["_data"]}}, {"source": {"identifier": "ethereum.muir_glacier.trie.copy_trie", "specifier": 0, "path": "src/ethereum/muir_glacier/trie.py"}, "content": {"type": ["function"], "name": ["copy_trie"], "text": ["Create a copy of  trie . Since only frozen objects may be stored in tries, the contents are reused. Parameters trie:  Trie Trie to copy. Returns new_trie :  Trie[K, V] A copy of the trie."]}}, {"source": {"identifier": "ethereum.muir_glacier.trie.trie_set", "specifier": 0, "path": "src/ethereum/muir_glacier/trie.py"}, "content": {"type": ["function"], "name": ["trie_set"], "text": ["Stores an item in a Merkle Trie. This method deletes the key if  value == trie.default , because the Merkle Trie represents the default value by omitting it from the trie. Parameters trie:  Trie Trie to store in. key :  Bytes Key to lookup. value :  V Node to insert at  key ."]}}, {"source": {"identifier": "ethereum.muir_glacier.trie.trie_get", "specifier": 0, "path": "src/ethereum/muir_glacier/trie.py"}, "content": {"type": ["function"], "name": ["trie_get"], "text": ["Gets an item from the Merkle Trie. This method returns  trie.default  if the key is missing. Parameters trie: Trie to lookup in. key : Key to lookup. Returns node :  V Node at  key  in the trie."]}}, {"source": {"identifier": "ethereum.muir_glacier.trie.common_prefix_length", "specifier": 0, "path": "src/ethereum/muir_glacier/trie.py"}, "content": {"type": ["function"], "name": ["common_prefix_length"], "text": ["Find the longest common prefix of two sequences."]}}, {"source": {"identifier": "ethereum.muir_glacier.trie.nibble_list_to_compact", "specifier": 0, "path": "src/ethereum/muir_glacier/trie.py"}, "content": {"type": ["function"], "name": ["nibble_list_to_compact"], "text": ["Compresses nibble-list into a standard byte array with a flag. A nibble-list is a list of byte values no greater than  15 . The flag is encoded in high nibble of the highest byte. The flag nibble can be broken down into two two-bit flags. Highest nibble:: +---+---+----------+--------+\n| _ | _ | is_leaf | parity |\n+---+---+----------+--------+\n  3   2      1         0\n The lowest bit of the nibble encodes the parity of the length of the remaining nibbles --  0  when even and  1  when odd. The second lowest bit is used to distinguish leaf and extension nodes. The other two bits are not used. Parameters x : Array of nibbles. is_leaf : True if this is part of a leaf node, or false if it is an extension node. Returns compressed :  bytearray Compact byte array."]}}, {"source": {"identifier": "ethereum.muir_glacier.trie.bytes_to_nibble_list", "specifier": 0, "path": "src/ethereum/muir_glacier/trie.py"}, "content": {"type": ["function"], "name": ["bytes_to_nibble_list"], "text": ["Converts a  Bytes  into to a sequence of nibbles (bytes with value < 16). Parameters bytes_: The  Bytes  to convert. Returns nibble_list :  Bytes The  Bytes  in nibble-list format."]}}, {"source": {"identifier": "ethereum.muir_glacier.trie._prepare_trie", "specifier": 0, "path": "src/ethereum/muir_glacier/trie.py"}, "content": {"type": ["function"], "name": ["_prepare_trie"], "text": ["Prepares the trie for root calculation. Removes values that are empty, hashes the keys (if  secured == True ) and encodes all the nodes. Parameters trie : The  Trie  to prepare. get_storage_root : Function to get the storage root of an account. Needed to encode Account  objects. Returns out :  Mapping[ethereum.base_types.Bytes, Node] Object with keys mapped to nibble-byte form."]}}, {"source": {"identifier": "ethereum.muir_glacier.trie.root", "specifier": 0, "path": "src/ethereum/muir_glacier/trie.py"}, "content": {"type": ["function"], "name": ["root"], "text": ["Computes the root of a modified merkle patricia trie (MPT). Parameters trie : Trie  to get the root of. get_storage_root : Function to get the storage root of an account. Needed to encode Account  objects. Returns root :  .fork_types.Root MPT root of the underlying key-value pairs."]}}, {"source": {"identifier": "ethereum.muir_glacier.trie.patricialize", "specifier": 0, "path": "src/ethereum/muir_glacier/trie.py"}, "content": {"type": ["function"], "name": ["patricialize"], "text": ["Structural composition function. Used to recursively patricialize and merkleize a dictionary. Includes memoization of the tree structure and hashes. Parameters obj : Underlying trie key-value pairs, with keys in nibble-list format. level : Current trie level. Returns node :  ethereum.base_types.Bytes Root node of  obj ."]}}, {"source": {"identifier": "ethereum.shanghai.vm.runtime", "specifier": 0, "path": "src/ethereum/shanghai/vm/runtime.py"}, "content": {"type": ["module"], "name": ["ethereum.shanghai.vm.runtime"], "text": ["Ethereum Virtual Machine (EVM) Runtime Operations ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Runtime related operations used while executing EVM code."]}}, {"source": {"identifier": "ethereum.shanghai.vm.runtime.get_valid_jump_destinations", "specifier": 0, "path": "src/ethereum/shanghai/vm/runtime.py"}, "content": {"type": ["function"], "name": ["get_valid_jump_destinations"], "text": ["Analyze the evm code to obtain the set of valid jump destinations. Valid jump destinations are defined as follows: * The jump destination is less than the length of the code. * The jump destination should have the  JUMPDEST  opcode (0x5B). * The jump destination shouldn't be part of the data corresponding to PUSH-N  opcodes. Note - Jump destinations are 0-indexed. Parameters code : The EVM code which is to be executed. Returns valid_jump_destinations:  Set[Uint] The set of valid jump destinations in the code."]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.keccak", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/keccak.py"}, "content": {"type": ["module"], "name": ["ethereum.dao_fork.vm.instructions.keccak"], "text": ["Ethereum Virtual Machine (EVM) Keccak Instructions ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementations of the EVM keccak instructions."]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.keccak.keccak", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/keccak.py"}, "content": {"type": ["function"], "name": ["keccak"], "text": ["Pushes to the stack the Keccak-256 hash of a region of memory. This also expands the memory, in case the memory is insufficient to access the data's memory location. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.memory", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/memory.py"}, "content": {"type": ["module"], "name": ["ethereum.gray_glacier.vm.memory"], "text": ["Ethereum Virtual Machine (EVM) Memory ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction EVM memory operations."]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.memory.memory_write", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/memory.py"}, "content": {"type": ["function"], "name": ["memory_write"], "text": ["Writes to memory. Parameters memory : Memory contents of the EVM. start_position : Starting pointer to the memory. value : Data to write to memory."]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.memory.memory_read_bytes", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/memory.py"}, "content": {"type": ["function"], "name": ["memory_read_bytes"], "text": ["Read bytes from memory. Parameters memory : Memory contents of the EVM. start_position : Starting pointer to the memory. size : Size of the data that needs to be read from  start_position . Returns data_bytes : Data read from memory."]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.memory.buffer_read", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/memory.py"}, "content": {"type": ["function"], "name": ["buffer_read"], "text": ["Read bytes from a buffer. Padding with zeros if neccesary. Parameters buffer : Memory contents of the EVM. start_position : Starting pointer to the memory. size : Size of the data that needs to be read from  start_position . Returns data_bytes : Data read from memory."]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.control_flow", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/control_flow.py"}, "content": {"type": ["module"], "name": ["ethereum.arrow_glacier.vm.instructions.control_flow"], "text": ["Ethereum Virtual Machine (EVM) Control Flow Instructions ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementations of the EVM control flow instructions."]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.control_flow.stop", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/control_flow.py"}, "content": {"type": ["function"], "name": ["stop"], "text": ["Stop further execution of EVM code. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.control_flow.jump", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/control_flow.py"}, "content": {"type": ["function"], "name": ["jump"], "text": ["Alter the program counter to the location specified by the top of the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.control_flow.jumpi", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/control_flow.py"}, "content": {"type": ["function"], "name": ["jumpi"], "text": ["Alter the program counter to the specified location if and only if a condition is true. If the condition is not true, then the program counter would increase only by 1. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.control_flow.pc", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/control_flow.py"}, "content": {"type": ["function"], "name": ["pc"], "text": ["Push onto the stack the value of the program counter after reaching the current instruction and without increasing it for the next instruction. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.control_flow.gas_left", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/control_flow.py"}, "content": {"type": ["function"], "name": ["gas_left"], "text": ["Push the amount of available gas (including the corresponding reduction for the cost of this instruction) onto the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.control_flow.jumpdest", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/control_flow.py"}, "content": {"type": ["function"], "name": ["jumpdest"], "text": ["Mark a valid destination for jumps. This is a noop, present only to be used by  JUMP  and  JUMPI  opcodes to verify that their jump is valid. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/__init__.py"}, "content": {"type": ["module"], "name": ["ethereum.byzantium.vm.instructions"], "text": ["EVM Instruction Encoding (Opcodes) ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Machine readable representations of EVM instructions, and a mapping to their implementations."]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.Ops", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/__init__.py"}, "content": {"type": ["class"], "name": ["Ops"], "text": ["Enum for EVM Opcodes"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.Ops.ADD", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["ADD"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.Ops.MUL", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["MUL"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.Ops.SUB", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SUB"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.Ops.DIV", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DIV"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.Ops.SDIV", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SDIV"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.Ops.MOD", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["MOD"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.Ops.SMOD", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SMOD"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.Ops.ADDMOD", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["ADDMOD"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.Ops.MULMOD", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["MULMOD"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.Ops.EXP", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["EXP"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.Ops.SIGNEXTEND", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SIGNEXTEND"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.Ops.LT", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["LT"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.Ops.GT", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["GT"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.Ops.SLT", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SLT"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.Ops.SGT", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SGT"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.Ops.EQ", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["EQ"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.Ops.ISZERO", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["ISZERO"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.Ops.AND", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["AND"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.Ops.OR", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["OR"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.Ops.XOR", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["XOR"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.Ops.NOT", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["NOT"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.Ops.BYTE", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["BYTE"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.Ops.KECCAK", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["KECCAK"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.Ops.ADDRESS", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["ADDRESS"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.Ops.BALANCE", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["BALANCE"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.Ops.ORIGIN", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["ORIGIN"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.Ops.CALLER", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["CALLER"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.Ops.CALLVALUE", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["CALLVALUE"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.Ops.CALLDATALOAD", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["CALLDATALOAD"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.Ops.CALLDATASIZE", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["CALLDATASIZE"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.Ops.CALLDATACOPY", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["CALLDATACOPY"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.Ops.CODESIZE", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["CODESIZE"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.Ops.CODECOPY", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["CODECOPY"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.Ops.GASPRICE", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["GASPRICE"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.Ops.EXTCODESIZE", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["EXTCODESIZE"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.Ops.EXTCODECOPY", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["EXTCODECOPY"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.Ops.RETURNDATASIZE", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["RETURNDATASIZE"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.Ops.RETURNDATACOPY", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["RETURNDATACOPY"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.Ops.BLOCKHASH", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["BLOCKHASH"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.Ops.COINBASE", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["COINBASE"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.Ops.TIMESTAMP", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["TIMESTAMP"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.Ops.NUMBER", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["NUMBER"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.Ops.DIFFICULTY", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DIFFICULTY"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.Ops.GASLIMIT", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["GASLIMIT"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.Ops.STOP", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["STOP"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.Ops.JUMP", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["JUMP"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.Ops.JUMPI", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["JUMPI"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.Ops.PC", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PC"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.Ops.GAS", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["GAS"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.Ops.JUMPDEST", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["JUMPDEST"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.Ops.SLOAD", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SLOAD"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.Ops.SSTORE", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SSTORE"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.Ops.POP", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["POP"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.Ops.PUSH1", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH1"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.Ops.PUSH2", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH2"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.Ops.PUSH3", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH3"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.Ops.PUSH4", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH4"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.Ops.PUSH5", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH5"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.Ops.PUSH6", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH6"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.Ops.PUSH7", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH7"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.Ops.PUSH8", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH8"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.Ops.PUSH9", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH9"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.Ops.PUSH10", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH10"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.Ops.PUSH11", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH11"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.Ops.PUSH12", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH12"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.Ops.PUSH13", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH13"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.Ops.PUSH14", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH14"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.Ops.PUSH15", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH15"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.Ops.PUSH16", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH16"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.Ops.PUSH17", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH17"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.Ops.PUSH18", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH18"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.Ops.PUSH19", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH19"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.Ops.PUSH20", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH20"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.Ops.PUSH21", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH21"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.Ops.PUSH22", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH22"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.Ops.PUSH23", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH23"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.Ops.PUSH24", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH24"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.Ops.PUSH25", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH25"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.Ops.PUSH26", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH26"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.Ops.PUSH27", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH27"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.Ops.PUSH28", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH28"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.Ops.PUSH29", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH29"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.Ops.PUSH30", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH30"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.Ops.PUSH31", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH31"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.Ops.PUSH32", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH32"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.Ops.DUP1", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP1"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.Ops.DUP2", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP2"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.Ops.DUP3", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP3"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.Ops.DUP4", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP4"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.Ops.DUP5", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP5"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.Ops.DUP6", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP6"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.Ops.DUP7", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP7"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.Ops.DUP8", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP8"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.Ops.DUP9", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP9"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.Ops.DUP10", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP10"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.Ops.DUP11", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP11"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.Ops.DUP12", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP12"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.Ops.DUP13", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP13"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.Ops.DUP14", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP14"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.Ops.DUP15", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP15"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.Ops.DUP16", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP16"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.Ops.SWAP1", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP1"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.Ops.SWAP2", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP2"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.Ops.SWAP3", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP3"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.Ops.SWAP4", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP4"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.Ops.SWAP5", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP5"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.Ops.SWAP6", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP6"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.Ops.SWAP7", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP7"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.Ops.SWAP8", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP8"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.Ops.SWAP9", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP9"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.Ops.SWAP10", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP10"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.Ops.SWAP11", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP11"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.Ops.SWAP12", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP12"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.Ops.SWAP13", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP13"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.Ops.SWAP14", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP14"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.Ops.SWAP15", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP15"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.Ops.SWAP16", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP16"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.Ops.MLOAD", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["MLOAD"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.Ops.MSTORE", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["MSTORE"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.Ops.MSTORE8", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["MSTORE8"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.Ops.MSIZE", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["MSIZE"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.Ops.LOG0", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["LOG0"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.Ops.LOG1", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["LOG1"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.Ops.LOG2", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["LOG2"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.Ops.LOG3", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["LOG3"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.Ops.LOG4", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["LOG4"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.Ops.CREATE", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["CREATE"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.Ops.RETURN", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["RETURN"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.Ops.CALL", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["CALL"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.Ops.CALLCODE", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["CALLCODE"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.Ops.DELEGATECALL", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DELEGATECALL"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.Ops.STATICCALL", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["STATICCALL"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.Ops.REVERT", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["REVERT"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.Ops.SELFDESTRUCT", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SELFDESTRUCT"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.op_implementation", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["op_implementation"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.exceptions", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/exceptions.py"}, "content": {"type": ["module"], "name": ["ethereum.gray_glacier.vm.exceptions"], "text": ["Ethereum Virtual Machine (EVM) Exceptions ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Exceptions which cause the EVM to halt exceptionally."]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.exceptions.ExceptionalHalt", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/exceptions.py"}, "content": {"type": ["class"], "name": ["ExceptionalHalt"], "text": ["Indicates that the EVM has experienced an exceptional halt. This causes execution to immediately end with all gas being consumed."]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.exceptions.Revert", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/exceptions.py"}, "content": {"type": ["class"], "name": ["Revert"], "text": ["Raised by the  REVERT  opcode. Unlike other EVM exceptions this does not result in the consumption of all gas."]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.exceptions.StackUnderflowError", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/exceptions.py"}, "content": {"type": ["class"], "name": ["StackUnderflowError"], "text": ["Occurs when a pop is executed on an empty stack."]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.exceptions.StackOverflowError", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/exceptions.py"}, "content": {"type": ["class"], "name": ["StackOverflowError"], "text": ["Occurs when a push is executed on a stack at max capacity."]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.exceptions.OutOfGasError", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/exceptions.py"}, "content": {"type": ["class"], "name": ["OutOfGasError"], "text": ["Occurs when an operation costs more than the amount of gas left in the frame."]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.exceptions.InvalidOpcode", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/exceptions.py"}, "content": {"type": ["class"], "name": ["InvalidOpcode"], "text": ["Raised when an invalid opcode is encountered."]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.exceptions.InvalidJumpDestError", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/exceptions.py"}, "content": {"type": ["class"], "name": ["InvalidJumpDestError"], "text": ["Occurs when the destination of a jump operation doesn't meet any of the following criteria: The jump destination is less than the length of the code. The jump destination should have the  JUMPDEST  opcode (0x5B). The jump destination shouldn't be part of the data corresponding to PUSH-N  opcodes."]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.exceptions.StackDepthLimitError", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/exceptions.py"}, "content": {"type": ["class"], "name": ["StackDepthLimitError"], "text": ["Raised when the message depth is greater than  1024"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.exceptions.WriteInStaticContext", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/exceptions.py"}, "content": {"type": ["class"], "name": ["WriteInStaticContext"], "text": ["Raised when an attempt is made to modify the state while operating inside of a STATICCALL context."]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.exceptions.OutOfBoundsRead", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/exceptions.py"}, "content": {"type": ["class"], "name": ["OutOfBoundsRead"], "text": ["Raised when an attempt was made to read data beyond the boundaries of the buffer."]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.exceptions.InvalidParameter", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/exceptions.py"}, "content": {"type": ["class"], "name": ["InvalidParameter"], "text": ["Raised when invalid parameters are passed."]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.exceptions.InvalidContractPrefix", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/exceptions.py"}, "content": {"type": ["class"], "name": ["InvalidContractPrefix"], "text": ["Raised when the new contract code starts with 0xEF."]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.comparison", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/comparison.py"}, "content": {"type": ["module"], "name": ["ethereum.arrow_glacier.vm.instructions.comparison"], "text": ["Ethereum Virtual Machine (EVM) Comparison Instructions ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementations of the EVM Comparison instructions."]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.comparison.less_than", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/comparison.py"}, "content": {"type": ["function"], "name": ["less_than"], "text": ["Checks if the top element is less than the next top element. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.comparison.signed_less_than", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/comparison.py"}, "content": {"type": ["function"], "name": ["signed_less_than"], "text": ["Signed less-than comparison. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.comparison.greater_than", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/comparison.py"}, "content": {"type": ["function"], "name": ["greater_than"], "text": ["Checks if the top element is greater than the next top element. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.comparison.signed_greater_than", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/comparison.py"}, "content": {"type": ["function"], "name": ["signed_greater_than"], "text": ["Signed greater-than comparison. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.comparison.equal", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/comparison.py"}, "content": {"type": ["function"], "name": ["equal"], "text": ["Checks if the top element is equal to the next top element. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.comparison.is_zero", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/comparison.py"}, "content": {"type": ["function"], "name": ["is_zero"], "text": ["Checks if the top element is equal to 0. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.control_flow", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/control_flow.py"}, "content": {"type": ["module"], "name": ["ethereum.byzantium.vm.instructions.control_flow"], "text": ["Ethereum Virtual Machine (EVM) Control Flow Instructions ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementations of the EVM control flow instructions."]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.control_flow.stop", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/control_flow.py"}, "content": {"type": ["function"], "name": ["stop"], "text": ["Stop further execution of EVM code. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.control_flow.jump", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/control_flow.py"}, "content": {"type": ["function"], "name": ["jump"], "text": ["Alter the program counter to the location specified by the top of the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.control_flow.jumpi", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/control_flow.py"}, "content": {"type": ["function"], "name": ["jumpi"], "text": ["Alter the program counter to the specified location if and only if a condition is true. If the condition is not true, then the program counter would increase only by 1. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.control_flow.pc", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/control_flow.py"}, "content": {"type": ["function"], "name": ["pc"], "text": ["Push onto the stack the value of the program counter after reaching the current instruction and without increasing it for the next instruction. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.control_flow.gas_left", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/control_flow.py"}, "content": {"type": ["function"], "name": ["gas_left"], "text": ["Push the amount of available gas (including the corresponding reduction for the cost of this instruction) onto the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.control_flow.jumpdest", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/control_flow.py"}, "content": {"type": ["function"], "name": ["jumpdest"], "text": ["Mark a valid destination for jumps. This is a noop, present only to be used by  JUMP  and  JUMPI  opcodes to verify that their jump is valid. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.gray_glacier.vm", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/__init__.py"}, "content": {"type": ["module"], "name": ["ethereum.gray_glacier.vm"], "text": ["Ethereum Virtual Machine (EVM) ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction The abstract computer which runs the code stored in an .fork_types.Account ."]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.__all__", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["__all__"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.Environment", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/__init__.py"}, "content": {"type": ["class"], "name": ["Environment"], "text": ["Items external to the virtual machine itself, provided by the environment."]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.Environment.caller", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["caller"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.Environment.block_hashes", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["block_hashes"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.Environment.origin", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["origin"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.Environment.coinbase", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["coinbase"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.Environment.number", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["number"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.Environment.base_fee_per_gas", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["base_fee_per_gas"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.Environment.gas_limit", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["gas_limit"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.Environment.gas_price", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["gas_price"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.Environment.time", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["time"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.Environment.difficulty", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["difficulty"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.Environment.state", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["state"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.Environment.chain_id", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["chain_id"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.Message", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/__init__.py"}, "content": {"type": ["class"], "name": ["Message"], "text": ["Items that are used by contract creation or message call."]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.Message.caller", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["caller"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.Message.target", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["target"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.Message.current_target", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["current_target"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.Message.gas", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["gas"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.Message.value", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["value"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.Message.data", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["data"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.Message.code_address", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["code_address"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.Message.code", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["code"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.Message.depth", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["depth"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.Message.should_transfer_value", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["should_transfer_value"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.Message.is_static", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["is_static"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.Message.accessed_addresses", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["accessed_addresses"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.Message.accessed_storage_keys", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["accessed_storage_keys"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.Evm", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/__init__.py"}, "content": {"type": ["class"], "name": ["Evm"], "text": ["The internal state of the virtual machine."]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.Evm.pc", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["pc"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.Evm.stack", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["stack"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.Evm.memory", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["memory"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.Evm.code", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["code"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.Evm.gas_left", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["gas_left"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.Evm.env", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["env"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.Evm.valid_jump_destinations", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["valid_jump_destinations"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.Evm.logs", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["logs"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.Evm.refund_counter", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["refund_counter"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.Evm.running", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["running"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.Evm.message", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["message"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.Evm.output", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["output"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.Evm.accounts_to_delete", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["accounts_to_delete"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.Evm.touched_accounts", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["touched_accounts"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.Evm.has_erred", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["has_erred"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.Evm.return_data", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["return_data"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.Evm.error", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["error"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.Evm.accessed_addresses", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["accessed_addresses"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.Evm.accessed_storage_keys", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["accessed_storage_keys"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.incorporate_child_on_success", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/__init__.py"}, "content": {"type": ["function"], "name": ["incorporate_child_on_success"], "text": ["Incorporate the state of a successful  child_evm  into the parent  evm . Parameters evm : The parent  EVM . child_evm : The child evm to incorporate."]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.incorporate_child_on_error", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/__init__.py"}, "content": {"type": ["function"], "name": ["incorporate_child_on_error"], "text": ["Incorporate the state of an unsuccessful  child_evm  into the parent  evm . Parameters evm : The parent  EVM . child_evm : The child evm to incorporate."]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.log", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/log.py"}, "content": {"type": ["module"], "name": ["ethereum.arrow_glacier.vm.instructions.log"], "text": ["Ethereum Virtual Machine (EVM) Logging Instructions ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementations of the EVM logging instructions."]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.log.log_n", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/log.py"}, "content": {"type": ["function"], "name": ["log_n"], "text": ["Appends a log entry, having  num_topics  topics, to the evm logs. This will also expand the memory if the data (required by the log entry) corresponding to the memory is not accessible. Parameters evm : The current EVM frame. num_topics : The number of topics to be included in the log entry."]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.log.log0", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/log.py"}, "content": {"type": ["attribute"], "name": ["log0"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.log.log1", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/log.py"}, "content": {"type": ["attribute"], "name": ["log1"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.log.log2", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/log.py"}, "content": {"type": ["attribute"], "name": ["log2"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.log.log3", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/log.py"}, "content": {"type": ["attribute"], "name": ["log3"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.log.log4", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/log.py"}, "content": {"type": ["attribute"], "name": ["log4"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.comparison", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/comparison.py"}, "content": {"type": ["module"], "name": ["ethereum.byzantium.vm.instructions.comparison"], "text": ["Ethereum Virtual Machine (EVM) Comparison Instructions ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementations of the EVM Comparison instructions."]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.comparison.less_than", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/comparison.py"}, "content": {"type": ["function"], "name": ["less_than"], "text": ["Checks if the top element is less than the next top element. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.comparison.signed_less_than", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/comparison.py"}, "content": {"type": ["function"], "name": ["signed_less_than"], "text": ["Signed less-than comparison. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.comparison.greater_than", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/comparison.py"}, "content": {"type": ["function"], "name": ["greater_than"], "text": ["Checks if the top element is greater than the next top element. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.comparison.signed_greater_than", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/comparison.py"}, "content": {"type": ["function"], "name": ["signed_greater_than"], "text": ["Signed greater-than comparison. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.comparison.equal", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/comparison.py"}, "content": {"type": ["function"], "name": ["equal"], "text": ["Checks if the top element is equal to the next top element. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.comparison.is_zero", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/comparison.py"}, "content": {"type": ["function"], "name": ["is_zero"], "text": ["Checks if the top element is equal to 0. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.runtime", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/runtime.py"}, "content": {"type": ["module"], "name": ["ethereum.gray_glacier.vm.runtime"], "text": ["Ethereum Virtual Machine (EVM) Runtime Operations ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Runtime related operations used while executing EVM code."]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.runtime.get_valid_jump_destinations", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/runtime.py"}, "content": {"type": ["function"], "name": ["get_valid_jump_destinations"], "text": ["Analyze the evm code to obtain the set of valid jump destinations. Valid jump destinations are defined as follows: * The jump destination is less than the length of the code. * The jump destination should have the  JUMPDEST  opcode (0x5B). * The jump destination shouldn't be part of the data corresponding to PUSH-N  opcodes. Note - Jump destinations are 0-indexed. Parameters code : The EVM code which is to be executed. Returns valid_jump_destinations:  Set[Uint] The set of valid jump destinations in the code."]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.storage", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/storage.py"}, "content": {"type": ["module"], "name": ["ethereum.arrow_glacier.vm.instructions.storage"], "text": ["Ethereum Virtual Machine (EVM) Storage Instructions ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementations of the EVM storage related instructions."]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.storage.sload", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/storage.py"}, "content": {"type": ["function"], "name": ["sload"], "text": ["Loads to the stack, the value corresponding to a certain key from the storage of the current account. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.storage.sstore", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/storage.py"}, "content": {"type": ["function"], "name": ["sstore"], "text": ["Stores a value at a certain key in the current context's storage. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.log", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/log.py"}, "content": {"type": ["module"], "name": ["ethereum.byzantium.vm.instructions.log"], "text": ["Ethereum Virtual Machine (EVM) Logging Instructions ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementations of the EVM logging instructions."]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.log.log_n", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/log.py"}, "content": {"type": ["function"], "name": ["log_n"], "text": ["Appends a log entry, having  num_topics  topics, to the evm logs. This will also expand the memory if the data (required by the log entry) corresponding to the memory is not accessible. Parameters evm : The current EVM frame. num_topics : The number of topics to be included in the log entry."]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.log.log0", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/log.py"}, "content": {"type": ["attribute"], "name": ["log0"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.log.log1", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/log.py"}, "content": {"type": ["attribute"], "name": ["log1"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.log.log2", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/log.py"}, "content": {"type": ["attribute"], "name": ["log2"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.log.log3", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/log.py"}, "content": {"type": ["attribute"], "name": ["log3"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.log.log4", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/log.py"}, "content": {"type": ["attribute"], "name": ["log4"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.interpreter", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/interpreter.py"}, "content": {"type": ["module"], "name": ["ethereum.gray_glacier.vm.interpreter"], "text": ["Ethereum Virtual Machine (EVM) Interpreter ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction A straightforward interpreter that executes EVM code."]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.interpreter.STACK_DEPTH_LIMIT", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/interpreter.py"}, "content": {"type": ["attribute"], "name": ["STACK_DEPTH_LIMIT"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.interpreter.MAX_CODE_SIZE", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/interpreter.py"}, "content": {"type": ["attribute"], "name": ["MAX_CODE_SIZE"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.interpreter.MessageCallOutput", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/interpreter.py"}, "content": {"type": ["class"], "name": ["MessageCallOutput"], "text": ["Output of a particular message call Contains the following:   1. `gas_left`: remaining gas after execution.\n  2. `refund_counter`: gas to refund after execution.\n  3. `logs`: list of `Log` generated during execution.\n  4. `accounts_to_delete`: Contracts which have self-destructed.\n  5. `touched_accounts`: Accounts that have been touched.\n  6. `has_erred`: True if execution has caused an error.\n"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.interpreter.MessageCallOutput.gas_left", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/interpreter.py"}, "content": {"type": ["attribute"], "name": ["gas_left"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.interpreter.MessageCallOutput.refund_counter", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/interpreter.py"}, "content": {"type": ["attribute"], "name": ["refund_counter"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.interpreter.MessageCallOutput.logs", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/interpreter.py"}, "content": {"type": ["attribute"], "name": ["logs"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.interpreter.MessageCallOutput.accounts_to_delete", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/interpreter.py"}, "content": {"type": ["attribute"], "name": ["accounts_to_delete"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.interpreter.MessageCallOutput.touched_accounts", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/interpreter.py"}, "content": {"type": ["attribute"], "name": ["touched_accounts"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.interpreter.MessageCallOutput.has_erred", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/interpreter.py"}, "content": {"type": ["attribute"], "name": ["has_erred"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.interpreter.process_message_call", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/interpreter.py"}, "content": {"type": ["function"], "name": ["process_message_call"], "text": ["If  message.current  is empty then it creates a smart contract else it executes a call from the  message.caller  to the  message.target . Parameters message : Transaction specific items. env : External items required for EVM execution. Returns output :  MessageCallOutput Output of the message call"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.interpreter.process_create_message", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/interpreter.py"}, "content": {"type": ["function"], "name": ["process_create_message"], "text": ["Executes a call to create a smart contract. Parameters message : Transaction specific items. env : External items required for EVM execution. Returns evm: :py:class: ~ethereum.london.vm.Evm Items containing execution specific objects."]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.interpreter.process_message", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/interpreter.py"}, "content": {"type": ["function"], "name": ["process_message"], "text": ["Executes a call to create a smart contract. Parameters message : Transaction specific items. env : External items required for EVM execution. Returns evm: :py:class: ~ethereum.london.vm.Evm Items containing execution specific objects"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.interpreter.execute_code", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/interpreter.py"}, "content": {"type": ["function"], "name": ["execute_code"], "text": ["Executes bytecode present in the  message . Parameters message : Transaction specific items. env : External items required for EVM execution. Returns evm:  ethereum.vm.EVM Items containing execution specific objects"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.block", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/block.py"}, "content": {"type": ["module"], "name": ["ethereum.arrow_glacier.vm.instructions.block"], "text": ["Ethereum Virtual Machine (EVM) Block Instructions ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementations of the EVM block instructions."]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.block.block_hash", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/block.py"}, "content": {"type": ["function"], "name": ["block_hash"], "text": ["Push the hash of one of the 256 most recent complete blocks onto the stack. The block number to hash is present at the top of the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.block.coinbase", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/block.py"}, "content": {"type": ["function"], "name": ["coinbase"], "text": ["Push the current block's beneficiary address (address of the block miner) onto the stack. Here the current block refers to the block in which the currently executing transaction/call resides. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.block.timestamp", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/block.py"}, "content": {"type": ["function"], "name": ["timestamp"], "text": ["Push the current block's timestamp onto the stack. Here the timestamp being referred is actually the unix timestamp in seconds. Here the current block refers to the block in which the currently executing transaction/call resides. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.block.number", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/block.py"}, "content": {"type": ["function"], "name": ["number"], "text": ["Push the current block's number onto the stack. Here the current block refers to the block in which the currently executing transaction/call resides. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.block.difficulty", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/block.py"}, "content": {"type": ["function"], "name": ["difficulty"], "text": ["Push the current block's difficulty onto the stack. Here the current block refers to the block in which the currently executing transaction/call resides. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.block.gas_limit", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/block.py"}, "content": {"type": ["function"], "name": ["gas_limit"], "text": ["Push the current block's gas limit onto the stack. Here the current block refers to the block in which the currently executing transaction/call resides. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.block.chain_id", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/block.py"}, "content": {"type": ["function"], "name": ["chain_id"], "text": ["Push the chain id onto the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.storage", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/storage.py"}, "content": {"type": ["module"], "name": ["ethereum.byzantium.vm.instructions.storage"], "text": ["Ethereum Virtual Machine (EVM) Storage Instructions ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementations of the EVM storage related instructions."]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.storage.sload", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/storage.py"}, "content": {"type": ["function"], "name": ["sload"], "text": ["Loads to the stack, the value corresponding to a certain key from the storage of the current account. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.storage.sstore", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/storage.py"}, "content": {"type": ["function"], "name": ["sstore"], "text": ["Stores a value at a certain key in the current context's storage. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.stack", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/stack.py"}, "content": {"type": ["module"], "name": ["ethereum.gray_glacier.vm.stack"], "text": ["Ethereum Virtual Machine (EVM) Stack ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementation of the stack operators for the EVM."]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.stack.pop", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/stack.py"}, "content": {"type": ["function"], "name": ["pop"], "text": ["Pops the top item off of  stack . Parameters stack : EVM stack. Returns value :  U256 The top element on the stack."]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.stack.push", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/stack.py"}, "content": {"type": ["function"], "name": ["push"], "text": ["Pushes  value  onto  stack . Parameters stack : EVM stack. value : Item to be pushed onto  stack ."]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.arithmetic", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/arithmetic.py"}, "content": {"type": ["module"], "name": ["ethereum.arrow_glacier.vm.instructions.arithmetic"], "text": ["Ethereum Virtual Machine (EVM) Arithmetic Instructions ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementations of the EVM Arithmetic instructions."]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.arithmetic.add", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/arithmetic.py"}, "content": {"type": ["function"], "name": ["add"], "text": ["Adds the top two elements of the stack together, and pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.arithmetic.sub", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/arithmetic.py"}, "content": {"type": ["function"], "name": ["sub"], "text": ["Subtracts the top two elements of the stack, and pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.arithmetic.mul", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/arithmetic.py"}, "content": {"type": ["function"], "name": ["mul"], "text": ["Multiply the top two elements of the stack, and pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.arithmetic.div", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/arithmetic.py"}, "content": {"type": ["function"], "name": ["div"], "text": ["Integer division of the top two elements of the stack. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.arithmetic.sdiv", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/arithmetic.py"}, "content": {"type": ["function"], "name": ["sdiv"], "text": ["Signed integer division of the top two elements of the stack. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.arithmetic.mod", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/arithmetic.py"}, "content": {"type": ["function"], "name": ["mod"], "text": ["Modulo remainder of the top two elements of the stack. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.arithmetic.smod", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/arithmetic.py"}, "content": {"type": ["function"], "name": ["smod"], "text": ["Signed modulo remainder of the top two elements of the stack. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.arithmetic.addmod", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/arithmetic.py"}, "content": {"type": ["function"], "name": ["addmod"], "text": ["Modulo addition of the top 2 elements with the 3rd element. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.arithmetic.mulmod", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/arithmetic.py"}, "content": {"type": ["function"], "name": ["mulmod"], "text": ["Modulo multiplication of the top 2 elements with the 3rd element. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.arithmetic.exp", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/arithmetic.py"}, "content": {"type": ["function"], "name": ["exp"], "text": ["Exponential operation of the top 2 elements. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.arithmetic.signextend", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/arithmetic.py"}, "content": {"type": ["function"], "name": ["signextend"], "text": ["Sign extend operation. In other words, extend a signed number which fits in N bytes to 32 bytes. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.block", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/block.py"}, "content": {"type": ["module"], "name": ["ethereum.byzantium.vm.instructions.block"], "text": ["Ethereum Virtual Machine (EVM) Block Instructions ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementations of the EVM block instructions."]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.block.block_hash", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/block.py"}, "content": {"type": ["function"], "name": ["block_hash"], "text": ["Push the hash of one of the 256 most recent complete blocks onto the stack. The block number to hash is present at the top of the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.block.coinbase", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/block.py"}, "content": {"type": ["function"], "name": ["coinbase"], "text": ["Push the current block's beneficiary address (address of the block miner) onto the stack. Here the current block refers to the block in which the currently executing transaction/call resides. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.block.timestamp", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/block.py"}, "content": {"type": ["function"], "name": ["timestamp"], "text": ["Push the current block's timestamp onto the stack. Here the timestamp being referred is actually the unix timestamp in seconds. Here the current block refers to the block in which the currently executing transaction/call resides. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.block.number", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/block.py"}, "content": {"type": ["function"], "name": ["number"], "text": ["Push the current block's number onto the stack. Here the current block refers to the block in which the currently executing transaction/call resides. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.block.difficulty", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/block.py"}, "content": {"type": ["function"], "name": ["difficulty"], "text": ["Push the current block's difficulty onto the stack. Here the current block refers to the block in which the currently executing transaction/call resides. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.block.gas_limit", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/block.py"}, "content": {"type": ["function"], "name": ["gas_limit"], "text": ["Push the current block's gas limit onto the stack. Here the current block refers to the block in which the currently executing transaction/call resides. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.gas", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/gas.py"}, "content": {"type": ["module"], "name": ["ethereum.gray_glacier.vm.gas"], "text": ["Ethereum Virtual Machine (EVM) Gas ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction EVM gas constants and calculators."]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.gas.GAS_JUMPDEST", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_JUMPDEST"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.gas.GAS_BASE", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_BASE"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.gas.GAS_VERY_LOW", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_VERY_LOW"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.gas.GAS_STORAGE_SET", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_STORAGE_SET"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.gas.GAS_STORAGE_UPDATE", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_STORAGE_UPDATE"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.gas.GAS_STORAGE_CLEAR_REFUND", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_STORAGE_CLEAR_REFUND"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.gas.GAS_LOW", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_LOW"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.gas.GAS_MID", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_MID"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.gas.GAS_HIGH", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_HIGH"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.gas.GAS_EXPONENTIATION", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_EXPONENTIATION"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.gas.GAS_EXPONENTIATION_PER_BYTE", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_EXPONENTIATION_PER_BYTE"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.gas.GAS_MEMORY", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_MEMORY"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.gas.GAS_KECCAK256", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_KECCAK256"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.gas.GAS_KECCAK256_WORD", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_KECCAK256_WORD"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.gas.GAS_COPY", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_COPY"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.gas.GAS_BLOCK_HASH", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_BLOCK_HASH"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.gas.GAS_LOG", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_LOG"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.gas.GAS_LOG_DATA", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_LOG_DATA"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.gas.GAS_LOG_TOPIC", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_LOG_TOPIC"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.gas.GAS_CREATE", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_CREATE"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.gas.GAS_CODE_DEPOSIT", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_CODE_DEPOSIT"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.gas.GAS_ZERO", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_ZERO"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.gas.GAS_NEW_ACCOUNT", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_NEW_ACCOUNT"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.gas.GAS_CALL_VALUE", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_CALL_VALUE"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.gas.GAS_CALL_STIPEND", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_CALL_STIPEND"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.gas.GAS_SELF_DESTRUCT", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_SELF_DESTRUCT"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.gas.GAS_SELF_DESTRUCT_NEW_ACCOUNT", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_SELF_DESTRUCT_NEW_ACCOUNT"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.gas.GAS_ECRECOVER", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_ECRECOVER"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.gas.GAS_SHA256", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_SHA256"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.gas.GAS_SHA256_WORD", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_SHA256_WORD"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.gas.GAS_RIPEMD160", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_RIPEMD160"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.gas.GAS_RIPEMD160_WORD", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_RIPEMD160_WORD"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.gas.GAS_IDENTITY", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_IDENTITY"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.gas.GAS_IDENTITY_WORD", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_IDENTITY_WORD"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.gas.GAS_RETURN_DATA_COPY", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_RETURN_DATA_COPY"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.gas.GAS_FAST_STEP", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_FAST_STEP"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.gas.GAS_BLAKE2_PER_ROUND", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_BLAKE2_PER_ROUND"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.gas.GAS_COLD_SLOAD", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_COLD_SLOAD"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.gas.GAS_COLD_ACCOUNT_ACCESS", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_COLD_ACCOUNT_ACCESS"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.gas.GAS_WARM_ACCESS", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_WARM_ACCESS"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.gas.ExtendMemory", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/gas.py"}, "content": {"type": ["class"], "name": ["ExtendMemory"], "text": ["Define the parameters for memory extension in opcodes cost :  ethereum.base_types.Uint The gas required to perform the extension expand_by :  ethereum.base_types.Uint The size by which the memory will be extended"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.gas.ExtendMemory.cost", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["cost"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.gas.ExtendMemory.expand_by", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["expand_by"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.gas.MessageCallGas", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/gas.py"}, "content": {"type": ["class"], "name": ["MessageCallGas"], "text": ["Define the gas cost and stipend for executing the call opcodes. cost :  ethereum.base_types.Uint The non-refundable portion of gas reserved for executing the call opcode. stipend :  ethereum.base_types.Uint The portion of gas available to sub-calls that is refundable if not consumed"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.gas.MessageCallGas.cost", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["cost"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.gas.MessageCallGas.stipend", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["stipend"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.gas.charge_gas", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/gas.py"}, "content": {"type": ["function"], "name": ["charge_gas"], "text": ["Subtracts  amount  from  evm.gas_left . Parameters evm : The current EVM. amount : The amount of gas the current operation requires."]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.gas.calculate_memory_gas_cost", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/gas.py"}, "content": {"type": ["function"], "name": ["calculate_memory_gas_cost"], "text": ["Calculates the gas cost for allocating memory to the smallest multiple of 32 bytes, such that the allocated size is at least as big as the given size. Parameters size_in_bytes : The size of the data in bytes. Returns total_gas_cost :  ethereum.base_types.Uint The gas cost for storing data in memory."]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.gas.calculate_gas_extend_memory", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/gas.py"}, "content": {"type": ["function"], "name": ["calculate_gas_extend_memory"], "text": ["Calculates the gas amount to extend memory Parameters memory : Memory contents of the EVM. extensions: List of extensions to be made to the memory. Consists of a tuple of start position and size. Returns extend_memory:  ExtendMemory"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.gas.calculate_message_call_gas", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/gas.py"}, "content": {"type": ["function"], "name": ["calculate_message_call_gas"], "text": ["Calculates the MessageCallGas (cost and stipend) for executing call Opcodes. Parameters value: The amount of  ETH  that needs to be transferred. gas : The amount of gas provided to the message-call. gas_left : The amount of gas left in the current frame. memory_cost : The amount needed to extend the memory in the current frame. extra_gas : The amount of gas needed for transferring value + creating a new account inside a message call. call_stipend : The amount of stipend provided to a message call to execute code while transferring value(ETH). Returns message_call_gas:  MessageCallGas"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.gas.max_message_call_gas", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/gas.py"}, "content": {"type": ["function"], "name": ["max_message_call_gas"], "text": ["Calculates the maximum gas that is allowed for making a message call Parameters gas : The amount of gas provided to the message-call. Returns max_allowed_message_call_gas:  ethereum.base_types.Uint The maximum gas allowed for making the message-call."]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.keccak", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/keccak.py"}, "content": {"type": ["module"], "name": ["ethereum.arrow_glacier.vm.instructions.keccak"], "text": ["Ethereum Virtual Machine (EVM) Keccak Instructions ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementations of the EVM keccak instructions."]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.keccak.keccak", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/keccak.py"}, "content": {"type": ["function"], "name": ["keccak"], "text": ["Pushes to the stack the Keccak-256 hash of a region of memory. This also expands the memory, in case the memory is insufficient to access the data's memory location. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.arithmetic", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/arithmetic.py"}, "content": {"type": ["module"], "name": ["ethereum.byzantium.vm.instructions.arithmetic"], "text": ["Ethereum Virtual Machine (EVM) Arithmetic Instructions ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementations of the EVM Arithmetic instructions."]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.arithmetic.add", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/arithmetic.py"}, "content": {"type": ["function"], "name": ["add"], "text": ["Adds the top two elements of the stack together, and pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.arithmetic.sub", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/arithmetic.py"}, "content": {"type": ["function"], "name": ["sub"], "text": ["Subtracts the top two elements of the stack, and pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.arithmetic.mul", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/arithmetic.py"}, "content": {"type": ["function"], "name": ["mul"], "text": ["Multiply the top two elements of the stack, and pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.arithmetic.div", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/arithmetic.py"}, "content": {"type": ["function"], "name": ["div"], "text": ["Integer division of the top two elements of the stack. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.arithmetic.sdiv", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/arithmetic.py"}, "content": {"type": ["function"], "name": ["sdiv"], "text": ["Signed integer division of the top two elements of the stack. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.arithmetic.mod", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/arithmetic.py"}, "content": {"type": ["function"], "name": ["mod"], "text": ["Modulo remainder of the top two elements of the stack. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.arithmetic.smod", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/arithmetic.py"}, "content": {"type": ["function"], "name": ["smod"], "text": ["Signed modulo remainder of the top two elements of the stack. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.arithmetic.addmod", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/arithmetic.py"}, "content": {"type": ["function"], "name": ["addmod"], "text": ["Modulo addition of the top 2 elements with the 3rd element. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.arithmetic.mulmod", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/arithmetic.py"}, "content": {"type": ["function"], "name": ["mulmod"], "text": ["Modulo multiplication of the top 2 elements with the 3rd element. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.arithmetic.exp", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/arithmetic.py"}, "content": {"type": ["function"], "name": ["exp"], "text": ["Exponential operation of the top 2 elements. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.arithmetic.signextend", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/arithmetic.py"}, "content": {"type": ["function"], "name": ["signextend"], "text": ["Sign extend operation. In other words, extend a signed number which fits in N bytes to 32 bytes. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.precompiled_contracts.blake2f", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/precompiled_contracts/blake2f.py"}, "content": {"type": ["module"], "name": ["ethereum.gray_glacier.vm.precompiled_contracts.blake2f"], "text": ["Ethereum Virtual Machine (EVM) Blake2 PRECOMPILED CONTRACT ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementation of the  Blake2  precompiled contract."]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.precompiled_contracts.blake2f.blake2f", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/precompiled_contracts/blake2f.py"}, "content": {"type": ["function"], "name": ["blake2f"], "text": ["Writes the Blake2 hash to output. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.bitwise", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/bitwise.py"}, "content": {"type": ["module"], "name": ["ethereum.arrow_glacier.vm.instructions.bitwise"], "text": ["Ethereum Virtual Machine (EVM) Bitwise Instructions ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementations of the EVM bitwise instructions."]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.bitwise.bitwise_and", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/bitwise.py"}, "content": {"type": ["function"], "name": ["bitwise_and"], "text": ["Bitwise AND operation of the top 2 elements of the stack. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.bitwise.bitwise_or", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/bitwise.py"}, "content": {"type": ["function"], "name": ["bitwise_or"], "text": ["Bitwise OR operation of the top 2 elements of the stack. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.bitwise.bitwise_xor", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/bitwise.py"}, "content": {"type": ["function"], "name": ["bitwise_xor"], "text": ["Bitwise XOR operation of the top 2 elements of the stack. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.bitwise.bitwise_not", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/bitwise.py"}, "content": {"type": ["function"], "name": ["bitwise_not"], "text": ["Bitwise NOT operation of the top element of the stack. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.bitwise.get_byte", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/bitwise.py"}, "content": {"type": ["function"], "name": ["get_byte"], "text": ["For a word (defined by next top element of the stack), retrieve the Nth byte (0-indexed and defined by top element of stack) from the left (most significant) to right (least significant). Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.bitwise.bitwise_shl", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/bitwise.py"}, "content": {"type": ["function"], "name": ["bitwise_shl"], "text": ["Logical shift left (SHL) operation of the top 2 elements of the stack. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.bitwise.bitwise_shr", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/bitwise.py"}, "content": {"type": ["function"], "name": ["bitwise_shr"], "text": ["Logical shift right (SHR) operation of the top 2 elements of the stack. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.bitwise.bitwise_sar", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/bitwise.py"}, "content": {"type": ["function"], "name": ["bitwise_sar"], "text": ["Arithmetic shift right (SAR) operation of the top 2 elements of the stack. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.keccak", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/keccak.py"}, "content": {"type": ["module"], "name": ["ethereum.byzantium.vm.instructions.keccak"], "text": ["Ethereum Virtual Machine (EVM) Keccak Instructions ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementations of the EVM keccak instructions."]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.keccak.keccak", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/keccak.py"}, "content": {"type": ["function"], "name": ["keccak"], "text": ["Pushes to the stack the Keccak-256 hash of a region of memory. This also expands the memory, in case the memory is insufficient to access the data's memory location. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.precompiled_contracts.mapping", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/precompiled_contracts/mapping.py"}, "content": {"type": ["module"], "name": ["ethereum.gray_glacier.vm.precompiled_contracts.mapping"], "text": ["Precompiled Contract Addresses ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Mapping of precompiled contracts their implementations."]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.precompiled_contracts.mapping.PRE_COMPILED_CONTRACTS", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/precompiled_contracts/mapping.py"}, "content": {"type": ["attribute"], "name": ["PRE_COMPILED_CONTRACTS"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.environment", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/environment.py"}, "content": {"type": ["module"], "name": ["ethereum.arrow_glacier.vm.instructions.environment"], "text": ["Ethereum Virtual Machine (EVM) Environmental Instructions ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementations of the EVM environment related instructions."]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.environment.address", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["address"], "text": ["Pushes the address of the current executing account to the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.environment.balance", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["balance"], "text": ["Pushes the balance of the given account onto the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.environment.origin", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["origin"], "text": ["Pushes the address of the original transaction sender to the stack. The origin address can only be an EOA. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.environment.caller", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["caller"], "text": ["Pushes the address of the caller onto the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.environment.callvalue", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["callvalue"], "text": ["Push the value (in wei) sent with the call onto the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.environment.calldataload", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["calldataload"], "text": ["Push a word (32 bytes) of the input data belonging to the current environment onto the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.environment.calldatasize", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["calldatasize"], "text": ["Push the size of input data in current environment onto the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.environment.calldatacopy", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["calldatacopy"], "text": ["Copy a portion of the input data in current environment to memory. This will also expand the memory, in case that the memory is insufficient to store the data. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.environment.codesize", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["codesize"], "text": ["Push the size of code running in current environment onto the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.environment.codecopy", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["codecopy"], "text": ["Copy a portion of the code in current environment to memory. This will also expand the memory, in case that the memory is insufficient to store the data. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.environment.gasprice", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["gasprice"], "text": ["Push the gas price used in current environment onto the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.environment.extcodesize", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["extcodesize"], "text": ["Push the code size of a given account onto the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.environment.extcodecopy", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["extcodecopy"], "text": ["Copy a portion of an account's code to memory. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.environment.returndatasize", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["returndatasize"], "text": ["Pushes the size of the return data buffer onto the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.environment.returndatacopy", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["returndatacopy"], "text": ["Copies data from the return data buffer code to memory Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.environment.extcodehash", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["extcodehash"], "text": ["Returns the keccak256 hash of a contract\u2019s bytecode Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.environment.self_balance", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["self_balance"], "text": ["Pushes the balance of the current address to the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.environment.base_fee", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["base_fee"], "text": ["Pushes the base fee of the current block on to the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.bitwise", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/bitwise.py"}, "content": {"type": ["module"], "name": ["ethereum.byzantium.vm.instructions.bitwise"], "text": ["Ethereum Virtual Machine (EVM) Bitwise Instructions ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementations of the EVM bitwise instructions."]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.bitwise.bitwise_and", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/bitwise.py"}, "content": {"type": ["function"], "name": ["bitwise_and"], "text": ["Bitwise AND operation of the top 2 elements of the stack. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.bitwise.bitwise_or", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/bitwise.py"}, "content": {"type": ["function"], "name": ["bitwise_or"], "text": ["Bitwise OR operation of the top 2 elements of the stack. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.bitwise.bitwise_xor", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/bitwise.py"}, "content": {"type": ["function"], "name": ["bitwise_xor"], "text": ["Bitwise XOR operation of the top 2 elements of the stack. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.bitwise.bitwise_not", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/bitwise.py"}, "content": {"type": ["function"], "name": ["bitwise_not"], "text": ["Bitwise NOT operation of the top element of the stack. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.bitwise.get_byte", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/bitwise.py"}, "content": {"type": ["function"], "name": ["get_byte"], "text": ["For a word (defined by next top element of the stack), retrieve the Nth byte (0-indexed and defined by top element of stack) from the left (most significant) to right (least significant). Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.precompiled_contracts", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/precompiled_contracts/__init__.py"}, "content": {"type": ["module"], "name": ["ethereum.gray_glacier.vm.precompiled_contracts"], "text": ["Precompiled Contract Addresses ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Addresses of precompiled contracts and mappings to their implementations."]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.precompiled_contracts.__all__", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/precompiled_contracts/__init__.py"}, "content": {"type": ["attribute"], "name": ["__all__"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.precompiled_contracts.ECRECOVER_ADDRESS", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/precompiled_contracts/__init__.py"}, "content": {"type": ["attribute"], "name": ["ECRECOVER_ADDRESS"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.precompiled_contracts.SHA256_ADDRESS", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/precompiled_contracts/__init__.py"}, "content": {"type": ["attribute"], "name": ["SHA256_ADDRESS"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.precompiled_contracts.RIPEMD160_ADDRESS", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/precompiled_contracts/__init__.py"}, "content": {"type": ["attribute"], "name": ["RIPEMD160_ADDRESS"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.precompiled_contracts.IDENTITY_ADDRESS", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/precompiled_contracts/__init__.py"}, "content": {"type": ["attribute"], "name": ["IDENTITY_ADDRESS"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.precompiled_contracts.MODEXP_ADDRESS", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/precompiled_contracts/__init__.py"}, "content": {"type": ["attribute"], "name": ["MODEXP_ADDRESS"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.precompiled_contracts.ALT_BN128_ADD_ADDRESS", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/precompiled_contracts/__init__.py"}, "content": {"type": ["attribute"], "name": ["ALT_BN128_ADD_ADDRESS"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.precompiled_contracts.ALT_BN128_MUL_ADDRESS", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/precompiled_contracts/__init__.py"}, "content": {"type": ["attribute"], "name": ["ALT_BN128_MUL_ADDRESS"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.precompiled_contracts.ALT_BN128_PAIRING_CHECK_ADDRESS", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/precompiled_contracts/__init__.py"}, "content": {"type": ["attribute"], "name": ["ALT_BN128_PAIRING_CHECK_ADDRESS"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.precompiled_contracts.BLAKE2F_ADDRESS", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/precompiled_contracts/__init__.py"}, "content": {"type": ["attribute"], "name": ["BLAKE2F_ADDRESS"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.stack", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/stack.py"}, "content": {"type": ["module"], "name": ["ethereum.arrow_glacier.vm.instructions.stack"], "text": ["Ethereum Virtual Machine (EVM) Stack Instructions ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementations of the EVM stack related instructions."]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.stack.pop", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/stack.py"}, "content": {"type": ["function"], "name": ["pop"], "text": ["Remove item from stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.stack.push_n", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/stack.py"}, "content": {"type": ["function"], "name": ["push_n"], "text": ["Pushes a N-byte immediate onto the stack. Parameters evm : The current EVM frame. num_bytes : The number of immediate bytes to be read from the code and pushed to the stack."]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.stack.dup_n", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/stack.py"}, "content": {"type": ["function"], "name": ["dup_n"], "text": ["Duplicate the Nth stack item (from top of the stack) to the top of stack. Parameters evm : The current EVM frame. item_number : The stack item number (0-indexed from top of stack) to be duplicated to the top of stack."]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.stack.swap_n", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/stack.py"}, "content": {"type": ["function"], "name": ["swap_n"], "text": ["Swap the top and the  item_number  element of the stack, where the top of the stack is position zero. If  item_number  is zero, this function does nothing (which should not be possible, since there is no  SWAP0  instruction). Parameters evm : The current EVM frame. item_number : The stack item number (0-indexed from top of stack) to be swapped with the top of stack element."]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.stack.push1", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push1"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.stack.push2", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push2"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.stack.push3", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push3"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.stack.push4", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push4"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.stack.push5", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push5"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.stack.push6", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push6"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.stack.push7", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push7"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.stack.push8", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push8"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.stack.push9", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push9"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.stack.push10", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push10"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.stack.push11", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push11"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.stack.push12", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push12"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.stack.push13", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push13"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.stack.push14", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push14"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.stack.push15", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push15"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.stack.push16", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push16"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.stack.push17", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push17"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.stack.push18", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push18"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.stack.push19", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push19"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.stack.push20", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push20"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.stack.push21", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push21"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.stack.push22", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push22"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.stack.push23", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push23"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.stack.push24", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push24"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.stack.push25", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push25"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.stack.push26", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push26"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.stack.push27", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push27"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.stack.push28", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push28"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.stack.push29", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push29"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.stack.push30", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push30"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.stack.push31", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push31"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.stack.push32", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push32"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.stack.dup1", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup1"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.stack.dup2", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup2"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.stack.dup3", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup3"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.stack.dup4", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup4"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.stack.dup5", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup5"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.stack.dup6", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup6"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.stack.dup7", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup7"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.stack.dup8", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup8"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.stack.dup9", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup9"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.stack.dup10", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup10"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.stack.dup11", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup11"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.stack.dup12", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup12"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.stack.dup13", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup13"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.stack.dup14", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup14"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.stack.dup15", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup15"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.stack.dup16", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup16"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.stack.swap1", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap1"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.stack.swap2", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap2"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.stack.swap3", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap3"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.stack.swap4", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap4"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.stack.swap5", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap5"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.stack.swap6", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap6"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.stack.swap7", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap7"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.stack.swap8", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap8"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.stack.swap9", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap9"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.stack.swap10", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap10"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.stack.swap11", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap11"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.stack.swap12", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap12"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.stack.swap13", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap13"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.stack.swap14", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap14"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.stack.swap15", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap15"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.stack.swap16", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap16"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.environment", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/environment.py"}, "content": {"type": ["module"], "name": ["ethereum.byzantium.vm.instructions.environment"], "text": ["Ethereum Virtual Machine (EVM) Environmental Instructions ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementations of the EVM environment related instructions."]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.environment.address", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["address"], "text": ["Pushes the address of the current executing account to the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.environment.balance", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["balance"], "text": ["Pushes the balance of the given account onto the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.environment.origin", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["origin"], "text": ["Pushes the address of the original transaction sender to the stack. The origin address can only be an EOA. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.environment.caller", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["caller"], "text": ["Pushes the address of the caller onto the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.environment.callvalue", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["callvalue"], "text": ["Push the value (in wei) sent with the call onto the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.environment.calldataload", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["calldataload"], "text": ["Push a word (32 bytes) of the input data belonging to the current environment onto the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.environment.calldatasize", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["calldatasize"], "text": ["Push the size of input data in current environment onto the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.environment.calldatacopy", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["calldatacopy"], "text": ["Copy a portion of the input data in current environment to memory. This will also expand the memory, in case that the memory is insufficient to store the data. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.environment.codesize", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["codesize"], "text": ["Push the size of code running in current environment onto the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.environment.codecopy", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["codecopy"], "text": ["Copy a portion of the code in current environment to memory. This will also expand the memory, in case that the memory is insufficient to store the data. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.environment.gasprice", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["gasprice"], "text": ["Push the gas price used in current environment onto the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.environment.extcodesize", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["extcodesize"], "text": ["Push the code size of a given account onto the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.environment.extcodecopy", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["extcodecopy"], "text": ["Copy a portion of an account's code to memory. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.environment.returndatasize", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["returndatasize"], "text": ["Pushes the size of the return data buffer onto the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.environment.returndatacopy", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["returndatacopy"], "text": ["Copies data from the return data buffer code to memory Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.precompiled_contracts.alt_bn128", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/precompiled_contracts/alt_bn128.py"}, "content": {"type": ["module"], "name": ["ethereum.gray_glacier.vm.precompiled_contracts.alt_bn128"], "text": ["Ethereum Virtual Machine (EVM) ALT_BN128 CONTRACTS ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementation of the ALT_BN128 precompiled contracts."]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.precompiled_contracts.alt_bn128.alt_bn128_add", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/precompiled_contracts/alt_bn128.py"}, "content": {"type": ["function"], "name": ["alt_bn128_add"], "text": ["The ALT_BN128 addition precompiled contract. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.precompiled_contracts.alt_bn128.alt_bn128_mul", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/precompiled_contracts/alt_bn128.py"}, "content": {"type": ["function"], "name": ["alt_bn128_mul"], "text": ["The ALT_BN128 multiplication precompiled contract. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.precompiled_contracts.alt_bn128.alt_bn128_pairing_check", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/precompiled_contracts/alt_bn128.py"}, "content": {"type": ["function"], "name": ["alt_bn128_pairing_check"], "text": ["The ALT_BN128 pairing check precompiled contract. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.arrow_glacier.utils", "specifier": 0, "path": "src/ethereum/arrow_glacier/utils/__init__.py"}, "content": {"type": ["module"], "name": ["ethereum.arrow_glacier.utils"], "text": ["Hardfork Utility Functions ^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Utility functions used in this arrow_glacier version of specification."]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.stack", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/stack.py"}, "content": {"type": ["module"], "name": ["ethereum.byzantium.vm.instructions.stack"], "text": ["Ethereum Virtual Machine (EVM) Stack Instructions ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementations of the EVM stack related instructions."]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.stack.pop", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/stack.py"}, "content": {"type": ["function"], "name": ["pop"], "text": ["Remove item from stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.stack.push_n", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/stack.py"}, "content": {"type": ["function"], "name": ["push_n"], "text": ["Pushes a N-byte immediate onto the stack. Parameters evm : The current EVM frame. num_bytes : The number of immediate bytes to be read from the code and pushed to the stack."]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.stack.dup_n", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/stack.py"}, "content": {"type": ["function"], "name": ["dup_n"], "text": ["Duplicate the Nth stack item (from top of the stack) to the top of stack. Parameters evm : The current EVM frame. item_number : The stack item number (0-indexed from top of stack) to be duplicated to the top of stack."]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.stack.swap_n", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/stack.py"}, "content": {"type": ["function"], "name": ["swap_n"], "text": ["Swap the top and the  item_number  element of the stack, where the top of the stack is position zero. If  item_number  is zero, this function does nothing (which should not be possible, since there is no  SWAP0  instruction). Parameters evm : The current EVM frame. item_number : The stack item number (0-indexed from top of stack) to be swapped with the top of stack element."]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.stack.push1", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push1"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.stack.push2", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push2"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.stack.push3", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push3"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.stack.push4", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push4"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.stack.push5", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push5"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.stack.push6", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push6"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.stack.push7", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push7"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.stack.push8", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push8"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.stack.push9", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push9"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.stack.push10", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push10"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.stack.push11", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push11"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.stack.push12", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push12"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.stack.push13", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push13"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.stack.push14", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push14"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.stack.push15", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push15"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.stack.push16", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push16"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.stack.push17", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push17"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.stack.push18", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push18"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.stack.push19", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push19"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.stack.push20", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push20"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.stack.push21", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push21"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.stack.push22", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push22"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.stack.push23", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push23"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.stack.push24", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push24"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.stack.push25", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push25"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.stack.push26", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push26"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.stack.push27", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push27"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.stack.push28", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push28"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.stack.push29", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push29"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.stack.push30", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push30"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.stack.push31", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push31"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.stack.push32", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push32"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.stack.dup1", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup1"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.stack.dup2", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup2"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.stack.dup3", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup3"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.stack.dup4", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup4"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.stack.dup5", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup5"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.stack.dup6", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup6"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.stack.dup7", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup7"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.stack.dup8", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup8"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.stack.dup9", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup9"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.stack.dup10", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup10"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.stack.dup11", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup11"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.stack.dup12", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup12"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.stack.dup13", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup13"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.stack.dup14", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup14"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.stack.dup15", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup15"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.stack.dup16", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup16"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.stack.swap1", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap1"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.stack.swap2", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap2"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.stack.swap3", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap3"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.stack.swap4", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap4"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.stack.swap5", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap5"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.stack.swap6", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap6"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.stack.swap7", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap7"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.stack.swap8", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap8"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.stack.swap9", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap9"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.stack.swap10", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap10"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.stack.swap11", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap11"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.stack.swap12", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap12"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.stack.swap13", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap13"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.stack.swap14", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap14"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.stack.swap15", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap15"]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.stack.swap16", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap16"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.precompiled_contracts.ripemd160", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/precompiled_contracts/ripemd160.py"}, "content": {"type": ["module"], "name": ["ethereum.gray_glacier.vm.precompiled_contracts.ripemd160"], "text": ["Ethereum Virtual Machine (EVM) RIPEMD160 PRECOMPILED CONTRACT ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementation of the  RIPEMD160  precompiled contract."]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.precompiled_contracts.ripemd160.ripemd160", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/precompiled_contracts/ripemd160.py"}, "content": {"type": ["function"], "name": ["ripemd160"], "text": ["Writes the ripemd160 hash to output. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.arrow_glacier.utils.address", "specifier": 0, "path": "src/ethereum/arrow_glacier/utils/address.py"}, "content": {"type": ["module"], "name": ["ethereum.arrow_glacier.utils.address"], "text": ["Hardfork Utility Functions For Addresses ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Address specific functions used in this arrow_glacier version of specification."]}}, {"source": {"identifier": "ethereum.arrow_glacier.utils.address.to_address", "specifier": 0, "path": "src/ethereum/arrow_glacier/utils/address.py"}, "content": {"type": ["function"], "name": ["to_address"], "text": ["Convert a Uint or U256 value to a valid address (20 bytes). Parameters data : The string to be converted to bytes. Returns address :  Address The obtained address."]}}, {"source": {"identifier": "ethereum.arrow_glacier.utils.address.compute_contract_address", "specifier": 0, "path": "src/ethereum/arrow_glacier/utils/address.py"}, "content": {"type": ["function"], "name": ["compute_contract_address"], "text": ["Computes address of the new account that needs to be created. Parameters address : The address of the account that wants to create the new account. nonce : The transaction count of the account that wants to create the new account. Returns address:  Address The computed address of the new account."]}}, {"source": {"identifier": "ethereum.arrow_glacier.utils.address.compute_create2_contract_address", "specifier": 0, "path": "src/ethereum/arrow_glacier/utils/address.py"}, "content": {"type": ["function"], "name": ["compute_create2_contract_address"], "text": ["Computes address of the new account that needs to be created, which is based on the sender address, salt and the call data as well. Parameters address : The address of the account that wants to create the new account. salt : Address generation salt. call_data : The code of the new account which is to be created. Returns address:  ethereum.arrow_glacier.fork_types.Address The computed address of the new account."]}}, {"source": {"identifier": "ethereum.byzantium.utils", "specifier": 0, "path": "src/ethereum/byzantium/utils/__init__.py"}, "content": {"type": ["module"], "name": ["ethereum.byzantium.utils"], "text": ["Hardfork Utility Functions ^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Utility functions used in this byzantium version of specification."]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.precompiled_contracts.sha256", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/precompiled_contracts/sha256.py"}, "content": {"type": ["module"], "name": ["ethereum.gray_glacier.vm.precompiled_contracts.sha256"], "text": ["Ethereum Virtual Machine (EVM) SHA256 PRECOMPILED CONTRACT ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementation of the  SHA256  precompiled contract."]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.precompiled_contracts.sha256.sha256", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/precompiled_contracts/sha256.py"}, "content": {"type": ["function"], "name": ["sha256"], "text": ["Writes the sha256 hash to output. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.arrow_glacier.utils.message", "specifier": 0, "path": "src/ethereum/arrow_glacier/utils/message.py"}, "content": {"type": ["module"], "name": ["ethereum.arrow_glacier.utils.message"], "text": ["Hardfork Utility Functions For The Message Data-structure ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Message specific functions used in this arrow_glacier version of specification."]}}, {"source": {"identifier": "ethereum.arrow_glacier.utils.message.prepare_message", "specifier": 0, "path": "src/ethereum/arrow_glacier/utils/message.py"}, "content": {"type": ["function"], "name": ["prepare_message"], "text": ["Execute a transaction against the provided environment. Parameters caller : Address which initiated the transaction target : Address whose code will be executed value : Value to be transferred. data : Array of bytes provided to the code in  target . gas : Gas provided for the code in  target . env : Environment for the Ethereum Virtual Machine. code_address : This is usually same as the  target  address except when an alternative accounts code needs to be executed. eg.  CALLCODE  calling a precompile. should_transfer_value : if True ETH should be transferred while executing a message call. is_static: if True then it prevents all state-changing operations from being executed. preaccessed_addresses: Addresses that should be marked as accessed prior to the message call preaccessed_storage_keys: Storage keys that should be marked as accessed prior to the message call Returns message:  ethereum.arrow_glacier.vm.Message Items containing contract creation or message call specific data."]}}, {"source": {"identifier": "ethereum.byzantium.utils.address", "specifier": 0, "path": "src/ethereum/byzantium/utils/address.py"}, "content": {"type": ["module"], "name": ["ethereum.byzantium.utils.address"], "text": ["Hardfork Utility Functions For Addresses ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Address specific functions used in this byzantium version of specification."]}}, {"source": {"identifier": "ethereum.byzantium.utils.address.to_address", "specifier": 0, "path": "src/ethereum/byzantium/utils/address.py"}, "content": {"type": ["function"], "name": ["to_address"], "text": ["Convert a Uint or U256 value to a valid address (20 bytes). Parameters data : The string to be converted to bytes. Returns address :  Address The obtained address."]}}, {"source": {"identifier": "ethereum.byzantium.utils.address.compute_contract_address", "specifier": 0, "path": "src/ethereum/byzantium/utils/address.py"}, "content": {"type": ["function"], "name": ["compute_contract_address"], "text": ["Computes address of the new account that needs to be created. Parameters address : The address of the account that wants to create the new account. nonce : The transaction count of the account that wants to create the new account. Returns address:  ethereum.byzantium.fork_types.Address The computed address of the new account."]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.precompiled_contracts.modexp", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/precompiled_contracts/modexp.py"}, "content": {"type": ["module"], "name": ["ethereum.gray_glacier.vm.precompiled_contracts.modexp"], "text": ["Ethereum Virtual Machine (EVM) MODEXP PRECOMPILED CONTRACT ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementation of the  MODEXP  precompiled contract."]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.precompiled_contracts.modexp.GQUADDIVISOR", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/precompiled_contracts/modexp.py"}, "content": {"type": ["attribute"], "name": ["GQUADDIVISOR"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.precompiled_contracts.modexp.modexp", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/precompiled_contracts/modexp.py"}, "content": {"type": ["function"], "name": ["modexp"], "text": ["Calculates  (base**exp) % modulus  for arbitary sized  base ,  exp  and. modulus . The return value is the same length as the modulus."]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.precompiled_contracts.modexp.complexity", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/precompiled_contracts/modexp.py"}, "content": {"type": ["function"], "name": ["complexity"], "text": ["Estimate the complexity of performing a modular exponentiation. Parameters base_length : Length of the array representing the base integer. modulus_length : Length of the array representing the modulus integer. Returns complexity :  Uint Complexity of performing the operation."]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.precompiled_contracts.modexp.iterations", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/precompiled_contracts/modexp.py"}, "content": {"type": ["function"], "name": ["iterations"], "text": ["Calculate the number of iterations required to perform a modular exponentiation. Parameters exponent_length : Length of the array representing the exponent integer. exponent_head : First 32 bytes of the exponent (with leading zero padding if it is shorter than 32 bytes), as an unsigned integer. Returns iterations :  Uint Number of iterations."]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.precompiled_contracts.modexp.gas_cost", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/precompiled_contracts/modexp.py"}, "content": {"type": ["function"], "name": ["gas_cost"], "text": ["Calculate the gas cost of performing a modular exponentiation. Parameters base_length : Length of the array representing the base integer. modulus_length : Length of the array representing the modulus integer. exponent_length : Length of the array representing the exponent integer. exponent_head : First 32 bytes of the exponent (with leading zero padding if it is shorter than 32 bytes), as an unsigned integer. Returns gas_cost :  Uint Gas required for performing the operation."]}}, {"source": {"identifier": "ethereum.arrow_glacier.utils.hexadecimal", "specifier": 0, "path": "src/ethereum/arrow_glacier/utils/hexadecimal.py"}, "content": {"type": ["module"], "name": ["ethereum.arrow_glacier.utils.hexadecimal"], "text": ["Utility Functions For Hexadecimal Strings ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Hexadecimal utility functions used in this specification, specific to Arrow Glacier types."]}}, {"source": {"identifier": "ethereum.arrow_glacier.utils.hexadecimal.hex_to_root", "specifier": 0, "path": "src/ethereum/arrow_glacier/utils/hexadecimal.py"}, "content": {"type": ["function"], "name": ["hex_to_root"], "text": ["Convert hex string to trie root. Parameters hex_string : The hexadecimal string to be converted to trie root. Returns root :  Root Trie root obtained from the given hexadecimal string."]}}, {"source": {"identifier": "ethereum.arrow_glacier.utils.hexadecimal.hex_to_bloom", "specifier": 0, "path": "src/ethereum/arrow_glacier/utils/hexadecimal.py"}, "content": {"type": ["function"], "name": ["hex_to_bloom"], "text": ["Convert hex string to bloom. Parameters hex_string : The hexadecimal string to be converted to bloom. Returns bloom :  Bloom Bloom obtained from the given hexadecimal string."]}}, {"source": {"identifier": "ethereum.arrow_glacier.utils.hexadecimal.hex_to_address", "specifier": 0, "path": "src/ethereum/arrow_glacier/utils/hexadecimal.py"}, "content": {"type": ["function"], "name": ["hex_to_address"], "text": ["Convert hex string to Address (20 bytes). Parameters hex_string : The hexadecimal string to be converted to Address. Returns address :  Address The address obtained from the given hexadecimal string."]}}, {"source": {"identifier": "ethereum.istanbul.state", "specifier": 0, "path": "src/ethereum/istanbul/state.py"}, "content": {"type": ["module"], "name": ["ethereum.istanbul.state"], "text": ["State ^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction The state contains all information that is preserved between transactions. It consists of a main account trie and storage tries for each contract. There is a distinction between an account that does not exist and EMPTY_ACCOUNT ."]}}, {"source": {"identifier": "ethereum.istanbul.state.State", "specifier": 0, "path": "src/ethereum/istanbul/state.py"}, "content": {"type": ["class"], "name": ["State"], "text": ["Contains all information that is preserved between transactions."]}}, {"source": {"identifier": "ethereum.istanbul.state.State._main_trie", "specifier": 0, "path": "src/ethereum/istanbul/state.py"}, "content": {"type": ["attribute"], "name": ["_main_trie"]}}, {"source": {"identifier": "ethereum.istanbul.state.State._storage_tries", "specifier": 0, "path": "src/ethereum/istanbul/state.py"}, "content": {"type": ["attribute"], "name": ["_storage_tries"]}}, {"source": {"identifier": "ethereum.istanbul.state.State._snapshots", "specifier": 0, "path": "src/ethereum/istanbul/state.py"}, "content": {"type": ["attribute"], "name": ["_snapshots"]}}, {"source": {"identifier": "ethereum.istanbul.state.close_state", "specifier": 0, "path": "src/ethereum/istanbul/state.py"}, "content": {"type": ["function"], "name": ["close_state"], "text": ["Free resources held by the state. Used by optimized implementations to release file descriptors."]}}, {"source": {"identifier": "ethereum.istanbul.state.begin_transaction", "specifier": 0, "path": "src/ethereum/istanbul/state.py"}, "content": {"type": ["function"], "name": ["begin_transaction"], "text": ["Start a state transaction. Transactions are entirely implicit and can be nested. It is not possible to calculate the state root during a transaction. Parameters state : State The state."]}}, {"source": {"identifier": "ethereum.istanbul.state.commit_transaction", "specifier": 0, "path": "src/ethereum/istanbul/state.py"}, "content": {"type": ["function"], "name": ["commit_transaction"], "text": ["Commit a state transaction. Parameters state : State The state."]}}, {"source": {"identifier": "ethereum.istanbul.state.rollback_transaction", "specifier": 0, "path": "src/ethereum/istanbul/state.py"}, "content": {"type": ["function"], "name": ["rollback_transaction"], "text": ["Rollback a state transaction, resetting the state to the point when the corresponding  start_transaction()  call was made. Parameters state : State The state."]}}, {"source": {"identifier": "ethereum.istanbul.state.get_account", "specifier": 0, "path": "src/ethereum/istanbul/state.py"}, "content": {"type": ["function"], "name": ["get_account"], "text": ["Get the  Account  object at an address. Returns  EMPTY_ACCOUNT  if there is no account at the address. Use  get_account_optional()  if you care about the difference between a non-existent account and  EMPTY_ACCOUNT . Parameters state:  State The state address :  Address Address to lookup. Returns account :  Account Account at address."]}}, {"source": {"identifier": "ethereum.istanbul.state.get_account_optional", "specifier": 0, "path": "src/ethereum/istanbul/state.py"}, "content": {"type": ["function"], "name": ["get_account_optional"], "text": ["Get the  Account  object at an address. Returns  None  (rather than EMPTY_ACCOUNT ) if there is no account at the address. Parameters state:  State The state address :  Address Address to lookup. Returns account :  Account Account at address."]}}, {"source": {"identifier": "ethereum.istanbul.state.set_account", "specifier": 0, "path": "src/ethereum/istanbul/state.py"}, "content": {"type": ["function"], "name": ["set_account"], "text": ["Set the  Account  object at an address. Setting to  None  deletes the account (but not its storage, see  destroy_account() ). Parameters state:  State The state address :  Address Address to set. account :  Account Account to set at address."]}}, {"source": {"identifier": "ethereum.istanbul.state.destroy_account", "specifier": 0, "path": "src/ethereum/istanbul/state.py"}, "content": {"type": ["function"], "name": ["destroy_account"], "text": ["Completely remove the account at  address  and all of its storage. This function is made available exclusively for the  SELFDESTRUCT opcode. It is expected that  SELFDESTRUCT  will be disabled in a future hardfork and this function will be removed. Parameters state:  State The state address :  Address Address of account to destroy."]}}, {"source": {"identifier": "ethereum.istanbul.state.destroy_storage", "specifier": 0, "path": "src/ethereum/istanbul/state.py"}, "content": {"type": ["function"], "name": ["destroy_storage"], "text": ["Completely remove the storage at  address . Parameters state:  State The state address :  Address Address of account whose storage is to be deleted."]}}, {"source": {"identifier": "ethereum.istanbul.state.get_storage", "specifier": 0, "path": "src/ethereum/istanbul/state.py"}, "content": {"type": ["function"], "name": ["get_storage"], "text": ["Get a value at a storage key on an account. Returns  U256(0)  if the storage key has not been set previously. Parameters state:  State The state address :  Address Address of the account. key :  Bytes Key to lookup. Returns value :  U256 Value at the key."]}}, {"source": {"identifier": "ethereum.istanbul.state.set_storage", "specifier": 0, "path": "src/ethereum/istanbul/state.py"}, "content": {"type": ["function"], "name": ["set_storage"], "text": ["Set a value at a storage key on an account. Setting to  U256(0)  deletes the key. Parameters state:  State The state address :  Address Address of the account. key :  Bytes Key to set. value :  U256 Value to set at the key."]}}, {"source": {"identifier": "ethereum.istanbul.state.storage_root", "specifier": 0, "path": "src/ethereum/istanbul/state.py"}, "content": {"type": ["function"], "name": ["storage_root"], "text": ["Calculate the storage root of an account. Parameters state: The state address : Address of the account. Returns root :  Root Storage root of the account."]}}, {"source": {"identifier": "ethereum.istanbul.state.state_root", "specifier": 0, "path": "src/ethereum/istanbul/state.py"}, "content": {"type": ["function"], "name": ["state_root"], "text": ["Calculate the state root. Parameters state: The current state. Returns root :  Root The state root."]}}, {"source": {"identifier": "ethereum.istanbul.state.account_exists", "specifier": 0, "path": "src/ethereum/istanbul/state.py"}, "content": {"type": ["function"], "name": ["account_exists"], "text": ["Checks if an account exists in the state trie Parameters state: The state address: Address of the account that needs to be checked. Returns account_exists :  bool True if account exists in the state trie, False otherwise"]}}, {"source": {"identifier": "ethereum.istanbul.state.account_has_code_or_nonce", "specifier": 0, "path": "src/ethereum/istanbul/state.py"}, "content": {"type": ["function"], "name": ["account_has_code_or_nonce"], "text": ["Checks if an account has non zero nonce or non empty code Parameters state: The state address: Address of the account that needs to be checked. Returns has_code_or_nonce :  bool True if if an account has non zero nonce or non empty code, False otherwise."]}}, {"source": {"identifier": "ethereum.istanbul.state.is_account_empty", "specifier": 0, "path": "src/ethereum/istanbul/state.py"}, "content": {"type": ["function"], "name": ["is_account_empty"], "text": ["Checks if an account has zero nonce, empty code and zero balance. Parameters state: The state address: Address of the account that needs to be checked. Returns is_empty :  bool True if if an account has zero nonce, empty code and zero balance, False otherwise."]}}, {"source": {"identifier": "ethereum.istanbul.state.account_exists_and_is_empty", "specifier": 0, "path": "src/ethereum/istanbul/state.py"}, "content": {"type": ["function"], "name": ["account_exists_and_is_empty"], "text": ["Checks if an account exists and has zero nonce, empty code and zero balance. Parameters state: The state address: Address of the account that needs to be checked. Returns exists_and_is_empty :  bool True if an account exists and has zero nonce, empty code and zero balance, False otherwise."]}}, {"source": {"identifier": "ethereum.istanbul.state.is_account_alive", "specifier": 0, "path": "src/ethereum/istanbul/state.py"}, "content": {"type": ["function"], "name": ["is_account_alive"], "text": ["Check whether is an account is both in the state and non empty. Parameters state: The state address: Address of the account that needs to be checked. Returns is_alive :  bool True if the account is alive."]}}, {"source": {"identifier": "ethereum.istanbul.state.modify_state", "specifier": 0, "path": "src/ethereum/istanbul/state.py"}, "content": {"type": ["function"], "name": ["modify_state"], "text": ["Modify an  Account  in the  State ."]}}, {"source": {"identifier": "ethereum.istanbul.state.move_ether", "specifier": 0, "path": "src/ethereum/istanbul/state.py"}, "content": {"type": ["function"], "name": ["move_ether"], "text": ["Move funds between accounts."]}}, {"source": {"identifier": "ethereum.istanbul.state.set_account_balance", "specifier": 0, "path": "src/ethereum/istanbul/state.py"}, "content": {"type": ["function"], "name": ["set_account_balance"], "text": ["Sets the balance of an account. Parameters state: The current state. address: Address of the account whose nonce needs to be incremented. amount: The amount that needs to set in balance."]}}, {"source": {"identifier": "ethereum.istanbul.state.touch_account", "specifier": 0, "path": "src/ethereum/istanbul/state.py"}, "content": {"type": ["function"], "name": ["touch_account"], "text": ["Initializes an account to state. Parameters state: The current state. address: The address of the account that need to initialised."]}}, {"source": {"identifier": "ethereum.istanbul.state.increment_nonce", "specifier": 0, "path": "src/ethereum/istanbul/state.py"}, "content": {"type": ["function"], "name": ["increment_nonce"], "text": ["Increments the nonce of an account. Parameters state: The current state. address: Address of the account whose nonce needs to be incremented."]}}, {"source": {"identifier": "ethereum.istanbul.state.set_code", "specifier": 0, "path": "src/ethereum/istanbul/state.py"}, "content": {"type": ["function"], "name": ["set_code"], "text": ["Sets Account code. Parameters state: The current state. address: Address of the account whose code needs to be update. code: The bytecode that needs to be set."]}}, {"source": {"identifier": "ethereum.istanbul.state.create_ether", "specifier": 0, "path": "src/ethereum/istanbul/state.py"}, "content": {"type": ["function"], "name": ["create_ether"], "text": ["Add newly created ether to an account. Parameters state: The current state. address: Address of the account to which ether is added. amount: The amount of ether to be added to the account of interest."]}}, {"source": {"identifier": "ethereum.istanbul.state.get_storage_original", "specifier": 0, "path": "src/ethereum/istanbul/state.py"}, "content": {"type": ["function"], "name": ["get_storage_original"], "text": ["Get the original value in a storage slot i.e. the value before the current transaction began. This function reads the value from the snapshots taken before executing the transaction. Parameters state: The current state. address: Address of the account to read the value from. key: Key of the storage slot."]}}, {"source": {"identifier": "ethereum.byzantium.utils.message", "specifier": 0, "path": "src/ethereum/byzantium/utils/message.py"}, "content": {"type": ["module"], "name": ["ethereum.byzantium.utils.message"], "text": ["Hardfork Utility Functions For The Message Data-structure ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Message specific functions used in this byzantium version of specification."]}}, {"source": {"identifier": "ethereum.byzantium.utils.message.prepare_message", "specifier": 0, "path": "src/ethereum/byzantium/utils/message.py"}, "content": {"type": ["function"], "name": ["prepare_message"], "text": ["Execute a transaction against the provided environment. Parameters caller : Address which initiated the transaction target : Address whose code will be executed value : Value to be transferred. data : Array of bytes provided to the code in  target . gas : Gas provided for the code in  target . env : Environment for the Ethereum Virtual Machine. code_address : This is usually same as the  target  address except when an alternative accounts code needs to be executed. eg.  CALLCODE  calling a precompile. should_transfer_value : if True ETH should be transferred while executing a message call. is_static: if True then it prevents all state-changing operations from being executed. Returns message:  ethereum.byzantium.vm.Message Items containing contract creation or message call specific data."]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.precompiled_contracts.ecrecover", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/precompiled_contracts/ecrecover.py"}, "content": {"type": ["module"], "name": ["ethereum.gray_glacier.vm.precompiled_contracts.ecrecover"], "text": ["Ethereum Virtual Machine (EVM) ECRECOVER PRECOMPILED CONTRACT ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementation of the ECRECOVER precompiled contract."]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.precompiled_contracts.ecrecover.ecrecover", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/precompiled_contracts/ecrecover.py"}, "content": {"type": ["function"], "name": ["ecrecover"], "text": ["Decrypts the address using elliptic curve DSA recovery mechanism and writes the address to output. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.istanbul", "specifier": 0, "path": "src/ethereum/istanbul/__init__.py"}, "content": {"type": ["module"], "name": ["ethereum.istanbul"], "text": ["Ethereum Istanbul Hardfork ^^^^^^^^^^^^^^^^^^^^^^^^^^ The Eighth Ethereum hardfork."]}}, {"source": {"identifier": "ethereum.istanbul.MAINNET_FORK_BLOCK", "specifier": 0, "path": "src/ethereum/istanbul/__init__.py"}, "content": {"type": ["attribute"], "name": ["MAINNET_FORK_BLOCK"]}}, {"source": {"identifier": "ethereum.byzantium.utils.hexadecimal", "specifier": 0, "path": "src/ethereum/byzantium/utils/hexadecimal.py"}, "content": {"type": ["module"], "name": ["ethereum.byzantium.utils.hexadecimal"], "text": ["Utility Functions For Hexadecimal Strings ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Hexadecimal utility functions used in this specification, specific to Byzantium types."]}}, {"source": {"identifier": "ethereum.byzantium.utils.hexadecimal.hex_to_root", "specifier": 0, "path": "src/ethereum/byzantium/utils/hexadecimal.py"}, "content": {"type": ["function"], "name": ["hex_to_root"], "text": ["Convert hex string to trie root. Parameters hex_string : The hexadecimal string to be converted to trie root. Returns root :  Root Trie root obtained from the given hexadecimal string."]}}, {"source": {"identifier": "ethereum.byzantium.utils.hexadecimal.hex_to_bloom", "specifier": 0, "path": "src/ethereum/byzantium/utils/hexadecimal.py"}, "content": {"type": ["function"], "name": ["hex_to_bloom"], "text": ["Convert hex string to bloom. Parameters hex_string : The hexadecimal string to be converted to bloom. Returns bloom :  Bloom Bloom obtained from the given hexadecimal string."]}}, {"source": {"identifier": "ethereum.byzantium.utils.hexadecimal.hex_to_address", "specifier": 0, "path": "src/ethereum/byzantium/utils/hexadecimal.py"}, "content": {"type": ["function"], "name": ["hex_to_address"], "text": ["Convert hex string to Address (20 bytes). Parameters hex_string : The hexadecimal string to be converted to Address. Returns address :  Address The address obtained from the given hexadecimal string."]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.precompiled_contracts.identity", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/precompiled_contracts/identity.py"}, "content": {"type": ["module"], "name": ["ethereum.gray_glacier.vm.precompiled_contracts.identity"], "text": ["Ethereum Virtual Machine (EVM) IDENTITY PRECOMPILED CONTRACT ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementation of the  IDENTITY  precompiled contract."]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.precompiled_contracts.identity.identity", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/precompiled_contracts/identity.py"}, "content": {"type": ["function"], "name": ["identity"], "text": ["Writes the message data to output. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.istanbul.bloom", "specifier": 0, "path": "src/ethereum/istanbul/bloom.py"}, "content": {"type": ["module"], "name": ["ethereum.istanbul.bloom"], "text": ["Ethereum Logs Bloom ^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction This modules defines functions for calculating bloom filters of logs. For the general theory of bloom filters see e.g.  Wikipedia <https://en.wikipedia.org/wiki/Bloom_filter> _. Bloom filters are used to allow for efficient searching of logs by address and/or topic, by rapidly eliminating blocks and reciepts from their search."]}}, {"source": {"identifier": "ethereum.istanbul.bloom.add_to_bloom", "specifier": 0, "path": "src/ethereum/istanbul/bloom.py"}, "content": {"type": ["function"], "name": ["add_to_bloom"], "text": ["Add a bloom entry to the bloom filter ( bloom ). The number of hash functions used is 3. They are calculated by taking the least significant 11 bits from the first 3 16-bit words of the keccak_256()  hash of  bloom_entry . Parameters bloom : The bloom filter. bloom_entry : An entry which is to be added to bloom filter."]}}, {"source": {"identifier": "ethereum.istanbul.bloom.logs_bloom", "specifier": 0, "path": "src/ethereum/istanbul/bloom.py"}, "content": {"type": ["function"], "name": ["logs_bloom"], "text": ["Obtain the logs bloom from a list of log entries. The address and each topic of a log are added to the bloom filter. Parameters logs : List of logs for which the logs bloom is to be obtained. Returns logs_bloom :  Bloom The logs bloom obtained which is 256 bytes with some bits set as per the caller address and the log topics."]}}, {"source": {"identifier": "ethereum.crypto.finite_field", "specifier": 0, "path": "src/ethereum/crypto/finite_field.py"}, "content": {"type": ["module"], "name": ["ethereum.crypto.finite_field"], "text": ["Finite Fields ^^^^^^^^^^^^^"]}}, {"source": {"identifier": "ethereum.crypto.finite_field.F", "specifier": 0, "path": "src/ethereum/crypto/finite_field.py"}, "content": {"type": ["attribute"], "name": ["F"]}}, {"source": {"identifier": "ethereum.crypto.finite_field.Field", "specifier": 0, "path": "src/ethereum/crypto/finite_field.py"}, "content": {"type": ["class"], "name": ["Field"], "text": ["A type protocol for defining fields."]}}, {"source": {"identifier": "ethereum.crypto.finite_field.Field.__slots__", "specifier": 0, "path": "src/ethereum/crypto/finite_field.py"}, "content": {"type": ["attribute"], "name": ["__slots__"]}}, {"source": {"identifier": "ethereum.crypto.finite_field.Field.zero", "specifier": 0, "path": "src/ethereum/crypto/finite_field.py"}, "content": {"type": ["function"], "name": ["zero"]}}, {"source": {"identifier": "ethereum.crypto.finite_field.Field.from_int", "specifier": 0, "path": "src/ethereum/crypto/finite_field.py"}, "content": {"type": ["function"], "name": ["from_int"]}}, {"source": {"identifier": "ethereum.crypto.finite_field.Field.__radd__", "specifier": 0, "path": "src/ethereum/crypto/finite_field.py"}, "content": {"type": ["function"], "name": ["__radd__"]}}, {"source": {"identifier": "ethereum.crypto.finite_field.Field.__add__", "specifier": 0, "path": "src/ethereum/crypto/finite_field.py"}, "content": {"type": ["function"], "name": ["__add__"]}}, {"source": {"identifier": "ethereum.crypto.finite_field.Field.__iadd__", "specifier": 0, "path": "src/ethereum/crypto/finite_field.py"}, "content": {"type": ["function"], "name": ["__iadd__"]}}, {"source": {"identifier": "ethereum.crypto.finite_field.Field.__sub__", "specifier": 0, "path": "src/ethereum/crypto/finite_field.py"}, "content": {"type": ["function"], "name": ["__sub__"]}}, {"source": {"identifier": "ethereum.crypto.finite_field.Field.__rsub__", "specifier": 0, "path": "src/ethereum/crypto/finite_field.py"}, "content": {"type": ["function"], "name": ["__rsub__"]}}, {"source": {"identifier": "ethereum.crypto.finite_field.Field.__mul__", "specifier": 0, "path": "src/ethereum/crypto/finite_field.py"}, "content": {"type": ["function"], "name": ["__mul__"]}}, {"source": {"identifier": "ethereum.crypto.finite_field.Field.__rmul__", "specifier": 0, "path": "src/ethereum/crypto/finite_field.py"}, "content": {"type": ["function"], "name": ["__rmul__"]}}, {"source": {"identifier": "ethereum.crypto.finite_field.Field.__imul__", "specifier": 0, "path": "src/ethereum/crypto/finite_field.py"}, "content": {"type": ["function"], "name": ["__imul__"]}}, {"source": {"identifier": "ethereum.crypto.finite_field.Field.__pow__", "specifier": 0, "path": "src/ethereum/crypto/finite_field.py"}, "content": {"type": ["function"], "name": ["__pow__"]}}, {"source": {"identifier": "ethereum.crypto.finite_field.Field.__ipow__", "specifier": 0, "path": "src/ethereum/crypto/finite_field.py"}, "content": {"type": ["function"], "name": ["__ipow__"]}}, {"source": {"identifier": "ethereum.crypto.finite_field.Field.__neg__", "specifier": 0, "path": "src/ethereum/crypto/finite_field.py"}, "content": {"type": ["function"], "name": ["__neg__"]}}, {"source": {"identifier": "ethereum.crypto.finite_field.Field.__truediv__", "specifier": 0, "path": "src/ethereum/crypto/finite_field.py"}, "content": {"type": ["function"], "name": ["__truediv__"]}}, {"source": {"identifier": "ethereum.crypto.finite_field.T", "specifier": 0, "path": "src/ethereum/crypto/finite_field.py"}, "content": {"type": ["attribute"], "name": ["T"]}}, {"source": {"identifier": "ethereum.crypto.finite_field.PrimeField", "specifier": 0, "path": "src/ethereum/crypto/finite_field.py"}, "content": {"type": ["class"], "name": ["PrimeField"], "text": ["Superclass for integers modulo a prime. Not intended to be used directly, but rather to be subclassed."]}}, {"source": {"identifier": "ethereum.crypto.finite_field.PrimeField.__slots__", "specifier": 0, "path": "src/ethereum/crypto/finite_field.py"}, "content": {"type": ["attribute"], "name": ["__slots__"]}}, {"source": {"identifier": "ethereum.crypto.finite_field.PrimeField.PRIME", "specifier": 0, "path": "src/ethereum/crypto/finite_field.py"}, "content": {"type": ["attribute"], "name": ["PRIME"]}}, {"source": {"identifier": "ethereum.crypto.finite_field.PrimeField.from_be_bytes", "specifier": 0, "path": "src/ethereum/crypto/finite_field.py"}, "content": {"type": ["function"], "name": ["from_be_bytes"], "text": ["Converts a sequence of bytes into a element of the field. Parameters buffer : Bytes to decode. Returns self :  T Unsigned integer decoded from  buffer ."]}}, {"source": {"identifier": "ethereum.crypto.finite_field.PrimeField.zero", "specifier": 0, "path": "src/ethereum/crypto/finite_field.py"}, "content": {"type": ["function"], "name": ["zero"]}}, {"source": {"identifier": "ethereum.crypto.finite_field.PrimeField.from_int", "specifier": 0, "path": "src/ethereum/crypto/finite_field.py"}, "content": {"type": ["function"], "name": ["from_int"]}}, {"source": {"identifier": "ethereum.crypto.finite_field.PrimeField.__new__", "specifier": 0, "path": "src/ethereum/crypto/finite_field.py"}, "content": {"type": ["function"], "name": ["__new__"]}}, {"source": {"identifier": "ethereum.crypto.finite_field.PrimeField.__radd__", "specifier": 0, "path": "src/ethereum/crypto/finite_field.py"}, "content": {"type": ["function"], "name": ["__radd__"]}}, {"source": {"identifier": "ethereum.crypto.finite_field.PrimeField.__add__", "specifier": 0, "path": "src/ethereum/crypto/finite_field.py"}, "content": {"type": ["function"], "name": ["__add__"]}}, {"source": {"identifier": "ethereum.crypto.finite_field.PrimeField.__iadd__", "specifier": 0, "path": "src/ethereum/crypto/finite_field.py"}, "content": {"type": ["function"], "name": ["__iadd__"]}}, {"source": {"identifier": "ethereum.crypto.finite_field.PrimeField.__sub__", "specifier": 0, "path": "src/ethereum/crypto/finite_field.py"}, "content": {"type": ["function"], "name": ["__sub__"]}}, {"source": {"identifier": "ethereum.crypto.finite_field.PrimeField.__rsub__", "specifier": 0, "path": "src/ethereum/crypto/finite_field.py"}, "content": {"type": ["function"], "name": ["__rsub__"]}}, {"source": {"identifier": "ethereum.crypto.finite_field.PrimeField.__mul__", "specifier": 0, "path": "src/ethereum/crypto/finite_field.py"}, "content": {"type": ["function"], "name": ["__mul__"]}}, {"source": {"identifier": "ethereum.crypto.finite_field.PrimeField.__rmul__", "specifier": 0, "path": "src/ethereum/crypto/finite_field.py"}, "content": {"type": ["function"], "name": ["__rmul__"]}}, {"source": {"identifier": "ethereum.crypto.finite_field.PrimeField.__imul__", "specifier": 0, "path": "src/ethereum/crypto/finite_field.py"}, "content": {"type": ["function"], "name": ["__imul__"]}}, {"source": {"identifier": "ethereum.crypto.finite_field.PrimeField.__floordiv__", "specifier": 0, "path": "src/ethereum/crypto/finite_field.py"}, "content": {"type": ["attribute"], "name": ["__floordiv__"]}}, {"source": {"identifier": "ethereum.crypto.finite_field.PrimeField.__rfloordiv__", "specifier": 0, "path": "src/ethereum/crypto/finite_field.py"}, "content": {"type": ["attribute"], "name": ["__rfloordiv__"]}}, {"source": {"identifier": "ethereum.crypto.finite_field.PrimeField.__ifloordiv__", "specifier": 0, "path": "src/ethereum/crypto/finite_field.py"}, "content": {"type": ["attribute"], "name": ["__ifloordiv__"]}}, {"source": {"identifier": "ethereum.crypto.finite_field.PrimeField.__divmod__", "specifier": 0, "path": "src/ethereum/crypto/finite_field.py"}, "content": {"type": ["attribute"], "name": ["__divmod__"]}}, {"source": {"identifier": "ethereum.crypto.finite_field.PrimeField.__rdivmod__", "specifier": 0, "path": "src/ethereum/crypto/finite_field.py"}, "content": {"type": ["attribute"], "name": ["__rdivmod__"]}}, {"source": {"identifier": "ethereum.crypto.finite_field.PrimeField.__pow__", "specifier": 0, "path": "src/ethereum/crypto/finite_field.py"}, "content": {"type": ["function"], "name": ["__pow__"]}}, {"source": {"identifier": "ethereum.crypto.finite_field.PrimeField.__rpow__", "specifier": 0, "path": "src/ethereum/crypto/finite_field.py"}, "content": {"type": ["attribute"], "name": ["__rpow__"]}}, {"source": {"identifier": "ethereum.crypto.finite_field.PrimeField.__ipow__", "specifier": 0, "path": "src/ethereum/crypto/finite_field.py"}, "content": {"type": ["function"], "name": ["__ipow__"]}}, {"source": {"identifier": "ethereum.crypto.finite_field.PrimeField.__and__", "specifier": 0, "path": "src/ethereum/crypto/finite_field.py"}, "content": {"type": ["attribute"], "name": ["__and__"]}}, {"source": {"identifier": "ethereum.crypto.finite_field.PrimeField.__or__", "specifier": 0, "path": "src/ethereum/crypto/finite_field.py"}, "content": {"type": ["attribute"], "name": ["__or__"]}}, {"source": {"identifier": "ethereum.crypto.finite_field.PrimeField.__xor__", "specifier": 0, "path": "src/ethereum/crypto/finite_field.py"}, "content": {"type": ["attribute"], "name": ["__xor__"]}}, {"source": {"identifier": "ethereum.crypto.finite_field.PrimeField.__rxor__", "specifier": 0, "path": "src/ethereum/crypto/finite_field.py"}, "content": {"type": ["attribute"], "name": ["__rxor__"]}}, {"source": {"identifier": "ethereum.crypto.finite_field.PrimeField.__ixor__", "specifier": 0, "path": "src/ethereum/crypto/finite_field.py"}, "content": {"type": ["attribute"], "name": ["__ixor__"]}}, {"source": {"identifier": "ethereum.crypto.finite_field.PrimeField.__rshift__", "specifier": 0, "path": "src/ethereum/crypto/finite_field.py"}, "content": {"type": ["attribute"], "name": ["__rshift__"]}}, {"source": {"identifier": "ethereum.crypto.finite_field.PrimeField.__lshift__", "specifier": 0, "path": "src/ethereum/crypto/finite_field.py"}, "content": {"type": ["attribute"], "name": ["__lshift__"]}}, {"source": {"identifier": "ethereum.crypto.finite_field.PrimeField.__irshift__", "specifier": 0, "path": "src/ethereum/crypto/finite_field.py"}, "content": {"type": ["attribute"], "name": ["__irshift__"]}}, {"source": {"identifier": "ethereum.crypto.finite_field.PrimeField.__ilshift__", "specifier": 0, "path": "src/ethereum/crypto/finite_field.py"}, "content": {"type": ["attribute"], "name": ["__ilshift__"]}}, {"source": {"identifier": "ethereum.crypto.finite_field.PrimeField.__neg__", "specifier": 0, "path": "src/ethereum/crypto/finite_field.py"}, "content": {"type": ["function"], "name": ["__neg__"]}}, {"source": {"identifier": "ethereum.crypto.finite_field.PrimeField.__truediv__", "specifier": 0, "path": "src/ethereum/crypto/finite_field.py"}, "content": {"type": ["function"], "name": ["__truediv__"]}}, {"source": {"identifier": "ethereum.crypto.finite_field.PrimeField.multiplicative_inverse", "specifier": 0, "path": "src/ethereum/crypto/finite_field.py"}, "content": {"type": ["function"], "name": ["multiplicative_inverse"]}}, {"source": {"identifier": "ethereum.crypto.finite_field.PrimeField.to_be_bytes32", "specifier": 0, "path": "src/ethereum/crypto/finite_field.py"}, "content": {"type": ["function"], "name": ["to_be_bytes32"], "text": ["Converts this arbitrarily sized unsigned integer into its big endian representation with exactly 32 bytes. Returns big_endian :  Bytes32 Big endian (most significant bits first) representation."]}}, {"source": {"identifier": "ethereum.crypto.finite_field.U", "specifier": 0, "path": "src/ethereum/crypto/finite_field.py"}, "content": {"type": ["attribute"], "name": ["U"]}}, {"source": {"identifier": "ethereum.crypto.finite_field.GaloisField", "specifier": 0, "path": "src/ethereum/crypto/finite_field.py"}, "content": {"type": ["class"], "name": ["GaloisField"], "text": ["Superclass for defining finite fields. Not intended to be used directly, but rather to be subclassed. Fields are represented as  F_p[x]/(x^n + ...)  where the  MODULUS  is a tuple of the non-leading coefficients of the defining polynomial. For example  x^3 + 2x^2 + 3x + 4  is  (2, 3, 4) . In practice the polynomial is likely to be be sparse and you should overload the  __mul__()  function to take advantage of this fact."]}}, {"source": {"identifier": "ethereum.crypto.finite_field.GaloisField.__slots__", "specifier": 0, "path": "src/ethereum/crypto/finite_field.py"}, "content": {"type": ["attribute"], "name": ["__slots__"]}}, {"source": {"identifier": "ethereum.crypto.finite_field.GaloisField.PRIME", "specifier": 0, "path": "src/ethereum/crypto/finite_field.py"}, "content": {"type": ["attribute"], "name": ["PRIME"]}}, {"source": {"identifier": "ethereum.crypto.finite_field.GaloisField.MODULUS", "specifier": 0, "path": "src/ethereum/crypto/finite_field.py"}, "content": {"type": ["attribute"], "name": ["MODULUS"]}}, {"source": {"identifier": "ethereum.crypto.finite_field.GaloisField.FROBENIUS_COEFFICIENTS", "specifier": 0, "path": "src/ethereum/crypto/finite_field.py"}, "content": {"type": ["attribute"], "name": ["FROBENIUS_COEFFICIENTS"]}}, {"source": {"identifier": "ethereum.crypto.finite_field.GaloisField.zero", "specifier": 0, "path": "src/ethereum/crypto/finite_field.py"}, "content": {"type": ["function"], "name": ["zero"]}}, {"source": {"identifier": "ethereum.crypto.finite_field.GaloisField.from_int", "specifier": 0, "path": "src/ethereum/crypto/finite_field.py"}, "content": {"type": ["function"], "name": ["from_int"]}}, {"source": {"identifier": "ethereum.crypto.finite_field.GaloisField.__new__", "specifier": 0, "path": "src/ethereum/crypto/finite_field.py"}, "content": {"type": ["function"], "name": ["__new__"]}}, {"source": {"identifier": "ethereum.crypto.finite_field.GaloisField.__add__", "specifier": 0, "path": "src/ethereum/crypto/finite_field.py"}, "content": {"type": ["function"], "name": ["__add__"]}}, {"source": {"identifier": "ethereum.crypto.finite_field.GaloisField.__radd__", "specifier": 0, "path": "src/ethereum/crypto/finite_field.py"}, "content": {"type": ["function"], "name": ["__radd__"]}}, {"source": {"identifier": "ethereum.crypto.finite_field.GaloisField.__iadd__", "specifier": 0, "path": "src/ethereum/crypto/finite_field.py"}, "content": {"type": ["function"], "name": ["__iadd__"]}}, {"source": {"identifier": "ethereum.crypto.finite_field.GaloisField.__sub__", "specifier": 0, "path": "src/ethereum/crypto/finite_field.py"}, "content": {"type": ["function"], "name": ["__sub__"]}}, {"source": {"identifier": "ethereum.crypto.finite_field.GaloisField.__rsub__", "specifier": 0, "path": "src/ethereum/crypto/finite_field.py"}, "content": {"type": ["function"], "name": ["__rsub__"]}}, {"source": {"identifier": "ethereum.crypto.finite_field.GaloisField.__mul__", "specifier": 0, "path": "src/ethereum/crypto/finite_field.py"}, "content": {"type": ["function"], "name": ["__mul__"]}}, {"source": {"identifier": "ethereum.crypto.finite_field.GaloisField.__rmul__", "specifier": 0, "path": "src/ethereum/crypto/finite_field.py"}, "content": {"type": ["function"], "name": ["__rmul__"]}}, {"source": {"identifier": "ethereum.crypto.finite_field.GaloisField.__imul__", "specifier": 0, "path": "src/ethereum/crypto/finite_field.py"}, "content": {"type": ["function"], "name": ["__imul__"]}}, {"source": {"identifier": "ethereum.crypto.finite_field.GaloisField.__truediv__", "specifier": 0, "path": "src/ethereum/crypto/finite_field.py"}, "content": {"type": ["function"], "name": ["__truediv__"]}}, {"source": {"identifier": "ethereum.crypto.finite_field.GaloisField.__neg__", "specifier": 0, "path": "src/ethereum/crypto/finite_field.py"}, "content": {"type": ["function"], "name": ["__neg__"]}}, {"source": {"identifier": "ethereum.crypto.finite_field.GaloisField.scalar_mul", "specifier": 0, "path": "src/ethereum/crypto/finite_field.py"}, "content": {"type": ["function"], "name": ["scalar_mul"], "text": ["Multiply a field element by a integer. This is faster than using from_int()  and field multiplication."]}}, {"source": {"identifier": "ethereum.crypto.finite_field.GaloisField.deg", "specifier": 0, "path": "src/ethereum/crypto/finite_field.py"}, "content": {"type": ["function"], "name": ["deg"], "text": ["This is a support function for  multiplicative_inverse() ."]}}, {"source": {"identifier": "ethereum.crypto.finite_field.GaloisField.multiplicative_inverse", "specifier": 0, "path": "src/ethereum/crypto/finite_field.py"}, "content": {"type": ["function"], "name": ["multiplicative_inverse"], "text": ["Calculate the multiplicative inverse. Uses the Euclidian algorithm."]}}, {"source": {"identifier": "ethereum.crypto.finite_field.GaloisField.__pow__", "specifier": 0, "path": "src/ethereum/crypto/finite_field.py"}, "content": {"type": ["function"], "name": ["__pow__"]}}, {"source": {"identifier": "ethereum.crypto.finite_field.GaloisField.calculate_frobenius_coefficients", "specifier": 0, "path": "src/ethereum/crypto/finite_field.py"}, "content": {"type": ["function"], "name": ["calculate_frobenius_coefficients"], "text": ["Calculate the coefficients needed by  frobenius() ."]}}, {"source": {"identifier": "ethereum.crypto.finite_field.GaloisField.frobenius", "specifier": 0, "path": "src/ethereum/crypto/finite_field.py"}, "content": {"type": ["function"], "name": ["frobenius"], "text": ["Returns  self ** p . This function is known as the Frobenius endomorphism and has many special mathematical properties. In particular it is extremely cheap to compute compared to other exponentiations."]}}, {"source": {"identifier": "ethereum.istanbul.fork_types", "specifier": 0, "path": "src/ethereum/istanbul/fork_types.py"}, "content": {"type": ["module"], "name": ["ethereum.istanbul.fork_types"], "text": ["Ethereum Types ^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Types re-used throughout the specification, which are specific to Ethereum."]}}, {"source": {"identifier": "ethereum.istanbul.fork_types.Address", "specifier": 0, "path": "src/ethereum/istanbul/fork_types.py"}, "content": {"type": ["attribute"], "name": ["Address"]}}, {"source": {"identifier": "ethereum.istanbul.fork_types.Root", "specifier": 0, "path": "src/ethereum/istanbul/fork_types.py"}, "content": {"type": ["attribute"], "name": ["Root"]}}, {"source": {"identifier": "ethereum.istanbul.fork_types.Bloom", "specifier": 0, "path": "src/ethereum/istanbul/fork_types.py"}, "content": {"type": ["attribute"], "name": ["Bloom"]}}, {"source": {"identifier": "ethereum.istanbul.fork_types.TX_BASE_COST", "specifier": 0, "path": "src/ethereum/istanbul/fork_types.py"}, "content": {"type": ["attribute"], "name": ["TX_BASE_COST"]}}, {"source": {"identifier": "ethereum.istanbul.fork_types.TX_DATA_COST_PER_NON_ZERO", "specifier": 0, "path": "src/ethereum/istanbul/fork_types.py"}, "content": {"type": ["attribute"], "name": ["TX_DATA_COST_PER_NON_ZERO"]}}, {"source": {"identifier": "ethereum.istanbul.fork_types.TX_DATA_COST_PER_ZERO", "specifier": 0, "path": "src/ethereum/istanbul/fork_types.py"}, "content": {"type": ["attribute"], "name": ["TX_DATA_COST_PER_ZERO"]}}, {"source": {"identifier": "ethereum.istanbul.fork_types.TX_CREATE_COST", "specifier": 0, "path": "src/ethereum/istanbul/fork_types.py"}, "content": {"type": ["attribute"], "name": ["TX_CREATE_COST"]}}, {"source": {"identifier": "ethereum.istanbul.fork_types.Transaction", "specifier": 0, "path": "src/ethereum/istanbul/fork_types.py"}, "content": {"type": ["class"], "name": ["Transaction"], "text": ["Atomic operation performed on the block chain."]}}, {"source": {"identifier": "ethereum.istanbul.fork_types.Transaction.nonce", "specifier": 0, "path": "src/ethereum/istanbul/fork_types.py"}, "content": {"type": ["attribute"], "name": ["nonce"]}}, {"source": {"identifier": "ethereum.istanbul.fork_types.Transaction.gas_price", "specifier": 0, "path": "src/ethereum/istanbul/fork_types.py"}, "content": {"type": ["attribute"], "name": ["gas_price"]}}, {"source": {"identifier": "ethereum.istanbul.fork_types.Transaction.gas", "specifier": 0, "path": "src/ethereum/istanbul/fork_types.py"}, "content": {"type": ["attribute"], "name": ["gas"]}}, {"source": {"identifier": "ethereum.istanbul.fork_types.Transaction.to", "specifier": 0, "path": "src/ethereum/istanbul/fork_types.py"}, "content": {"type": ["attribute"], "name": ["to"]}}, {"source": {"identifier": "ethereum.istanbul.fork_types.Transaction.value", "specifier": 0, "path": "src/ethereum/istanbul/fork_types.py"}, "content": {"type": ["attribute"], "name": ["value"]}}, {"source": {"identifier": "ethereum.istanbul.fork_types.Transaction.data", "specifier": 0, "path": "src/ethereum/istanbul/fork_types.py"}, "content": {"type": ["attribute"], "name": ["data"]}}, {"source": {"identifier": "ethereum.istanbul.fork_types.Transaction.v", "specifier": 0, "path": "src/ethereum/istanbul/fork_types.py"}, "content": {"type": ["attribute"], "name": ["v"]}}, {"source": {"identifier": "ethereum.istanbul.fork_types.Transaction.r", "specifier": 0, "path": "src/ethereum/istanbul/fork_types.py"}, "content": {"type": ["attribute"], "name": ["r"]}}, {"source": {"identifier": "ethereum.istanbul.fork_types.Transaction.s", "specifier": 0, "path": "src/ethereum/istanbul/fork_types.py"}, "content": {"type": ["attribute"], "name": ["s"]}}, {"source": {"identifier": "ethereum.istanbul.fork_types.Account", "specifier": 0, "path": "src/ethereum/istanbul/fork_types.py"}, "content": {"type": ["class"], "name": ["Account"], "text": ["State associated with an address."]}}, {"source": {"identifier": "ethereum.istanbul.fork_types.Account.nonce", "specifier": 0, "path": "src/ethereum/istanbul/fork_types.py"}, "content": {"type": ["attribute"], "name": ["nonce"]}}, {"source": {"identifier": "ethereum.istanbul.fork_types.Account.balance", "specifier": 0, "path": "src/ethereum/istanbul/fork_types.py"}, "content": {"type": ["attribute"], "name": ["balance"]}}, {"source": {"identifier": "ethereum.istanbul.fork_types.Account.code", "specifier": 0, "path": "src/ethereum/istanbul/fork_types.py"}, "content": {"type": ["attribute"], "name": ["code"]}}, {"source": {"identifier": "ethereum.istanbul.fork_types.EMPTY_ACCOUNT", "specifier": 0, "path": "src/ethereum/istanbul/fork_types.py"}, "content": {"type": ["attribute"], "name": ["EMPTY_ACCOUNT"]}}, {"source": {"identifier": "ethereum.istanbul.fork_types.encode_account", "specifier": 0, "path": "src/ethereum/istanbul/fork_types.py"}, "content": {"type": ["function"], "name": ["encode_account"], "text": ["Encode  Account  dataclass. Storage is not stored in the  Account  dataclass, so  Accounts  cannot be encoded with providing a storage root."]}}, {"source": {"identifier": "ethereum.istanbul.fork_types.Header", "specifier": 0, "path": "src/ethereum/istanbul/fork_types.py"}, "content": {"type": ["class"], "name": ["Header"], "text": ["Header portion of a block on the chain."]}}, {"source": {"identifier": "ethereum.istanbul.fork_types.Header.parent_hash", "specifier": 0, "path": "src/ethereum/istanbul/fork_types.py"}, "content": {"type": ["attribute"], "name": ["parent_hash"]}}, {"source": {"identifier": "ethereum.istanbul.fork_types.Header.ommers_hash", "specifier": 0, "path": "src/ethereum/istanbul/fork_types.py"}, "content": {"type": ["attribute"], "name": ["ommers_hash"]}}, {"source": {"identifier": "ethereum.istanbul.fork_types.Header.coinbase", "specifier": 0, "path": "src/ethereum/istanbul/fork_types.py"}, "content": {"type": ["attribute"], "name": ["coinbase"]}}, {"source": {"identifier": "ethereum.istanbul.fork_types.Header.state_root", "specifier": 0, "path": "src/ethereum/istanbul/fork_types.py"}, "content": {"type": ["attribute"], "name": ["state_root"]}}, {"source": {"identifier": "ethereum.istanbul.fork_types.Header.transactions_root", "specifier": 0, "path": "src/ethereum/istanbul/fork_types.py"}, "content": {"type": ["attribute"], "name": ["transactions_root"]}}, {"source": {"identifier": "ethereum.istanbul.fork_types.Header.receipt_root", "specifier": 0, "path": "src/ethereum/istanbul/fork_types.py"}, "content": {"type": ["attribute"], "name": ["receipt_root"]}}, {"source": {"identifier": "ethereum.istanbul.fork_types.Header.bloom", "specifier": 0, "path": "src/ethereum/istanbul/fork_types.py"}, "content": {"type": ["attribute"], "name": ["bloom"]}}, {"source": {"identifier": "ethereum.istanbul.fork_types.Header.difficulty", "specifier": 0, "path": "src/ethereum/istanbul/fork_types.py"}, "content": {"type": ["attribute"], "name": ["difficulty"]}}, {"source": {"identifier": "ethereum.istanbul.fork_types.Header.number", "specifier": 0, "path": "src/ethereum/istanbul/fork_types.py"}, "content": {"type": ["attribute"], "name": ["number"]}}, {"source": {"identifier": "ethereum.istanbul.fork_types.Header.gas_limit", "specifier": 0, "path": "src/ethereum/istanbul/fork_types.py"}, "content": {"type": ["attribute"], "name": ["gas_limit"]}}, {"source": {"identifier": "ethereum.istanbul.fork_types.Header.gas_used", "specifier": 0, "path": "src/ethereum/istanbul/fork_types.py"}, "content": {"type": ["attribute"], "name": ["gas_used"]}}, {"source": {"identifier": "ethereum.istanbul.fork_types.Header.timestamp", "specifier": 0, "path": "src/ethereum/istanbul/fork_types.py"}, "content": {"type": ["attribute"], "name": ["timestamp"]}}, {"source": {"identifier": "ethereum.istanbul.fork_types.Header.extra_data", "specifier": 0, "path": "src/ethereum/istanbul/fork_types.py"}, "content": {"type": ["attribute"], "name": ["extra_data"]}}, {"source": {"identifier": "ethereum.istanbul.fork_types.Header.mix_digest", "specifier": 0, "path": "src/ethereum/istanbul/fork_types.py"}, "content": {"type": ["attribute"], "name": ["mix_digest"]}}, {"source": {"identifier": "ethereum.istanbul.fork_types.Header.nonce", "specifier": 0, "path": "src/ethereum/istanbul/fork_types.py"}, "content": {"type": ["attribute"], "name": ["nonce"]}}, {"source": {"identifier": "ethereum.istanbul.fork_types.Block", "specifier": 0, "path": "src/ethereum/istanbul/fork_types.py"}, "content": {"type": ["class"], "name": ["Block"], "text": ["A complete block."]}}, {"source": {"identifier": "ethereum.istanbul.fork_types.Block.header", "specifier": 0, "path": "src/ethereum/istanbul/fork_types.py"}, "content": {"type": ["attribute"], "name": ["header"]}}, {"source": {"identifier": "ethereum.istanbul.fork_types.Block.transactions", "specifier": 0, "path": "src/ethereum/istanbul/fork_types.py"}, "content": {"type": ["attribute"], "name": ["transactions"]}}, {"source": {"identifier": "ethereum.istanbul.fork_types.Block.ommers", "specifier": 0, "path": "src/ethereum/istanbul/fork_types.py"}, "content": {"type": ["attribute"], "name": ["ommers"]}}, {"source": {"identifier": "ethereum.istanbul.fork_types.Log", "specifier": 0, "path": "src/ethereum/istanbul/fork_types.py"}, "content": {"type": ["class"], "name": ["Log"], "text": ["Data record produced during the execution of a transaction."]}}, {"source": {"identifier": "ethereum.istanbul.fork_types.Log.address", "specifier": 0, "path": "src/ethereum/istanbul/fork_types.py"}, "content": {"type": ["attribute"], "name": ["address"]}}, {"source": {"identifier": "ethereum.istanbul.fork_types.Log.topics", "specifier": 0, "path": "src/ethereum/istanbul/fork_types.py"}, "content": {"type": ["attribute"], "name": ["topics"]}}, {"source": {"identifier": "ethereum.istanbul.fork_types.Log.data", "specifier": 0, "path": "src/ethereum/istanbul/fork_types.py"}, "content": {"type": ["attribute"], "name": ["data"]}}, {"source": {"identifier": "ethereum.istanbul.fork_types.Receipt", "specifier": 0, "path": "src/ethereum/istanbul/fork_types.py"}, "content": {"type": ["class"], "name": ["Receipt"], "text": ["Result of a transaction."]}}, {"source": {"identifier": "ethereum.istanbul.fork_types.Receipt.succeeded", "specifier": 0, "path": "src/ethereum/istanbul/fork_types.py"}, "content": {"type": ["attribute"], "name": ["succeeded"]}}, {"source": {"identifier": "ethereum.istanbul.fork_types.Receipt.cumulative_gas_used", "specifier": 0, "path": "src/ethereum/istanbul/fork_types.py"}, "content": {"type": ["attribute"], "name": ["cumulative_gas_used"]}}, {"source": {"identifier": "ethereum.istanbul.fork_types.Receipt.bloom", "specifier": 0, "path": "src/ethereum/istanbul/fork_types.py"}, "content": {"type": ["attribute"], "name": ["bloom"]}}, {"source": {"identifier": "ethereum.istanbul.fork_types.Receipt.logs", "specifier": 0, "path": "src/ethereum/istanbul/fork_types.py"}, "content": {"type": ["attribute"], "name": ["logs"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.memory", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/memory.py"}, "content": {"type": ["module"], "name": ["ethereum.gray_glacier.vm.instructions.memory"], "text": ["Ethereum Virtual Machine (EVM) Memory Instructions ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementations of the EVM Memory instructions."]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.memory.mstore", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/memory.py"}, "content": {"type": ["function"], "name": ["mstore"], "text": ["Stores a word to memory. This also expands the memory, if the memory is insufficient to store the word. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.memory.mstore8", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/memory.py"}, "content": {"type": ["function"], "name": ["mstore8"], "text": ["Stores a byte to memory. This also expands the memory, if the memory is insufficient to store the word. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.memory.mload", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/memory.py"}, "content": {"type": ["function"], "name": ["mload"], "text": ["Load word from memory. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.memory.msize", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/memory.py"}, "content": {"type": ["function"], "name": ["msize"], "text": ["Push the size of active memory in bytes onto the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.crypto.blake2", "specifier": 0, "path": "src/ethereum/crypto/blake2.py"}, "content": {"type": ["module"], "name": ["ethereum.crypto.blake2"], "text": ["The Blake2 Implementation ^^^^^^^^^^^^^^^^^^^^^^^^^^"]}}, {"source": {"identifier": "ethereum.crypto.blake2.spit_le_to_uint", "specifier": 0, "path": "src/ethereum/crypto/blake2.py"}, "content": {"type": ["function"], "name": ["spit_le_to_uint"], "text": ["Extracts 8 byte words from a given data. Parameters data : The data in bytes from which the words need to be extracted start : Position to start the extraction num_words: The number of words to be extracted"]}}, {"source": {"identifier": "ethereum.crypto.blake2.Blake2", "specifier": 0, "path": "src/ethereum/crypto/blake2.py"}, "content": {"type": ["class"], "name": ["Blake2"], "text": ["Implementation of the BLAKE2 cryptographic hashing algorithm. Please refer the following document for details: https://datatracker.ietf.org/doc/html/rfc7693"]}}, {"source": {"identifier": "ethereum.crypto.blake2.Blake2.w", "specifier": 0, "path": "src/ethereum/crypto/blake2.py"}, "content": {"type": ["attribute"], "name": ["w"]}}, {"source": {"identifier": "ethereum.crypto.blake2.Blake2.mask_bits", "specifier": 0, "path": "src/ethereum/crypto/blake2.py"}, "content": {"type": ["attribute"], "name": ["mask_bits"]}}, {"source": {"identifier": "ethereum.crypto.blake2.Blake2.word_format", "specifier": 0, "path": "src/ethereum/crypto/blake2.py"}, "content": {"type": ["attribute"], "name": ["word_format"]}}, {"source": {"identifier": "ethereum.crypto.blake2.Blake2.R1", "specifier": 0, "path": "src/ethereum/crypto/blake2.py"}, "content": {"type": ["attribute"], "name": ["R1"]}}, {"source": {"identifier": "ethereum.crypto.blake2.Blake2.R2", "specifier": 0, "path": "src/ethereum/crypto/blake2.py"}, "content": {"type": ["attribute"], "name": ["R2"]}}, {"source": {"identifier": "ethereum.crypto.blake2.Blake2.R3", "specifier": 0, "path": "src/ethereum/crypto/blake2.py"}, "content": {"type": ["attribute"], "name": ["R3"]}}, {"source": {"identifier": "ethereum.crypto.blake2.Blake2.R4", "specifier": 0, "path": "src/ethereum/crypto/blake2.py"}, "content": {"type": ["attribute"], "name": ["R4"]}}, {"source": {"identifier": "ethereum.crypto.blake2.Blake2.max_word", "specifier": 0, "path": "src/ethereum/crypto/blake2.py"}, "content": {"type": ["function"], "name": ["max_word"], "text": ["Largest value for a given Blake2 flavor."]}}, {"source": {"identifier": "ethereum.crypto.blake2.Blake2.w_R1", "specifier": 0, "path": "src/ethereum/crypto/blake2.py"}, "content": {"type": ["function"], "name": ["w_R1"], "text": ["(w - R1) value for a given Blake2 flavor. Used in the function G"]}}, {"source": {"identifier": "ethereum.crypto.blake2.Blake2.w_R2", "specifier": 0, "path": "src/ethereum/crypto/blake2.py"}, "content": {"type": ["function"], "name": ["w_R2"], "text": ["(w - R2) value for a given Blake2 flavor. Used in the function G"]}}, {"source": {"identifier": "ethereum.crypto.blake2.Blake2.w_R3", "specifier": 0, "path": "src/ethereum/crypto/blake2.py"}, "content": {"type": ["function"], "name": ["w_R3"], "text": ["(w - R3) value for a given Blake2 flavor. Used in the function G"]}}, {"source": {"identifier": "ethereum.crypto.blake2.Blake2.w_R4", "specifier": 0, "path": "src/ethereum/crypto/blake2.py"}, "content": {"type": ["function"], "name": ["w_R4"], "text": ["(w - R4) value for a given Blake2 flavor. Used in the function G"]}}, {"source": {"identifier": "ethereum.crypto.blake2.Blake2.sigma", "specifier": 0, "path": "src/ethereum/crypto/blake2.py"}, "content": {"type": ["attribute"], "name": ["sigma"]}}, {"source": {"identifier": "ethereum.crypto.blake2.Blake2.IV", "specifier": 0, "path": "src/ethereum/crypto/blake2.py"}, "content": {"type": ["attribute"], "name": ["IV"]}}, {"source": {"identifier": "ethereum.crypto.blake2.Blake2.sigma_len", "specifier": 0, "path": "src/ethereum/crypto/blake2.py"}, "content": {"type": ["function"], "name": ["sigma_len"], "text": ["Length of the sigma parameter."]}}, {"source": {"identifier": "ethereum.crypto.blake2.Blake2.get_blake2_parameters", "specifier": 0, "path": "src/ethereum/crypto/blake2.py"}, "content": {"type": ["function"], "name": ["get_blake2_parameters"], "text": ["Extract the parameters required in the Blake2 compression function from the provided bytes data. Parameters data : The bytes data that has been passed in the message."]}}, {"source": {"identifier": "ethereum.crypto.blake2.Blake2.G", "specifier": 0, "path": "src/ethereum/crypto/blake2.py"}, "content": {"type": ["function"], "name": ["G"], "text": ["The mixing function used in Blake2 https://datatracker.ietf.org/doc/html/rfc7693#section-3.1 Parameters v : The working vector to be mixed. a, b, c, d : Indexes within v of the words to be mixed. x, y : The two input words for the mixing."]}}, {"source": {"identifier": "ethereum.crypto.blake2.Blake2.compress", "specifier": 0, "path": "src/ethereum/crypto/blake2.py"}, "content": {"type": ["function"], "name": ["compress"], "text": ["'F Compression' from section 3.2 of RFC 7693: https://tools.ietf.org/html/rfc7693#section-3.2 Parameters num_rounds : The number of rounds. A 32-bit unsigned big-endian word h : The state vector. 8 unsigned 64-bit little-endian words m : The message block vector. 16 unsigned 64-bit little-endian words t_0, t_1 : Offset counters. 2 unsigned 64-bit little-endian words f: The final block indicator flag. An 8-bit word"]}}, {"source": {"identifier": "ethereum.crypto.blake2.Blake2b", "specifier": 0, "path": "src/ethereum/crypto/blake2.py"}, "content": {"type": ["class"], "name": ["Blake2b"], "text": ["The Blake2b flavor (64-bits) of Blake2. This version is used in the pre-compiled contract."]}}, {"source": {"identifier": "ethereum.crypto.blake2.Blake2b.w", "specifier": 0, "path": "src/ethereum/crypto/blake2.py"}, "content": {"type": ["attribute"], "name": ["w"]}}, {"source": {"identifier": "ethereum.crypto.blake2.Blake2b.mask_bits", "specifier": 0, "path": "src/ethereum/crypto/blake2.py"}, "content": {"type": ["attribute"], "name": ["mask_bits"]}}, {"source": {"identifier": "ethereum.crypto.blake2.Blake2b.word_format", "specifier": 0, "path": "src/ethereum/crypto/blake2.py"}, "content": {"type": ["attribute"], "name": ["word_format"]}}, {"source": {"identifier": "ethereum.crypto.blake2.Blake2b.R1", "specifier": 0, "path": "src/ethereum/crypto/blake2.py"}, "content": {"type": ["attribute"], "name": ["R1"]}}, {"source": {"identifier": "ethereum.crypto.blake2.Blake2b.R2", "specifier": 0, "path": "src/ethereum/crypto/blake2.py"}, "content": {"type": ["attribute"], "name": ["R2"]}}, {"source": {"identifier": "ethereum.crypto.blake2.Blake2b.R3", "specifier": 0, "path": "src/ethereum/crypto/blake2.py"}, "content": {"type": ["attribute"], "name": ["R3"]}}, {"source": {"identifier": "ethereum.crypto.blake2.Blake2b.R4", "specifier": 0, "path": "src/ethereum/crypto/blake2.py"}, "content": {"type": ["attribute"], "name": ["R4"]}}, {"source": {"identifier": "ethereum.istanbul.trie", "specifier": 0, "path": "src/ethereum/istanbul/trie.py"}, "content": {"type": ["module"], "name": ["ethereum.istanbul.trie"], "text": ["State Trie ^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction The state trie is the structure responsible for storing .fork_types.Account  objects."]}}, {"source": {"identifier": "ethereum.istanbul.trie.EMPTY_TRIE_ROOT", "specifier": 0, "path": "src/ethereum/istanbul/trie.py"}, "content": {"type": ["attribute"], "name": ["EMPTY_TRIE_ROOT"]}}, {"source": {"identifier": "ethereum.istanbul.trie.Node", "specifier": 0, "path": "src/ethereum/istanbul/trie.py"}, "content": {"type": ["attribute"], "name": ["Node"]}}, {"source": {"identifier": "ethereum.istanbul.trie.K", "specifier": 0, "path": "src/ethereum/istanbul/trie.py"}, "content": {"type": ["attribute"], "name": ["K"]}}, {"source": {"identifier": "ethereum.istanbul.trie.V", "specifier": 0, "path": "src/ethereum/istanbul/trie.py"}, "content": {"type": ["attribute"], "name": ["V"]}}, {"source": {"identifier": "ethereum.istanbul.trie.LeafNode", "specifier": 0, "path": "src/ethereum/istanbul/trie.py"}, "content": {"type": ["class"], "name": ["LeafNode"], "text": ["Leaf node in the Merkle Trie"]}}, {"source": {"identifier": "ethereum.istanbul.trie.LeafNode.rest_of_key", "specifier": 0, "path": "src/ethereum/istanbul/trie.py"}, "content": {"type": ["attribute"], "name": ["rest_of_key"]}}, {"source": {"identifier": "ethereum.istanbul.trie.LeafNode.value", "specifier": 0, "path": "src/ethereum/istanbul/trie.py"}, "content": {"type": ["attribute"], "name": ["value"]}}, {"source": {"identifier": "ethereum.istanbul.trie.ExtensionNode", "specifier": 0, "path": "src/ethereum/istanbul/trie.py"}, "content": {"type": ["class"], "name": ["ExtensionNode"], "text": ["Extension node in the Merkle Trie"]}}, {"source": {"identifier": "ethereum.istanbul.trie.ExtensionNode.key_segment", "specifier": 0, "path": "src/ethereum/istanbul/trie.py"}, "content": {"type": ["attribute"], "name": ["key_segment"]}}, {"source": {"identifier": "ethereum.istanbul.trie.ExtensionNode.subnode", "specifier": 0, "path": "src/ethereum/istanbul/trie.py"}, "content": {"type": ["attribute"], "name": ["subnode"]}}, {"source": {"identifier": "ethereum.istanbul.trie.BranchNode", "specifier": 0, "path": "src/ethereum/istanbul/trie.py"}, "content": {"type": ["class"], "name": ["BranchNode"], "text": ["Branch node in the Merkle Trie"]}}, {"source": {"identifier": "ethereum.istanbul.trie.BranchNode.subnodes", "specifier": 0, "path": "src/ethereum/istanbul/trie.py"}, "content": {"type": ["attribute"], "name": ["subnodes"]}}, {"source": {"identifier": "ethereum.istanbul.trie.BranchNode.value", "specifier": 0, "path": "src/ethereum/istanbul/trie.py"}, "content": {"type": ["attribute"], "name": ["value"]}}, {"source": {"identifier": "ethereum.istanbul.trie.InternalNode", "specifier": 0, "path": "src/ethereum/istanbul/trie.py"}, "content": {"type": ["attribute"], "name": ["InternalNode"]}}, {"source": {"identifier": "ethereum.istanbul.trie.encode_internal_node", "specifier": 0, "path": "src/ethereum/istanbul/trie.py"}, "content": {"type": ["function"], "name": ["encode_internal_node"], "text": ["Encodes a Merkle Trie node into its RLP form. The RLP will then be serialized into a  Bytes  and hashed unless it is less that 32 bytes when serialized. This function also accepts  None , representing the absence of a node, which is encoded to  b\"\" . Parameters node : Optional[InternalNode] The node to encode. Returns encoded :  rlp.RLP The node encoded as RLP."]}}, {"source": {"identifier": "ethereum.istanbul.trie.encode_node", "specifier": 0, "path": "src/ethereum/istanbul/trie.py"}, "content": {"type": ["function"], "name": ["encode_node"], "text": ["Encode a Node for storage in the Merkle Trie. Currently mostly an unimplemented stub."]}}, {"source": {"identifier": "ethereum.istanbul.trie.Trie", "specifier": 0, "path": "src/ethereum/istanbul/trie.py"}, "content": {"type": ["class"], "name": ["Trie"], "text": ["The Merkle Trie."]}}, {"source": {"identifier": "ethereum.istanbul.trie.Trie.secured", "specifier": 0, "path": "src/ethereum/istanbul/trie.py"}, "content": {"type": ["attribute"], "name": ["secured"]}}, {"source": {"identifier": "ethereum.istanbul.trie.Trie.default", "specifier": 0, "path": "src/ethereum/istanbul/trie.py"}, "content": {"type": ["attribute"], "name": ["default"]}}, {"source": {"identifier": "ethereum.istanbul.trie.Trie._data", "specifier": 0, "path": "src/ethereum/istanbul/trie.py"}, "content": {"type": ["attribute"], "name": ["_data"]}}, {"source": {"identifier": "ethereum.istanbul.trie.copy_trie", "specifier": 0, "path": "src/ethereum/istanbul/trie.py"}, "content": {"type": ["function"], "name": ["copy_trie"], "text": ["Create a copy of  trie . Since only frozen objects may be stored in tries, the contents are reused. Parameters trie:  Trie Trie to copy. Returns new_trie :  Trie[K, V] A copy of the trie."]}}, {"source": {"identifier": "ethereum.istanbul.trie.trie_set", "specifier": 0, "path": "src/ethereum/istanbul/trie.py"}, "content": {"type": ["function"], "name": ["trie_set"], "text": ["Stores an item in a Merkle Trie. This method deletes the key if  value == trie.default , because the Merkle Trie represents the default value by omitting it from the trie. Parameters trie:  Trie Trie to store in. key :  Bytes Key to lookup. value :  V Node to insert at  key ."]}}, {"source": {"identifier": "ethereum.istanbul.trie.trie_get", "specifier": 0, "path": "src/ethereum/istanbul/trie.py"}, "content": {"type": ["function"], "name": ["trie_get"], "text": ["Gets an item from the Merkle Trie. This method returns  trie.default  if the key is missing. Parameters trie: Trie to lookup in. key : Key to lookup. Returns node :  V Node at  key  in the trie."]}}, {"source": {"identifier": "ethereum.istanbul.trie.common_prefix_length", "specifier": 0, "path": "src/ethereum/istanbul/trie.py"}, "content": {"type": ["function"], "name": ["common_prefix_length"], "text": ["Find the longest common prefix of two sequences."]}}, {"source": {"identifier": "ethereum.istanbul.trie.nibble_list_to_compact", "specifier": 0, "path": "src/ethereum/istanbul/trie.py"}, "content": {"type": ["function"], "name": ["nibble_list_to_compact"], "text": ["Compresses nibble-list into a standard byte array with a flag. A nibble-list is a list of byte values no greater than  15 . The flag is encoded in high nibble of the highest byte. The flag nibble can be broken down into two two-bit flags. Highest nibble:: +---+---+----------+--------+\n| _ | _ | is_leaf | parity |\n+---+---+----------+--------+\n  3   2      1         0\n The lowest bit of the nibble encodes the parity of the length of the remaining nibbles --  0  when even and  1  when odd. The second lowest bit is used to distinguish leaf and extension nodes. The other two bits are not used. Parameters x : Array of nibbles. is_leaf : True if this is part of a leaf node, or false if it is an extension node. Returns compressed :  bytearray Compact byte array."]}}, {"source": {"identifier": "ethereum.istanbul.trie.bytes_to_nibble_list", "specifier": 0, "path": "src/ethereum/istanbul/trie.py"}, "content": {"type": ["function"], "name": ["bytes_to_nibble_list"], "text": ["Converts a  Bytes  into to a sequence of nibbles (bytes with value < 16). Parameters bytes_: The  Bytes  to convert. Returns nibble_list :  Bytes The  Bytes  in nibble-list format."]}}, {"source": {"identifier": "ethereum.istanbul.trie._prepare_trie", "specifier": 0, "path": "src/ethereum/istanbul/trie.py"}, "content": {"type": ["function"], "name": ["_prepare_trie"], "text": ["Prepares the trie for root calculation. Removes values that are empty, hashes the keys (if  secured == True ) and encodes all the nodes. Parameters trie : The  Trie  to prepare. get_storage_root : Function to get the storage root of an account. Needed to encode Account  objects. Returns out :  Mapping[ethereum.base_types.Bytes, Node] Object with keys mapped to nibble-byte form."]}}, {"source": {"identifier": "ethereum.istanbul.trie.root", "specifier": 0, "path": "src/ethereum/istanbul/trie.py"}, "content": {"type": ["function"], "name": ["root"], "text": ["Computes the root of a modified merkle patricia trie (MPT). Parameters trie : Trie  to get the root of. get_storage_root : Function to get the storage root of an account. Needed to encode Account  objects. Returns root :  .fork_types.Root MPT root of the underlying key-value pairs."]}}, {"source": {"identifier": "ethereum.istanbul.trie.patricialize", "specifier": 0, "path": "src/ethereum/istanbul/trie.py"}, "content": {"type": ["function"], "name": ["patricialize"], "text": ["Structural composition function. Used to recursively patricialize and merkleize a dictionary. Includes memoization of the tree structure and hashes. Parameters obj : Underlying trie key-value pairs, with keys in nibble-list format. level : Current trie level. Returns node :  ethereum.base_types.Bytes Root node of  obj ."]}}, {"source": {"identifier": "ethereum.crypto", "specifier": 0, "path": "src/ethereum/crypto/__init__.py"}, "content": {"type": ["module"], "name": ["ethereum.crypto"], "text": ["Cryptographic Functions ^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Cryptographic primatives used in Ethereum."]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.system", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/system.py"}, "content": {"type": ["module"], "name": ["ethereum.gray_glacier.vm.instructions.system"], "text": ["Ethereum Virtual Machine (EVM) System Instructions ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementations of the EVM system related instructions."]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.system.generic_create", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/system.py"}, "content": {"type": ["function"], "name": ["generic_create"], "text": ["Core logic used by the  CREATE*  family of opcodes."]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.system.create", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/system.py"}, "content": {"type": ["function"], "name": ["create"], "text": ["Creates a new account with associated code. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.system.create2", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/system.py"}, "content": {"type": ["function"], "name": ["create2"], "text": ["Creates a new account with associated code. It's similar to CREATE opcode except that the address of new account depends on the init_code instead of the nonce of sender. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.system.return_", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/system.py"}, "content": {"type": ["function"], "name": ["return_"], "text": ["Halts execution returning output data. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.system.generic_call", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/system.py"}, "content": {"type": ["function"], "name": ["generic_call"], "text": ["Perform the core logic of the  CALL*  family of opcodes."]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.system.call", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/system.py"}, "content": {"type": ["function"], "name": ["call"], "text": ["Message-call into an account. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.system.callcode", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/system.py"}, "content": {"type": ["function"], "name": ["callcode"], "text": ["Message-call into this account with alternative account\u2019s code. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.system.selfdestruct", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/system.py"}, "content": {"type": ["function"], "name": ["selfdestruct"], "text": ["Halt execution and register account for later deletion. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.system.delegatecall", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/system.py"}, "content": {"type": ["function"], "name": ["delegatecall"], "text": ["Message-call into an account. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.system.staticcall", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/system.py"}, "content": {"type": ["function"], "name": ["staticcall"], "text": ["Message-call into an account. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.system.revert", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/system.py"}, "content": {"type": ["function"], "name": ["revert"], "text": ["Stop execution and revert state changes, without consuming all provided gas and also has the ability to return a reason Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.istanbul.fork", "specifier": 0, "path": "src/ethereum/istanbul/fork.py"}, "content": {"type": ["module"], "name": ["ethereum.istanbul.fork"], "text": ["Ethereum Specification ^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Entry point for the Ethereum specification."]}}, {"source": {"identifier": "ethereum.istanbul.fork.BLOCK_REWARD", "specifier": 0, "path": "src/ethereum/istanbul/fork.py"}, "content": {"type": ["attribute"], "name": ["BLOCK_REWARD"]}}, {"source": {"identifier": "ethereum.istanbul.fork.GAS_LIMIT_ADJUSTMENT_FACTOR", "specifier": 0, "path": "src/ethereum/istanbul/fork.py"}, "content": {"type": ["attribute"], "name": ["GAS_LIMIT_ADJUSTMENT_FACTOR"]}}, {"source": {"identifier": "ethereum.istanbul.fork.GAS_LIMIT_MINIMUM", "specifier": 0, "path": "src/ethereum/istanbul/fork.py"}, "content": {"type": ["attribute"], "name": ["GAS_LIMIT_MINIMUM"]}}, {"source": {"identifier": "ethereum.istanbul.fork.MINIMUM_DIFFICULTY", "specifier": 0, "path": "src/ethereum/istanbul/fork.py"}, "content": {"type": ["attribute"], "name": ["MINIMUM_DIFFICULTY"]}}, {"source": {"identifier": "ethereum.istanbul.fork.MAX_OMMER_DEPTH", "specifier": 0, "path": "src/ethereum/istanbul/fork.py"}, "content": {"type": ["attribute"], "name": ["MAX_OMMER_DEPTH"]}}, {"source": {"identifier": "ethereum.istanbul.fork.BOMB_DELAY_BLOCKS", "specifier": 0, "path": "src/ethereum/istanbul/fork.py"}, "content": {"type": ["attribute"], "name": ["BOMB_DELAY_BLOCKS"]}}, {"source": {"identifier": "ethereum.istanbul.fork.EMPTY_OMMER_HASH", "specifier": 0, "path": "src/ethereum/istanbul/fork.py"}, "content": {"type": ["attribute"], "name": ["EMPTY_OMMER_HASH"]}}, {"source": {"identifier": "ethereum.istanbul.fork.BlockChain", "specifier": 0, "path": "src/ethereum/istanbul/fork.py"}, "content": {"type": ["class"], "name": ["BlockChain"], "text": ["History and current state of the block chain."]}}, {"source": {"identifier": "ethereum.istanbul.fork.BlockChain.blocks", "specifier": 0, "path": "src/ethereum/istanbul/fork.py"}, "content": {"type": ["attribute"], "name": ["blocks"]}}, {"source": {"identifier": "ethereum.istanbul.fork.BlockChain.state", "specifier": 0, "path": "src/ethereum/istanbul/fork.py"}, "content": {"type": ["attribute"], "name": ["state"]}}, {"source": {"identifier": "ethereum.istanbul.fork.BlockChain.chain_id", "specifier": 0, "path": "src/ethereum/istanbul/fork.py"}, "content": {"type": ["attribute"], "name": ["chain_id"]}}, {"source": {"identifier": "ethereum.istanbul.fork.apply_fork", "specifier": 0, "path": "src/ethereum/istanbul/fork.py"}, "content": {"type": ["function"], "name": ["apply_fork"], "text": ["Transforms the state from the previous hard fork ( old ) into the block chain object for this hard fork and returns it. When forks need to implement an irregular state transition, this function is used to handle the irregularity. See the :ref: DAO Fork <dao-fork>  for an example. Parameters old : Previous block chain object. Returns new :  BlockChain Upgraded block chain object for this hard fork."]}}, {"source": {"identifier": "ethereum.istanbul.fork.get_last_256_block_hashes", "specifier": 0, "path": "src/ethereum/istanbul/fork.py"}, "content": {"type": ["function"], "name": ["get_last_256_block_hashes"], "text": ["Obtain the list of hashes of the previous 256 blocks in order of increasing block number. This function will return less hashes for the first 256 blocks. The  BLOCKHASH  opcode needs to access the latest hashes on the chain, therefore this function retrieves them. Parameters chain : History and current state. Returns recent_block_hashes :  List[Hash32] Hashes of the recent 256 blocks in order of increasing block number."]}}, {"source": {"identifier": "ethereum.istanbul.fork.state_transition", "specifier": 0, "path": "src/ethereum/istanbul/fork.py"}, "content": {"type": ["function"], "name": ["state_transition"], "text": ["Attempts to apply a block to an existing block chain. All parts of the block's contents need to be verified before being added to the chain. Blocks are verified by ensuring that the contents of the block make logical sense with the contents of the parent block. The information in the block's header must also match the corresponding information in the block. To implement Ethereum, in theory clients are only required to store the most recent 255 blocks of the chain since as far as execution is concerned, only those blocks are accessed. Practically, however, clients should store more blocks to handle reorgs. Parameters chain : History and current state. block : Block to apply to  chain ."]}}, {"source": {"identifier": "ethereum.istanbul.fork.validate_header", "specifier": 0, "path": "src/ethereum/istanbul/fork.py"}, "content": {"type": ["function"], "name": ["validate_header"], "text": ["Verifies a block header. In order to consider a block's header valid, the logic for the quantities in the header should match the logic for the block itself. For example the header timestamp should be greater than the block's parent timestamp because the block was created  after  the parent block. Additionally, the block's number should be directly folowing the parent block's number since it is the next block in the sequence. Parameters header : Header to check for correctness. parent_header : Parent Header of the header to check for correctness"]}}, {"source": {"identifier": "ethereum.istanbul.fork.generate_header_hash_for_pow", "specifier": 0, "path": "src/ethereum/istanbul/fork.py"}, "content": {"type": ["function"], "name": ["generate_header_hash_for_pow"], "text": ["Generate rlp hash of the header which is to be used for Proof-of-Work verification. In other words, the PoW artefacts  mix_digest  and  nonce  are ignored while calculating this hash. A particular PoW is valid for a single hash, that hash is computed by this function. The  nonce  and  mix_digest  are omitted from this hash because they are being changed by miners in their search for a sufficient proof-of-work. Parameters header : The header object for which the hash is to be generated. Returns hash :  Hash32 The PoW valid rlp hash of the passed in header."]}}, {"source": {"identifier": "ethereum.istanbul.fork.validate_proof_of_work", "specifier": 0, "path": "src/ethereum/istanbul/fork.py"}, "content": {"type": ["function"], "name": ["validate_proof_of_work"], "text": ["Validates the Proof of Work constraints. In order to verify that a miner's proof-of-work is valid for a block, a mix-digest  and  result  are calculated using the  hashimoto_light hash function. The mix digest is a hash of the header and the nonce that is passed through and it confirms whether or not proof-of-work was done on the correct block. The result is the actual hash value of the block. Parameters header : Header of interest."]}}, {"source": {"identifier": "ethereum.istanbul.fork.check_transaction", "specifier": 0, "path": "src/ethereum/istanbul/fork.py"}, "content": {"type": ["function"], "name": ["check_transaction"], "text": ["Check if the transaction is includable in the block. Parameters tx : The transaction. gas_available : The gas remaining in the block. chain_id : The ID of the current chain. Returns sender_address : The sender of the transaction. Raises InvalidBlock : If the transaction is not includable."]}}, {"source": {"identifier": "ethereum.istanbul.fork.make_receipt", "specifier": 0, "path": "src/ethereum/istanbul/fork.py"}, "content": {"type": ["function"], "name": ["make_receipt"], "text": ["Make the receipt for a transaction that was executed. Parameters tx : The executed transaction. has_erred : Whether the top level frame of the transaction exited with an error. cumulative_gas_used : The total gas used so far in the block after the transaction was executed. logs : The logs produced by the transaction. Returns receipt : The receipt for the transaction."]}}, {"source": {"identifier": "ethereum.istanbul.fork.apply_body", "specifier": 0, "path": "src/ethereum/istanbul/fork.py"}, "content": {"type": ["function"], "name": ["apply_body"], "text": ["Executes a block. Many of the contents of a block are stored in data structures called tries. There is a transactions trie which is similar to a ledger of the transactions stored in the current block. There is also a receipts trie which stores the results of executing a transaction, like the post state and gas used. This function creates and executes the block that is to be added to the chain. Parameters state : Current account state. block_hashes : List of hashes of the previous 256 blocks in the order of increasing block number. coinbase : Address of account which receives block reward and transaction fees. block_number : Position of the block within the chain. block_gas_limit : Initial amount of gas available for execution in this block. block_time : Time the block was produced, measured in seconds since the epoch. block_difficulty : Difficulty of the block. transactions : Transactions included in the block. ommers : Headers of ancestor blocks which are not direct parents (formerly uncles.) chain_id : ID of the executing chain. Returns gas_available :  ethereum.base_types.Uint Remaining gas after all transactions have been executed. transactions_root :  ethereum.fork_types.Root Trie root of all the transactions in the block. receipt_root :  ethereum.fork_types.Root Trie root of all the receipts in the block. block_logs_bloom :  Bloom Logs bloom of all the logs included in all the transactions of the block. state :  ethereum.fork_types.State State after all transactions have been executed."]}}, {"source": {"identifier": "ethereum.istanbul.fork.validate_ommers", "specifier": 0, "path": "src/ethereum/istanbul/fork.py"}, "content": {"type": ["function"], "name": ["validate_ommers"], "text": ["Validates the ommers mentioned in the block. An ommer block is a block that wasn't canonically added to the blockchain because it wasn't validated as fast as the canonical block but was mined at the same time. To be considered valid, the ommers must adhere to the rules defined in the Ethereum protocol. The maximum amount of ommers is 2 per block and there cannot be duplicate ommers in a block. Many of the other ommer contraints are listed in the in-line comments of this function. Parameters ommers : List of ommers mentioned in the current block. block_header: The header of current block. chain : History and current state."]}}, {"source": {"identifier": "ethereum.istanbul.fork.pay_rewards", "specifier": 0, "path": "src/ethereum/istanbul/fork.py"}, "content": {"type": ["function"], "name": ["pay_rewards"], "text": ["Pay rewards to the block miner as well as the ommers miners. The miner of the canonical block is rewarded with the predetermined block reward,  BLOCK_REWARD , plus a variable award based off of the number of ommer blocks that were mined around the same time, and included in the canonical block's header. An ommer block is a block that wasn't added to the canonical blockchain because it wasn't validated as fast as the accepted block but was mined at the same time. Although not all blocks that are mined are added to the canonical chain, miners are still paid a reward for their efforts. This reward is called an ommer reward and is calculated based on the number associated with the ommer block that they mined. Parameters state : Current account state. block_number : Position of the block within the chain. coinbase : Address of account which receives block reward and transaction fees. ommers : List of ommers mentioned in the current block."]}}, {"source": {"identifier": "ethereum.istanbul.fork.process_transaction", "specifier": 0, "path": "src/ethereum/istanbul/fork.py"}, "content": {"type": ["function"], "name": ["process_transaction"], "text": ["Execute a transaction against the provided environment. This function processes the actions needed to execute a transaction. It decrements the sender's account after calculating the gas fee and refunds them the proper amount after execution. Calling contracts, deploying code, and incrementing nonces are all examples of actions that happen within this function or from a call made within this function. Accounts that are marked for deletion are processed and destroyed after execution. Parameters env : Environment for the Ethereum Virtual Machine. tx : Transaction to execute. Returns gas_left :  ethereum.base_types.U256 Remaining gas after execution. logs :  Tuple[ethereum.fork_types.Log, ...] Logs generated during execution."]}}, {"source": {"identifier": "ethereum.istanbul.fork.validate_transaction", "specifier": 0, "path": "src/ethereum/istanbul/fork.py"}, "content": {"type": ["function"], "name": ["validate_transaction"], "text": ["Verifies a transaction. The gas in a transaction gets used to pay for the intrinsic cost of operations, therefore if there is insufficient gas then it would not be possible to execute a transaction and it will be declared invalid. Additionally, the nonce of a transaction must not equal or exceed the limit defined in  EIP-2681 <https://eips.ethereum.org/EIPS/eip-2681> _. In practice, defining the limit as  2**64-1  has no impact because sending  2**64-1  transactions is improbable. It's not strictly impossible though,  2**64-1  transactions is the entire capacity of the Ethereum blockchain at 2022 gas limits for a little over 22 years. Parameters tx : Transaction to validate. Returns verified :  bool True if the transaction can be executed, or False otherwise."]}}, {"source": {"identifier": "ethereum.istanbul.fork.calculate_intrinsic_cost", "specifier": 0, "path": "src/ethereum/istanbul/fork.py"}, "content": {"type": ["function"], "name": ["calculate_intrinsic_cost"], "text": ["Calculates the gas that is charged before execution is started. The intrinsic cost of the transaction is charged before execution has begun. Functions/operations in the EVM cost money to execute so this intrinsic cost is for the operations that need to be paid for as part of the transaction. Data transfer, for example, is part of this intrinsic cost. It costs ether to send data over the wire and that ether is accounted for in the intrinsic cost calculated in this function. This intrinsic cost must be calculated and paid for before execution in order for all operations to be implemented. Parameters tx : Transaction to compute the intrinsic cost of. Returns verified :  ethereum.base_types.Uint The intrinsic cost of the transaction."]}}, {"source": {"identifier": "ethereum.istanbul.fork.recover_sender", "specifier": 0, "path": "src/ethereum/istanbul/fork.py"}, "content": {"type": ["function"], "name": ["recover_sender"], "text": ["Extracts the sender address from a transaction. The v, r, and s values are the three parts that make up the signature of a transaction. In order to recover the sender of a transaction the two components needed are the signature ( v ,  r , and  s ) and the signing hash of the transaction. The sender's public key can be obtained with these two values and therefore the sender address can be retrieved. Parameters tx : Transaction of interest. chain_id : ID of the executing chain. Returns sender :  ethereum.fork_types.Address The address of the account that signed the transaction."]}}, {"source": {"identifier": "ethereum.istanbul.fork.signing_hash_pre155", "specifier": 0, "path": "src/ethereum/istanbul/fork.py"}, "content": {"type": ["function"], "name": ["signing_hash_pre155"], "text": ["Compute the hash of a transaction used in a legacy (pre EIP 155) signature. Parameters tx : Transaction of interest. Returns hash :  ethereum.crypto.hash.Hash32 Hash of the transaction."]}}, {"source": {"identifier": "ethereum.istanbul.fork.signing_hash_155", "specifier": 0, "path": "src/ethereum/istanbul/fork.py"}, "content": {"type": ["function"], "name": ["signing_hash_155"], "text": ["Compute the hash of a transaction used in a EIP 155 signature. Parameters tx : Transaction of interest. Returns hash :  ethereum.crypto.hash.Hash32 Hash of the transaction."]}}, {"source": {"identifier": "ethereum.istanbul.fork.compute_header_hash", "specifier": 0, "path": "src/ethereum/istanbul/fork.py"}, "content": {"type": ["function"], "name": ["compute_header_hash"], "text": ["Computes the hash of a block header. The header hash of a block is the canonical hash that is used to refer to a specific block and completely distinguishes a block from another. keccak256  is a function that produces a 256 bit hash of any input. It also takes in any number of bytes as an input and produces a single hash for them. A hash is a completely unique output for a single input. So an input corresponds to one unique hash that can be used to identify the input exactly. Prior to using the  keccak256  hash function, the header must be encoded using the Recursive-Length Prefix. See :ref: rlp . RLP encoding the header converts it into a space-efficient format that allows for easy transfer of data between nodes. The purpose of RLP is to encode arbitrarily nested arrays of binary data, and RLP is the primary encoding method used to serialize objects in Ethereum's execution layer. The only purpose of RLP is to encode structure; encoding specific data types (e.g. strings, floats) is left up to higher-order protocols. Parameters header : Header of interest. Returns hash :  ethereum.crypto.hash.Hash32 Hash of the header."]}}, {"source": {"identifier": "ethereum.istanbul.fork.check_gas_limit", "specifier": 0, "path": "src/ethereum/istanbul/fork.py"}, "content": {"type": ["function"], "name": ["check_gas_limit"], "text": ["Validates the gas limit for a block. The bounds of the gas limit,  max_adjustment_delta , is set as the quotient of the parent block's gas limit and the GAS_LIMIT_ADJUSTMENT_FACTOR . Therefore, if the gas limit that is passed through as a parameter is greater than or equal to the  sum  of the parent's gas and the adjustment delta then the limit for gas is too high and fails this function's check. Similarly, if the limit is less than or equal to the  difference  of the parent's gas and the adjustment delta  or  the predefined  GAS_LIMIT_MINIMUM  then this function's check fails because the gas limit doesn't allow for a sufficient or reasonable amount of gas to be used on a block. Parameters gas_limit : Gas limit to validate. parent_gas_limit : Gas limit of the parent block. Returns check :  bool True if gas limit constraints are satisfied, False otherwise."]}}, {"source": {"identifier": "ethereum.istanbul.fork.calculate_block_difficulty", "specifier": 0, "path": "src/ethereum/istanbul/fork.py"}, "content": {"type": ["function"], "name": ["calculate_block_difficulty"], "text": ["Computes difficulty of a block using its header and parent header. The difficulty is determined by the time the block was created after its parent. The  offset  is calculated using the parent block's difficulty, parent_difficulty , and the timestamp between blocks. This offset is then added to the parent difficulty and is stored as the  difficulty variable. If the time between the block and its parent is too short, the offset will result in a positive number thus making the sum of parent_difficulty  and  offset  to be a greater value in order to avoid mass forking. But, if the time is long enough, then the offset results in a negative value making the block less difficult than its parent. The base standard for a block's difficulty is the predefined value set for the genesis block since it has no parent. So, a block can't be less difficult than the genesis block, therefore each block's difficulty is set to the maximum value between the calculated difficulty and the  GENESIS_DIFFICULTY . Parameters block_number : Block number of the block. block_timestamp : Timestamp of the block. parent_timestamp : Timestamp of the parent block. parent_difficulty : difficulty of the parent block. parent_has_ommers: does the parent have ommers. Returns difficulty :  ethereum.base_types.Uint Computed difficulty for a block."]}}, {"source": {"identifier": "ethereum.crypto.elliptic_curve", "specifier": 0, "path": "src/ethereum/crypto/elliptic_curve.py"}, "content": {"type": ["module"], "name": ["ethereum.crypto.elliptic_curve"], "text": ["Elliptic Curves ^^^^^^^^^^^^^^^"]}}, {"source": {"identifier": "ethereum.crypto.elliptic_curve.SECP256K1N", "specifier": 0, "path": "src/ethereum/crypto/elliptic_curve.py"}, "content": {"type": ["attribute"], "name": ["SECP256K1N"]}}, {"source": {"identifier": "ethereum.crypto.elliptic_curve.F", "specifier": 0, "path": "src/ethereum/crypto/elliptic_curve.py"}, "content": {"type": ["attribute"], "name": ["F"]}}, {"source": {"identifier": "ethereum.crypto.elliptic_curve.T", "specifier": 0, "path": "src/ethereum/crypto/elliptic_curve.py"}, "content": {"type": ["attribute"], "name": ["T"]}}, {"source": {"identifier": "ethereum.crypto.elliptic_curve.secp256k1_recover", "specifier": 0, "path": "src/ethereum/crypto/elliptic_curve.py"}, "content": {"type": ["function"], "name": ["secp256k1_recover"], "text": ["Recovers the public key from a given signature. Parameters r : TODO s : TODO v : TODO msg_hash : Hash of the message being recovered. Returns public_key :  ethereum.base_types.Bytes Recovered public key."]}}, {"source": {"identifier": "ethereum.crypto.elliptic_curve.EllipticCurve", "specifier": 0, "path": "src/ethereum/crypto/elliptic_curve.py"}, "content": {"type": ["class"], "name": ["EllipticCurve"], "text": ["Superclass for integers modulo a prime. Not intended to be used directly, but rather to be subclassed."]}}, {"source": {"identifier": "ethereum.crypto.elliptic_curve.EllipticCurve.__slots__", "specifier": 0, "path": "src/ethereum/crypto/elliptic_curve.py"}, "content": {"type": ["attribute"], "name": ["__slots__"]}}, {"source": {"identifier": "ethereum.crypto.elliptic_curve.EllipticCurve.FIELD", "specifier": 0, "path": "src/ethereum/crypto/elliptic_curve.py"}, "content": {"type": ["attribute"], "name": ["FIELD"]}}, {"source": {"identifier": "ethereum.crypto.elliptic_curve.EllipticCurve.A", "specifier": 0, "path": "src/ethereum/crypto/elliptic_curve.py"}, "content": {"type": ["attribute"], "name": ["A"]}}, {"source": {"identifier": "ethereum.crypto.elliptic_curve.EllipticCurve.B", "specifier": 0, "path": "src/ethereum/crypto/elliptic_curve.py"}, "content": {"type": ["attribute"], "name": ["B"]}}, {"source": {"identifier": "ethereum.crypto.elliptic_curve.EllipticCurve.x", "specifier": 0, "path": "src/ethereum/crypto/elliptic_curve.py"}, "content": {"type": ["attribute"], "name": ["x"]}}, {"source": {"identifier": "ethereum.crypto.elliptic_curve.EllipticCurve.y", "specifier": 0, "path": "src/ethereum/crypto/elliptic_curve.py"}, "content": {"type": ["attribute"], "name": ["y"]}}, {"source": {"identifier": "ethereum.crypto.elliptic_curve.EllipticCurve.__new__", "specifier": 0, "path": "src/ethereum/crypto/elliptic_curve.py"}, "content": {"type": ["function"], "name": ["__new__"], "text": ["Make new point on the curve. The point is not checked to see if it is on the curve."]}}, {"source": {"identifier": "ethereum.crypto.elliptic_curve.EllipticCurve.__init__", "specifier": 0, "path": "src/ethereum/crypto/elliptic_curve.py"}, "content": {"type": ["function"], "name": ["__init__"], "text": ["Checks if the point is on the curve. To skip this check call __new__()  directly."]}}, {"source": {"identifier": "ethereum.crypto.elliptic_curve.EllipticCurve.__eq__", "specifier": 0, "path": "src/ethereum/crypto/elliptic_curve.py"}, "content": {"type": ["function"], "name": ["__eq__"], "text": ["Test two points for equality."]}}, {"source": {"identifier": "ethereum.crypto.elliptic_curve.EllipticCurve.__str__", "specifier": 0, "path": "src/ethereum/crypto/elliptic_curve.py"}, "content": {"type": ["function"], "name": ["__str__"], "text": ["Stringify a point as its coordinates."]}}, {"source": {"identifier": "ethereum.crypto.elliptic_curve.EllipticCurve.point_at_infinity", "specifier": 0, "path": "src/ethereum/crypto/elliptic_curve.py"}, "content": {"type": ["function"], "name": ["point_at_infinity"], "text": ["Return the point at infinity. This is the identity element of the group operation. The point at infinity doesn't actually have coordinates so we use (0, 0)  (which isn't on the curve) to represent it."]}}, {"source": {"identifier": "ethereum.crypto.elliptic_curve.EllipticCurve.double", "specifier": 0, "path": "src/ethereum/crypto/elliptic_curve.py"}, "content": {"type": ["function"], "name": ["double"], "text": ["Add a point to itself."]}}, {"source": {"identifier": "ethereum.crypto.elliptic_curve.EllipticCurve.__add__", "specifier": 0, "path": "src/ethereum/crypto/elliptic_curve.py"}, "content": {"type": ["function"], "name": ["__add__"], "text": ["Add two points together."]}}, {"source": {"identifier": "ethereum.crypto.elliptic_curve.EllipticCurve.mul_by", "specifier": 0, "path": "src/ethereum/crypto/elliptic_curve.py"}, "content": {"type": ["function"], "name": ["mul_by"], "text": ["Multiply  self  by  n  using the double and add algorithm."]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/__init__.py"}, "content": {"type": ["module"], "name": ["ethereum.gray_glacier.vm.instructions"], "text": ["EVM Instruction Encoding (Opcodes) ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Machine readable representations of EVM instructions, and a mapping to their implementations."]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.Ops", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/__init__.py"}, "content": {"type": ["class"], "name": ["Ops"], "text": ["Enum for EVM Opcodes"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.Ops.ADD", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["ADD"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.Ops.MUL", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["MUL"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.Ops.SUB", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SUB"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.Ops.DIV", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DIV"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.Ops.SDIV", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SDIV"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.Ops.MOD", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["MOD"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.Ops.SMOD", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SMOD"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.Ops.ADDMOD", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["ADDMOD"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.Ops.MULMOD", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["MULMOD"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.Ops.EXP", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["EXP"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.Ops.SIGNEXTEND", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SIGNEXTEND"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.Ops.LT", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["LT"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.Ops.GT", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["GT"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.Ops.SLT", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SLT"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.Ops.SGT", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SGT"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.Ops.EQ", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["EQ"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.Ops.ISZERO", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["ISZERO"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.Ops.AND", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["AND"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.Ops.OR", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["OR"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.Ops.XOR", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["XOR"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.Ops.NOT", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["NOT"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.Ops.BYTE", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["BYTE"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.Ops.SHL", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SHL"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.Ops.SHR", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SHR"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.Ops.SAR", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SAR"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.Ops.KECCAK", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["KECCAK"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.Ops.ADDRESS", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["ADDRESS"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.Ops.BALANCE", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["BALANCE"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.Ops.ORIGIN", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["ORIGIN"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.Ops.CALLER", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["CALLER"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.Ops.CALLVALUE", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["CALLVALUE"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.Ops.CALLDATALOAD", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["CALLDATALOAD"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.Ops.CALLDATASIZE", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["CALLDATASIZE"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.Ops.CALLDATACOPY", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["CALLDATACOPY"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.Ops.CODESIZE", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["CODESIZE"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.Ops.CODECOPY", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["CODECOPY"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.Ops.GASPRICE", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["GASPRICE"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.Ops.EXTCODESIZE", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["EXTCODESIZE"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.Ops.EXTCODECOPY", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["EXTCODECOPY"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.Ops.RETURNDATASIZE", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["RETURNDATASIZE"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.Ops.RETURNDATACOPY", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["RETURNDATACOPY"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.Ops.EXTCODEHASH", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["EXTCODEHASH"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.Ops.BLOCKHASH", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["BLOCKHASH"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.Ops.COINBASE", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["COINBASE"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.Ops.TIMESTAMP", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["TIMESTAMP"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.Ops.NUMBER", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["NUMBER"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.Ops.DIFFICULTY", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DIFFICULTY"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.Ops.GASLIMIT", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["GASLIMIT"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.Ops.CHAINID", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["CHAINID"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.Ops.SELFBALANCE", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SELFBALANCE"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.Ops.BASEFEE", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["BASEFEE"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.Ops.STOP", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["STOP"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.Ops.JUMP", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["JUMP"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.Ops.JUMPI", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["JUMPI"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.Ops.PC", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PC"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.Ops.GAS", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["GAS"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.Ops.JUMPDEST", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["JUMPDEST"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.Ops.SLOAD", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SLOAD"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.Ops.SSTORE", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SSTORE"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.Ops.POP", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["POP"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.Ops.PUSH1", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH1"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.Ops.PUSH2", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH2"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.Ops.PUSH3", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH3"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.Ops.PUSH4", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH4"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.Ops.PUSH5", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH5"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.Ops.PUSH6", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH6"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.Ops.PUSH7", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH7"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.Ops.PUSH8", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH8"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.Ops.PUSH9", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH9"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.Ops.PUSH10", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH10"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.Ops.PUSH11", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH11"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.Ops.PUSH12", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH12"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.Ops.PUSH13", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH13"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.Ops.PUSH14", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH14"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.Ops.PUSH15", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH15"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.Ops.PUSH16", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH16"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.Ops.PUSH17", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH17"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.Ops.PUSH18", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH18"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.Ops.PUSH19", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH19"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.Ops.PUSH20", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH20"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.Ops.PUSH21", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH21"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.Ops.PUSH22", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH22"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.Ops.PUSH23", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH23"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.Ops.PUSH24", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH24"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.Ops.PUSH25", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH25"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.Ops.PUSH26", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH26"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.Ops.PUSH27", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH27"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.Ops.PUSH28", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH28"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.Ops.PUSH29", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH29"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.Ops.PUSH30", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH30"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.Ops.PUSH31", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH31"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.Ops.PUSH32", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH32"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.Ops.DUP1", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP1"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.Ops.DUP2", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP2"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.Ops.DUP3", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP3"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.Ops.DUP4", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP4"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.Ops.DUP5", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP5"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.Ops.DUP6", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP6"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.Ops.DUP7", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP7"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.Ops.DUP8", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP8"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.Ops.DUP9", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP9"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.Ops.DUP10", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP10"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.Ops.DUP11", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP11"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.Ops.DUP12", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP12"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.Ops.DUP13", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP13"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.Ops.DUP14", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP14"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.Ops.DUP15", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP15"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.Ops.DUP16", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP16"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.Ops.SWAP1", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP1"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.Ops.SWAP2", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP2"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.Ops.SWAP3", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP3"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.Ops.SWAP4", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP4"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.Ops.SWAP5", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP5"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.Ops.SWAP6", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP6"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.Ops.SWAP7", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP7"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.Ops.SWAP8", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP8"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.Ops.SWAP9", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP9"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.Ops.SWAP10", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP10"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.Ops.SWAP11", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP11"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.Ops.SWAP12", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP12"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.Ops.SWAP13", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP13"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.Ops.SWAP14", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP14"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.Ops.SWAP15", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP15"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.Ops.SWAP16", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP16"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.Ops.MLOAD", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["MLOAD"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.Ops.MSTORE", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["MSTORE"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.Ops.MSTORE8", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["MSTORE8"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.Ops.MSIZE", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["MSIZE"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.Ops.LOG0", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["LOG0"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.Ops.LOG1", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["LOG1"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.Ops.LOG2", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["LOG2"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.Ops.LOG3", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["LOG3"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.Ops.LOG4", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["LOG4"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.Ops.CREATE", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["CREATE"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.Ops.RETURN", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["RETURN"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.Ops.CALL", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["CALL"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.Ops.CALLCODE", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["CALLCODE"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.Ops.DELEGATECALL", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DELEGATECALL"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.Ops.STATICCALL", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["STATICCALL"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.Ops.REVERT", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["REVERT"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.Ops.SELFDESTRUCT", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SELFDESTRUCT"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.Ops.CREATE2", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["CREATE2"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.op_implementation", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["op_implementation"]}}, {"source": {"identifier": "ethereum.istanbul.vm.memory", "specifier": 0, "path": "src/ethereum/istanbul/vm/memory.py"}, "content": {"type": ["module"], "name": ["ethereum.istanbul.vm.memory"], "text": ["Ethereum Virtual Machine (EVM) Memory ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction EVM memory operations."]}}, {"source": {"identifier": "ethereum.istanbul.vm.memory.memory_write", "specifier": 0, "path": "src/ethereum/istanbul/vm/memory.py"}, "content": {"type": ["function"], "name": ["memory_write"], "text": ["Writes to memory. Parameters memory : Memory contents of the EVM. start_position : Starting pointer to the memory. value : Data to write to memory."]}}, {"source": {"identifier": "ethereum.istanbul.vm.memory.memory_read_bytes", "specifier": 0, "path": "src/ethereum/istanbul/vm/memory.py"}, "content": {"type": ["function"], "name": ["memory_read_bytes"], "text": ["Read bytes from memory. Parameters memory : Memory contents of the EVM. start_position : Starting pointer to the memory. size : Size of the data that needs to be read from  start_position . Returns data_bytes : Data read from memory."]}}, {"source": {"identifier": "ethereum.istanbul.vm.memory.buffer_read", "specifier": 0, "path": "src/ethereum/istanbul/vm/memory.py"}, "content": {"type": ["function"], "name": ["buffer_read"], "text": ["Read bytes from a buffer. Padding with zeros if neccesary. Parameters buffer : Memory contents of the EVM. start_position : Starting pointer to the memory. size : Size of the data that needs to be read from  start_position . Returns data_bytes : Data read from memory."]}}, {"source": {"identifier": "ethereum.crypto.alt_bn128", "specifier": 0, "path": "src/ethereum/crypto/alt_bn128.py"}, "content": {"type": ["module"], "name": ["ethereum.crypto.alt_bn128"], "text": ["The alt_bn128 curve ^^^^^^^^^^^^^^^^^^^"]}}, {"source": {"identifier": "ethereum.crypto.alt_bn128.ALT_BN128_PRIME", "specifier": 0, "path": "src/ethereum/crypto/alt_bn128.py"}, "content": {"type": ["attribute"], "name": ["ALT_BN128_PRIME"]}}, {"source": {"identifier": "ethereum.crypto.alt_bn128.ALT_BN128_CURVE_ORDER", "specifier": 0, "path": "src/ethereum/crypto/alt_bn128.py"}, "content": {"type": ["attribute"], "name": ["ALT_BN128_CURVE_ORDER"]}}, {"source": {"identifier": "ethereum.crypto.alt_bn128.ATE_PAIRING_COUNT", "specifier": 0, "path": "src/ethereum/crypto/alt_bn128.py"}, "content": {"type": ["attribute"], "name": ["ATE_PAIRING_COUNT"]}}, {"source": {"identifier": "ethereum.crypto.alt_bn128.ATE_PAIRING_COUNT_BITS", "specifier": 0, "path": "src/ethereum/crypto/alt_bn128.py"}, "content": {"type": ["attribute"], "name": ["ATE_PAIRING_COUNT_BITS"]}}, {"source": {"identifier": "ethereum.crypto.alt_bn128.BNF", "specifier": 0, "path": "src/ethereum/crypto/alt_bn128.py"}, "content": {"type": ["class"], "name": ["BNF"], "text": ["The prime field over which the alt_bn128 curve is defined."]}}, {"source": {"identifier": "ethereum.crypto.alt_bn128.BNF.PRIME", "specifier": 0, "path": "src/ethereum/crypto/alt_bn128.py"}, "content": {"type": ["attribute"], "name": ["PRIME"]}}, {"source": {"identifier": "ethereum.crypto.alt_bn128.BNP", "specifier": 0, "path": "src/ethereum/crypto/alt_bn128.py"}, "content": {"type": ["class"], "name": ["BNP"], "text": ["The alt_bn128 curve."]}}, {"source": {"identifier": "ethereum.crypto.alt_bn128.BNP.FIELD", "specifier": 0, "path": "src/ethereum/crypto/alt_bn128.py"}, "content": {"type": ["attribute"], "name": ["FIELD"]}}, {"source": {"identifier": "ethereum.crypto.alt_bn128.BNP.A", "specifier": 0, "path": "src/ethereum/crypto/alt_bn128.py"}, "content": {"type": ["attribute"], "name": ["A"]}}, {"source": {"identifier": "ethereum.crypto.alt_bn128.BNP.B", "specifier": 0, "path": "src/ethereum/crypto/alt_bn128.py"}, "content": {"type": ["attribute"], "name": ["B"]}}, {"source": {"identifier": "ethereum.crypto.alt_bn128.BNF2", "specifier": 0, "path": "src/ethereum/crypto/alt_bn128.py"}, "content": {"type": ["class"], "name": ["BNF2"], "text": ["BNF  extended with a square root of 1 ( i )."]}}, {"source": {"identifier": "ethereum.crypto.alt_bn128.BNF2.PRIME", "specifier": 0, "path": "src/ethereum/crypto/alt_bn128.py"}, "content": {"type": ["attribute"], "name": ["PRIME"]}}, {"source": {"identifier": "ethereum.crypto.alt_bn128.BNF2.MODULUS", "specifier": 0, "path": "src/ethereum/crypto/alt_bn128.py"}, "content": {"type": ["attribute"], "name": ["MODULUS"]}}, {"source": {"identifier": "ethereum.crypto.alt_bn128.BNF2.i", "specifier": 0, "path": "src/ethereum/crypto/alt_bn128.py"}, "content": {"type": ["attribute"], "name": ["i"]}}, {"source": {"identifier": "ethereum.crypto.alt_bn128.BNF2.i_plus_9", "specifier": 0, "path": "src/ethereum/crypto/alt_bn128.py"}, "content": {"type": ["attribute"], "name": ["i_plus_9"]}}, {"source": {"identifier": "ethereum.crypto.alt_bn128.BNF2.FROBENIUS_COEFFICIENTS", "specifier": 0, "path": "src/ethereum/crypto/alt_bn128.py"}, "content": {"type": ["attribute"], "name": ["BNF2", "FROBENIUS_COEFFICIENTS"], "text": ["autoapi_noindex"]}}, {"source": {"identifier": "ethereum.crypto.alt_bn128.BNF2.i", "specifier": 1, "path": "src/ethereum/crypto/alt_bn128.py"}, "content": {"type": ["attribute"], "name": ["BNF2", "i"], "text": ["autoapi_noindex"]}}, {"source": {"identifier": "ethereum.crypto.alt_bn128.BNF2.i_plus_9", "specifier": 1, "path": "src/ethereum/crypto/alt_bn128.py"}, "content": {"type": ["attribute"], "name": ["BNF2", "i_plus_9"], "text": ["autoapi_noindex"]}}, {"source": {"identifier": "ethereum.crypto.alt_bn128.BNP2", "specifier": 0, "path": "src/ethereum/crypto/alt_bn128.py"}, "content": {"type": ["class"], "name": ["BNP2"], "text": ["A twist of  BNP . This is actually the same curve as  BNP  under a change of variable, but that change of variable is only possible over the larger field  BNP12 ."]}}, {"source": {"identifier": "ethereum.crypto.alt_bn128.BNP2.FIELD", "specifier": 0, "path": "src/ethereum/crypto/alt_bn128.py"}, "content": {"type": ["attribute"], "name": ["FIELD"]}}, {"source": {"identifier": "ethereum.crypto.alt_bn128.BNP2.A", "specifier": 0, "path": "src/ethereum/crypto/alt_bn128.py"}, "content": {"type": ["attribute"], "name": ["A"]}}, {"source": {"identifier": "ethereum.crypto.alt_bn128.BNP2.B", "specifier": 0, "path": "src/ethereum/crypto/alt_bn128.py"}, "content": {"type": ["attribute"], "name": ["B"]}}, {"source": {"identifier": "ethereum.crypto.alt_bn128.BNF12", "specifier": 0, "path": "src/ethereum/crypto/alt_bn128.py"}, "content": {"type": ["class"], "name": ["BNF12"], "text": ["BNF2  extended by adding a 6th root of  9 + i  called  w  (omega)."]}}, {"source": {"identifier": "ethereum.crypto.alt_bn128.BNF12.PRIME", "specifier": 0, "path": "src/ethereum/crypto/alt_bn128.py"}, "content": {"type": ["attribute"], "name": ["PRIME"]}}, {"source": {"identifier": "ethereum.crypto.alt_bn128.BNF12.MODULUS", "specifier": 0, "path": "src/ethereum/crypto/alt_bn128.py"}, "content": {"type": ["attribute"], "name": ["MODULUS"]}}, {"source": {"identifier": "ethereum.crypto.alt_bn128.BNF12.w", "specifier": 0, "path": "src/ethereum/crypto/alt_bn128.py"}, "content": {"type": ["attribute"], "name": ["w"]}}, {"source": {"identifier": "ethereum.crypto.alt_bn128.BNF12.i_plus_9", "specifier": 0, "path": "src/ethereum/crypto/alt_bn128.py"}, "content": {"type": ["attribute"], "name": ["i_plus_9"]}}, {"source": {"identifier": "ethereum.crypto.alt_bn128.BNF12.__mul__", "specifier": 0, "path": "src/ethereum/crypto/alt_bn128.py"}, "content": {"type": ["function"], "name": ["__mul__"], "text": ["Multiplication special cased for BNF12."]}}, {"source": {"identifier": "ethereum.crypto.alt_bn128.BNF12.FROBENIUS_COEFFICIENTS", "specifier": 0, "path": "src/ethereum/crypto/alt_bn128.py"}, "content": {"type": ["attribute"], "name": ["BNF12", "FROBENIUS_COEFFICIENTS"], "text": ["autoapi_noindex"]}}, {"source": {"identifier": "ethereum.crypto.alt_bn128.BNF12.w", "specifier": 1, "path": "src/ethereum/crypto/alt_bn128.py"}, "content": {"type": ["attribute"], "name": ["BNF12", "w"], "text": ["autoapi_noindex"]}}, {"source": {"identifier": "ethereum.crypto.alt_bn128.BNF12.i_plus_9", "specifier": 1, "path": "src/ethereum/crypto/alt_bn128.py"}, "content": {"type": ["attribute"], "name": ["BNF12", "i_plus_9"], "text": ["autoapi_noindex"]}}, {"source": {"identifier": "ethereum.crypto.alt_bn128.BNP12", "specifier": 0, "path": "src/ethereum/crypto/alt_bn128.py"}, "content": {"type": ["class"], "name": ["BNP12"], "text": ["The same curve as  BNP , but defined over the larger field. This curve has both subgroups of order  ALT_BN128_CURVE_ORDER  and allows pairings to be computed."]}}, {"source": {"identifier": "ethereum.crypto.alt_bn128.BNP12.FIELD", "specifier": 0, "path": "src/ethereum/crypto/alt_bn128.py"}, "content": {"type": ["attribute"], "name": ["FIELD"]}}, {"source": {"identifier": "ethereum.crypto.alt_bn128.BNP12.A", "specifier": 0, "path": "src/ethereum/crypto/alt_bn128.py"}, "content": {"type": ["attribute"], "name": ["A"]}}, {"source": {"identifier": "ethereum.crypto.alt_bn128.BNP12.B", "specifier": 0, "path": "src/ethereum/crypto/alt_bn128.py"}, "content": {"type": ["attribute"], "name": ["B"]}}, {"source": {"identifier": "ethereum.crypto.alt_bn128.bnf2_to_bnf12", "specifier": 0, "path": "src/ethereum/crypto/alt_bn128.py"}, "content": {"type": ["function"], "name": ["bnf2_to_bnf12"], "text": ["Lift a field element in  BNF2  to  BNF12 ."]}}, {"source": {"identifier": "ethereum.crypto.alt_bn128.bnp_to_bnp12", "specifier": 0, "path": "src/ethereum/crypto/alt_bn128.py"}, "content": {"type": ["function"], "name": ["bnp_to_bnp12"], "text": ["Lift a point from  BNP  to  BNP12 ."]}}, {"source": {"identifier": "ethereum.crypto.alt_bn128.twist", "specifier": 0, "path": "src/ethereum/crypto/alt_bn128.py"}, "content": {"type": ["function"], "name": ["twist"], "text": ["Apply to twist to change variables from the curve  BNP2  to  BNP12 ."]}}, {"source": {"identifier": "ethereum.crypto.alt_bn128.linefunc", "specifier": 0, "path": "src/ethereum/crypto/alt_bn128.py"}, "content": {"type": ["function"], "name": ["linefunc"], "text": ["Evaluate the function defining the line between points  p1  and  p2  at the point  t . The mathematical significance of this function is that is has divisor  (p1) + (p2) + (p1 + p2) - 3(O) . Note: Abstract mathematical presentations of Miller's algorithm often specify the divisor  (p1) + (p2) - (p1 + p2) - (O) . This turns out not to matter."]}}, {"source": {"identifier": "ethereum.crypto.alt_bn128.miller_loop", "specifier": 0, "path": "src/ethereum/crypto/alt_bn128.py"}, "content": {"type": ["function"], "name": ["miller_loop"], "text": ["The core of the pairing algorithm."]}}, {"source": {"identifier": "ethereum.crypto.alt_bn128.pairing", "specifier": 0, "path": "src/ethereum/crypto/alt_bn128.py"}, "content": {"type": ["function"], "name": ["pairing"], "text": ["Compute the pairing of  q  and  p ."]}}, {"source": {"identifier": "ethereum.crypto.hash", "specifier": 0, "path": "src/ethereum/crypto/hash.py"}, "content": {"type": ["module"], "name": ["ethereum.crypto.hash"], "text": ["Cryptographic Hash Functions ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Cryptographic hashing functions."]}}, {"source": {"identifier": "ethereum.crypto.hash.Hash32", "specifier": 0, "path": "src/ethereum/crypto/hash.py"}, "content": {"type": ["attribute"], "name": ["Hash32"]}}, {"source": {"identifier": "ethereum.crypto.hash.Hash64", "specifier": 0, "path": "src/ethereum/crypto/hash.py"}, "content": {"type": ["attribute"], "name": ["Hash64"]}}, {"source": {"identifier": "ethereum.crypto.hash.keccak256", "specifier": 0, "path": "src/ethereum/crypto/hash.py"}, "content": {"type": ["function"], "name": ["keccak256"], "text": ["Computes the keccak256 hash of the input  buffer . Parameters buffer : Input for the hashing function. Returns hash :  ethereum.base_types.Hash32 Output of the hash function."]}}, {"source": {"identifier": "ethereum.crypto.hash.keccak512", "specifier": 0, "path": "src/ethereum/crypto/hash.py"}, "content": {"type": ["function"], "name": ["keccak512"], "text": ["Computes the keccak512 hash of the input  buffer . Parameters buffer : Input for the hashing function. Returns hash :  ethereum.base_types.Hash32 Output of the hash function."]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.control_flow", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/control_flow.py"}, "content": {"type": ["module"], "name": ["ethereum.gray_glacier.vm.instructions.control_flow"], "text": ["Ethereum Virtual Machine (EVM) Control Flow Instructions ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementations of the EVM control flow instructions."]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.control_flow.stop", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/control_flow.py"}, "content": {"type": ["function"], "name": ["stop"], "text": ["Stop further execution of EVM code. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.control_flow.jump", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/control_flow.py"}, "content": {"type": ["function"], "name": ["jump"], "text": ["Alter the program counter to the location specified by the top of the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.control_flow.jumpi", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/control_flow.py"}, "content": {"type": ["function"], "name": ["jumpi"], "text": ["Alter the program counter to the specified location if and only if a condition is true. If the condition is not true, then the program counter would increase only by 1. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.control_flow.pc", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/control_flow.py"}, "content": {"type": ["function"], "name": ["pc"], "text": ["Push onto the stack the value of the program counter after reaching the current instruction and without increasing it for the next instruction. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.control_flow.gas_left", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/control_flow.py"}, "content": {"type": ["function"], "name": ["gas_left"], "text": ["Push the amount of available gas (including the corresponding reduction for the cost of this instruction) onto the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.control_flow.jumpdest", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/control_flow.py"}, "content": {"type": ["function"], "name": ["jumpdest"], "text": ["Mark a valid destination for jumps. This is a noop, present only to be used by  JUMP  and  JUMPI  opcodes to verify that their jump is valid. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.istanbul.vm.exceptions", "specifier": 0, "path": "src/ethereum/istanbul/vm/exceptions.py"}, "content": {"type": ["module"], "name": ["ethereum.istanbul.vm.exceptions"], "text": ["Ethereum Virtual Machine (EVM) Exceptions ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Exceptions which cause the EVM to halt exceptionally."]}}, {"source": {"identifier": "ethereum.istanbul.vm.exceptions.ExceptionalHalt", "specifier": 0, "path": "src/ethereum/istanbul/vm/exceptions.py"}, "content": {"type": ["class"], "name": ["ExceptionalHalt"], "text": ["Indicates that the EVM has experienced an exceptional halt. This causes execution to immediately end with all gas being consumed."]}}, {"source": {"identifier": "ethereum.istanbul.vm.exceptions.Revert", "specifier": 0, "path": "src/ethereum/istanbul/vm/exceptions.py"}, "content": {"type": ["class"], "name": ["Revert"], "text": ["Raised by the  REVERT  opcode. Unlike other EVM exceptions this does not result in the consumption of all gas."]}}, {"source": {"identifier": "ethereum.istanbul.vm.exceptions.StackUnderflowError", "specifier": 0, "path": "src/ethereum/istanbul/vm/exceptions.py"}, "content": {"type": ["class"], "name": ["StackUnderflowError"], "text": ["Occurs when a pop is executed on an empty stack."]}}, {"source": {"identifier": "ethereum.istanbul.vm.exceptions.StackOverflowError", "specifier": 0, "path": "src/ethereum/istanbul/vm/exceptions.py"}, "content": {"type": ["class"], "name": ["StackOverflowError"], "text": ["Occurs when a push is executed on a stack at max capacity."]}}, {"source": {"identifier": "ethereum.istanbul.vm.exceptions.OutOfGasError", "specifier": 0, "path": "src/ethereum/istanbul/vm/exceptions.py"}, "content": {"type": ["class"], "name": ["OutOfGasError"], "text": ["Occurs when an operation costs more than the amount of gas left in the frame."]}}, {"source": {"identifier": "ethereum.istanbul.vm.exceptions.InvalidOpcode", "specifier": 0, "path": "src/ethereum/istanbul/vm/exceptions.py"}, "content": {"type": ["class"], "name": ["InvalidOpcode"], "text": ["Raised when an invalid opcode is encountered."]}}, {"source": {"identifier": "ethereum.istanbul.vm.exceptions.InvalidJumpDestError", "specifier": 0, "path": "src/ethereum/istanbul/vm/exceptions.py"}, "content": {"type": ["class"], "name": ["InvalidJumpDestError"], "text": ["Occurs when the destination of a jump operation doesn't meet any of the following criteria: The jump destination is less than the length of the code. The jump destination should have the  JUMPDEST  opcode (0x5B). The jump destination shouldn't be part of the data corresponding to PUSH-N  opcodes."]}}, {"source": {"identifier": "ethereum.istanbul.vm.exceptions.StackDepthLimitError", "specifier": 0, "path": "src/ethereum/istanbul/vm/exceptions.py"}, "content": {"type": ["class"], "name": ["StackDepthLimitError"], "text": ["Raised when the message depth is greater than  1024"]}}, {"source": {"identifier": "ethereum.istanbul.vm.exceptions.WriteInStaticContext", "specifier": 0, "path": "src/ethereum/istanbul/vm/exceptions.py"}, "content": {"type": ["class"], "name": ["WriteInStaticContext"], "text": ["Raised when an attempt is made to modify the state while operating inside of a STATICCALL context."]}}, {"source": {"identifier": "ethereum.istanbul.vm.exceptions.OutOfBoundsRead", "specifier": 0, "path": "src/ethereum/istanbul/vm/exceptions.py"}, "content": {"type": ["class"], "name": ["OutOfBoundsRead"], "text": ["Raised when an attempt was made to read data beyond the boundaries of the buffer."]}}, {"source": {"identifier": "ethereum.istanbul.vm.exceptions.InvalidParameter", "specifier": 0, "path": "src/ethereum/istanbul/vm/exceptions.py"}, "content": {"type": ["class"], "name": ["InvalidParameter"], "text": ["Raised when invalid parameters are passed."]}}, {"source": {"identifier": "ethereum_spec_tools.forks", "specifier": 0, "path": "src/ethereum_spec_tools/forks.py"}, "content": {"type": ["module"], "name": ["ethereum_spec_tools.forks"], "text": ["Ethereum Forks ^^^^^^^^^^^^^^ Detects Python packages that specify Ethereum hardforks."]}}, {"source": {"identifier": "ethereum_spec_tools.forks.H", "specifier": 0, "path": "src/ethereum_spec_tools/forks.py"}, "content": {"type": ["attribute"], "name": ["H"]}}, {"source": {"identifier": "ethereum_spec_tools.forks.Hardfork", "specifier": 0, "path": "src/ethereum_spec_tools/forks.py"}, "content": {"type": ["class"], "name": ["Hardfork"], "text": ["Metadata associated with an Ethereum hardfork."]}}, {"source": {"identifier": "ethereum_spec_tools.forks.Hardfork.mod", "specifier": 0, "path": "src/ethereum_spec_tools/forks.py"}, "content": {"type": ["attribute"], "name": ["mod"]}}, {"source": {"identifier": "ethereum_spec_tools.forks.Hardfork.discover", "specifier": 0, "path": "src/ethereum_spec_tools/forks.py"}, "content": {"type": ["function"], "name": ["discover"], "text": ["Find packages which contain Ethereum hardfork specifications."]}}, {"source": {"identifier": "ethereum_spec_tools.forks.Hardfork.__init__", "specifier": 0, "path": "src/ethereum_spec_tools/forks.py"}, "content": {"type": ["function"], "name": ["__init__"]}}, {"source": {"identifier": "ethereum_spec_tools.forks.Hardfork.block", "specifier": 0, "path": "src/ethereum_spec_tools/forks.py"}, "content": {"type": ["function"], "name": ["block"], "text": ["Block number of the first block in this hard fork."]}}, {"source": {"identifier": "ethereum_spec_tools.forks.Hardfork.path", "specifier": 0, "path": "src/ethereum_spec_tools/forks.py"}, "content": {"type": ["function"], "name": ["path"], "text": ["Path to the module containing this hard fork."]}}, {"source": {"identifier": "ethereum_spec_tools.forks.Hardfork.short_name", "specifier": 0, "path": "src/ethereum_spec_tools/forks.py"}, "content": {"type": ["function"], "name": ["short_name"], "text": ["Short name (without the  ethereum.  prefix) of the hard fork."]}}, {"source": {"identifier": "ethereum_spec_tools.forks.Hardfork.name", "specifier": 0, "path": "src/ethereum_spec_tools/forks.py"}, "content": {"type": ["function"], "name": ["name"], "text": ["Name of the hard fork."]}}, {"source": {"identifier": "ethereum_spec_tools.forks.Hardfork.title_case_name", "specifier": 0, "path": "src/ethereum_spec_tools/forks.py"}, "content": {"type": ["function"], "name": ["title_case_name"], "text": ["Name of the hard fork."]}}, {"source": {"identifier": "ethereum_spec_tools.forks.Hardfork.__repr__", "specifier": 0, "path": "src/ethereum_spec_tools/forks.py"}, "content": {"type": ["function"], "name": ["__repr__"], "text": ["Return repr(self)."]}}, {"source": {"identifier": "ethereum_spec_tools.forks.Hardfork.import_module", "specifier": 0, "path": "src/ethereum_spec_tools/forks.py"}, "content": {"type": ["function"], "name": ["import_module"], "text": ["Return the module containing this specification."]}}, {"source": {"identifier": "ethereum_spec_tools.forks.Hardfork.module", "specifier": 0, "path": "src/ethereum_spec_tools/forks.py"}, "content": {"type": ["function"], "name": ["module"], "text": ["Import if necessary, and return the given module belonging to this hard fork."]}}, {"source": {"identifier": "ethereum_spec_tools.forks.Hardfork.optimized_module", "specifier": 0, "path": "src/ethereum_spec_tools/forks.py"}, "content": {"type": ["function"], "name": ["optimized_module"], "text": ["Import if necessary, and return the given module belonging to this hard fork's optimized implementation."]}}, {"source": {"identifier": "ethereum_spec_tools.forks.Hardfork.iter_modules", "specifier": 0, "path": "src/ethereum_spec_tools/forks.py"}, "content": {"type": ["function"], "name": ["iter_modules"], "text": ["Iterate through the (sub-)modules describing this hardfork."]}}, {"source": {"identifier": "ethereum_spec_tools.forks.Hardfork.walk_packages", "specifier": 0, "path": "src/ethereum_spec_tools/forks.py"}, "content": {"type": ["function"], "name": ["walk_packages"], "text": ["Iterate recursively through the (sub-)modules describing this hardfork."]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.comparison", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/comparison.py"}, "content": {"type": ["module"], "name": ["ethereum.gray_glacier.vm.instructions.comparison"], "text": ["Ethereum Virtual Machine (EVM) Comparison Instructions ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementations of the EVM Comparison instructions."]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.comparison.less_than", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/comparison.py"}, "content": {"type": ["function"], "name": ["less_than"], "text": ["Checks if the top element is less than the next top element. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.comparison.signed_less_than", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/comparison.py"}, "content": {"type": ["function"], "name": ["signed_less_than"], "text": ["Signed less-than comparison. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.comparison.greater_than", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/comparison.py"}, "content": {"type": ["function"], "name": ["greater_than"], "text": ["Checks if the top element is greater than the next top element. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.comparison.signed_greater_than", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/comparison.py"}, "content": {"type": ["function"], "name": ["signed_greater_than"], "text": ["Signed greater-than comparison. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.comparison.equal", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/comparison.py"}, "content": {"type": ["function"], "name": ["equal"], "text": ["Checks if the top element is equal to the next top element. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.comparison.is_zero", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/comparison.py"}, "content": {"type": ["function"], "name": ["is_zero"], "text": ["Checks if the top element is equal to 0. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.istanbul.vm", "specifier": 0, "path": "src/ethereum/istanbul/vm/__init__.py"}, "content": {"type": ["module"], "name": ["ethereum.istanbul.vm"], "text": ["Ethereum Virtual Machine (EVM) ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction The abstract computer which runs the code stored in an .fork_types.Account ."]}}, {"source": {"identifier": "ethereum.istanbul.vm.__all__", "specifier": 0, "path": "src/ethereum/istanbul/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["__all__"]}}, {"source": {"identifier": "ethereum.istanbul.vm.Environment", "specifier": 0, "path": "src/ethereum/istanbul/vm/__init__.py"}, "content": {"type": ["class"], "name": ["Environment"], "text": ["Items external to the virtual machine itself, provided by the environment."]}}, {"source": {"identifier": "ethereum.istanbul.vm.Environment.caller", "specifier": 0, "path": "src/ethereum/istanbul/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["caller"]}}, {"source": {"identifier": "ethereum.istanbul.vm.Environment.block_hashes", "specifier": 0, "path": "src/ethereum/istanbul/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["block_hashes"]}}, {"source": {"identifier": "ethereum.istanbul.vm.Environment.origin", "specifier": 0, "path": "src/ethereum/istanbul/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["origin"]}}, {"source": {"identifier": "ethereum.istanbul.vm.Environment.coinbase", "specifier": 0, "path": "src/ethereum/istanbul/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["coinbase"]}}, {"source": {"identifier": "ethereum.istanbul.vm.Environment.number", "specifier": 0, "path": "src/ethereum/istanbul/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["number"]}}, {"source": {"identifier": "ethereum.istanbul.vm.Environment.gas_limit", "specifier": 0, "path": "src/ethereum/istanbul/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["gas_limit"]}}, {"source": {"identifier": "ethereum.istanbul.vm.Environment.gas_price", "specifier": 0, "path": "src/ethereum/istanbul/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["gas_price"]}}, {"source": {"identifier": "ethereum.istanbul.vm.Environment.time", "specifier": 0, "path": "src/ethereum/istanbul/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["time"]}}, {"source": {"identifier": "ethereum.istanbul.vm.Environment.difficulty", "specifier": 0, "path": "src/ethereum/istanbul/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["difficulty"]}}, {"source": {"identifier": "ethereum.istanbul.vm.Environment.state", "specifier": 0, "path": "src/ethereum/istanbul/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["state"]}}, {"source": {"identifier": "ethereum.istanbul.vm.Environment.chain_id", "specifier": 0, "path": "src/ethereum/istanbul/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["chain_id"]}}, {"source": {"identifier": "ethereum.istanbul.vm.Message", "specifier": 0, "path": "src/ethereum/istanbul/vm/__init__.py"}, "content": {"type": ["class"], "name": ["Message"], "text": ["Items that are used by contract creation or message call."]}}, {"source": {"identifier": "ethereum.istanbul.vm.Message.caller", "specifier": 0, "path": "src/ethereum/istanbul/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["caller"]}}, {"source": {"identifier": "ethereum.istanbul.vm.Message.target", "specifier": 0, "path": "src/ethereum/istanbul/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["target"]}}, {"source": {"identifier": "ethereum.istanbul.vm.Message.current_target", "specifier": 0, "path": "src/ethereum/istanbul/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["current_target"]}}, {"source": {"identifier": "ethereum.istanbul.vm.Message.gas", "specifier": 0, "path": "src/ethereum/istanbul/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["gas"]}}, {"source": {"identifier": "ethereum.istanbul.vm.Message.value", "specifier": 0, "path": "src/ethereum/istanbul/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["value"]}}, {"source": {"identifier": "ethereum.istanbul.vm.Message.data", "specifier": 0, "path": "src/ethereum/istanbul/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["data"]}}, {"source": {"identifier": "ethereum.istanbul.vm.Message.code_address", "specifier": 0, "path": "src/ethereum/istanbul/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["code_address"]}}, {"source": {"identifier": "ethereum.istanbul.vm.Message.code", "specifier": 0, "path": "src/ethereum/istanbul/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["code"]}}, {"source": {"identifier": "ethereum.istanbul.vm.Message.depth", "specifier": 0, "path": "src/ethereum/istanbul/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["depth"]}}, {"source": {"identifier": "ethereum.istanbul.vm.Message.should_transfer_value", "specifier": 0, "path": "src/ethereum/istanbul/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["should_transfer_value"]}}, {"source": {"identifier": "ethereum.istanbul.vm.Message.is_static", "specifier": 0, "path": "src/ethereum/istanbul/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["is_static"]}}, {"source": {"identifier": "ethereum.istanbul.vm.Evm", "specifier": 0, "path": "src/ethereum/istanbul/vm/__init__.py"}, "content": {"type": ["class"], "name": ["Evm"], "text": ["The internal state of the virtual machine."]}}, {"source": {"identifier": "ethereum.istanbul.vm.Evm.pc", "specifier": 0, "path": "src/ethereum/istanbul/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["pc"]}}, {"source": {"identifier": "ethereum.istanbul.vm.Evm.stack", "specifier": 0, "path": "src/ethereum/istanbul/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["stack"]}}, {"source": {"identifier": "ethereum.istanbul.vm.Evm.memory", "specifier": 0, "path": "src/ethereum/istanbul/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["memory"]}}, {"source": {"identifier": "ethereum.istanbul.vm.Evm.code", "specifier": 0, "path": "src/ethereum/istanbul/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["code"]}}, {"source": {"identifier": "ethereum.istanbul.vm.Evm.gas_left", "specifier": 0, "path": "src/ethereum/istanbul/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["gas_left"]}}, {"source": {"identifier": "ethereum.istanbul.vm.Evm.env", "specifier": 0, "path": "src/ethereum/istanbul/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["env"]}}, {"source": {"identifier": "ethereum.istanbul.vm.Evm.valid_jump_destinations", "specifier": 0, "path": "src/ethereum/istanbul/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["valid_jump_destinations"]}}, {"source": {"identifier": "ethereum.istanbul.vm.Evm.logs", "specifier": 0, "path": "src/ethereum/istanbul/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["logs"]}}, {"source": {"identifier": "ethereum.istanbul.vm.Evm.refund_counter", "specifier": 0, "path": "src/ethereum/istanbul/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["refund_counter"]}}, {"source": {"identifier": "ethereum.istanbul.vm.Evm.running", "specifier": 0, "path": "src/ethereum/istanbul/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["running"]}}, {"source": {"identifier": "ethereum.istanbul.vm.Evm.message", "specifier": 0, "path": "src/ethereum/istanbul/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["message"]}}, {"source": {"identifier": "ethereum.istanbul.vm.Evm.output", "specifier": 0, "path": "src/ethereum/istanbul/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["output"]}}, {"source": {"identifier": "ethereum.istanbul.vm.Evm.accounts_to_delete", "specifier": 0, "path": "src/ethereum/istanbul/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["accounts_to_delete"]}}, {"source": {"identifier": "ethereum.istanbul.vm.Evm.touched_accounts", "specifier": 0, "path": "src/ethereum/istanbul/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["touched_accounts"]}}, {"source": {"identifier": "ethereum.istanbul.vm.Evm.has_erred", "specifier": 0, "path": "src/ethereum/istanbul/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["has_erred"]}}, {"source": {"identifier": "ethereum.istanbul.vm.Evm.return_data", "specifier": 0, "path": "src/ethereum/istanbul/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["return_data"]}}, {"source": {"identifier": "ethereum.istanbul.vm.Evm.error", "specifier": 0, "path": "src/ethereum/istanbul/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["error"]}}, {"source": {"identifier": "ethereum.istanbul.vm.incorporate_child_on_success", "specifier": 0, "path": "src/ethereum/istanbul/vm/__init__.py"}, "content": {"type": ["function"], "name": ["incorporate_child_on_success"], "text": ["Incorporate the state of a successful  child_evm  into the parent  evm . Parameters evm : The parent  EVM . child_evm : The child evm to incorporate."]}}, {"source": {"identifier": "ethereum.istanbul.vm.incorporate_child_on_error", "specifier": 0, "path": "src/ethereum/istanbul/vm/__init__.py"}, "content": {"type": ["function"], "name": ["incorporate_child_on_error"], "text": ["Incorporate the state of an unsuccessful  child_evm  into the parent  evm . Parameters evm : The parent  EVM . child_evm : The child evm to incorporate."]}}, {"source": {"identifier": "ethereum_spec_tools.toctree", "specifier": 0, "path": "src/ethereum_spec_tools/toctree.py"}, "content": {"type": ["module"], "name": ["ethereum_spec_tools.toctree"], "text": ["Modify toctree ^^^^^^^^^^^^^^ Plug-in that modifies/re-orders the toc-tree before writing."]}}, {"source": {"identifier": "ethereum_spec_tools.toctree.forks", "specifier": 0, "path": "src/ethereum_spec_tools/toctree.py"}, "content": {"type": ["attribute"], "name": ["forks"]}}, {"source": {"identifier": "ethereum_spec_tools.toctree.modify_toctree", "specifier": 0, "path": "src/ethereum_spec_tools/toctree.py"}, "content": {"type": ["function"], "name": ["modify_toctree"], "text": ["The function can be used to modify the toctree in any way. Currently handles the following modifications Re-order the packages in the order of the hardforks Change the visibility of any items that are marked as autoapi_noshow"]}}, {"source": {"identifier": "ethereum_spec_tools.toctree.setup", "specifier": 0, "path": "src/ethereum_spec_tools/toctree.py"}, "content": {"type": ["function"], "name": ["setup"], "text": ["Update documentation structure before writing the files"]}}, {"source": {"identifier": "ethereum_spec_tools.sync", "specifier": 0, "path": "src/ethereum_spec_tools/sync.py"}, "content": {"type": ["module"], "name": ["ethereum_spec_tools.sync"], "text": ["Ethereum Sync ^^^^^^^^^^^^^ Using an RPC provider, fetch each block and validate it with the specification."]}}, {"source": {"identifier": "ethereum_spec_tools.sync.T", "specifier": 0, "path": "src/ethereum_spec_tools/sync.py"}, "content": {"type": ["attribute"], "name": ["T"]}}, {"source": {"identifier": "ethereum_spec_tools.sync.RpcError", "specifier": 0, "path": "src/ethereum_spec_tools/sync.py"}, "content": {"type": ["class"], "name": ["RpcError"], "text": ["Error message and code returned by the RPC provider."]}}, {"source": {"identifier": "ethereum_spec_tools.sync.RpcError.__init__", "specifier": 0, "path": "src/ethereum_spec_tools/sync.py"}, "content": {"type": ["function"], "name": ["__init__"]}}, {"source": {"identifier": "ethereum_spec_tools.sync.ForkTracking", "specifier": 0, "path": "src/ethereum_spec_tools/sync.py"}, "content": {"type": ["class"], "name": ["ForkTracking"], "text": ["Enables subclasses to track the current fork."]}}, {"source": {"identifier": "ethereum_spec_tools.sync.ForkTracking.forks", "specifier": 0, "path": "src/ethereum_spec_tools/sync.py"}, "content": {"type": ["attribute"], "name": ["forks"]}}, {"source": {"identifier": "ethereum_spec_tools.sync.ForkTracking.block_number", "specifier": 0, "path": "src/ethereum_spec_tools/sync.py"}, "content": {"type": ["attribute"], "name": ["block_number"]}}, {"source": {"identifier": "ethereum_spec_tools.sync.ForkTracking.active_fork_index", "specifier": 0, "path": "src/ethereum_spec_tools/sync.py"}, "content": {"type": ["attribute"], "name": ["active_fork_index"]}}, {"source": {"identifier": "ethereum_spec_tools.sync.ForkTracking.__init__", "specifier": 0, "path": "src/ethereum_spec_tools/sync.py"}, "content": {"type": ["function"], "name": ["__init__"]}}, {"source": {"identifier": "ethereum_spec_tools.sync.ForkTracking.active_fork", "specifier": 0, "path": "src/ethereum_spec_tools/sync.py"}, "content": {"type": ["function"], "name": ["active_fork"], "text": ["Currently executing hard fork."]}}, {"source": {"identifier": "ethereum_spec_tools.sync.ForkTracking.next_fork", "specifier": 0, "path": "src/ethereum_spec_tools/sync.py"}, "content": {"type": ["function"], "name": ["next_fork"], "text": ["Hard fork that follows the currently executing hard fork."]}}, {"source": {"identifier": "ethereum_spec_tools.sync.ForkTracking.module", "specifier": 0, "path": "src/ethereum_spec_tools/sync.py"}, "content": {"type": ["function"], "name": ["module"], "text": ["Return a module from the current hard fork."]}}, {"source": {"identifier": "ethereum_spec_tools.sync.ForkTracking.set_block", "specifier": 0, "path": "src/ethereum_spec_tools/sync.py"}, "content": {"type": ["function"], "name": ["set_block"], "text": ["Set the block number and switch to the correct fork."]}}, {"source": {"identifier": "ethereum_spec_tools.sync.ForkTracking.advance_block", "specifier": 0, "path": "src/ethereum_spec_tools/sync.py"}, "content": {"type": ["function"], "name": ["advance_block"], "text": ["Increment the block number, return  True  if the fork changed."]}}, {"source": {"identifier": "ethereum_spec_tools.sync.BlockDownloader", "specifier": 0, "path": "src/ethereum_spec_tools/sync.py"}, "content": {"type": ["class"], "name": ["BlockDownloader"], "text": ["Downloads blocks from the RPC provider."]}}, {"source": {"identifier": "ethereum_spec_tools.sync.BlockDownloader.queue", "specifier": 0, "path": "src/ethereum_spec_tools/sync.py"}, "content": {"type": ["attribute"], "name": ["queue"]}}, {"source": {"identifier": "ethereum_spec_tools.sync.BlockDownloader.log", "specifier": 0, "path": "src/ethereum_spec_tools/sync.py"}, "content": {"type": ["attribute"], "name": ["log"]}}, {"source": {"identifier": "ethereum_spec_tools.sync.BlockDownloader.rpc_url", "specifier": 0, "path": "src/ethereum_spec_tools/sync.py"}, "content": {"type": ["attribute"], "name": ["rpc_url"]}}, {"source": {"identifier": "ethereum_spec_tools.sync.BlockDownloader.geth", "specifier": 0, "path": "src/ethereum_spec_tools/sync.py"}, "content": {"type": ["attribute"], "name": ["geth"]}}, {"source": {"identifier": "ethereum_spec_tools.sync.BlockDownloader.__init__", "specifier": 0, "path": "src/ethereum_spec_tools/sync.py"}, "content": {"type": ["function"], "name": ["__init__"]}}, {"source": {"identifier": "ethereum_spec_tools.sync.BlockDownloader.take_block", "specifier": 0, "path": "src/ethereum_spec_tools/sync.py"}, "content": {"type": ["function"], "name": ["take_block"], "text": ["Pop a block of the download queue."]}}, {"source": {"identifier": "ethereum_spec_tools.sync.BlockDownloader.download", "specifier": 0, "path": "src/ethereum_spec_tools/sync.py"}, "content": {"type": ["function"], "name": ["download"], "text": ["Fetch chunks of blocks from the RPC provider."]}}, {"source": {"identifier": "ethereum_spec_tools.sync.BlockDownloader.fetch_blocks", "specifier": 0, "path": "src/ethereum_spec_tools/sync.py"}, "content": {"type": ["function"], "name": ["fetch_blocks"], "text": ["Fetch the block specified by the given number from the RPC provider."]}}, {"source": {"identifier": "ethereum_spec_tools.sync.BlockDownloader.fetch_blocks_debug", "specifier": 0, "path": "src/ethereum_spec_tools/sync.py"}, "content": {"type": ["function"], "name": ["fetch_blocks_debug"], "text": ["Fetch the block specified by the given number from the RPC provider as an RLP encoded byte array."]}}, {"source": {"identifier": "ethereum_spec_tools.sync.BlockDownloader.load_transaction", "specifier": 0, "path": "src/ethereum_spec_tools/sync.py"}, "content": {"type": ["function"], "name": ["load_transaction"], "text": ["Turn a json transaction into a  Transaction ."]}}, {"source": {"identifier": "ethereum_spec_tools.sync.BlockDownloader.fetch_blocks_eth", "specifier": 0, "path": "src/ethereum_spec_tools/sync.py"}, "content": {"type": ["function"], "name": ["fetch_blocks_eth"], "text": ["Fetch the block specified by the given number from the RPC provider using only standard endpoints."]}}, {"source": {"identifier": "ethereum_spec_tools.sync.BlockDownloader.fetch_ommers", "specifier": 0, "path": "src/ethereum_spec_tools/sync.py"}, "content": {"type": ["function"], "name": ["fetch_ommers"], "text": ["Fetch the ommers for a given block from the RPC provider."]}}, {"source": {"identifier": "ethereum_spec_tools.sync.BlockDownloader.make_header", "specifier": 0, "path": "src/ethereum_spec_tools/sync.py"}, "content": {"type": ["function"], "name": ["make_header"], "text": ["Create a Header object from JSON describing it."]}}, {"source": {"identifier": "ethereum_spec_tools.sync.BlockDownloader.download_chain_id", "specifier": 0, "path": "src/ethereum_spec_tools/sync.py"}, "content": {"type": ["function"], "name": ["download_chain_id"], "text": ["Fetch the chain id of the executing chain from the rpc provider."]}}, {"source": {"identifier": "ethereum_spec_tools.sync.Sync", "specifier": 0, "path": "src/ethereum_spec_tools/sync.py"}, "content": {"type": ["class"], "name": ["Sync"], "text": ["A command line tool to fetch blocks from an RPC provider and validate them against the specification."]}}, {"source": {"identifier": "ethereum_spec_tools.sync.Sync.parse_arguments", "specifier": 0, "path": "src/ethereum_spec_tools/sync.py"}, "content": {"type": ["function"], "name": ["parse_arguments"], "text": ["Parse command line arguments."]}}, {"source": {"identifier": "ethereum_spec_tools.sync.Sync.downloader", "specifier": 0, "path": "src/ethereum_spec_tools/sync.py"}, "content": {"type": ["attribute"], "name": ["downloader"]}}, {"source": {"identifier": "ethereum_spec_tools.sync.Sync.options", "specifier": 0, "path": "src/ethereum_spec_tools/sync.py"}, "content": {"type": ["attribute"], "name": ["options"]}}, {"source": {"identifier": "ethereum_spec_tools.sync.Sync.chain", "specifier": 0, "path": "src/ethereum_spec_tools/sync.py"}, "content": {"type": ["attribute"], "name": ["chain"]}}, {"source": {"identifier": "ethereum_spec_tools.sync.Sync.log", "specifier": 0, "path": "src/ethereum_spec_tools/sync.py"}, "content": {"type": ["attribute"], "name": ["log"]}}, {"source": {"identifier": "ethereum_spec_tools.sync.Sync.__init__", "specifier": 0, "path": "src/ethereum_spec_tools/sync.py"}, "content": {"type": ["function"], "name": ["__init__"]}}, {"source": {"identifier": "ethereum_spec_tools.sync.Sync.persist", "specifier": 0, "path": "src/ethereum_spec_tools/sync.py"}, "content": {"type": ["function"], "name": ["persist"], "text": ["Save the block list, state and chain id to file."]}}, {"source": {"identifier": "ethereum_spec_tools.sync.Sync.fetch_chain_id", "specifier": 0, "path": "src/ethereum_spec_tools/sync.py"}, "content": {"type": ["function"], "name": ["fetch_chain_id"], "text": ["Fetch the persisted chain id from the database."]}}, {"source": {"identifier": "ethereum_spec_tools.sync.Sync.process_blocks", "specifier": 0, "path": "src/ethereum_spec_tools/sync.py"}, "content": {"type": ["function"], "name": ["process_blocks"], "text": ["Validate blocks that have been fetched."]}}, {"source": {"identifier": "ethereum_spec_tools.sync.main", "specifier": 0, "path": "src/ethereum_spec_tools/sync.py"}, "content": {"type": ["function"], "name": ["main"], "text": ["Using an RPC provider, fetch each block and validate it."]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.log", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/log.py"}, "content": {"type": ["module"], "name": ["ethereum.gray_glacier.vm.instructions.log"], "text": ["Ethereum Virtual Machine (EVM) Logging Instructions ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementations of the EVM logging instructions."]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.log.log_n", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/log.py"}, "content": {"type": ["function"], "name": ["log_n"], "text": ["Appends a log entry, having  num_topics  topics, to the evm logs. This will also expand the memory if the data (required by the log entry) corresponding to the memory is not accessible. Parameters evm : The current EVM frame. num_topics : The number of topics to be included in the log entry."]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.log.log0", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/log.py"}, "content": {"type": ["attribute"], "name": ["log0"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.log.log1", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/log.py"}, "content": {"type": ["attribute"], "name": ["log1"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.log.log2", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/log.py"}, "content": {"type": ["attribute"], "name": ["log2"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.log.log3", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/log.py"}, "content": {"type": ["attribute"], "name": ["log3"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.log.log4", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/log.py"}, "content": {"type": ["attribute"], "name": ["log4"]}}, {"source": {"identifier": "ethereum.istanbul.vm.runtime", "specifier": 0, "path": "src/ethereum/istanbul/vm/runtime.py"}, "content": {"type": ["module"], "name": ["ethereum.istanbul.vm.runtime"], "text": ["Ethereum Virtual Machine (EVM) Runtime Operations ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Runtime related operations used while executing EVM code."]}}, {"source": {"identifier": "ethereum.istanbul.vm.runtime.get_valid_jump_destinations", "specifier": 0, "path": "src/ethereum/istanbul/vm/runtime.py"}, "content": {"type": ["function"], "name": ["get_valid_jump_destinations"], "text": ["Analyze the evm code to obtain the set of valid jump destinations. Valid jump destinations are defined as follows: * The jump destination is less than the length of the code. * The jump destination should have the  JUMPDEST  opcode (0x5B). * The jump destination shouldn't be part of the data corresponding to PUSH-N  opcodes. Note - Jump destinations are 0-indexed. Parameters code : The EVM code which is to be executed. Returns valid_jump_destinations:  Set[Uint] The set of valid jump destinations in the code."]}}, {"source": {"identifier": "ethereum_spec_tools.evm_trace", "specifier": 0, "path": "src/ethereum_spec_tools/evm_trace.py"}, "content": {"type": ["module"], "name": ["ethereum_spec_tools.evm_trace"], "text": ["The module implements the raw EVM tracer for pytest"]}}, {"source": {"identifier": "ethereum_spec_tools.evm_trace.EvmTrace", "specifier": 0, "path": "src/ethereum_spec_tools/evm_trace.py"}, "content": {"type": ["class"], "name": ["EvmTrace"], "text": ["The object that is logged when pytest log_cli_level is set to 10. This can be used to create a raw trace of the evm. Contains the following:   1. `depth`: depth of the message\n  2. `pc`: programcounter before opcode execution\n  3. `op`: the opcode to be executed\n  4. `has_erred`: has the evm erred before execution\n  5. `start_gas`: evm.gas_left before execution starts\n  6. `refund`: refund counter before opcode execution\n  7. `output`: evm output\n  8. `stack`: the stack before opcode execution\n"]}}, {"source": {"identifier": "ethereum_spec_tools.evm_trace.EvmTrace.depth", "specifier": 0, "path": "src/ethereum_spec_tools/evm_trace.py"}, "content": {"type": ["attribute"], "name": ["depth"]}}, {"source": {"identifier": "ethereum_spec_tools.evm_trace.EvmTrace.pc", "specifier": 0, "path": "src/ethereum_spec_tools/evm_trace.py"}, "content": {"type": ["attribute"], "name": ["pc"]}}, {"source": {"identifier": "ethereum_spec_tools.evm_trace.EvmTrace.op", "specifier": 0, "path": "src/ethereum_spec_tools/evm_trace.py"}, "content": {"type": ["attribute"], "name": ["op"]}}, {"source": {"identifier": "ethereum_spec_tools.evm_trace.EvmTrace.has_erred", "specifier": 0, "path": "src/ethereum_spec_tools/evm_trace.py"}, "content": {"type": ["attribute"], "name": ["has_erred"]}}, {"source": {"identifier": "ethereum_spec_tools.evm_trace.EvmTrace.start_gas", "specifier": 0, "path": "src/ethereum_spec_tools/evm_trace.py"}, "content": {"type": ["attribute"], "name": ["start_gas"]}}, {"source": {"identifier": "ethereum_spec_tools.evm_trace.EvmTrace.refund", "specifier": 0, "path": "src/ethereum_spec_tools/evm_trace.py"}, "content": {"type": ["attribute"], "name": ["refund"]}}, {"source": {"identifier": "ethereum_spec_tools.evm_trace.EvmTrace.output", "specifier": 0, "path": "src/ethereum_spec_tools/evm_trace.py"}, "content": {"type": ["attribute"], "name": ["output"]}}, {"source": {"identifier": "ethereum_spec_tools.evm_trace.EvmTrace.stack", "specifier": 0, "path": "src/ethereum_spec_tools/evm_trace.py"}, "content": {"type": ["attribute"], "name": ["stack"]}}, {"source": {"identifier": "ethereum_spec_tools.evm_trace.EvmTrace.custom_repr", "specifier": 0, "path": "src/ethereum_spec_tools/evm_trace.py"}, "content": {"type": ["function"], "name": ["custom_repr"], "text": ["Add indentation for child evms (depth > 0)"]}}, {"source": {"identifier": "ethereum_spec_tools.evm_trace.evm_trace", "specifier": 0, "path": "src/ethereum_spec_tools/evm_trace.py"}, "content": {"type": ["function"], "name": ["evm_trace"], "text": ["Create a new trace instance before opcode execution"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.storage", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/storage.py"}, "content": {"type": ["module"], "name": ["ethereum.gray_glacier.vm.instructions.storage"], "text": ["Ethereum Virtual Machine (EVM) Storage Instructions ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementations of the EVM storage related instructions."]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.storage.sload", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/storage.py"}, "content": {"type": ["function"], "name": ["sload"], "text": ["Loads to the stack, the value corresponding to a certain key from the storage of the current account. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.storage.sstore", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/storage.py"}, "content": {"type": ["function"], "name": ["sstore"], "text": ["Stores a value at a certain key in the current context's storage. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.istanbul.vm.interpreter", "specifier": 0, "path": "src/ethereum/istanbul/vm/interpreter.py"}, "content": {"type": ["module"], "name": ["ethereum.istanbul.vm.interpreter"], "text": ["Ethereum Virtual Machine (EVM) Interpreter ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction A straightforward interpreter that executes EVM code."]}}, {"source": {"identifier": "ethereum.istanbul.vm.interpreter.STACK_DEPTH_LIMIT", "specifier": 0, "path": "src/ethereum/istanbul/vm/interpreter.py"}, "content": {"type": ["attribute"], "name": ["STACK_DEPTH_LIMIT"]}}, {"source": {"identifier": "ethereum.istanbul.vm.interpreter.MAX_CODE_SIZE", "specifier": 0, "path": "src/ethereum/istanbul/vm/interpreter.py"}, "content": {"type": ["attribute"], "name": ["MAX_CODE_SIZE"]}}, {"source": {"identifier": "ethereum.istanbul.vm.interpreter.MessageCallOutput", "specifier": 0, "path": "src/ethereum/istanbul/vm/interpreter.py"}, "content": {"type": ["class"], "name": ["MessageCallOutput"], "text": ["Output of a particular message call Contains the following:   1. `gas_left`: remaining gas after execution.\n  2. `refund_counter`: gas to refund after execution.\n  3. `logs`: list of `Log` generated during execution.\n  4. `accounts_to_delete`: Contracts which have self-destructed.\n  5. `touched_accounts`: Accounts that have been touched.\n  6. `has_erred`: True if execution has caused an error.\n"]}}, {"source": {"identifier": "ethereum.istanbul.vm.interpreter.MessageCallOutput.gas_left", "specifier": 0, "path": "src/ethereum/istanbul/vm/interpreter.py"}, "content": {"type": ["attribute"], "name": ["gas_left"]}}, {"source": {"identifier": "ethereum.istanbul.vm.interpreter.MessageCallOutput.refund_counter", "specifier": 0, "path": "src/ethereum/istanbul/vm/interpreter.py"}, "content": {"type": ["attribute"], "name": ["refund_counter"]}}, {"source": {"identifier": "ethereum.istanbul.vm.interpreter.MessageCallOutput.logs", "specifier": 0, "path": "src/ethereum/istanbul/vm/interpreter.py"}, "content": {"type": ["attribute"], "name": ["logs"]}}, {"source": {"identifier": "ethereum.istanbul.vm.interpreter.MessageCallOutput.accounts_to_delete", "specifier": 0, "path": "src/ethereum/istanbul/vm/interpreter.py"}, "content": {"type": ["attribute"], "name": ["accounts_to_delete"]}}, {"source": {"identifier": "ethereum.istanbul.vm.interpreter.MessageCallOutput.touched_accounts", "specifier": 0, "path": "src/ethereum/istanbul/vm/interpreter.py"}, "content": {"type": ["attribute"], "name": ["touched_accounts"]}}, {"source": {"identifier": "ethereum.istanbul.vm.interpreter.MessageCallOutput.has_erred", "specifier": 0, "path": "src/ethereum/istanbul/vm/interpreter.py"}, "content": {"type": ["attribute"], "name": ["has_erred"]}}, {"source": {"identifier": "ethereum.istanbul.vm.interpreter.process_message_call", "specifier": 0, "path": "src/ethereum/istanbul/vm/interpreter.py"}, "content": {"type": ["function"], "name": ["process_message_call"], "text": ["If  message.current  is empty then it creates a smart contract else it executes a call from the  message.caller  to the  message.target . Parameters message : Transaction specific items. env : External items required for EVM execution. Returns output :  MessageCallOutput Output of the message call"]}}, {"source": {"identifier": "ethereum.istanbul.vm.interpreter.process_create_message", "specifier": 0, "path": "src/ethereum/istanbul/vm/interpreter.py"}, "content": {"type": ["function"], "name": ["process_create_message"], "text": ["Executes a call to create a smart contract. Parameters message : Transaction specific items. env : External items required for EVM execution. Returns evm: :py:class: ~ethereum.istanbul.vm.Evm Items containing execution specific objects."]}}, {"source": {"identifier": "ethereum.istanbul.vm.interpreter.process_message", "specifier": 0, "path": "src/ethereum/istanbul/vm/interpreter.py"}, "content": {"type": ["function"], "name": ["process_message"], "text": ["Executes a call to create a smart contract. Parameters message : Transaction specific items. env : External items required for EVM execution. Returns evm: :py:class: ~ethereum.istanbul.vm.Evm Items containing execution specific objects"]}}, {"source": {"identifier": "ethereum.istanbul.vm.interpreter.execute_code", "specifier": 0, "path": "src/ethereum/istanbul/vm/interpreter.py"}, "content": {"type": ["function"], "name": ["execute_code"], "text": ["Executes bytecode present in the  message . Parameters message : Transaction specific items. env : External items required for EVM execution. Returns evm:  ethereum.vm.EVM Items containing execution specific objects"]}}, {"source": {"identifier": "ethereum_spec_tools", "specifier": 0, "path": "src/ethereum_spec_tools/__init__.py"}, "content": {"type": ["module"], "name": ["ethereum_spec_tools"], "text": ["Ethereum Specification Tools ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Library of utilities and tools necessary for rendering (or otherwise working with) the Ethereum specifications."]}}, {"source": {"identifier": "ethereum_spec_tools.nav", "specifier": 0, "path": "src/ethereum_spec_tools/nav.py"}, "content": {"type": ["module"], "name": ["ethereum_spec_tools.nav"], "text": ["Sphinx extension to collect navigation metadata for hard forks."]}}, {"source": {"identifier": "ethereum_spec_tools.nav.BASE_FORKS", "specifier": 0, "path": "src/ethereum_spec_tools/nav.py"}, "content": {"type": ["attribute"], "name": ["BASE_FORKS"]}}, {"source": {"identifier": "ethereum_spec_tools.nav._remove_prefix", "specifier": 0, "path": "src/ethereum_spec_tools/nav.py"}, "content": {"type": ["function"], "name": ["_remove_prefix"]}}, {"source": {"identifier": "ethereum_spec_tools.nav._ForkEntry", "specifier": 0, "path": "src/ethereum_spec_tools/nav.py"}, "content": {"type": ["class"], "name": ["_ForkEntry"]}}, {"source": {"identifier": "ethereum_spec_tools.nav._ForkEntry.modules", "specifier": 0, "path": "src/ethereum_spec_tools/nav.py"}, "content": {"type": ["attribute"], "name": ["modules"]}}, {"source": {"identifier": "ethereum_spec_tools.nav._ForkEntry.comparisons", "specifier": 0, "path": "src/ethereum_spec_tools/nav.py"}, "content": {"type": ["attribute"], "name": ["comparisons"]}}, {"source": {"identifier": "ethereum_spec_tools.nav.HardforkIndex", "specifier": 0, "path": "src/ethereum_spec_tools/nav.py"}, "content": {"type": ["class"], "name": ["HardforkIndex"], "text": ["Collects metadata for hard forks."]}}, {"source": {"identifier": "ethereum_spec_tools.nav.HardforkIndex.name", "specifier": 0, "path": "src/ethereum_spec_tools/nav.py"}, "content": {"type": ["attribute"], "name": ["name"]}}, {"source": {"identifier": "ethereum_spec_tools.nav.HardforkIndex.localname", "specifier": 0, "path": "src/ethereum_spec_tools/nav.py"}, "content": {"type": ["attribute"], "name": ["localname"]}}, {"source": {"identifier": "ethereum_spec_tools.nav.HardforkIndex.shortname", "specifier": 0, "path": "src/ethereum_spec_tools/nav.py"}, "content": {"type": ["attribute"], "name": ["shortname"]}}, {"source": {"identifier": "ethereum_spec_tools.nav.HardforkIndex.generate", "specifier": 0, "path": "src/ethereum_spec_tools/nav.py"}, "content": {"type": ["function"], "name": ["generate"], "text": ["Build an index."]}}, {"source": {"identifier": "ethereum_spec_tools.nav.NavigationBarEntry", "specifier": 0, "path": "src/ethereum_spec_tools/nav.py"}, "content": {"type": ["class"], "name": ["NavigationBarEntry"], "text": ["Additional hard fork context for HTML templates."]}}, {"source": {"identifier": "ethereum_spec_tools.nav.NavigationBarEntry.uri", "specifier": 0, "path": "src/ethereum_spec_tools/nav.py"}, "content": {"type": ["attribute"], "name": ["uri"]}}, {"source": {"identifier": "ethereum_spec_tools.nav.NavigationBarEntry.short_name", "specifier": 0, "path": "src/ethereum_spec_tools/nav.py"}, "content": {"type": ["attribute"], "name": ["short_name"]}}, {"source": {"identifier": "ethereum_spec_tools.nav.NavigationBarEntry.selected", "specifier": 0, "path": "src/ethereum_spec_tools/nav.py"}, "content": {"type": ["attribute"], "name": ["selected"]}}, {"source": {"identifier": "ethereum_spec_tools.nav.NavigationBar", "specifier": 0, "path": "src/ethereum_spec_tools/nav.py"}, "content": {"type": ["class"], "name": ["NavigationBar"], "text": ["Adds information to the HTML page context about hard forks."]}}, {"source": {"identifier": "ethereum_spec_tools.nav.NavigationBar.hardforks", "specifier": 0, "path": "src/ethereum_spec_tools/nav.py"}, "content": {"type": ["attribute"], "name": ["hardforks"]}}, {"source": {"identifier": "ethereum_spec_tools.nav.NavigationBar.__init__", "specifier": 0, "path": "src/ethereum_spec_tools/nav.py"}, "content": {"type": ["function"], "name": ["__init__"]}}, {"source": {"identifier": "ethereum_spec_tools.nav.NavigationBar.builder_init", "specifier": 0, "path": "src/ethereum_spec_tools/nav.py"}, "content": {"type": ["function"], "name": ["builder_init"], "text": ["Initialize this plugin."]}}, {"source": {"identifier": "ethereum_spec_tools.nav.NavigationBar.html_page_context", "specifier": 0, "path": "src/ethereum_spec_tools/nav.py"}, "content": {"type": ["function"], "name": ["html_page_context"], "text": ["Add additional context for the HTML template."]}}, {"source": {"identifier": "ethereum_spec_tools.nav.setup", "specifier": 0, "path": "src/ethereum_spec_tools/nav.py"}, "content": {"type": ["function"], "name": ["setup"], "text": ["Register the Sphinx plugin."]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.block", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/block.py"}, "content": {"type": ["module"], "name": ["ethereum.gray_glacier.vm.instructions.block"], "text": ["Ethereum Virtual Machine (EVM) Block Instructions ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementations of the EVM block instructions."]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.block.block_hash", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/block.py"}, "content": {"type": ["function"], "name": ["block_hash"], "text": ["Push the hash of one of the 256 most recent complete blocks onto the stack. The block number to hash is present at the top of the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.block.coinbase", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/block.py"}, "content": {"type": ["function"], "name": ["coinbase"], "text": ["Push the current block's beneficiary address (address of the block miner) onto the stack. Here the current block refers to the block in which the currently executing transaction/call resides. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.block.timestamp", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/block.py"}, "content": {"type": ["function"], "name": ["timestamp"], "text": ["Push the current block's timestamp onto the stack. Here the timestamp being referred is actually the unix timestamp in seconds. Here the current block refers to the block in which the currently executing transaction/call resides. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.block.number", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/block.py"}, "content": {"type": ["function"], "name": ["number"], "text": ["Push the current block's number onto the stack. Here the current block refers to the block in which the currently executing transaction/call resides. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.block.difficulty", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/block.py"}, "content": {"type": ["function"], "name": ["difficulty"], "text": ["Push the current block's difficulty onto the stack. Here the current block refers to the block in which the currently executing transaction/call resides. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.block.gas_limit", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/block.py"}, "content": {"type": ["function"], "name": ["gas_limit"], "text": ["Push the current block's gas limit onto the stack. Here the current block refers to the block in which the currently executing transaction/call resides. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.block.chain_id", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/block.py"}, "content": {"type": ["function"], "name": ["chain_id"], "text": ["Push the chain id onto the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.istanbul.vm.stack", "specifier": 0, "path": "src/ethereum/istanbul/vm/stack.py"}, "content": {"type": ["module"], "name": ["ethereum.istanbul.vm.stack"], "text": ["Ethereum Virtual Machine (EVM) Stack ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementation of the stack operators for the EVM."]}}, {"source": {"identifier": "ethereum.istanbul.vm.stack.pop", "specifier": 0, "path": "src/ethereum/istanbul/vm/stack.py"}, "content": {"type": ["function"], "name": ["pop"], "text": ["Pops the top item off of  stack . Parameters stack : EVM stack. Returns value :  U256 The top element on the stack."]}}, {"source": {"identifier": "ethereum.istanbul.vm.stack.push", "specifier": 0, "path": "src/ethereum/istanbul/vm/stack.py"}, "content": {"type": ["function"], "name": ["push"], "text": ["Pushes  value  onto  stack . Parameters stack : EVM stack. value : Item to be pushed onto  stack ."]}}, {"source": {"identifier": "ethereum_spec_tools.autoapi_patch", "specifier": 0, "path": "src/ethereum_spec_tools/autoapi_patch.py"}, "content": {"type": ["module"], "name": ["ethereum_spec_tools.autoapi_patch"], "text": ["The autoapi function used for documentation does not fully capture assignment of object variables. E.g- in the module test.py A.x = 10 B.x = 5 Both instances are treated as  test.x  instead of  test.A.x  &  test.B.x This could incorrectly lead to duplicates. This tool is used as a patch."]}}, {"source": {"identifier": "ethereum_spec_tools.autoapi_patch.get_assign_value_patch", "specifier": 0, "path": "src/ethereum_spec_tools/autoapi_patch.py"}, "content": {"type": ["function"], "name": ["get_assign_value_patch"], "text": ["The get_assign_value function in autoapi.mappers.python.astroid_utils does not handle Attribute assignment properly in that it only considers the attribute name and omits out the information about the parent object"]}}, {"source": {"identifier": "ethereum_spec_tools.autoapi_patch.get_assign_name", "specifier": 0, "path": "src/ethereum_spec_tools/autoapi_patch.py"}, "content": {"type": ["function"], "name": ["get_assign_name"], "text": ["Recursively the assign name"]}}, {"source": {"identifier": "ethereum_spec_tools.autoapi_patch.apply_patch", "specifier": 0, "path": "src/ethereum_spec_tools/autoapi_patch.py"}, "content": {"type": ["function"], "name": ["apply_patch"], "text": ["Apply the patch"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.arithmetic", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/arithmetic.py"}, "content": {"type": ["module"], "name": ["ethereum.gray_glacier.vm.instructions.arithmetic"], "text": ["Ethereum Virtual Machine (EVM) Arithmetic Instructions ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementations of the EVM Arithmetic instructions."]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.arithmetic.add", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/arithmetic.py"}, "content": {"type": ["function"], "name": ["add"], "text": ["Adds the top two elements of the stack together, and pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.arithmetic.sub", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/arithmetic.py"}, "content": {"type": ["function"], "name": ["sub"], "text": ["Subtracts the top two elements of the stack, and pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.arithmetic.mul", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/arithmetic.py"}, "content": {"type": ["function"], "name": ["mul"], "text": ["Multiply the top two elements of the stack, and pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.arithmetic.div", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/arithmetic.py"}, "content": {"type": ["function"], "name": ["div"], "text": ["Integer division of the top two elements of the stack. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.arithmetic.sdiv", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/arithmetic.py"}, "content": {"type": ["function"], "name": ["sdiv"], "text": ["Signed integer division of the top two elements of the stack. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.arithmetic.mod", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/arithmetic.py"}, "content": {"type": ["function"], "name": ["mod"], "text": ["Modulo remainder of the top two elements of the stack. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.arithmetic.smod", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/arithmetic.py"}, "content": {"type": ["function"], "name": ["smod"], "text": ["Signed modulo remainder of the top two elements of the stack. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.arithmetic.addmod", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/arithmetic.py"}, "content": {"type": ["function"], "name": ["addmod"], "text": ["Modulo addition of the top 2 elements with the 3rd element. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.arithmetic.mulmod", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/arithmetic.py"}, "content": {"type": ["function"], "name": ["mulmod"], "text": ["Modulo multiplication of the top 2 elements with the 3rd element. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.arithmetic.exp", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/arithmetic.py"}, "content": {"type": ["function"], "name": ["exp"], "text": ["Exponential operation of the top 2 elements. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.arithmetic.signextend", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/arithmetic.py"}, "content": {"type": ["function"], "name": ["signextend"], "text": ["Sign extend operation. In other words, extend a signed number which fits in N bytes to 32 bytes. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.istanbul.vm.gas", "specifier": 0, "path": "src/ethereum/istanbul/vm/gas.py"}, "content": {"type": ["module"], "name": ["ethereum.istanbul.vm.gas"], "text": ["Ethereum Virtual Machine (EVM) Gas ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction EVM gas constants and calculators."]}}, {"source": {"identifier": "ethereum.istanbul.vm.gas.GAS_JUMPDEST", "specifier": 0, "path": "src/ethereum/istanbul/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_JUMPDEST"]}}, {"source": {"identifier": "ethereum.istanbul.vm.gas.GAS_BASE", "specifier": 0, "path": "src/ethereum/istanbul/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_BASE"]}}, {"source": {"identifier": "ethereum.istanbul.vm.gas.GAS_VERY_LOW", "specifier": 0, "path": "src/ethereum/istanbul/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_VERY_LOW"]}}, {"source": {"identifier": "ethereum.istanbul.vm.gas.GAS_SLOAD", "specifier": 0, "path": "src/ethereum/istanbul/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_SLOAD"]}}, {"source": {"identifier": "ethereum.istanbul.vm.gas.GAS_STORAGE_SET", "specifier": 0, "path": "src/ethereum/istanbul/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_STORAGE_SET"]}}, {"source": {"identifier": "ethereum.istanbul.vm.gas.GAS_STORAGE_UPDATE", "specifier": 0, "path": "src/ethereum/istanbul/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_STORAGE_UPDATE"]}}, {"source": {"identifier": "ethereum.istanbul.vm.gas.GAS_STORAGE_CLEAR_REFUND", "specifier": 0, "path": "src/ethereum/istanbul/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_STORAGE_CLEAR_REFUND"]}}, {"source": {"identifier": "ethereum.istanbul.vm.gas.GAS_LOW", "specifier": 0, "path": "src/ethereum/istanbul/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_LOW"]}}, {"source": {"identifier": "ethereum.istanbul.vm.gas.GAS_MID", "specifier": 0, "path": "src/ethereum/istanbul/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_MID"]}}, {"source": {"identifier": "ethereum.istanbul.vm.gas.GAS_HIGH", "specifier": 0, "path": "src/ethereum/istanbul/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_HIGH"]}}, {"source": {"identifier": "ethereum.istanbul.vm.gas.GAS_EXPONENTIATION", "specifier": 0, "path": "src/ethereum/istanbul/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_EXPONENTIATION"]}}, {"source": {"identifier": "ethereum.istanbul.vm.gas.GAS_EXPONENTIATION_PER_BYTE", "specifier": 0, "path": "src/ethereum/istanbul/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_EXPONENTIATION_PER_BYTE"]}}, {"source": {"identifier": "ethereum.istanbul.vm.gas.GAS_MEMORY", "specifier": 0, "path": "src/ethereum/istanbul/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_MEMORY"]}}, {"source": {"identifier": "ethereum.istanbul.vm.gas.GAS_KECCAK256", "specifier": 0, "path": "src/ethereum/istanbul/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_KECCAK256"]}}, {"source": {"identifier": "ethereum.istanbul.vm.gas.GAS_KECCAK256_WORD", "specifier": 0, "path": "src/ethereum/istanbul/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_KECCAK256_WORD"]}}, {"source": {"identifier": "ethereum.istanbul.vm.gas.GAS_COPY", "specifier": 0, "path": "src/ethereum/istanbul/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_COPY"]}}, {"source": {"identifier": "ethereum.istanbul.vm.gas.GAS_BLOCK_HASH", "specifier": 0, "path": "src/ethereum/istanbul/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_BLOCK_HASH"]}}, {"source": {"identifier": "ethereum.istanbul.vm.gas.GAS_EXTERNAL", "specifier": 0, "path": "src/ethereum/istanbul/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_EXTERNAL"]}}, {"source": {"identifier": "ethereum.istanbul.vm.gas.GAS_BALANCE", "specifier": 0, "path": "src/ethereum/istanbul/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_BALANCE"]}}, {"source": {"identifier": "ethereum.istanbul.vm.gas.GAS_LOG", "specifier": 0, "path": "src/ethereum/istanbul/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_LOG"]}}, {"source": {"identifier": "ethereum.istanbul.vm.gas.GAS_LOG_DATA", "specifier": 0, "path": "src/ethereum/istanbul/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_LOG_DATA"]}}, {"source": {"identifier": "ethereum.istanbul.vm.gas.GAS_LOG_TOPIC", "specifier": 0, "path": "src/ethereum/istanbul/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_LOG_TOPIC"]}}, {"source": {"identifier": "ethereum.istanbul.vm.gas.GAS_CREATE", "specifier": 0, "path": "src/ethereum/istanbul/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_CREATE"]}}, {"source": {"identifier": "ethereum.istanbul.vm.gas.GAS_CODE_DEPOSIT", "specifier": 0, "path": "src/ethereum/istanbul/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_CODE_DEPOSIT"]}}, {"source": {"identifier": "ethereum.istanbul.vm.gas.GAS_ZERO", "specifier": 0, "path": "src/ethereum/istanbul/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_ZERO"]}}, {"source": {"identifier": "ethereum.istanbul.vm.gas.GAS_CALL", "specifier": 0, "path": "src/ethereum/istanbul/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_CALL"]}}, {"source": {"identifier": "ethereum.istanbul.vm.gas.GAS_NEW_ACCOUNT", "specifier": 0, "path": "src/ethereum/istanbul/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_NEW_ACCOUNT"]}}, {"source": {"identifier": "ethereum.istanbul.vm.gas.GAS_CALL_VALUE", "specifier": 0, "path": "src/ethereum/istanbul/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_CALL_VALUE"]}}, {"source": {"identifier": "ethereum.istanbul.vm.gas.GAS_CALL_STIPEND", "specifier": 0, "path": "src/ethereum/istanbul/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_CALL_STIPEND"]}}, {"source": {"identifier": "ethereum.istanbul.vm.gas.GAS_SELF_DESTRUCT", "specifier": 0, "path": "src/ethereum/istanbul/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_SELF_DESTRUCT"]}}, {"source": {"identifier": "ethereum.istanbul.vm.gas.GAS_SELF_DESTRUCT_NEW_ACCOUNT", "specifier": 0, "path": "src/ethereum/istanbul/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_SELF_DESTRUCT_NEW_ACCOUNT"]}}, {"source": {"identifier": "ethereum.istanbul.vm.gas.REFUND_SELF_DESTRUCT", "specifier": 0, "path": "src/ethereum/istanbul/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["REFUND_SELF_DESTRUCT"]}}, {"source": {"identifier": "ethereum.istanbul.vm.gas.GAS_ECRECOVER", "specifier": 0, "path": "src/ethereum/istanbul/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_ECRECOVER"]}}, {"source": {"identifier": "ethereum.istanbul.vm.gas.GAS_SHA256", "specifier": 0, "path": "src/ethereum/istanbul/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_SHA256"]}}, {"source": {"identifier": "ethereum.istanbul.vm.gas.GAS_SHA256_WORD", "specifier": 0, "path": "src/ethereum/istanbul/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_SHA256_WORD"]}}, {"source": {"identifier": "ethereum.istanbul.vm.gas.GAS_RIPEMD160", "specifier": 0, "path": "src/ethereum/istanbul/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_RIPEMD160"]}}, {"source": {"identifier": "ethereum.istanbul.vm.gas.GAS_RIPEMD160_WORD", "specifier": 0, "path": "src/ethereum/istanbul/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_RIPEMD160_WORD"]}}, {"source": {"identifier": "ethereum.istanbul.vm.gas.GAS_IDENTITY", "specifier": 0, "path": "src/ethereum/istanbul/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_IDENTITY"]}}, {"source": {"identifier": "ethereum.istanbul.vm.gas.GAS_IDENTITY_WORD", "specifier": 0, "path": "src/ethereum/istanbul/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_IDENTITY_WORD"]}}, {"source": {"identifier": "ethereum.istanbul.vm.gas.GAS_RETURN_DATA_COPY", "specifier": 0, "path": "src/ethereum/istanbul/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_RETURN_DATA_COPY"]}}, {"source": {"identifier": "ethereum.istanbul.vm.gas.GAS_CODE_HASH", "specifier": 0, "path": "src/ethereum/istanbul/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_CODE_HASH"]}}, {"source": {"identifier": "ethereum.istanbul.vm.gas.GAS_FAST_STEP", "specifier": 0, "path": "src/ethereum/istanbul/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_FAST_STEP"]}}, {"source": {"identifier": "ethereum.istanbul.vm.gas.GAS_BLAKE2_PER_ROUND", "specifier": 0, "path": "src/ethereum/istanbul/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_BLAKE2_PER_ROUND"]}}, {"source": {"identifier": "ethereum.istanbul.vm.gas.ExtendMemory", "specifier": 0, "path": "src/ethereum/istanbul/vm/gas.py"}, "content": {"type": ["class"], "name": ["ExtendMemory"], "text": ["Define the parameters for memory extension in opcodes cost :  ethereum.base_types.Uint The gas required to perform the extension expand_by :  ethereum.base_types.Uint The size by which the memory will be extended"]}}, {"source": {"identifier": "ethereum.istanbul.vm.gas.ExtendMemory.cost", "specifier": 0, "path": "src/ethereum/istanbul/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["cost"]}}, {"source": {"identifier": "ethereum.istanbul.vm.gas.ExtendMemory.expand_by", "specifier": 0, "path": "src/ethereum/istanbul/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["expand_by"]}}, {"source": {"identifier": "ethereum.istanbul.vm.gas.MessageCallGas", "specifier": 0, "path": "src/ethereum/istanbul/vm/gas.py"}, "content": {"type": ["class"], "name": ["MessageCallGas"], "text": ["Define the gas cost and stipend for executing the call opcodes. cost :  ethereum.base_types.Uint The non-refundable portion of gas reserved for executing the call opcode. stipend :  ethereum.base_types.Uint The portion of gas available to sub-calls that is refundable if not consumed"]}}, {"source": {"identifier": "ethereum.istanbul.vm.gas.MessageCallGas.cost", "specifier": 0, "path": "src/ethereum/istanbul/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["cost"]}}, {"source": {"identifier": "ethereum.istanbul.vm.gas.MessageCallGas.stipend", "specifier": 0, "path": "src/ethereum/istanbul/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["stipend"]}}, {"source": {"identifier": "ethereum.istanbul.vm.gas.charge_gas", "specifier": 0, "path": "src/ethereum/istanbul/vm/gas.py"}, "content": {"type": ["function"], "name": ["charge_gas"], "text": ["Subtracts  amount  from  evm.gas_left . Parameters evm : The current EVM. amount : The amount of gas the current operation requires."]}}, {"source": {"identifier": "ethereum.istanbul.vm.gas.calculate_memory_gas_cost", "specifier": 0, "path": "src/ethereum/istanbul/vm/gas.py"}, "content": {"type": ["function"], "name": ["calculate_memory_gas_cost"], "text": ["Calculates the gas cost for allocating memory to the smallest multiple of 32 bytes, such that the allocated size is at least as big as the given size. Parameters size_in_bytes : The size of the data in bytes. Returns total_gas_cost :  ethereum.base_types.Uint The gas cost for storing data in memory."]}}, {"source": {"identifier": "ethereum.istanbul.vm.gas.calculate_gas_extend_memory", "specifier": 0, "path": "src/ethereum/istanbul/vm/gas.py"}, "content": {"type": ["function"], "name": ["calculate_gas_extend_memory"], "text": ["Calculates the gas amount to extend memory Parameters memory : Memory contents of the EVM. extensions: List of extensions to be made to the memory. Consists of a tuple of start position and size. Returns extend_memory:  ExtendMemory"]}}, {"source": {"identifier": "ethereum.istanbul.vm.gas.calculate_message_call_gas", "specifier": 0, "path": "src/ethereum/istanbul/vm/gas.py"}, "content": {"type": ["function"], "name": ["calculate_message_call_gas"], "text": ["Calculates the MessageCallGas (cost and stipend) for executing call Opcodes. Parameters value: The amount of  ETH  that needs to be transferred. gas : The amount of gas provided to the message-call. gas_left : The amount of gas left in the current frame. memory_cost : The amount needed to extend the memory in the current frame. extra_gas : The amount of gas needed for transferring value + creating a new account inside a message call. call_stipend : The amount of stipend provided to a message call to execute code while transferring value(ETH). Returns message_call_gas:  MessageCallGas"]}}, {"source": {"identifier": "ethereum.istanbul.vm.gas.max_message_call_gas", "specifier": 0, "path": "src/ethereum/istanbul/vm/gas.py"}, "content": {"type": ["function"], "name": ["max_message_call_gas"], "text": ["Calculates the maximum gas that is allowed for making a message call Parameters gas : The amount of gas provided to the message-call. Returns max_allowed_message_call_gas:  ethereum.base_types.Uint The maximum gas allowed for making the message-call."]}}, {"source": {"identifier": "ethereum_spec_tools.patch_tool", "specifier": 0, "path": "src/ethereum_spec_tools/patch_tool.py"}, "content": {"type": ["module"], "name": ["ethereum_spec_tools.patch_tool"], "text": ["Simple patching tool"]}}, {"source": {"identifier": "ethereum_spec_tools.patch_tool.DESCRIPTION", "specifier": 0, "path": "src/ethereum_spec_tools/patch_tool.py"}, "content": {"type": ["attribute"], "name": ["DESCRIPTION"]}}, {"source": {"identifier": "ethereum_spec_tools.patch_tool.parser", "specifier": 0, "path": "src/ethereum_spec_tools/patch_tool.py"}, "content": {"type": ["attribute"], "name": ["parser"]}}, {"source": {"identifier": "ethereum_spec_tools.patch_tool.options", "specifier": 0, "path": "src/ethereum_spec_tools/patch_tool.py"}, "content": {"type": ["attribute"], "name": ["options"]}}, {"source": {"identifier": "ethereum_spec_tools.patch_tool.source_fork_path", "specifier": 0, "path": "src/ethereum_spec_tools/patch_tool.py"}, "content": {"type": ["attribute"], "name": ["source_fork_path"]}}, {"source": {"identifier": "ethereum_spec_tools.patch_tool.git_diff", "specifier": 0, "path": "src/ethereum_spec_tools/patch_tool.py"}, "content": {"type": ["attribute"], "name": ["git_diff"]}}, {"source": {"identifier": "ethereum_spec_tools.patch_tool.output_lines", "specifier": 0, "path": "src/ethereum_spec_tools/patch_tool.py"}, "content": {"type": ["attribute"], "name": ["output_lines"]}}, {"source": {"identifier": "ethereum_spec_tools.diff", "specifier": 0, "path": "src/ethereum_spec_tools/diff.py"}, "content": {"type": ["module"], "name": ["ethereum_spec_tools.diff"], "text": ["Generates diffs between Ethereum hardforks documentation."]}}, {"source": {"identifier": "ethereum_spec_tools.diff.T", "specifier": 0, "path": "src/ethereum_spec_tools/diff.py"}, "content": {"type": ["attribute"], "name": ["T"]}}, {"source": {"identifier": "ethereum_spec_tools.diff.window", "specifier": 0, "path": "src/ethereum_spec_tools/diff.py"}, "content": {"type": ["function"], "name": ["window"], "text": ["Group a list into overlapping chunks."]}}, {"source": {"identifier": "ethereum_spec_tools.diff.find_pickles", "specifier": 0, "path": "src/ethereum_spec_tools/diff.py"}, "content": {"type": ["function"], "name": ["find_pickles"], "text": ["Find files ending with :code: extension ."]}}, {"source": {"identifier": "ethereum_spec_tools.diff.pattern", "specifier": 0, "path": "src/ethereum_spec_tools/diff.py"}, "content": {"type": ["attribute"], "name": ["pattern"]}}, {"source": {"identifier": "ethereum_spec_tools.diff.meaningful_diffs", "specifier": 0, "path": "src/ethereum_spec_tools/diff.py"}, "content": {"type": ["function"], "name": ["meaningful_diffs"], "text": ["Find if there are meaningful differences between the docs"]}}, {"source": {"identifier": "ethereum_spec_tools.diff._diff", "specifier": 0, "path": "src/ethereum_spec_tools/diff.py"}, "content": {"type": ["function"], "name": ["_diff"]}}, {"source": {"identifier": "ethereum_spec_tools.diff.diff", "specifier": 0, "path": "src/ethereum_spec_tools/diff.py"}, "content": {"type": ["function"], "name": ["diff"], "text": ["Calculate the structured diff between two hardforks."]}}, {"source": {"identifier": "ethereum_spec_tools.diff.main", "specifier": 0, "path": "src/ethereum_spec_tools/diff.py"}, "content": {"type": ["function"], "name": ["main"], "text": ["Compute structural diffs between hard forks."]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.keccak", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/keccak.py"}, "content": {"type": ["module"], "name": ["ethereum.gray_glacier.vm.instructions.keccak"], "text": ["Ethereum Virtual Machine (EVM) Keccak Instructions ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementations of the EVM keccak instructions."]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.keccak.keccak", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/keccak.py"}, "content": {"type": ["function"], "name": ["keccak"], "text": ["Pushes to the stack the Keccak-256 hash of a region of memory. This also expands the memory, in case the memory is insufficient to access the data's memory location. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.istanbul.vm.precompiled_contracts.blake2f", "specifier": 0, "path": "src/ethereum/istanbul/vm/precompiled_contracts/blake2f.py"}, "content": {"type": ["module"], "name": ["ethereum.istanbul.vm.precompiled_contracts.blake2f"], "text": ["Ethereum Virtual Machine (EVM) Blake2 PRECOMPILED CONTRACT ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementation of the  Blake2  precompiled contract."]}}, {"source": {"identifier": "ethereum.istanbul.vm.precompiled_contracts.blake2f.blake2f", "specifier": 0, "path": "src/ethereum/istanbul/vm/precompiled_contracts/blake2f.py"}, "content": {"type": ["function"], "name": ["blake2f"], "text": ["Writes the Blake2 hash to output. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum_spec_tools.new_fork", "specifier": 0, "path": "src/ethereum_spec_tools/new_fork.py"}, "content": {"type": ["module"], "name": ["ethereum_spec_tools.new_fork"], "text": ["Tool to create a new fork using the latest fork"]}}, {"source": {"identifier": "ethereum_spec_tools.new_fork.DESCRIPTION", "specifier": 0, "path": "src/ethereum_spec_tools/new_fork.py"}, "content": {"type": ["attribute"], "name": ["DESCRIPTION"]}}, {"source": {"identifier": "ethereum_spec_tools.new_fork.parser", "specifier": 0, "path": "src/ethereum_spec_tools/new_fork.py"}, "content": {"type": ["attribute"], "name": ["parser"]}}, {"source": {"identifier": "ethereum_spec_tools.new_fork.find_replace", "specifier": 0, "path": "src/ethereum_spec_tools/new_fork.py"}, "content": {"type": ["function"], "name": ["find_replace"], "text": ["Replace the occurrance of a certain text in files with a new text"]}}, {"source": {"identifier": "ethereum_spec_tools.new_fork.ForkCreator", "specifier": 0, "path": "src/ethereum_spec_tools/new_fork.py"}, "content": {"type": ["class"], "name": ["ForkCreator"], "text": ["Object to create base code for a new fork from the previous fork."]}}, {"source": {"identifier": "ethereum_spec_tools.new_fork.ForkCreator.__init__", "specifier": 0, "path": "src/ethereum_spec_tools/new_fork.py"}, "content": {"type": ["function"], "name": ["__init__"]}}, {"source": {"identifier": "ethereum_spec_tools.new_fork.ForkCreator.get_fork_paths", "specifier": 0, "path": "src/ethereum_spec_tools/new_fork.py"}, "content": {"type": ["function"], "name": ["get_fork_paths"], "text": ["Get the relevant paths for all folders in a particular fork."]}}, {"source": {"identifier": "ethereum_spec_tools.new_fork.ForkCreator.duplicate_fork", "specifier": 0, "path": "src/ethereum_spec_tools/new_fork.py"}, "content": {"type": ["function"], "name": ["duplicate_fork"], "text": ["Copy the relevant files/folders from the old fork"]}}, {"source": {"identifier": "ethereum_spec_tools.new_fork.ForkCreator.update_new_fork_contents", "specifier": 0, "path": "src/ethereum_spec_tools/new_fork.py"}, "content": {"type": ["function"], "name": ["update_new_fork_contents"], "text": ["Replace references to the old fork with the new ones The following however, will have to be updated manually 1. The fork number and MAINNET_FORK_BLOCK in  init .py 2. Any absolute package imports from other forks eg. in trie.py 3. Package Names under setup.cfg"]}}, {"source": {"identifier": "ethereum_spec_tools.new_fork.main", "specifier": 0, "path": "src/ethereum_spec_tools/new_fork.py"}, "content": {"type": ["function"], "name": ["main"], "text": ["Create the new fork"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.bitwise", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/bitwise.py"}, "content": {"type": ["module"], "name": ["ethereum.gray_glacier.vm.instructions.bitwise"], "text": ["Ethereum Virtual Machine (EVM) Bitwise Instructions ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementations of the EVM bitwise instructions."]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.bitwise.bitwise_and", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/bitwise.py"}, "content": {"type": ["function"], "name": ["bitwise_and"], "text": ["Bitwise AND operation of the top 2 elements of the stack. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.bitwise.bitwise_or", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/bitwise.py"}, "content": {"type": ["function"], "name": ["bitwise_or"], "text": ["Bitwise OR operation of the top 2 elements of the stack. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.bitwise.bitwise_xor", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/bitwise.py"}, "content": {"type": ["function"], "name": ["bitwise_xor"], "text": ["Bitwise XOR operation of the top 2 elements of the stack. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.bitwise.bitwise_not", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/bitwise.py"}, "content": {"type": ["function"], "name": ["bitwise_not"], "text": ["Bitwise NOT operation of the top element of the stack. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.bitwise.get_byte", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/bitwise.py"}, "content": {"type": ["function"], "name": ["get_byte"], "text": ["For a word (defined by next top element of the stack), retrieve the Nth byte (0-indexed and defined by top element of stack) from the left (most significant) to right (least significant). Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.bitwise.bitwise_shl", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/bitwise.py"}, "content": {"type": ["function"], "name": ["bitwise_shl"], "text": ["Logical shift left (SHL) operation of the top 2 elements of the stack. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.bitwise.bitwise_shr", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/bitwise.py"}, "content": {"type": ["function"], "name": ["bitwise_shr"], "text": ["Logical shift right (SHR) operation of the top 2 elements of the stack. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.bitwise.bitwise_sar", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/bitwise.py"}, "content": {"type": ["function"], "name": ["bitwise_sar"], "text": ["Arithmetic shift right (SAR) operation of the top 2 elements of the stack. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.istanbul.vm.precompiled_contracts.mapping", "specifier": 0, "path": "src/ethereum/istanbul/vm/precompiled_contracts/mapping.py"}, "content": {"type": ["module"], "name": ["ethereum.istanbul.vm.precompiled_contracts.mapping"], "text": ["Precompiled Contract Addresses ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Mapping of precompiled contracts their implementations."]}}, {"source": {"identifier": "ethereum.istanbul.vm.precompiled_contracts.mapping.PRE_COMPILED_CONTRACTS", "specifier": 0, "path": "src/ethereum/istanbul/vm/precompiled_contracts/mapping.py"}, "content": {"type": ["attribute"], "name": ["PRE_COMPILED_CONTRACTS"]}}, {"source": {"identifier": "ethereum_spec_tools.evm_tools", "specifier": 1, "path": "src/ethereum_spec_tools/evm_tools/__init__.py"}, "content": {"type": ["module"], "name": ["ethereum_spec_tools.evm_tools"], "text": ["Defines EVM tools for use in the Ethereum specification."]}}, {"source": {"identifier": "ethereum_spec_tools.evm_tools.DESCRIPTION", "specifier": 0, "path": "src/ethereum_spec_tools/evm_tools/__init__.py"}, "content": {"type": ["attribute"], "name": ["DESCRIPTION"]}}, {"source": {"identifier": "ethereum_spec_tools.evm_tools.parser", "specifier": 0, "path": "src/ethereum_spec_tools/evm_tools/__init__.py"}, "content": {"type": ["attribute"], "name": ["parser"]}}, {"source": {"identifier": "ethereum_spec_tools.evm_tools.subparsers", "specifier": 0, "path": "src/ethereum_spec_tools/evm_tools/__init__.py"}, "content": {"type": ["attribute"], "name": ["subparsers"]}}, {"source": {"identifier": "ethereum_spec_tools.evm_tools.main", "specifier": 0, "path": "src/ethereum_spec_tools/evm_tools/__init__.py"}, "content": {"type": ["function"], "name": ["main"], "text": ["Run the tools based on the given options."]}}, {"source": {"identifier": "ethereum_spec_tools.evm_tools.utils", "specifier": 0, "path": "src/ethereum_spec_tools/evm_tools/utils.py"}, "content": {"type": ["module"], "name": ["ethereum_spec_tools.evm_tools.utils"], "text": ["Utilities for the EVM tools"]}}, {"source": {"identifier": "ethereum_spec_tools.evm_tools.utils.W", "specifier": 0, "path": "src/ethereum_spec_tools/evm_tools/utils.py"}, "content": {"type": ["attribute"], "name": ["W"]}}, {"source": {"identifier": "ethereum_spec_tools.evm_tools.utils.EXCEPTION_MAPS", "specifier": 0, "path": "src/ethereum_spec_tools/evm_tools/utils.py"}, "content": {"type": ["attribute"], "name": ["EXCEPTION_MAPS"]}}, {"source": {"identifier": "ethereum_spec_tools.evm_tools.utils.parse_hex_or_int", "specifier": 0, "path": "src/ethereum_spec_tools/evm_tools/utils.py"}, "content": {"type": ["function"], "name": ["parse_hex_or_int"], "text": ["Read a Uint type from a hex string or int"]}}, {"source": {"identifier": "ethereum_spec_tools.evm_tools.utils.FatalException", "specifier": 0, "path": "src/ethereum_spec_tools/evm_tools/utils.py"}, "content": {"type": ["class"], "name": ["FatalException"], "text": ["Exception that causes the tool to stop"]}}, {"source": {"identifier": "ethereum_spec_tools.evm_tools.utils.ensure_success", "specifier": 0, "path": "src/ethereum_spec_tools/evm_tools/utils.py"}, "content": {"type": ["function"], "name": ["ensure_success"], "text": ["Ensure that the function call succeeds. Raise a FatalException if it fails."]}}, {"source": {"identifier": "ethereum_spec_tools.evm_tools.utils.get_module_name", "specifier": 0, "path": "src/ethereum_spec_tools/evm_tools/utils.py"}, "content": {"type": ["function"], "name": ["get_module_name"], "text": ["Get the module name and the fork block for the given state fork."]}}, {"source": {"identifier": "ethereum_spec_tools.evm_tools.utils.get_stream_logger", "specifier": 0, "path": "src/ethereum_spec_tools/evm_tools/utils.py"}, "content": {"type": ["function"], "name": ["get_stream_logger"], "text": ["Get a logger that writes to stdout."]}}, {"source": {"identifier": "ethereum_spec_tools.evm_tools.utils.secp256k1_sign", "specifier": 0, "path": "src/ethereum_spec_tools/evm_tools/utils.py"}, "content": {"type": ["function"], "name": ["secp256k1_sign"], "text": ["Returns the signature of a message hash given the secret key."]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.environment", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/environment.py"}, "content": {"type": ["module"], "name": ["ethereum.gray_glacier.vm.instructions.environment"], "text": ["Ethereum Virtual Machine (EVM) Environmental Instructions ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementations of the EVM environment related instructions."]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.environment.address", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["address"], "text": ["Pushes the address of the current executing account to the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.environment.balance", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["balance"], "text": ["Pushes the balance of the given account onto the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.environment.origin", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["origin"], "text": ["Pushes the address of the original transaction sender to the stack. The origin address can only be an EOA. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.environment.caller", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["caller"], "text": ["Pushes the address of the caller onto the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.environment.callvalue", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["callvalue"], "text": ["Push the value (in wei) sent with the call onto the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.environment.calldataload", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["calldataload"], "text": ["Push a word (32 bytes) of the input data belonging to the current environment onto the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.environment.calldatasize", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["calldatasize"], "text": ["Push the size of input data in current environment onto the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.environment.calldatacopy", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["calldatacopy"], "text": ["Copy a portion of the input data in current environment to memory. This will also expand the memory, in case that the memory is insufficient to store the data. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.environment.codesize", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["codesize"], "text": ["Push the size of code running in current environment onto the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.environment.codecopy", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["codecopy"], "text": ["Copy a portion of the code in current environment to memory. This will also expand the memory, in case that the memory is insufficient to store the data. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.environment.gasprice", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["gasprice"], "text": ["Push the gas price used in current environment onto the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.environment.extcodesize", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["extcodesize"], "text": ["Push the code size of a given account onto the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.environment.extcodecopy", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["extcodecopy"], "text": ["Copy a portion of an account's code to memory. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.environment.returndatasize", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["returndatasize"], "text": ["Pushes the size of the return data buffer onto the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.environment.returndatacopy", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["returndatacopy"], "text": ["Copies data from the return data buffer code to memory Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.environment.extcodehash", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["extcodehash"], "text": ["Returns the keccak256 hash of a contract\u2019s bytecode Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.environment.self_balance", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["self_balance"], "text": ["Pushes the balance of the current address to the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.environment.base_fee", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["base_fee"], "text": ["Pushes the base fee of the current block on to the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.istanbul.vm.precompiled_contracts", "specifier": 0, "path": "src/ethereum/istanbul/vm/precompiled_contracts/__init__.py"}, "content": {"type": ["module"], "name": ["ethereum.istanbul.vm.precompiled_contracts"], "text": ["Precompiled Contract Addresses ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Addresses of precompiled contracts and mappings to their implementations."]}}, {"source": {"identifier": "ethereum.istanbul.vm.precompiled_contracts.__all__", "specifier": 0, "path": "src/ethereum/istanbul/vm/precompiled_contracts/__init__.py"}, "content": {"type": ["attribute"], "name": ["__all__"]}}, {"source": {"identifier": "ethereum.istanbul.vm.precompiled_contracts.ECRECOVER_ADDRESS", "specifier": 0, "path": "src/ethereum/istanbul/vm/precompiled_contracts/__init__.py"}, "content": {"type": ["attribute"], "name": ["ECRECOVER_ADDRESS"]}}, {"source": {"identifier": "ethereum.istanbul.vm.precompiled_contracts.SHA256_ADDRESS", "specifier": 0, "path": "src/ethereum/istanbul/vm/precompiled_contracts/__init__.py"}, "content": {"type": ["attribute"], "name": ["SHA256_ADDRESS"]}}, {"source": {"identifier": "ethereum.istanbul.vm.precompiled_contracts.RIPEMD160_ADDRESS", "specifier": 0, "path": "src/ethereum/istanbul/vm/precompiled_contracts/__init__.py"}, "content": {"type": ["attribute"], "name": ["RIPEMD160_ADDRESS"]}}, {"source": {"identifier": "ethereum.istanbul.vm.precompiled_contracts.IDENTITY_ADDRESS", "specifier": 0, "path": "src/ethereum/istanbul/vm/precompiled_contracts/__init__.py"}, "content": {"type": ["attribute"], "name": ["IDENTITY_ADDRESS"]}}, {"source": {"identifier": "ethereum.istanbul.vm.precompiled_contracts.MODEXP_ADDRESS", "specifier": 0, "path": "src/ethereum/istanbul/vm/precompiled_contracts/__init__.py"}, "content": {"type": ["attribute"], "name": ["MODEXP_ADDRESS"]}}, {"source": {"identifier": "ethereum.istanbul.vm.precompiled_contracts.ALT_BN128_ADD_ADDRESS", "specifier": 0, "path": "src/ethereum/istanbul/vm/precompiled_contracts/__init__.py"}, "content": {"type": ["attribute"], "name": ["ALT_BN128_ADD_ADDRESS"]}}, {"source": {"identifier": "ethereum.istanbul.vm.precompiled_contracts.ALT_BN128_MUL_ADDRESS", "specifier": 0, "path": "src/ethereum/istanbul/vm/precompiled_contracts/__init__.py"}, "content": {"type": ["attribute"], "name": ["ALT_BN128_MUL_ADDRESS"]}}, {"source": {"identifier": "ethereum.istanbul.vm.precompiled_contracts.ALT_BN128_PAIRING_CHECK_ADDRESS", "specifier": 0, "path": "src/ethereum/istanbul/vm/precompiled_contracts/__init__.py"}, "content": {"type": ["attribute"], "name": ["ALT_BN128_PAIRING_CHECK_ADDRESS"]}}, {"source": {"identifier": "ethereum.istanbul.vm.precompiled_contracts.BLAKE2F_ADDRESS", "specifier": 0, "path": "src/ethereum/istanbul/vm/precompiled_contracts/__init__.py"}, "content": {"type": ["attribute"], "name": ["BLAKE2F_ADDRESS"]}}, {"source": {"identifier": "ethereum_spec_tools.evm_tools.fixture_loader", "specifier": 0, "path": "src/ethereum_spec_tools/evm_tools/fixture_loader.py"}, "content": {"type": ["module"], "name": ["ethereum_spec_tools.evm_tools.fixture_loader"], "text": ["Defines Load class for loading json fixtures for the evm tools (t8n, b11r, etc.) as well as the execution specs testing framework."]}}, {"source": {"identifier": "ethereum_spec_tools.evm_tools.fixture_loader.UnsupportedTx", "specifier": 0, "path": "src/ethereum_spec_tools/evm_tools/fixture_loader.py"}, "content": {"type": ["class"], "name": ["UnsupportedTx"], "text": ["Exception for unsupported transactions"]}}, {"source": {"identifier": "ethereum_spec_tools.evm_tools.fixture_loader.UnsupportedTx.__init__", "specifier": 0, "path": "src/ethereum_spec_tools/evm_tools/fixture_loader.py"}, "content": {"type": ["function"], "name": ["__init__"]}}, {"source": {"identifier": "ethereum_spec_tools.evm_tools.fixture_loader.BaseLoad", "specifier": 0, "path": "src/ethereum_spec_tools/evm_tools/fixture_loader.py"}, "content": {"type": ["class"], "name": ["BaseLoad"], "text": ["Base class for loading json fixtures"]}}, {"source": {"identifier": "ethereum_spec_tools.evm_tools.fixture_loader.BaseLoad.fork_module", "specifier": 0, "path": "src/ethereum_spec_tools/evm_tools/fixture_loader.py"}, "content": {"type": ["function"], "name": ["fork_module"], "text": ["Module that contains the fork code"]}}, {"source": {"identifier": "ethereum_spec_tools.evm_tools.fixture_loader.BaseLoad.network", "specifier": 0, "path": "src/ethereum_spec_tools/evm_tools/fixture_loader.py"}, "content": {"type": ["function"], "name": ["network"], "text": ["Network name"]}}, {"source": {"identifier": "ethereum_spec_tools.evm_tools.fixture_loader.BaseLoad.proof_of_stake", "specifier": 0, "path": "src/ethereum_spec_tools/evm_tools/fixture_loader.py"}, "content": {"type": ["function"], "name": ["proof_of_stake"], "text": ["Whether the fork is proof of stake"]}}, {"source": {"identifier": "ethereum_spec_tools.evm_tools.fixture_loader.BaseLoad.Block", "specifier": 0, "path": "src/ethereum_spec_tools/evm_tools/fixture_loader.py"}, "content": {"type": ["function"], "name": ["Block"], "text": ["Block class of the fork"]}}, {"source": {"identifier": "ethereum_spec_tools.evm_tools.fixture_loader.BaseLoad.Environment", "specifier": 0, "path": "src/ethereum_spec_tools/evm_tools/fixture_loader.py"}, "content": {"type": ["function"], "name": ["Environment"], "text": ["Environment class of the fork"]}}, {"source": {"identifier": "ethereum_spec_tools.evm_tools.fixture_loader.BaseLoad.LegacyTransaction", "specifier": 0, "path": "src/ethereum_spec_tools/evm_tools/fixture_loader.py"}, "content": {"type": ["function"], "name": ["LegacyTransaction"], "text": ["Legacy transaction class of the fork"]}}, {"source": {"identifier": "ethereum_spec_tools.evm_tools.fixture_loader.BaseLoad.Account", "specifier": 0, "path": "src/ethereum_spec_tools/evm_tools/fixture_loader.py"}, "content": {"type": ["function"], "name": ["Account"], "text": ["Account class of the fork"]}}, {"source": {"identifier": "ethereum_spec_tools.evm_tools.fixture_loader.BaseLoad.State", "specifier": 0, "path": "src/ethereum_spec_tools/evm_tools/fixture_loader.py"}, "content": {"type": ["function"], "name": ["State"], "text": ["State class of the fork"]}}, {"source": {"identifier": "ethereum_spec_tools.evm_tools.fixture_loader.BaseLoad.set_account", "specifier": 0, "path": "src/ethereum_spec_tools/evm_tools/fixture_loader.py"}, "content": {"type": ["function"], "name": ["set_account"], "text": ["set_account function of the fork"]}}, {"source": {"identifier": "ethereum_spec_tools.evm_tools.fixture_loader.BaseLoad.BlockChain", "specifier": 0, "path": "src/ethereum_spec_tools/evm_tools/fixture_loader.py"}, "content": {"type": ["function"], "name": ["BlockChain"], "text": ["Block chain class of the fork"]}}, {"source": {"identifier": "ethereum_spec_tools.evm_tools.fixture_loader.BaseLoad.process_transaction", "specifier": 0, "path": "src/ethereum_spec_tools/evm_tools/fixture_loader.py"}, "content": {"type": ["function"], "name": ["process_transaction"], "text": ["process_transaction function of the fork"]}}, {"source": {"identifier": "ethereum_spec_tools.evm_tools.fixture_loader.BaseLoad.state_transition", "specifier": 0, "path": "src/ethereum_spec_tools/evm_tools/fixture_loader.py"}, "content": {"type": ["function"], "name": ["state_transition"], "text": ["state_transition function of the fork"]}}, {"source": {"identifier": "ethereum_spec_tools.evm_tools.fixture_loader.BaseLoad.close_state", "specifier": 0, "path": "src/ethereum_spec_tools/evm_tools/fixture_loader.py"}, "content": {"type": ["function"], "name": ["close_state"], "text": ["close_state function of the fork"]}}, {"source": {"identifier": "ethereum_spec_tools.evm_tools.fixture_loader.BaseLoad.json_to_header", "specifier": 0, "path": "src/ethereum_spec_tools/evm_tools/fixture_loader.py"}, "content": {"type": ["function"], "name": ["json_to_header"], "text": ["Converts json header data to a header object"]}}, {"source": {"identifier": "ethereum_spec_tools.evm_tools.fixture_loader.BaseLoad.json_to_state", "specifier": 0, "path": "src/ethereum_spec_tools/evm_tools/fixture_loader.py"}, "content": {"type": ["function"], "name": ["json_to_state"], "text": ["Converts json state data to a state object"]}}, {"source": {"identifier": "ethereum_spec_tools.evm_tools.fixture_loader.BaseLoad.json_to_blocks", "specifier": 0, "path": "src/ethereum_spec_tools/evm_tools/fixture_loader.py"}, "content": {"type": ["function"], "name": ["json_to_blocks"], "text": ["Converts json block data to a list of blocks"]}}, {"source": {"identifier": "ethereum_spec_tools.evm_tools.fixture_loader.Load", "specifier": 0, "path": "src/ethereum_spec_tools/evm_tools/fixture_loader.py"}, "content": {"type": ["class"], "name": ["Load"], "text": ["Class for loading json fixtures"]}}, {"source": {"identifier": "ethereum_spec_tools.evm_tools.fixture_loader.Load._network", "specifier": 0, "path": "src/ethereum_spec_tools/evm_tools/fixture_loader.py"}, "content": {"type": ["attribute"], "name": ["_network"]}}, {"source": {"identifier": "ethereum_spec_tools.evm_tools.fixture_loader.Load._fork_module", "specifier": 0, "path": "src/ethereum_spec_tools/evm_tools/fixture_loader.py"}, "content": {"type": ["attribute"], "name": ["_fork_module"]}}, {"source": {"identifier": "ethereum_spec_tools.evm_tools.fixture_loader.Load.fork_module", "specifier": 0, "path": "src/ethereum_spec_tools/evm_tools/fixture_loader.py"}, "content": {"type": ["function"], "name": ["fork_module"], "text": ["Module that contains the fork code"]}}, {"source": {"identifier": "ethereum_spec_tools.evm_tools.fixture_loader.Load.network", "specifier": 0, "path": "src/ethereum_spec_tools/evm_tools/fixture_loader.py"}, "content": {"type": ["function"], "name": ["network"], "text": ["Network name"]}}, {"source": {"identifier": "ethereum_spec_tools.evm_tools.fixture_loader.Load.proof_of_stake", "specifier": 0, "path": "src/ethereum_spec_tools/evm_tools/fixture_loader.py"}, "content": {"type": ["function"], "name": ["proof_of_stake"], "text": ["Whether the fork is proof of stake"]}}, {"source": {"identifier": "ethereum_spec_tools.evm_tools.fixture_loader.Load.Block", "specifier": 0, "path": "src/ethereum_spec_tools/evm_tools/fixture_loader.py"}, "content": {"type": ["function"], "name": ["Block"], "text": ["Block class of the fork"]}}, {"source": {"identifier": "ethereum_spec_tools.evm_tools.fixture_loader.Load.Bloom", "specifier": 0, "path": "src/ethereum_spec_tools/evm_tools/fixture_loader.py"}, "content": {"type": ["function"], "name": ["Bloom"], "text": ["Bloom class of the fork"]}}, {"source": {"identifier": "ethereum_spec_tools.evm_tools.fixture_loader.Load.Header", "specifier": 0, "path": "src/ethereum_spec_tools/evm_tools/fixture_loader.py"}, "content": {"type": ["function"], "name": ["Header"], "text": ["Header class of the fork"]}}, {"source": {"identifier": "ethereum_spec_tools.evm_tools.fixture_loader.Load.Environment", "specifier": 0, "path": "src/ethereum_spec_tools/evm_tools/fixture_loader.py"}, "content": {"type": ["function"], "name": ["Environment"], "text": ["Environment class of the fork"]}}, {"source": {"identifier": "ethereum_spec_tools.evm_tools.fixture_loader.Load.LegacyTransaction", "specifier": 0, "path": "src/ethereum_spec_tools/evm_tools/fixture_loader.py"}, "content": {"type": ["function"], "name": ["LegacyTransaction"], "text": ["Legacy transaction class of the fork"]}}, {"source": {"identifier": "ethereum_spec_tools.evm_tools.fixture_loader.Load.Account", "specifier": 0, "path": "src/ethereum_spec_tools/evm_tools/fixture_loader.py"}, "content": {"type": ["function"], "name": ["Account"], "text": ["Account class of the fork"]}}, {"source": {"identifier": "ethereum_spec_tools.evm_tools.fixture_loader.Load.State", "specifier": 0, "path": "src/ethereum_spec_tools/evm_tools/fixture_loader.py"}, "content": {"type": ["function"], "name": ["State"], "text": ["State class of the fork"]}}, {"source": {"identifier": "ethereum_spec_tools.evm_tools.fixture_loader.Load.set_account", "specifier": 0, "path": "src/ethereum_spec_tools/evm_tools/fixture_loader.py"}, "content": {"type": ["function"], "name": ["set_account"], "text": ["set_account function of the fork"]}}, {"source": {"identifier": "ethereum_spec_tools.evm_tools.fixture_loader.Load.state_transition", "specifier": 0, "path": "src/ethereum_spec_tools/evm_tools/fixture_loader.py"}, "content": {"type": ["function"], "name": ["state_transition"], "text": ["state_transition function of the fork"]}}, {"source": {"identifier": "ethereum_spec_tools.evm_tools.fixture_loader.Load.process_transaction", "specifier": 0, "path": "src/ethereum_spec_tools/evm_tools/fixture_loader.py"}, "content": {"type": ["function"], "name": ["process_transaction"], "text": ["process_transaction function of the fork"]}}, {"source": {"identifier": "ethereum_spec_tools.evm_tools.fixture_loader.Load.BlockChain", "specifier": 0, "path": "src/ethereum_spec_tools/evm_tools/fixture_loader.py"}, "content": {"type": ["function"], "name": ["BlockChain"], "text": ["Block chain class of the fork"]}}, {"source": {"identifier": "ethereum_spec_tools.evm_tools.fixture_loader.Load.hex_to_address", "specifier": 0, "path": "src/ethereum_spec_tools/evm_tools/fixture_loader.py"}, "content": {"type": ["function"], "name": ["hex_to_address"], "text": ["hex_to_address function of the fork"]}}, {"source": {"identifier": "ethereum_spec_tools.evm_tools.fixture_loader.Load.hex_to_root", "specifier": 0, "path": "src/ethereum_spec_tools/evm_tools/fixture_loader.py"}, "content": {"type": ["function"], "name": ["hex_to_root"], "text": ["hex_to_root function of the fork"]}}, {"source": {"identifier": "ethereum_spec_tools.evm_tools.fixture_loader.Load.close_state", "specifier": 0, "path": "src/ethereum_spec_tools/evm_tools/fixture_loader.py"}, "content": {"type": ["function"], "name": ["close_state"], "text": ["close_state function of the fork"]}}, {"source": {"identifier": "ethereum_spec_tools.evm_tools.fixture_loader.Load.__init__", "specifier": 0, "path": "src/ethereum_spec_tools/evm_tools/fixture_loader.py"}, "content": {"type": ["function"], "name": ["__init__"]}}, {"source": {"identifier": "ethereum_spec_tools.evm_tools.fixture_loader.Load._module", "specifier": 0, "path": "src/ethereum_spec_tools/evm_tools/fixture_loader.py"}, "content": {"type": ["function"], "name": ["_module"], "text": ["Imports a module from the fork"]}}, {"source": {"identifier": "ethereum_spec_tools.evm_tools.fixture_loader.Load.json_to_state", "specifier": 0, "path": "src/ethereum_spec_tools/evm_tools/fixture_loader.py"}, "content": {"type": ["function"], "name": ["json_to_state"], "text": ["Converts json state data to a state object"]}}, {"source": {"identifier": "ethereum_spec_tools.evm_tools.fixture_loader.Load.json_to_access_list", "specifier": 0, "path": "src/ethereum_spec_tools/evm_tools/fixture_loader.py"}, "content": {"type": ["function"], "name": ["json_to_access_list"], "text": ["Converts json access list data to a list of access list entries"]}}, {"source": {"identifier": "ethereum_spec_tools.evm_tools.fixture_loader.Load.json_to_tx", "specifier": 0, "path": "src/ethereum_spec_tools/evm_tools/fixture_loader.py"}, "content": {"type": ["function"], "name": ["json_to_tx"], "text": ["Converts json transaction data to a transaction object"]}}, {"source": {"identifier": "ethereum_spec_tools.evm_tools.fixture_loader.Load.json_to_withdrawals", "specifier": 0, "path": "src/ethereum_spec_tools/evm_tools/fixture_loader.py"}, "content": {"type": ["function"], "name": ["json_to_withdrawals"], "text": ["Converts json withdrawal data to a withdrawal object"]}}, {"source": {"identifier": "ethereum_spec_tools.evm_tools.fixture_loader.Load.json_to_blocks", "specifier": 0, "path": "src/ethereum_spec_tools/evm_tools/fixture_loader.py"}, "content": {"type": ["function"], "name": ["json_to_blocks"], "text": ["Converts json block data to a block object"]}}, {"source": {"identifier": "ethereum_spec_tools.evm_tools.fixture_loader.Load.json_to_header", "specifier": 0, "path": "src/ethereum_spec_tools/evm_tools/fixture_loader.py"}, "content": {"type": ["function"], "name": ["json_to_header"], "text": ["Converts json header data to a header object"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.environment", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/environment.py"}, "content": {"type": ["module"], "name": ["ethereum.muir_glacier.vm.instructions.environment"], "text": ["Ethereum Virtual Machine (EVM) Environmental Instructions ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementations of the EVM environment related instructions."]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.environment.address", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["address"], "text": ["Pushes the address of the current executing account to the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.environment.balance", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["balance"], "text": ["Pushes the balance of the given account onto the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.environment.origin", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["origin"], "text": ["Pushes the address of the original transaction sender to the stack. The origin address can only be an EOA. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.environment.caller", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["caller"], "text": ["Pushes the address of the caller onto the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.environment.callvalue", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["callvalue"], "text": ["Push the value (in wei) sent with the call onto the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.environment.calldataload", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["calldataload"], "text": ["Push a word (32 bytes) of the input data belonging to the current environment onto the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.environment.calldatasize", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["calldatasize"], "text": ["Push the size of input data in current environment onto the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.environment.calldatacopy", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["calldatacopy"], "text": ["Copy a portion of the input data in current environment to memory. This will also expand the memory, in case that the memory is insufficient to store the data. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.environment.codesize", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["codesize"], "text": ["Push the size of code running in current environment onto the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.environment.codecopy", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["codecopy"], "text": ["Copy a portion of the code in current environment to memory. This will also expand the memory, in case that the memory is insufficient to store the data. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.environment.gasprice", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["gasprice"], "text": ["Push the gas price used in current environment onto the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.environment.extcodesize", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["extcodesize"], "text": ["Push the code size of a given account onto the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.environment.extcodecopy", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["extcodecopy"], "text": ["Copy a portion of an account's code to memory. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.environment.returndatasize", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["returndatasize"], "text": ["Pushes the size of the return data buffer onto the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.environment.returndatacopy", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["returndatacopy"], "text": ["Copies data from the return data buffer code to memory Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.environment.extcodehash", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["extcodehash"], "text": ["Returns the keccak256 hash of a contract\u2019s bytecode Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.environment.self_balance", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["self_balance"], "text": ["Pushes the balance of the current address to the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.shanghai.utils.hexadecimal", "specifier": 0, "path": "src/ethereum/shanghai/utils/hexadecimal.py"}, "content": {"type": ["module"], "name": ["ethereum.shanghai.utils.hexadecimal"], "text": ["Utility Functions For Hexadecimal Strings ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Hexadecimal utility functions used in this specification, specific to Shanghai types."]}}, {"source": {"identifier": "ethereum.shanghai.utils.hexadecimal.hex_to_root", "specifier": 0, "path": "src/ethereum/shanghai/utils/hexadecimal.py"}, "content": {"type": ["function"], "name": ["hex_to_root"], "text": ["Convert hex string to trie root. Parameters hex_string : The hexadecimal string to be converted to trie root. Returns root :  Root Trie root obtained from the given hexadecimal string."]}}, {"source": {"identifier": "ethereum.shanghai.utils.hexadecimal.hex_to_bloom", "specifier": 0, "path": "src/ethereum/shanghai/utils/hexadecimal.py"}, "content": {"type": ["function"], "name": ["hex_to_bloom"], "text": ["Convert hex string to bloom. Parameters hex_string : The hexadecimal string to be converted to bloom. Returns bloom :  Bloom Bloom obtained from the given hexadecimal string."]}}, {"source": {"identifier": "ethereum.shanghai.utils.hexadecimal.hex_to_address", "specifier": 0, "path": "src/ethereum/shanghai/utils/hexadecimal.py"}, "content": {"type": ["function"], "name": ["hex_to_address"], "text": ["Convert hex string to Address (20 bytes). Parameters hex_string : The hexadecimal string to be converted to Address. Returns address :  Address The address obtained from the given hexadecimal string."]}}, {"source": {"identifier": "ethereum.homestead.state", "specifier": 0, "path": "src/ethereum/homestead/state.py"}, "content": {"type": ["module"], "name": ["ethereum.homestead.state"], "text": ["State ^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction The state contains all information that is preserved between transactions. It consists of a main account trie and storage tries for each contract. There is a distinction between an account that does not exist and EMPTY_ACCOUNT ."]}}, {"source": {"identifier": "ethereum.homestead.state.State", "specifier": 0, "path": "src/ethereum/homestead/state.py"}, "content": {"type": ["class"], "name": ["State"], "text": ["Contains all information that is preserved between transactions."]}}, {"source": {"identifier": "ethereum.homestead.state.State._main_trie", "specifier": 0, "path": "src/ethereum/homestead/state.py"}, "content": {"type": ["attribute"], "name": ["_main_trie"]}}, {"source": {"identifier": "ethereum.homestead.state.State._storage_tries", "specifier": 0, "path": "src/ethereum/homestead/state.py"}, "content": {"type": ["attribute"], "name": ["_storage_tries"]}}, {"source": {"identifier": "ethereum.homestead.state.State._snapshots", "specifier": 0, "path": "src/ethereum/homestead/state.py"}, "content": {"type": ["attribute"], "name": ["_snapshots"]}}, {"source": {"identifier": "ethereum.homestead.state.close_state", "specifier": 0, "path": "src/ethereum/homestead/state.py"}, "content": {"type": ["function"], "name": ["close_state"], "text": ["Free resources held by the state. Used by optimized implementations to release file descriptors."]}}, {"source": {"identifier": "ethereum.homestead.state.begin_transaction", "specifier": 0, "path": "src/ethereum/homestead/state.py"}, "content": {"type": ["function"], "name": ["begin_transaction"], "text": ["Start a state transaction. Transactions are entirely implicit and can be nested. It is not possible to calculate the state root during a transaction. Parameters state : State The state."]}}, {"source": {"identifier": "ethereum.homestead.state.commit_transaction", "specifier": 0, "path": "src/ethereum/homestead/state.py"}, "content": {"type": ["function"], "name": ["commit_transaction"], "text": ["Commit a state transaction. Parameters state : State The state."]}}, {"source": {"identifier": "ethereum.homestead.state.rollback_transaction", "specifier": 0, "path": "src/ethereum/homestead/state.py"}, "content": {"type": ["function"], "name": ["rollback_transaction"], "text": ["Rollback a state transaction, resetting the state to the point when the corresponding  start_transaction()  call was made. Parameters state : State The state."]}}, {"source": {"identifier": "ethereum.homestead.state.get_account", "specifier": 0, "path": "src/ethereum/homestead/state.py"}, "content": {"type": ["function"], "name": ["get_account"], "text": ["Get the  Account  object at an address. Returns  EMPTY_ACCOUNT  if there is no account at the address. Use  get_account_optional()  if you care about the difference between a non-existent account and  EMPTY_ACCOUNT . Parameters state:  State The state address :  Address Address to lookup. Returns account :  Account Account at address."]}}, {"source": {"identifier": "ethereum.homestead.state.get_account_optional", "specifier": 0, "path": "src/ethereum/homestead/state.py"}, "content": {"type": ["function"], "name": ["get_account_optional"], "text": ["Get the  Account  object at an address. Returns  None  (rather than EMPTY_ACCOUNT ) if there is no account at the address. Parameters state:  State The state address :  Address Address to lookup. Returns account :  Account Account at address."]}}, {"source": {"identifier": "ethereum.homestead.state.set_account", "specifier": 0, "path": "src/ethereum/homestead/state.py"}, "content": {"type": ["function"], "name": ["set_account"], "text": ["Set the  Account  object at an address. Setting to  None  deletes the account (but not its storage, see  destroy_account() ). Parameters state:  State The state address :  Address Address to set. account :  Account Account to set at address."]}}, {"source": {"identifier": "ethereum.homestead.state.destroy_account", "specifier": 0, "path": "src/ethereum/homestead/state.py"}, "content": {"type": ["function"], "name": ["destroy_account"], "text": ["Completely remove the account at  address  and all of its storage. This function is made available exclusively for the  SELFDESTRUCT opcode. It is expected that  SELFDESTRUCT  will be disabled in a future hardfork and this function will be removed. Parameters state:  State The state address :  Address Address of account to destroy."]}}, {"source": {"identifier": "ethereum.homestead.state.destroy_storage", "specifier": 0, "path": "src/ethereum/homestead/state.py"}, "content": {"type": ["function"], "name": ["destroy_storage"], "text": ["Completely remove the storage at  address . Parameters state:  State The state address :  Address Address of account whose storage is to be deleted."]}}, {"source": {"identifier": "ethereum.homestead.state.get_storage", "specifier": 0, "path": "src/ethereum/homestead/state.py"}, "content": {"type": ["function"], "name": ["get_storage"], "text": ["Get a value at a storage key on an account. Returns  U256(0)  if the storage key has not been set previously. Parameters state:  State The state address :  Address Address of the account. key :  Bytes Key to lookup. Returns value :  U256 Value at the key."]}}, {"source": {"identifier": "ethereum.homestead.state.set_storage", "specifier": 0, "path": "src/ethereum/homestead/state.py"}, "content": {"type": ["function"], "name": ["set_storage"], "text": ["Set a value at a storage key on an account. Setting to  U256(0)  deletes the key. Parameters state:  State The state address :  Address Address of the account. key :  Bytes Key to set. value :  U256 Value to set at the key."]}}, {"source": {"identifier": "ethereum.homestead.state.storage_root", "specifier": 0, "path": "src/ethereum/homestead/state.py"}, "content": {"type": ["function"], "name": ["storage_root"], "text": ["Calculate the storage root of an account. Parameters state: The state address : Address of the account. Returns root :  Root Storage root of the account."]}}, {"source": {"identifier": "ethereum.homestead.state.state_root", "specifier": 0, "path": "src/ethereum/homestead/state.py"}, "content": {"type": ["function"], "name": ["state_root"], "text": ["Calculate the state root. Parameters state: The current state. Returns root :  Root The state root."]}}, {"source": {"identifier": "ethereum.homestead.state.account_exists", "specifier": 0, "path": "src/ethereum/homestead/state.py"}, "content": {"type": ["function"], "name": ["account_exists"], "text": ["Checks if an account exists in the state trie Parameters state: The state address: Address of the account that needs to be checked. Returns account_exists :  bool True if account exists in the state trie, False otherwise"]}}, {"source": {"identifier": "ethereum.homestead.state.account_has_code_or_nonce", "specifier": 0, "path": "src/ethereum/homestead/state.py"}, "content": {"type": ["function"], "name": ["account_has_code_or_nonce"], "text": ["Checks if an account has non zero nonce or non empty code Parameters state: The state address: Address of the account that needs to be checked. Returns has_code_or_nonce :  bool True if if an account has non zero nonce or non empty code, False otherwise."]}}, {"source": {"identifier": "ethereum.homestead.state.modify_state", "specifier": 0, "path": "src/ethereum/homestead/state.py"}, "content": {"type": ["function"], "name": ["modify_state"], "text": ["Modify an  Account  in the  State ."]}}, {"source": {"identifier": "ethereum.homestead.state.move_ether", "specifier": 0, "path": "src/ethereum/homestead/state.py"}, "content": {"type": ["function"], "name": ["move_ether"], "text": ["Move funds between accounts."]}}, {"source": {"identifier": "ethereum.homestead.state.set_account_balance", "specifier": 0, "path": "src/ethereum/homestead/state.py"}, "content": {"type": ["function"], "name": ["set_account_balance"], "text": ["Sets the balance of an account. Parameters state: The current state. address: Address of the account whose nonce needs to be incremented. amount: The amount that needs to set in balance."]}}, {"source": {"identifier": "ethereum.homestead.state.touch_account", "specifier": 0, "path": "src/ethereum/homestead/state.py"}, "content": {"type": ["function"], "name": ["touch_account"], "text": ["Initializes an account to state. Parameters state: The current state. address: The address of the account that need to initialised."]}}, {"source": {"identifier": "ethereum.homestead.state.increment_nonce", "specifier": 0, "path": "src/ethereum/homestead/state.py"}, "content": {"type": ["function"], "name": ["increment_nonce"], "text": ["Increments the nonce of an account. Parameters state: The current state. address: Address of the account whose nonce needs to be incremented."]}}, {"source": {"identifier": "ethereum.homestead.state.set_code", "specifier": 0, "path": "src/ethereum/homestead/state.py"}, "content": {"type": ["function"], "name": ["set_code"], "text": ["Sets Account code. Parameters state: The current state. address: Address of the account whose code needs to be update. code: The bytecode that needs to be set."]}}, {"source": {"identifier": "ethereum.homestead.state.create_ether", "specifier": 0, "path": "src/ethereum/homestead/state.py"}, "content": {"type": ["function"], "name": ["create_ether"], "text": ["Add newly created ether to an account. Parameters state: The current state. address: Address of the account to which ether is added. amount: The amount of ether to be added to the account of interest."]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.stack", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/stack.py"}, "content": {"type": ["module"], "name": ["ethereum.muir_glacier.vm.instructions.stack"], "text": ["Ethereum Virtual Machine (EVM) Stack Instructions ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementations of the EVM stack related instructions."]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.stack.pop", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/stack.py"}, "content": {"type": ["function"], "name": ["pop"], "text": ["Remove item from stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.stack.push_n", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/stack.py"}, "content": {"type": ["function"], "name": ["push_n"], "text": ["Pushes a N-byte immediate onto the stack. Parameters evm : The current EVM frame. num_bytes : The number of immediate bytes to be read from the code and pushed to the stack."]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.stack.dup_n", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/stack.py"}, "content": {"type": ["function"], "name": ["dup_n"], "text": ["Duplicate the Nth stack item (from top of the stack) to the top of stack. Parameters evm : The current EVM frame. item_number : The stack item number (0-indexed from top of stack) to be duplicated to the top of stack."]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.stack.swap_n", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/stack.py"}, "content": {"type": ["function"], "name": ["swap_n"], "text": ["Swap the top and the  item_number  element of the stack, where the top of the stack is position zero. If  item_number  is zero, this function does nothing (which should not be possible, since there is no  SWAP0  instruction). Parameters evm : The current EVM frame. item_number : The stack item number (0-indexed from top of stack) to be swapped with the top of stack element."]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.stack.push1", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push1"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.stack.push2", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push2"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.stack.push3", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push3"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.stack.push4", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push4"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.stack.push5", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push5"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.stack.push6", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push6"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.stack.push7", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push7"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.stack.push8", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push8"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.stack.push9", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push9"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.stack.push10", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push10"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.stack.push11", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push11"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.stack.push12", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push12"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.stack.push13", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push13"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.stack.push14", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push14"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.stack.push15", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push15"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.stack.push16", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push16"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.stack.push17", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push17"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.stack.push18", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push18"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.stack.push19", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push19"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.stack.push20", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push20"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.stack.push21", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push21"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.stack.push22", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push22"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.stack.push23", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push23"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.stack.push24", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push24"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.stack.push25", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push25"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.stack.push26", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push26"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.stack.push27", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push27"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.stack.push28", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push28"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.stack.push29", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push29"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.stack.push30", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push30"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.stack.push31", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push31"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.stack.push32", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push32"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.stack.dup1", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup1"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.stack.dup2", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup2"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.stack.dup3", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup3"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.stack.dup4", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup4"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.stack.dup5", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup5"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.stack.dup6", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup6"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.stack.dup7", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup7"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.stack.dup8", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup8"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.stack.dup9", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup9"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.stack.dup10", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup10"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.stack.dup11", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup11"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.stack.dup12", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup12"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.stack.dup13", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup13"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.stack.dup14", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup14"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.stack.dup15", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup15"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.stack.dup16", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup16"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.stack.swap1", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap1"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.stack.swap2", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap2"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.stack.swap3", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap3"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.stack.swap4", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap4"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.stack.swap5", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap5"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.stack.swap6", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap6"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.stack.swap7", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap7"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.stack.swap8", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap8"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.stack.swap9", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap9"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.stack.swap10", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap10"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.stack.swap11", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap11"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.stack.swap12", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap12"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.stack.swap13", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap13"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.stack.swap14", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap14"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.stack.swap15", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap15"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.stack.swap16", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap16"]}}, {"source": {"identifier": "ethereum.homestead", "specifier": 0, "path": "src/ethereum/homestead/__init__.py"}, "content": {"type": ["module"], "name": ["ethereum.homestead"], "text": ["Ethereum Homestead Hardfork ^^^^^^^^^^^^^^^^^^^^^^^^^^^ The second Ethereum hardfork."]}}, {"source": {"identifier": "ethereum.homestead.MAINNET_FORK_BLOCK", "specifier": 0, "path": "src/ethereum/homestead/__init__.py"}, "content": {"type": ["attribute"], "name": ["MAINNET_FORK_BLOCK"]}}, {"source": {"identifier": "ethereum.muir_glacier.utils", "specifier": 0, "path": "src/ethereum/muir_glacier/utils/__init__.py"}, "content": {"type": ["module"], "name": ["ethereum.muir_glacier.utils"], "text": ["Hardfork Utility Functions ^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Utility functions used in this muir_glacier version of specification."]}}, {"source": {"identifier": "ethereum.homestead.bloom", "specifier": 0, "path": "src/ethereum/homestead/bloom.py"}, "content": {"type": ["module"], "name": ["ethereum.homestead.bloom"], "text": ["Ethereum Logs Bloom ^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction This modules defines functions for calculating bloom filters of logs. For the general theory of bloom filters see e.g.  Wikipedia <https://en.wikipedia.org/wiki/Bloom_filter> _. Bloom filters are used to allow for efficient searching of logs by address and/or topic, by rapidly eliminating blocks and reciepts from their search."]}}, {"source": {"identifier": "ethereum.homestead.bloom.add_to_bloom", "specifier": 0, "path": "src/ethereum/homestead/bloom.py"}, "content": {"type": ["function"], "name": ["add_to_bloom"], "text": ["Add a bloom entry to the bloom filter ( bloom ). The number of hash functions used is 3. They are calculated by taking the least significant 11 bits from the first 3 16-bit words of the keccak_256()  hash of  bloom_entry . Parameters bloom : The bloom filter. bloom_entry : An entry which is to be added to bloom filter."]}}, {"source": {"identifier": "ethereum.homestead.bloom.logs_bloom", "specifier": 0, "path": "src/ethereum/homestead/bloom.py"}, "content": {"type": ["function"], "name": ["logs_bloom"], "text": ["Obtain the logs bloom from a list of log entries. The address and each topic of a log are added to the bloom filter. Parameters logs : List of logs for which the logs bloom is to be obtained. Returns logs_bloom :  Bloom The logs bloom obtained which is 256 bytes with some bits set as per the caller address and the log topics."]}}, {"source": {"identifier": "ethereum.homestead.fork_types", "specifier": 0, "path": "src/ethereum/homestead/fork_types.py"}, "content": {"type": ["module"], "name": ["ethereum.homestead.fork_types"], "text": ["Ethereum Types ^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Types re-used throughout the specification, which are specific to Ethereum."]}}, {"source": {"identifier": "ethereum.homestead.fork_types.Address", "specifier": 0, "path": "src/ethereum/homestead/fork_types.py"}, "content": {"type": ["attribute"], "name": ["Address"]}}, {"source": {"identifier": "ethereum.homestead.fork_types.Root", "specifier": 0, "path": "src/ethereum/homestead/fork_types.py"}, "content": {"type": ["attribute"], "name": ["Root"]}}, {"source": {"identifier": "ethereum.homestead.fork_types.Bloom", "specifier": 0, "path": "src/ethereum/homestead/fork_types.py"}, "content": {"type": ["attribute"], "name": ["Bloom"]}}, {"source": {"identifier": "ethereum.homestead.fork_types.TX_BASE_COST", "specifier": 0, "path": "src/ethereum/homestead/fork_types.py"}, "content": {"type": ["attribute"], "name": ["TX_BASE_COST"]}}, {"source": {"identifier": "ethereum.homestead.fork_types.TX_DATA_COST_PER_NON_ZERO", "specifier": 0, "path": "src/ethereum/homestead/fork_types.py"}, "content": {"type": ["attribute"], "name": ["TX_DATA_COST_PER_NON_ZERO"]}}, {"source": {"identifier": "ethereum.homestead.fork_types.TX_DATA_COST_PER_ZERO", "specifier": 0, "path": "src/ethereum/homestead/fork_types.py"}, "content": {"type": ["attribute"], "name": ["TX_DATA_COST_PER_ZERO"]}}, {"source": {"identifier": "ethereum.homestead.fork_types.TX_CREATE_COST", "specifier": 0, "path": "src/ethereum/homestead/fork_types.py"}, "content": {"type": ["attribute"], "name": ["TX_CREATE_COST"]}}, {"source": {"identifier": "ethereum.homestead.fork_types.Transaction", "specifier": 0, "path": "src/ethereum/homestead/fork_types.py"}, "content": {"type": ["class"], "name": ["Transaction"], "text": ["Atomic operation performed on the block chain."]}}, {"source": {"identifier": "ethereum.homestead.fork_types.Transaction.nonce", "specifier": 0, "path": "src/ethereum/homestead/fork_types.py"}, "content": {"type": ["attribute"], "name": ["nonce"]}}, {"source": {"identifier": "ethereum.homestead.fork_types.Transaction.gas_price", "specifier": 0, "path": "src/ethereum/homestead/fork_types.py"}, "content": {"type": ["attribute"], "name": ["gas_price"]}}, {"source": {"identifier": "ethereum.homestead.fork_types.Transaction.gas", "specifier": 0, "path": "src/ethereum/homestead/fork_types.py"}, "content": {"type": ["attribute"], "name": ["gas"]}}, {"source": {"identifier": "ethereum.homestead.fork_types.Transaction.to", "specifier": 0, "path": "src/ethereum/homestead/fork_types.py"}, "content": {"type": ["attribute"], "name": ["to"]}}, {"source": {"identifier": "ethereum.homestead.fork_types.Transaction.value", "specifier": 0, "path": "src/ethereum/homestead/fork_types.py"}, "content": {"type": ["attribute"], "name": ["value"]}}, {"source": {"identifier": "ethereum.homestead.fork_types.Transaction.data", "specifier": 0, "path": "src/ethereum/homestead/fork_types.py"}, "content": {"type": ["attribute"], "name": ["data"]}}, {"source": {"identifier": "ethereum.homestead.fork_types.Transaction.v", "specifier": 0, "path": "src/ethereum/homestead/fork_types.py"}, "content": {"type": ["attribute"], "name": ["v"]}}, {"source": {"identifier": "ethereum.homestead.fork_types.Transaction.r", "specifier": 0, "path": "src/ethereum/homestead/fork_types.py"}, "content": {"type": ["attribute"], "name": ["r"]}}, {"source": {"identifier": "ethereum.homestead.fork_types.Transaction.s", "specifier": 0, "path": "src/ethereum/homestead/fork_types.py"}, "content": {"type": ["attribute"], "name": ["s"]}}, {"source": {"identifier": "ethereum.homestead.fork_types.Account", "specifier": 0, "path": "src/ethereum/homestead/fork_types.py"}, "content": {"type": ["class"], "name": ["Account"], "text": ["State associated with an address."]}}, {"source": {"identifier": "ethereum.homestead.fork_types.Account.nonce", "specifier": 0, "path": "src/ethereum/homestead/fork_types.py"}, "content": {"type": ["attribute"], "name": ["nonce"]}}, {"source": {"identifier": "ethereum.homestead.fork_types.Account.balance", "specifier": 0, "path": "src/ethereum/homestead/fork_types.py"}, "content": {"type": ["attribute"], "name": ["balance"]}}, {"source": {"identifier": "ethereum.homestead.fork_types.Account.code", "specifier": 0, "path": "src/ethereum/homestead/fork_types.py"}, "content": {"type": ["attribute"], "name": ["code"]}}, {"source": {"identifier": "ethereum.homestead.fork_types.EMPTY_ACCOUNT", "specifier": 0, "path": "src/ethereum/homestead/fork_types.py"}, "content": {"type": ["attribute"], "name": ["EMPTY_ACCOUNT"]}}, {"source": {"identifier": "ethereum.homestead.fork_types.encode_account", "specifier": 0, "path": "src/ethereum/homestead/fork_types.py"}, "content": {"type": ["function"], "name": ["encode_account"], "text": ["Encode  Account  dataclass. Storage is not stored in the  Account  dataclass, so  Accounts  cannot be encoded with providing a storage root."]}}, {"source": {"identifier": "ethereum.homestead.fork_types.Header", "specifier": 0, "path": "src/ethereum/homestead/fork_types.py"}, "content": {"type": ["class"], "name": ["Header"], "text": ["Header portion of a block on the chain."]}}, {"source": {"identifier": "ethereum.homestead.fork_types.Header.parent_hash", "specifier": 0, "path": "src/ethereum/homestead/fork_types.py"}, "content": {"type": ["attribute"], "name": ["parent_hash"]}}, {"source": {"identifier": "ethereum.homestead.fork_types.Header.ommers_hash", "specifier": 0, "path": "src/ethereum/homestead/fork_types.py"}, "content": {"type": ["attribute"], "name": ["ommers_hash"]}}, {"source": {"identifier": "ethereum.homestead.fork_types.Header.coinbase", "specifier": 0, "path": "src/ethereum/homestead/fork_types.py"}, "content": {"type": ["attribute"], "name": ["coinbase"]}}, {"source": {"identifier": "ethereum.homestead.fork_types.Header.state_root", "specifier": 0, "path": "src/ethereum/homestead/fork_types.py"}, "content": {"type": ["attribute"], "name": ["state_root"]}}, {"source": {"identifier": "ethereum.homestead.fork_types.Header.transactions_root", "specifier": 0, "path": "src/ethereum/homestead/fork_types.py"}, "content": {"type": ["attribute"], "name": ["transactions_root"]}}, {"source": {"identifier": "ethereum.homestead.fork_types.Header.receipt_root", "specifier": 0, "path": "src/ethereum/homestead/fork_types.py"}, "content": {"type": ["attribute"], "name": ["receipt_root"]}}, {"source": {"identifier": "ethereum.homestead.fork_types.Header.bloom", "specifier": 0, "path": "src/ethereum/homestead/fork_types.py"}, "content": {"type": ["attribute"], "name": ["bloom"]}}, {"source": {"identifier": "ethereum.homestead.fork_types.Header.difficulty", "specifier": 0, "path": "src/ethereum/homestead/fork_types.py"}, "content": {"type": ["attribute"], "name": ["difficulty"]}}, {"source": {"identifier": "ethereum.homestead.fork_types.Header.number", "specifier": 0, "path": "src/ethereum/homestead/fork_types.py"}, "content": {"type": ["attribute"], "name": ["number"]}}, {"source": {"identifier": "ethereum.homestead.fork_types.Header.gas_limit", "specifier": 0, "path": "src/ethereum/homestead/fork_types.py"}, "content": {"type": ["attribute"], "name": ["gas_limit"]}}, {"source": {"identifier": "ethereum.homestead.fork_types.Header.gas_used", "specifier": 0, "path": "src/ethereum/homestead/fork_types.py"}, "content": {"type": ["attribute"], "name": ["gas_used"]}}, {"source": {"identifier": "ethereum.homestead.fork_types.Header.timestamp", "specifier": 0, "path": "src/ethereum/homestead/fork_types.py"}, "content": {"type": ["attribute"], "name": ["timestamp"]}}, {"source": {"identifier": "ethereum.homestead.fork_types.Header.extra_data", "specifier": 0, "path": "src/ethereum/homestead/fork_types.py"}, "content": {"type": ["attribute"], "name": ["extra_data"]}}, {"source": {"identifier": "ethereum.homestead.fork_types.Header.mix_digest", "specifier": 0, "path": "src/ethereum/homestead/fork_types.py"}, "content": {"type": ["attribute"], "name": ["mix_digest"]}}, {"source": {"identifier": "ethereum.homestead.fork_types.Header.nonce", "specifier": 0, "path": "src/ethereum/homestead/fork_types.py"}, "content": {"type": ["attribute"], "name": ["nonce"]}}, {"source": {"identifier": "ethereum.homestead.fork_types.Block", "specifier": 0, "path": "src/ethereum/homestead/fork_types.py"}, "content": {"type": ["class"], "name": ["Block"], "text": ["A complete block."]}}, {"source": {"identifier": "ethereum.homestead.fork_types.Block.header", "specifier": 0, "path": "src/ethereum/homestead/fork_types.py"}, "content": {"type": ["attribute"], "name": ["header"]}}, {"source": {"identifier": "ethereum.homestead.fork_types.Block.transactions", "specifier": 0, "path": "src/ethereum/homestead/fork_types.py"}, "content": {"type": ["attribute"], "name": ["transactions"]}}, {"source": {"identifier": "ethereum.homestead.fork_types.Block.ommers", "specifier": 0, "path": "src/ethereum/homestead/fork_types.py"}, "content": {"type": ["attribute"], "name": ["ommers"]}}, {"source": {"identifier": "ethereum.homestead.fork_types.Log", "specifier": 0, "path": "src/ethereum/homestead/fork_types.py"}, "content": {"type": ["class"], "name": ["Log"], "text": ["Data record produced during the execution of a transaction."]}}, {"source": {"identifier": "ethereum.homestead.fork_types.Log.address", "specifier": 0, "path": "src/ethereum/homestead/fork_types.py"}, "content": {"type": ["attribute"], "name": ["address"]}}, {"source": {"identifier": "ethereum.homestead.fork_types.Log.topics", "specifier": 0, "path": "src/ethereum/homestead/fork_types.py"}, "content": {"type": ["attribute"], "name": ["topics"]}}, {"source": {"identifier": "ethereum.homestead.fork_types.Log.data", "specifier": 0, "path": "src/ethereum/homestead/fork_types.py"}, "content": {"type": ["attribute"], "name": ["data"]}}, {"source": {"identifier": "ethereum.homestead.fork_types.Receipt", "specifier": 0, "path": "src/ethereum/homestead/fork_types.py"}, "content": {"type": ["class"], "name": ["Receipt"], "text": ["Result of a transaction."]}}, {"source": {"identifier": "ethereum.homestead.fork_types.Receipt.post_state", "specifier": 0, "path": "src/ethereum/homestead/fork_types.py"}, "content": {"type": ["attribute"], "name": ["post_state"]}}, {"source": {"identifier": "ethereum.homestead.fork_types.Receipt.cumulative_gas_used", "specifier": 0, "path": "src/ethereum/homestead/fork_types.py"}, "content": {"type": ["attribute"], "name": ["cumulative_gas_used"]}}, {"source": {"identifier": "ethereum.homestead.fork_types.Receipt.bloom", "specifier": 0, "path": "src/ethereum/homestead/fork_types.py"}, "content": {"type": ["attribute"], "name": ["bloom"]}}, {"source": {"identifier": "ethereum.homestead.fork_types.Receipt.logs", "specifier": 0, "path": "src/ethereum/homestead/fork_types.py"}, "content": {"type": ["attribute"], "name": ["logs"]}}, {"source": {"identifier": "ethereum.muir_glacier.utils.address", "specifier": 0, "path": "src/ethereum/muir_glacier/utils/address.py"}, "content": {"type": ["module"], "name": ["ethereum.muir_glacier.utils.address"], "text": ["Hardfork Utility Functions For Addresses ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Address specific functions used in this muir_glacier version of specification."]}}, {"source": {"identifier": "ethereum.muir_glacier.utils.address.to_address", "specifier": 0, "path": "src/ethereum/muir_glacier/utils/address.py"}, "content": {"type": ["function"], "name": ["to_address"], "text": ["Convert a Uint or U256 value to a valid address (20 bytes). Parameters data : The string to be converted to bytes. Returns address :  Address The obtained address."]}}, {"source": {"identifier": "ethereum.muir_glacier.utils.address.compute_contract_address", "specifier": 0, "path": "src/ethereum/muir_glacier/utils/address.py"}, "content": {"type": ["function"], "name": ["compute_contract_address"], "text": ["Computes address of the new account that needs to be created. Parameters address : The address of the account that wants to create the new account. nonce : The transaction count of the account that wants to create the new account. Returns address:  Address The computed address of the new account."]}}, {"source": {"identifier": "ethereum.muir_glacier.utils.address.compute_create2_contract_address", "specifier": 0, "path": "src/ethereum/muir_glacier/utils/address.py"}, "content": {"type": ["function"], "name": ["compute_create2_contract_address"], "text": ["Computes address of the new account that needs to be created, which is based on the sender address, salt and the call data as well. Parameters address : The address of the account that wants to create the new account. salt : Address generation salt. call_data : The code of the new account which is to be created. Returns address:  ethereum.muir_glacier.fork_types.Address The computed address of the new account."]}}, {"source": {"identifier": "ethereum.homestead.trie", "specifier": 0, "path": "src/ethereum/homestead/trie.py"}, "content": {"type": ["module"], "name": ["ethereum.homestead.trie"], "text": ["State Trie ^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction The state trie is the structure responsible for storing .fork_types.Account  objects."]}}, {"source": {"identifier": "ethereum.homestead.trie.EMPTY_TRIE_ROOT", "specifier": 0, "path": "src/ethereum/homestead/trie.py"}, "content": {"type": ["attribute"], "name": ["EMPTY_TRIE_ROOT"]}}, {"source": {"identifier": "ethereum.homestead.trie.Node", "specifier": 0, "path": "src/ethereum/homestead/trie.py"}, "content": {"type": ["attribute"], "name": ["Node"]}}, {"source": {"identifier": "ethereum.homestead.trie.K", "specifier": 0, "path": "src/ethereum/homestead/trie.py"}, "content": {"type": ["attribute"], "name": ["K"]}}, {"source": {"identifier": "ethereum.homestead.trie.V", "specifier": 0, "path": "src/ethereum/homestead/trie.py"}, "content": {"type": ["attribute"], "name": ["V"]}}, {"source": {"identifier": "ethereum.homestead.trie.LeafNode", "specifier": 0, "path": "src/ethereum/homestead/trie.py"}, "content": {"type": ["class"], "name": ["LeafNode"], "text": ["Leaf node in the Merkle Trie"]}}, {"source": {"identifier": "ethereum.homestead.trie.LeafNode.rest_of_key", "specifier": 0, "path": "src/ethereum/homestead/trie.py"}, "content": {"type": ["attribute"], "name": ["rest_of_key"]}}, {"source": {"identifier": "ethereum.homestead.trie.LeafNode.value", "specifier": 0, "path": "src/ethereum/homestead/trie.py"}, "content": {"type": ["attribute"], "name": ["value"]}}, {"source": {"identifier": "ethereum.homestead.trie.ExtensionNode", "specifier": 0, "path": "src/ethereum/homestead/trie.py"}, "content": {"type": ["class"], "name": ["ExtensionNode"], "text": ["Extension node in the Merkle Trie"]}}, {"source": {"identifier": "ethereum.homestead.trie.ExtensionNode.key_segment", "specifier": 0, "path": "src/ethereum/homestead/trie.py"}, "content": {"type": ["attribute"], "name": ["key_segment"]}}, {"source": {"identifier": "ethereum.homestead.trie.ExtensionNode.subnode", "specifier": 0, "path": "src/ethereum/homestead/trie.py"}, "content": {"type": ["attribute"], "name": ["subnode"]}}, {"source": {"identifier": "ethereum.homestead.trie.BranchNode", "specifier": 0, "path": "src/ethereum/homestead/trie.py"}, "content": {"type": ["class"], "name": ["BranchNode"], "text": ["Branch node in the Merkle Trie"]}}, {"source": {"identifier": "ethereum.homestead.trie.BranchNode.subnodes", "specifier": 0, "path": "src/ethereum/homestead/trie.py"}, "content": {"type": ["attribute"], "name": ["subnodes"]}}, {"source": {"identifier": "ethereum.homestead.trie.BranchNode.value", "specifier": 0, "path": "src/ethereum/homestead/trie.py"}, "content": {"type": ["attribute"], "name": ["value"]}}, {"source": {"identifier": "ethereum.homestead.trie.InternalNode", "specifier": 0, "path": "src/ethereum/homestead/trie.py"}, "content": {"type": ["attribute"], "name": ["InternalNode"]}}, {"source": {"identifier": "ethereum.homestead.trie.encode_internal_node", "specifier": 0, "path": "src/ethereum/homestead/trie.py"}, "content": {"type": ["function"], "name": ["encode_internal_node"], "text": ["Encodes a Merkle Trie node into its RLP form. The RLP will then be serialized into a  Bytes  and hashed unless it is less that 32 bytes when serialized. This function also accepts  None , representing the absence of a node, which is encoded to  b\"\" . Parameters node : Optional[InternalNode] The node to encode. Returns encoded :  rlp.RLP The node encoded as RLP."]}}, {"source": {"identifier": "ethereum.homestead.trie.encode_node", "specifier": 0, "path": "src/ethereum/homestead/trie.py"}, "content": {"type": ["function"], "name": ["encode_node"], "text": ["Encode a Node for storage in the Merkle Trie. Currently mostly an unimplemented stub."]}}, {"source": {"identifier": "ethereum.homestead.trie.Trie", "specifier": 0, "path": "src/ethereum/homestead/trie.py"}, "content": {"type": ["class"], "name": ["Trie"], "text": ["The Merkle Trie."]}}, {"source": {"identifier": "ethereum.homestead.trie.Trie.secured", "specifier": 0, "path": "src/ethereum/homestead/trie.py"}, "content": {"type": ["attribute"], "name": ["secured"]}}, {"source": {"identifier": "ethereum.homestead.trie.Trie.default", "specifier": 0, "path": "src/ethereum/homestead/trie.py"}, "content": {"type": ["attribute"], "name": ["default"]}}, {"source": {"identifier": "ethereum.homestead.trie.Trie._data", "specifier": 0, "path": "src/ethereum/homestead/trie.py"}, "content": {"type": ["attribute"], "name": ["_data"]}}, {"source": {"identifier": "ethereum.homestead.trie.copy_trie", "specifier": 0, "path": "src/ethereum/homestead/trie.py"}, "content": {"type": ["function"], "name": ["copy_trie"], "text": ["Create a copy of  trie . Since only frozen objects may be stored in tries, the contents are reused. Parameters trie:  Trie Trie to copy. Returns new_trie :  Trie[K, V] A copy of the trie."]}}, {"source": {"identifier": "ethereum.homestead.trie.trie_set", "specifier": 0, "path": "src/ethereum/homestead/trie.py"}, "content": {"type": ["function"], "name": ["trie_set"], "text": ["Stores an item in a Merkle Trie. This method deletes the key if  value == trie.default , because the Merkle Trie represents the default value by omitting it from the trie. Parameters trie:  Trie Trie to store in. key :  Bytes Key to lookup. value :  V Node to insert at  key ."]}}, {"source": {"identifier": "ethereum.homestead.trie.trie_get", "specifier": 0, "path": "src/ethereum/homestead/trie.py"}, "content": {"type": ["function"], "name": ["trie_get"], "text": ["Gets an item from the Merkle Trie. This method returns  trie.default  if the key is missing. Parameters trie: Trie to lookup in. key : Key to lookup. Returns node :  V Node at  key  in the trie."]}}, {"source": {"identifier": "ethereum.homestead.trie.common_prefix_length", "specifier": 0, "path": "src/ethereum/homestead/trie.py"}, "content": {"type": ["function"], "name": ["common_prefix_length"], "text": ["Find the longest common prefix of two sequences."]}}, {"source": {"identifier": "ethereum.homestead.trie.nibble_list_to_compact", "specifier": 0, "path": "src/ethereum/homestead/trie.py"}, "content": {"type": ["function"], "name": ["nibble_list_to_compact"], "text": ["Compresses nibble-list into a standard byte array with a flag. A nibble-list is a list of byte values no greater than  15 . The flag is encoded in high nibble of the highest byte. The flag nibble can be broken down into two two-bit flags. Highest nibble:: +---+---+----------+--------+\n| _ | _ | is_leaf | parity |\n+---+---+----------+--------+\n  3   2      1         0\n The lowest bit of the nibble encodes the parity of the length of the remaining nibbles --  0  when even and  1  when odd. The second lowest bit is used to distinguish leaf and extension nodes. The other two bits are not used. Parameters x : Array of nibbles. is_leaf : True if this is part of a leaf node, or false if it is an extension node. Returns compressed :  bytearray Compact byte array."]}}, {"source": {"identifier": "ethereum.homestead.trie.bytes_to_nibble_list", "specifier": 0, "path": "src/ethereum/homestead/trie.py"}, "content": {"type": ["function"], "name": ["bytes_to_nibble_list"], "text": ["Converts a  Bytes  into to a sequence of nibbles (bytes with value < 16). Parameters bytes_: The  Bytes  to convert. Returns nibble_list :  Bytes The  Bytes  in nibble-list format."]}}, {"source": {"identifier": "ethereum.homestead.trie._prepare_trie", "specifier": 0, "path": "src/ethereum/homestead/trie.py"}, "content": {"type": ["function"], "name": ["_prepare_trie"], "text": ["Prepares the trie for root calculation. Removes values that are empty, hashes the keys (if  secured == True ) and encodes all the nodes. Parameters trie : The  Trie  to prepare. get_storage_root : Function to get the storage root of an account. Needed to encode Account  objects. Returns out :  Mapping[ethereum.base_types.Bytes, Node] Object with keys mapped to nibble-byte form."]}}, {"source": {"identifier": "ethereum.homestead.trie.root", "specifier": 0, "path": "src/ethereum/homestead/trie.py"}, "content": {"type": ["function"], "name": ["root"], "text": ["Computes the root of a modified merkle patricia trie (MPT). Parameters trie : Trie  to get the root of. get_storage_root : Function to get the storage root of an account. Needed to encode Account  objects. Returns root :  .fork_types.Root MPT root of the underlying key-value pairs."]}}, {"source": {"identifier": "ethereum.homestead.trie.patricialize", "specifier": 0, "path": "src/ethereum/homestead/trie.py"}, "content": {"type": ["function"], "name": ["patricialize"], "text": ["Structural composition function. Used to recursively patricialize and merkleize a dictionary. Includes memoization of the tree structure and hashes. Parameters obj : Underlying trie key-value pairs, with keys in nibble-list format. level : Current trie level. Returns node :  ethereum.base_types.Bytes Root node of  obj ."]}}, {"source": {"identifier": "ethereum.muir_glacier.utils.message", "specifier": 0, "path": "src/ethereum/muir_glacier/utils/message.py"}, "content": {"type": ["module"], "name": ["ethereum.muir_glacier.utils.message"], "text": ["Hardfork Utility Functions For The Message Data-structure ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Message specific functions used in this muir_glacier version of specification."]}}, {"source": {"identifier": "ethereum.muir_glacier.utils.message.prepare_message", "specifier": 0, "path": "src/ethereum/muir_glacier/utils/message.py"}, "content": {"type": ["function"], "name": ["prepare_message"], "text": ["Execute a transaction against the provided environment. Parameters caller : Address which initiated the transaction target : Address whose code will be executed value : Value to be transferred. data : Array of bytes provided to the code in  target . gas : Gas provided for the code in  target . env : Environment for the Ethereum Virtual Machine. code_address : This is usually same as the  target  address except when an alternative accounts code needs to be executed. eg.  CALLCODE  calling a precompile. should_transfer_value : if True ETH should be transferred while executing a message call. is_static: if True then it prevents all state-changing operations from being executed. Returns message:  ethereum.muir_glacier.vm.Message Items containing contract creation or message call specific data."]}}, {"source": {"identifier": "ethereum.homestead.fork", "specifier": 0, "path": "src/ethereum/homestead/fork.py"}, "content": {"type": ["module"], "name": ["ethereum.homestead.fork"], "text": ["Ethereum Specification ^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Entry point for the Ethereum specification."]}}, {"source": {"identifier": "ethereum.homestead.fork.BLOCK_REWARD", "specifier": 0, "path": "src/ethereum/homestead/fork.py"}, "content": {"type": ["attribute"], "name": ["BLOCK_REWARD"]}}, {"source": {"identifier": "ethereum.homestead.fork.GAS_LIMIT_ADJUSTMENT_FACTOR", "specifier": 0, "path": "src/ethereum/homestead/fork.py"}, "content": {"type": ["attribute"], "name": ["GAS_LIMIT_ADJUSTMENT_FACTOR"]}}, {"source": {"identifier": "ethereum.homestead.fork.GAS_LIMIT_MINIMUM", "specifier": 0, "path": "src/ethereum/homestead/fork.py"}, "content": {"type": ["attribute"], "name": ["GAS_LIMIT_MINIMUM"]}}, {"source": {"identifier": "ethereum.homestead.fork.MINIMUM_DIFFICULTY", "specifier": 0, "path": "src/ethereum/homestead/fork.py"}, "content": {"type": ["attribute"], "name": ["MINIMUM_DIFFICULTY"]}}, {"source": {"identifier": "ethereum.homestead.fork.MAX_OMMER_DEPTH", "specifier": 0, "path": "src/ethereum/homestead/fork.py"}, "content": {"type": ["attribute"], "name": ["MAX_OMMER_DEPTH"]}}, {"source": {"identifier": "ethereum.homestead.fork.BlockChain", "specifier": 0, "path": "src/ethereum/homestead/fork.py"}, "content": {"type": ["class"], "name": ["BlockChain"], "text": ["History and current state of the block chain."]}}, {"source": {"identifier": "ethereum.homestead.fork.BlockChain.blocks", "specifier": 0, "path": "src/ethereum/homestead/fork.py"}, "content": {"type": ["attribute"], "name": ["blocks"]}}, {"source": {"identifier": "ethereum.homestead.fork.BlockChain.state", "specifier": 0, "path": "src/ethereum/homestead/fork.py"}, "content": {"type": ["attribute"], "name": ["state"]}}, {"source": {"identifier": "ethereum.homestead.fork.BlockChain.chain_id", "specifier": 0, "path": "src/ethereum/homestead/fork.py"}, "content": {"type": ["attribute"], "name": ["chain_id"]}}, {"source": {"identifier": "ethereum.homestead.fork.apply_fork", "specifier": 0, "path": "src/ethereum/homestead/fork.py"}, "content": {"type": ["function"], "name": ["apply_fork"], "text": ["Transforms the state from the previous hard fork ( old ) into the block chain object for this hard fork and returns it. When forks need to implement an irregular state transition, this function is used to handle the irregularity. See the :ref: DAO Fork <dao-fork>  for an example. Parameters old : Previous block chain object. Returns new :  BlockChain Upgraded block chain object for this hard fork."]}}, {"source": {"identifier": "ethereum.homestead.fork.get_last_256_block_hashes", "specifier": 0, "path": "src/ethereum/homestead/fork.py"}, "content": {"type": ["function"], "name": ["get_last_256_block_hashes"], "text": ["Obtain the list of hashes of the previous 256 blocks in order of increasing block number. This function will return less hashes for the first 256 blocks. The  BLOCKHASH  opcode needs to access the latest hashes on the chain, therefore this function retrieves them. Parameters chain : History and current state. Returns recent_block_hashes :  List[Hash32] Hashes of the recent 256 blocks in order of increasing block number."]}}, {"source": {"identifier": "ethereum.homestead.fork.state_transition", "specifier": 0, "path": "src/ethereum/homestead/fork.py"}, "content": {"type": ["function"], "name": ["state_transition"], "text": ["Attempts to apply a block to an existing block chain. All parts of the block's contents need to be verified before being added to the chain. Blocks are verified by ensuring that the contents of the block make logical sense with the contents of the parent block. The information in the block's header must also match the corresponding information in the block. To implement Ethereum, in theory clients are only required to store the most recent 255 blocks of the chain since as far as execution is concerned, only those blocks are accessed. Practically, however, clients should store more blocks to handle reorgs. Parameters chain : History and current state. block : Block to apply to  chain ."]}}, {"source": {"identifier": "ethereum.homestead.fork.validate_header", "specifier": 0, "path": "src/ethereum/homestead/fork.py"}, "content": {"type": ["function"], "name": ["validate_header"], "text": ["Verifies a block header. In order to consider a block's header valid, the logic for the quantities in the header should match the logic for the block itself. For example the header timestamp should be greater than the block's parent timestamp because the block was created  after  the parent block. Additionally, the block's number should be directly folowing the parent block's number since it is the next block in the sequence. Parameters header : Header to check for correctness. parent_header : Parent Header of the header to check for correctness"]}}, {"source": {"identifier": "ethereum.homestead.fork.generate_header_hash_for_pow", "specifier": 0, "path": "src/ethereum/homestead/fork.py"}, "content": {"type": ["function"], "name": ["generate_header_hash_for_pow"], "text": ["Generate rlp hash of the header which is to be used for Proof-of-Work verification. In other words, the PoW artefacts  mix_digest  and  nonce  are ignored while calculating this hash. A particular PoW is valid for a single hash, that hash is computed by this function. The  nonce  and  mix_digest  are omitted from this hash because they are being changed by miners in their search for a sufficient proof-of-work. Parameters header : The header object for which the hash is to be generated. Returns hash :  Hash32 The PoW valid rlp hash of the passed in header."]}}, {"source": {"identifier": "ethereum.homestead.fork.validate_proof_of_work", "specifier": 0, "path": "src/ethereum/homestead/fork.py"}, "content": {"type": ["function"], "name": ["validate_proof_of_work"], "text": ["Validates the Proof of Work constraints. In order to verify that a miner's proof-of-work is valid for a block, a mix-digest  and  result  are calculated using the  hashimoto_light hash function. The mix digest is a hash of the header and the nonce that is passed through and it confirms whether or not proof-of-work was done on the correct block. The result is the actual hash value of the block. Parameters header : Header of interest."]}}, {"source": {"identifier": "ethereum.homestead.fork.check_transaction", "specifier": 0, "path": "src/ethereum/homestead/fork.py"}, "content": {"type": ["function"], "name": ["check_transaction"], "text": ["Check if the transaction is includable in the block. Parameters tx : The transaction. gas_available : The gas remaining in the block. Returns sender_address : The sender of the transaction. Raises InvalidBlock : If the transaction is not includable."]}}, {"source": {"identifier": "ethereum.homestead.fork.make_receipt", "specifier": 0, "path": "src/ethereum/homestead/fork.py"}, "content": {"type": ["function"], "name": ["make_receipt"], "text": ["Make the receipt for a transaction that was executed. Parameters tx : The executed transaction. post_state : The state root immediately after this transaction. cumulative_gas_used : The total gas used so far in the block after the transaction was executed. logs : The logs produced by the transaction. Returns receipt : The receipt for the transaction."]}}, {"source": {"identifier": "ethereum.homestead.fork.apply_body", "specifier": 0, "path": "src/ethereum/homestead/fork.py"}, "content": {"type": ["function"], "name": ["apply_body"], "text": ["Executes a block. Many of the contents of a block are stored in data structures called tries. There is a transactions trie which is similar to a ledger of the transactions stored in the current block. There is also a receipts trie which stores the results of executing a transaction, like the post state and gas used. This function creates and executes the block that is to be added to the chain. Parameters state : Current account state. block_hashes : List of hashes of the previous 256 blocks in the order of increasing block number. coinbase : Address of account which receives block reward and transaction fees. block_number : Position of the block within the chain. block_gas_limit : Initial amount of gas available for execution in this block. block_time : Time the block was produced, measured in seconds since the epoch. block_difficulty : Difficulty of the block. transactions : Transactions included in the block. ommers : Headers of ancestor blocks which are not direct parents (formerly uncles.) Returns gas_available :  ethereum.base_types.Uint Remaining gas after all transactions have been executed. transactions_root :  ethereum.fork_types.Root Trie root of all the transactions in the block. receipt_root :  ethereum.fork_types.Root Trie root of all the receipts in the block. block_logs_bloom :  Bloom Logs bloom of all the logs included in all the transactions of the block. state :  ethereum.fork_types.State State after all transactions have been executed."]}}, {"source": {"identifier": "ethereum.homestead.fork.validate_ommers", "specifier": 0, "path": "src/ethereum/homestead/fork.py"}, "content": {"type": ["function"], "name": ["validate_ommers"], "text": ["Validates the ommers mentioned in the block. An ommer block is a block that wasn't canonically added to the blockchain because it wasn't validated as fast as the canonical block but was mined at the same time. To be considered valid, the ommers must adhere to the rules defined in the Ethereum protocol. The maximum amount of ommers is 2 per block and there cannot be duplicate ommers in a block. Many of the other ommer contraints are listed in the in-line comments of this function. Parameters ommers : List of ommers mentioned in the current block. block_header: The header of current block. chain : History and current state."]}}, {"source": {"identifier": "ethereum.homestead.fork.pay_rewards", "specifier": 0, "path": "src/ethereum/homestead/fork.py"}, "content": {"type": ["function"], "name": ["pay_rewards"], "text": ["Pay rewards to the block miner as well as the ommers miners. The miner of the canonical block is rewarded with the predetermined block reward,  BLOCK_REWARD , plus a variable award based off of the number of ommer blocks that were mined around the same time, and included in the canonical block's header. An ommer block is a block that wasn't added to the canonical blockchain because it wasn't validated as fast as the accepted block but was mined at the same time. Although not all blocks that are mined are added to the canonical chain, miners are still paid a reward for their efforts. This reward is called an ommer reward and is calculated based on the number associated with the ommer block that they mined. Parameters state : Current account state. block_number : Position of the block within the chain. coinbase : Address of account which receives block reward and transaction fees. ommers : List of ommers mentioned in the current block."]}}, {"source": {"identifier": "ethereum.homestead.fork.process_transaction", "specifier": 0, "path": "src/ethereum/homestead/fork.py"}, "content": {"type": ["function"], "name": ["process_transaction"], "text": ["Execute a transaction against the provided environment. This function processes the actions needed to execute a transaction. It decrements the sender's account after calculating the gas fee and refunds them the proper amount after execution. Calling contracts, deploying code, and incrementing nonces are all examples of actions that happen within this function or from a call made within this function. Accounts that are marked for deletion are processed and destroyed after execution. Parameters env : Environment for the Ethereum Virtual Machine. tx : Transaction to execute. Returns gas_left :  ethereum.base_types.U256 Remaining gas after execution. logs :  Tuple[ethereum.fork_types.Log, ...] Logs generated during execution."]}}, {"source": {"identifier": "ethereum.homestead.fork.validate_transaction", "specifier": 0, "path": "src/ethereum/homestead/fork.py"}, "content": {"type": ["function"], "name": ["validate_transaction"], "text": ["Verifies a transaction. The gas in a transaction gets used to pay for the intrinsic cost of operations, therefore if there is insufficient gas then it would not be possible to execute a transaction and it will be declared invalid. Additionally, the nonce of a transaction must not equal or exceed the limit defined in  EIP-2681 <https://eips.ethereum.org/EIPS/eip-2681> _. In practice, defining the limit as  2**64-1  has no impact because sending  2**64-1  transactions is improbable. It's not strictly impossible though,  2**64-1  transactions is the entire capacity of the Ethereum blockchain at 2022 gas limits for a little over 22 years. Parameters tx : Transaction to validate. Returns verified :  bool True if the transaction can be executed, or False otherwise."]}}, {"source": {"identifier": "ethereum.homestead.fork.calculate_intrinsic_cost", "specifier": 0, "path": "src/ethereum/homestead/fork.py"}, "content": {"type": ["function"], "name": ["calculate_intrinsic_cost"], "text": ["Calculates the gas that is charged before execution is started. The intrinsic cost of the transaction is charged before execution has begun. Functions/operations in the EVM cost money to execute so this intrinsic cost is for the operations that need to be paid for as part of the transaction. Data transfer, for example, is part of this intrinsic cost. It costs ether to send data over the wire and that ether is accounted for in the intrinsic cost calculated in this function. This intrinsic cost must be calculated and paid for before execution in order for all operations to be implemented. Parameters tx : Transaction to compute the intrinsic cost of. Returns verified :  ethereum.base_types.Uint The intrinsic cost of the transaction."]}}, {"source": {"identifier": "ethereum.homestead.fork.recover_sender", "specifier": 0, "path": "src/ethereum/homestead/fork.py"}, "content": {"type": ["function"], "name": ["recover_sender"], "text": ["Extracts the sender address from a transaction. The v, r, and s values are the three parts that make up the signature of a transaction. In order to recover the sender of a transaction the two components needed are the signature ( v ,  r , and  s ) and the signing hash of the transaction. The sender's public key can be obtained with these two values and therefore the sender address can be retrieved. Parameters tx : Transaction of interest. Returns sender :  ethereum.fork_types.Address The address of the account that signed the transaction."]}}, {"source": {"identifier": "ethereum.homestead.fork.signing_hash", "specifier": 0, "path": "src/ethereum/homestead/fork.py"}, "content": {"type": ["function"], "name": ["signing_hash"], "text": ["Compute the hash of a transaction used in the signature. The values that are used to compute the signing hash set the rules for a transaction. For example, signing over the gas sets a limit for the amount of money that is allowed to be pulled out of the sender's account. Parameters tx : Transaction of interest. Returns hash :  ethereum.crypto.hash.Hash32 Hash of the transaction."]}}, {"source": {"identifier": "ethereum.homestead.fork.compute_header_hash", "specifier": 0, "path": "src/ethereum/homestead/fork.py"}, "content": {"type": ["function"], "name": ["compute_header_hash"], "text": ["Computes the hash of a block header. The header hash of a block is the canonical hash that is used to refer to a specific block and completely distinguishes a block from another. keccak256  is a function that produces a 256 bit hash of any input. It also takes in any number of bytes as an input and produces a single hash for them. A hash is a completely unique output for a single input. So an input corresponds to one unique hash that can be used to identify the input exactly. Prior to using the  keccak256  hash function, the header must be encoded using the Recursive-Length Prefix. See :ref: rlp . RLP encoding the header converts it into a space-efficient format that allows for easy transfer of data between nodes. The purpose of RLP is to encode arbitrarily nested arrays of binary data, and RLP is the primary encoding method used to serialize objects in Ethereum's execution layer. The only purpose of RLP is to encode structure; encoding specific data types (e.g. strings, floats) is left up to higher-order protocols. Parameters header : Header of interest. Returns hash :  ethereum.crypto.hash.Hash32 Hash of the header."]}}, {"source": {"identifier": "ethereum.homestead.fork.check_gas_limit", "specifier": 0, "path": "src/ethereum/homestead/fork.py"}, "content": {"type": ["function"], "name": ["check_gas_limit"], "text": ["Validates the gas limit for a block. The bounds of the gas limit,  max_adjustment_delta , is set as the quotient of the parent block's gas limit and the GAS_LIMIT_ADJUSTMENT_FACTOR . Therefore, if the gas limit that is passed through as a parameter is greater than or equal to the  sum  of the parent's gas and the adjustment delta then the limit for gas is too high and fails this function's check. Similarly, if the limit is less than or equal to the  difference  of the parent's gas and the adjustment delta  or  the predefined  GAS_LIMIT_MINIMUM  then this function's check fails because the gas limit doesn't allow for a sufficient or reasonable amount of gas to be used on a block. Parameters gas_limit : Gas limit to validate. parent_gas_limit : Gas limit of the parent block. Returns check :  bool True if gas limit constraints are satisfied, False otherwise."]}}, {"source": {"identifier": "ethereum.homestead.fork.calculate_block_difficulty", "specifier": 0, "path": "src/ethereum/homestead/fork.py"}, "content": {"type": ["function"], "name": ["calculate_block_difficulty"], "text": ["Computes difficulty of a block using its header and parent header. The difficulty is determined by the time the block was created after its parent. The  offset  is calculated using the parent block's difficulty, parent_difficulty , and the timestamp between blocks. This offset is then added to the parent difficulty and is stored as the  difficulty variable. If the time between the block and its parent is too short, the offset will result in a positive number thus making the sum of parent_difficulty  and  offset  to be a greater value in order to avoid mass forking. But, if the time is long enough, then the offset results in a negative value making the block less difficult than its parent. The base standard for a block's difficulty is the predefined value set for the genesis block since it has no parent. So, a block can't be less difficult than the genesis block, therefore each block's difficulty is set to the maximum value between the calculated difficulty and the  GENESIS_DIFFICULTY . Parameters block_number : Block number of the block. block_timestamp : Timestamp of the block. parent_timestamp : Timestamp of the parent block. parent_difficulty : difficulty of the parent block. Returns difficulty :  ethereum.base_types.Uint Computed difficulty for a block."]}}, {"source": {"identifier": "ethereum.muir_glacier.utils.hexadecimal", "specifier": 0, "path": "src/ethereum/muir_glacier/utils/hexadecimal.py"}, "content": {"type": ["module"], "name": ["ethereum.muir_glacier.utils.hexadecimal"], "text": ["Utility Functions For Hexadecimal Strings ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Hexadecimal utility functions used in this specification, specific to Muir Glacier types."]}}, {"source": {"identifier": "ethereum.muir_glacier.utils.hexadecimal.hex_to_root", "specifier": 0, "path": "src/ethereum/muir_glacier/utils/hexadecimal.py"}, "content": {"type": ["function"], "name": ["hex_to_root"], "text": ["Convert hex string to trie root. Parameters hex_string : The hexadecimal string to be converted to trie root. Returns root :  Root Trie root obtained from the given hexadecimal string."]}}, {"source": {"identifier": "ethereum.muir_glacier.utils.hexadecimal.hex_to_bloom", "specifier": 0, "path": "src/ethereum/muir_glacier/utils/hexadecimal.py"}, "content": {"type": ["function"], "name": ["hex_to_bloom"], "text": ["Convert hex string to bloom. Parameters hex_string : The hexadecimal string to be converted to bloom. Returns bloom :  Bloom Bloom obtained from the given hexadecimal string."]}}, {"source": {"identifier": "ethereum.muir_glacier.utils.hexadecimal.hex_to_address", "specifier": 0, "path": "src/ethereum/muir_glacier/utils/hexadecimal.py"}, "content": {"type": ["function"], "name": ["hex_to_address"], "text": ["Convert hex string to Address (20 bytes). Parameters hex_string : The hexadecimal string to be converted to Address. Returns address :  Address The address obtained from the given hexadecimal string."]}}, {"source": {"identifier": "ethereum.homestead.vm.memory", "specifier": 0, "path": "src/ethereum/homestead/vm/memory.py"}, "content": {"type": ["module"], "name": ["ethereum.homestead.vm.memory"], "text": ["Ethereum Virtual Machine (EVM) Memory ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction EVM memory operations."]}}, {"source": {"identifier": "ethereum.homestead.vm.memory.memory_write", "specifier": 0, "path": "src/ethereum/homestead/vm/memory.py"}, "content": {"type": ["function"], "name": ["memory_write"], "text": ["Writes to memory. Parameters memory : Memory contents of the EVM. start_position : Starting pointer to the memory. value : Data to write to memory."]}}, {"source": {"identifier": "ethereum.homestead.vm.memory.memory_read_bytes", "specifier": 0, "path": "src/ethereum/homestead/vm/memory.py"}, "content": {"type": ["function"], "name": ["memory_read_bytes"], "text": ["Read bytes from memory. Parameters memory : Memory contents of the EVM. start_position : Starting pointer to the memory. size : Size of the data that needs to be read from  start_position . Returns data_bytes : Data read from memory."]}}, {"source": {"identifier": "ethereum.homestead.vm.memory.buffer_read", "specifier": 0, "path": "src/ethereum/homestead/vm/memory.py"}, "content": {"type": ["function"], "name": ["buffer_read"], "text": ["Read bytes from a buffer. Padding with zeros if neccesary. Parameters buffer : Memory contents of the EVM. start_position : Starting pointer to the memory. size : Size of the data that needs to be read from  start_position . Returns data_bytes : Data read from memory."]}}, {"source": {"identifier": "ethereum.paris.state", "specifier": 0, "path": "src/ethereum/paris/state.py"}, "content": {"type": ["module"], "name": ["ethereum.paris.state"], "text": ["State ^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction The state contains all information that is preserved between transactions. It consists of a main account trie and storage tries for each contract. There is a distinction between an account that does not exist and EMPTY_ACCOUNT ."]}}, {"source": {"identifier": "ethereum.paris.state.State", "specifier": 0, "path": "src/ethereum/paris/state.py"}, "content": {"type": ["class"], "name": ["State"], "text": ["Contains all information that is preserved between transactions."]}}, {"source": {"identifier": "ethereum.paris.state.State._main_trie", "specifier": 0, "path": "src/ethereum/paris/state.py"}, "content": {"type": ["attribute"], "name": ["_main_trie"]}}, {"source": {"identifier": "ethereum.paris.state.State._storage_tries", "specifier": 0, "path": "src/ethereum/paris/state.py"}, "content": {"type": ["attribute"], "name": ["_storage_tries"]}}, {"source": {"identifier": "ethereum.paris.state.State._snapshots", "specifier": 0, "path": "src/ethereum/paris/state.py"}, "content": {"type": ["attribute"], "name": ["_snapshots"]}}, {"source": {"identifier": "ethereum.paris.state.close_state", "specifier": 0, "path": "src/ethereum/paris/state.py"}, "content": {"type": ["function"], "name": ["close_state"], "text": ["Free resources held by the state. Used by optimized implementations to release file descriptors."]}}, {"source": {"identifier": "ethereum.paris.state.begin_transaction", "specifier": 0, "path": "src/ethereum/paris/state.py"}, "content": {"type": ["function"], "name": ["begin_transaction"], "text": ["Start a state transaction. Transactions are entirely implicit and can be nested. It is not possible to calculate the state root during a transaction. Parameters state : State The state."]}}, {"source": {"identifier": "ethereum.paris.state.commit_transaction", "specifier": 0, "path": "src/ethereum/paris/state.py"}, "content": {"type": ["function"], "name": ["commit_transaction"], "text": ["Commit a state transaction. Parameters state : State The state."]}}, {"source": {"identifier": "ethereum.paris.state.rollback_transaction", "specifier": 0, "path": "src/ethereum/paris/state.py"}, "content": {"type": ["function"], "name": ["rollback_transaction"], "text": ["Rollback a state transaction, resetting the state to the point when the corresponding  start_transaction()  call was made. Parameters state : State The state."]}}, {"source": {"identifier": "ethereum.paris.state.get_account", "specifier": 0, "path": "src/ethereum/paris/state.py"}, "content": {"type": ["function"], "name": ["get_account"], "text": ["Get the  Account  object at an address. Returns  EMPTY_ACCOUNT  if there is no account at the address. Use  get_account_optional()  if you care about the difference between a non-existent account and  EMPTY_ACCOUNT . Parameters state:  State The state address :  Address Address to lookup. Returns account :  Account Account at address."]}}, {"source": {"identifier": "ethereum.paris.state.get_account_optional", "specifier": 0, "path": "src/ethereum/paris/state.py"}, "content": {"type": ["function"], "name": ["get_account_optional"], "text": ["Get the  Account  object at an address. Returns  None  (rather than EMPTY_ACCOUNT ) if there is no account at the address. Parameters state:  State The state address :  Address Address to lookup. Returns account :  Account Account at address."]}}, {"source": {"identifier": "ethereum.paris.state.set_account", "specifier": 0, "path": "src/ethereum/paris/state.py"}, "content": {"type": ["function"], "name": ["set_account"], "text": ["Set the  Account  object at an address. Setting to  None  deletes the account (but not its storage, see  destroy_account() ). Parameters state:  State The state address :  Address Address to set. account :  Account Account to set at address."]}}, {"source": {"identifier": "ethereum.paris.state.destroy_account", "specifier": 0, "path": "src/ethereum/paris/state.py"}, "content": {"type": ["function"], "name": ["destroy_account"], "text": ["Completely remove the account at  address  and all of its storage. This function is made available exclusively for the  SELFDESTRUCT opcode. It is expected that  SELFDESTRUCT  will be disabled in a future hardfork and this function will be removed. Parameters state:  State The state address :  Address Address of account to destroy."]}}, {"source": {"identifier": "ethereum.paris.state.destroy_storage", "specifier": 0, "path": "src/ethereum/paris/state.py"}, "content": {"type": ["function"], "name": ["destroy_storage"], "text": ["Completely remove the storage at  address . Parameters state:  State The state address :  Address Address of account whose storage is to be deleted."]}}, {"source": {"identifier": "ethereum.paris.state.get_storage", "specifier": 0, "path": "src/ethereum/paris/state.py"}, "content": {"type": ["function"], "name": ["get_storage"], "text": ["Get a value at a storage key on an account. Returns  U256(0)  if the storage key has not been set previously. Parameters state:  State The state address :  Address Address of the account. key :  Bytes Key to lookup. Returns value :  U256 Value at the key."]}}, {"source": {"identifier": "ethereum.paris.state.set_storage", "specifier": 0, "path": "src/ethereum/paris/state.py"}, "content": {"type": ["function"], "name": ["set_storage"], "text": ["Set a value at a storage key on an account. Setting to  U256(0)  deletes the key. Parameters state:  State The state address :  Address Address of the account. key :  Bytes Key to set. value :  U256 Value to set at the key."]}}, {"source": {"identifier": "ethereum.paris.state.storage_root", "specifier": 0, "path": "src/ethereum/paris/state.py"}, "content": {"type": ["function"], "name": ["storage_root"], "text": ["Calculate the storage root of an account. Parameters state: The state address : Address of the account. Returns root :  Root Storage root of the account."]}}, {"source": {"identifier": "ethereum.paris.state.state_root", "specifier": 0, "path": "src/ethereum/paris/state.py"}, "content": {"type": ["function"], "name": ["state_root"], "text": ["Calculate the state root. Parameters state: The current state. Returns root :  Root The state root."]}}, {"source": {"identifier": "ethereum.paris.state.account_exists", "specifier": 0, "path": "src/ethereum/paris/state.py"}, "content": {"type": ["function"], "name": ["account_exists"], "text": ["Checks if an account exists in the state trie Parameters state: The state address: Address of the account that needs to be checked. Returns account_exists :  bool True if account exists in the state trie, False otherwise"]}}, {"source": {"identifier": "ethereum.paris.state.account_has_code_or_nonce", "specifier": 0, "path": "src/ethereum/paris/state.py"}, "content": {"type": ["function"], "name": ["account_has_code_or_nonce"], "text": ["Checks if an account has non zero nonce or non empty code Parameters state: The state address: Address of the account that needs to be checked. Returns has_code_or_nonce :  bool True if if an account has non zero nonce or non empty code, False otherwise."]}}, {"source": {"identifier": "ethereum.paris.state.is_account_empty", "specifier": 0, "path": "src/ethereum/paris/state.py"}, "content": {"type": ["function"], "name": ["is_account_empty"], "text": ["Checks if an account has zero nonce, empty code and zero balance. Parameters state: The state address: Address of the account that needs to be checked. Returns is_empty :  bool True if if an account has zero nonce, empty code and zero balance, False otherwise."]}}, {"source": {"identifier": "ethereum.paris.state.account_exists_and_is_empty", "specifier": 0, "path": "src/ethereum/paris/state.py"}, "content": {"type": ["function"], "name": ["account_exists_and_is_empty"], "text": ["Checks if an account exists and has zero nonce, empty code and zero balance. Parameters state: The state address: Address of the account that needs to be checked. Returns exists_and_is_empty :  bool True if an account exists and has zero nonce, empty code and zero balance, False otherwise."]}}, {"source": {"identifier": "ethereum.paris.state.is_account_alive", "specifier": 0, "path": "src/ethereum/paris/state.py"}, "content": {"type": ["function"], "name": ["is_account_alive"], "text": ["Check whether is an account is both in the state and non empty. Parameters state: The state address: Address of the account that needs to be checked. Returns is_alive :  bool True if the account is alive."]}}, {"source": {"identifier": "ethereum.paris.state.modify_state", "specifier": 0, "path": "src/ethereum/paris/state.py"}, "content": {"type": ["function"], "name": ["modify_state"], "text": ["Modify an  Account  in the  State ."]}}, {"source": {"identifier": "ethereum.paris.state.move_ether", "specifier": 0, "path": "src/ethereum/paris/state.py"}, "content": {"type": ["function"], "name": ["move_ether"], "text": ["Move funds between accounts."]}}, {"source": {"identifier": "ethereum.paris.state.set_account_balance", "specifier": 0, "path": "src/ethereum/paris/state.py"}, "content": {"type": ["function"], "name": ["set_account_balance"], "text": ["Sets the balance of an account. Parameters state: The current state. address: Address of the account whose nonce needs to be incremented. amount: The amount that needs to set in balance."]}}, {"source": {"identifier": "ethereum.paris.state.touch_account", "specifier": 0, "path": "src/ethereum/paris/state.py"}, "content": {"type": ["function"], "name": ["touch_account"], "text": ["Initializes an account to state. Parameters state: The current state. address: The address of the account that need to initialised."]}}, {"source": {"identifier": "ethereum.paris.state.increment_nonce", "specifier": 0, "path": "src/ethereum/paris/state.py"}, "content": {"type": ["function"], "name": ["increment_nonce"], "text": ["Increments the nonce of an account. Parameters state: The current state. address: Address of the account whose nonce needs to be incremented."]}}, {"source": {"identifier": "ethereum.paris.state.set_code", "specifier": 0, "path": "src/ethereum/paris/state.py"}, "content": {"type": ["function"], "name": ["set_code"], "text": ["Sets Account code. Parameters state: The current state. address: Address of the account whose code needs to be update. code: The bytecode that needs to be set."]}}, {"source": {"identifier": "ethereum.paris.state.get_storage_original", "specifier": 0, "path": "src/ethereum/paris/state.py"}, "content": {"type": ["function"], "name": ["get_storage_original"], "text": ["Get the original value in a storage slot i.e. the value before the current transaction began. This function reads the value from the snapshots taken before executing the transaction. Parameters state: The current state. address: Address of the account to read the value from. key: Key of the storage slot."]}}, {"source": {"identifier": "ethereum.homestead.vm.exceptions", "specifier": 0, "path": "src/ethereum/homestead/vm/exceptions.py"}, "content": {"type": ["module"], "name": ["ethereum.homestead.vm.exceptions"], "text": ["Ethereum Virtual Machine (EVM) Exceptions ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Exceptions which cause the EVM to halt exceptionally."]}}, {"source": {"identifier": "ethereum.homestead.vm.exceptions.ExceptionalHalt", "specifier": 0, "path": "src/ethereum/homestead/vm/exceptions.py"}, "content": {"type": ["class"], "name": ["ExceptionalHalt"], "text": ["Indicates that the EVM has experienced an exceptional halt. This causes execution to immediately end with all gas being consumed."]}}, {"source": {"identifier": "ethereum.homestead.vm.exceptions.StackUnderflowError", "specifier": 0, "path": "src/ethereum/homestead/vm/exceptions.py"}, "content": {"type": ["class"], "name": ["StackUnderflowError"], "text": ["Occurs when a pop is executed on an empty stack."]}}, {"source": {"identifier": "ethereum.homestead.vm.exceptions.StackOverflowError", "specifier": 0, "path": "src/ethereum/homestead/vm/exceptions.py"}, "content": {"type": ["class"], "name": ["StackOverflowError"], "text": ["Occurs when a push is executed on a stack at max capacity."]}}, {"source": {"identifier": "ethereum.homestead.vm.exceptions.OutOfGasError", "specifier": 0, "path": "src/ethereum/homestead/vm/exceptions.py"}, "content": {"type": ["class"], "name": ["OutOfGasError"], "text": ["Occurs when an operation costs more than the amount of gas left in the frame."]}}, {"source": {"identifier": "ethereum.homestead.vm.exceptions.InvalidOpcode", "specifier": 0, "path": "src/ethereum/homestead/vm/exceptions.py"}, "content": {"type": ["class"], "name": ["InvalidOpcode"], "text": ["Raised when an invalid opcode is encountered."]}}, {"source": {"identifier": "ethereum.homestead.vm.exceptions.InvalidJumpDestError", "specifier": 0, "path": "src/ethereum/homestead/vm/exceptions.py"}, "content": {"type": ["class"], "name": ["InvalidJumpDestError"], "text": ["Occurs when the destination of a jump operation doesn't meet any of the following criteria: The jump destination is less than the length of the code. The jump destination should have the  JUMPDEST  opcode (0x5B). The jump destination shouldn't be part of the data corresponding to PUSH-N  opcodes."]}}, {"source": {"identifier": "ethereum.homestead.vm.exceptions.StackDepthLimitError", "specifier": 0, "path": "src/ethereum/homestead/vm/exceptions.py"}, "content": {"type": ["class"], "name": ["StackDepthLimitError"], "text": ["Raised when the message depth is greater than  1024"]}}, {"source": {"identifier": "ethereum.paris", "specifier": 0, "path": "src/ethereum/paris/__init__.py"}, "content": {"type": ["module"], "name": ["ethereum.paris"], "text": ["Ethereum Paris Hardfork ^^^^^^^^^^^^^^^^^^^^^^^ The Fourteenth Ethereum hardfork."]}}, {"source": {"identifier": "ethereum.paris.MAINNET_FORK_BLOCK", "specifier": 0, "path": "src/ethereum/paris/__init__.py"}, "content": {"type": ["attribute"], "name": ["MAINNET_FORK_BLOCK"]}}, {"source": {"identifier": "ethereum.paris.bloom", "specifier": 0, "path": "src/ethereum/paris/bloom.py"}, "content": {"type": ["module"], "name": ["ethereum.paris.bloom"], "text": ["Ethereum Logs Bloom ^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction This modules defines functions for calculating bloom filters of logs. For the general theory of bloom filters see e.g.  Wikipedia <https://en.wikipedia.org/wiki/Bloom_filter> _. Bloom filters are used to allow for efficient searching of logs by address and/or topic, by rapidly eliminating blocks and reciepts from their search."]}}, {"source": {"identifier": "ethereum.paris.bloom.add_to_bloom", "specifier": 0, "path": "src/ethereum/paris/bloom.py"}, "content": {"type": ["function"], "name": ["add_to_bloom"], "text": ["Add a bloom entry to the bloom filter ( bloom ). The number of hash functions used is 3. They are calculated by taking the least significant 11 bits from the first 3 16-bit words of the keccak_256()  hash of  bloom_entry . Parameters bloom : The bloom filter. bloom_entry : An entry which is to be added to bloom filter."]}}, {"source": {"identifier": "ethereum.paris.bloom.logs_bloom", "specifier": 0, "path": "src/ethereum/paris/bloom.py"}, "content": {"type": ["function"], "name": ["logs_bloom"], "text": ["Obtain the logs bloom from a list of log entries. The address and each topic of a log are added to the bloom filter. Parameters logs : List of logs for which the logs bloom is to be obtained. Returns logs_bloom :  Bloom The logs bloom obtained which is 256 bytes with some bits set as per the caller address and the log topics."]}}, {"source": {"identifier": "ethereum.homestead.vm", "specifier": 0, "path": "src/ethereum/homestead/vm/__init__.py"}, "content": {"type": ["module"], "name": ["ethereum.homestead.vm"], "text": ["Ethereum Virtual Machine (EVM) ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction The abstract computer which runs the code stored in an .fork_types.Account ."]}}, {"source": {"identifier": "ethereum.homestead.vm.__all__", "specifier": 0, "path": "src/ethereum/homestead/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["__all__"]}}, {"source": {"identifier": "ethereum.homestead.vm.Environment", "specifier": 0, "path": "src/ethereum/homestead/vm/__init__.py"}, "content": {"type": ["class"], "name": ["Environment"], "text": ["Items external to the virtual machine itself, provided by the environment."]}}, {"source": {"identifier": "ethereum.homestead.vm.Environment.caller", "specifier": 0, "path": "src/ethereum/homestead/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["caller"]}}, {"source": {"identifier": "ethereum.homestead.vm.Environment.block_hashes", "specifier": 0, "path": "src/ethereum/homestead/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["block_hashes"]}}, {"source": {"identifier": "ethereum.homestead.vm.Environment.origin", "specifier": 0, "path": "src/ethereum/homestead/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["origin"]}}, {"source": {"identifier": "ethereum.homestead.vm.Environment.coinbase", "specifier": 0, "path": "src/ethereum/homestead/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["coinbase"]}}, {"source": {"identifier": "ethereum.homestead.vm.Environment.number", "specifier": 0, "path": "src/ethereum/homestead/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["number"]}}, {"source": {"identifier": "ethereum.homestead.vm.Environment.gas_limit", "specifier": 0, "path": "src/ethereum/homestead/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["gas_limit"]}}, {"source": {"identifier": "ethereum.homestead.vm.Environment.gas_price", "specifier": 0, "path": "src/ethereum/homestead/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["gas_price"]}}, {"source": {"identifier": "ethereum.homestead.vm.Environment.time", "specifier": 0, "path": "src/ethereum/homestead/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["time"]}}, {"source": {"identifier": "ethereum.homestead.vm.Environment.difficulty", "specifier": 0, "path": "src/ethereum/homestead/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["difficulty"]}}, {"source": {"identifier": "ethereum.homestead.vm.Environment.state", "specifier": 0, "path": "src/ethereum/homestead/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["state"]}}, {"source": {"identifier": "ethereum.homestead.vm.Message", "specifier": 0, "path": "src/ethereum/homestead/vm/__init__.py"}, "content": {"type": ["class"], "name": ["Message"], "text": ["Items that are used by contract creation or message call."]}}, {"source": {"identifier": "ethereum.homestead.vm.Message.caller", "specifier": 0, "path": "src/ethereum/homestead/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["caller"]}}, {"source": {"identifier": "ethereum.homestead.vm.Message.target", "specifier": 0, "path": "src/ethereum/homestead/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["target"]}}, {"source": {"identifier": "ethereum.homestead.vm.Message.current_target", "specifier": 0, "path": "src/ethereum/homestead/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["current_target"]}}, {"source": {"identifier": "ethereum.homestead.vm.Message.gas", "specifier": 0, "path": "src/ethereum/homestead/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["gas"]}}, {"source": {"identifier": "ethereum.homestead.vm.Message.value", "specifier": 0, "path": "src/ethereum/homestead/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["value"]}}, {"source": {"identifier": "ethereum.homestead.vm.Message.data", "specifier": 0, "path": "src/ethereum/homestead/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["data"]}}, {"source": {"identifier": "ethereum.homestead.vm.Message.code_address", "specifier": 0, "path": "src/ethereum/homestead/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["code_address"]}}, {"source": {"identifier": "ethereum.homestead.vm.Message.code", "specifier": 0, "path": "src/ethereum/homestead/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["code"]}}, {"source": {"identifier": "ethereum.homestead.vm.Message.depth", "specifier": 0, "path": "src/ethereum/homestead/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["depth"]}}, {"source": {"identifier": "ethereum.homestead.vm.Message.should_transfer_value", "specifier": 0, "path": "src/ethereum/homestead/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["should_transfer_value"]}}, {"source": {"identifier": "ethereum.homestead.vm.Evm", "specifier": 0, "path": "src/ethereum/homestead/vm/__init__.py"}, "content": {"type": ["class"], "name": ["Evm"], "text": ["The internal state of the virtual machine."]}}, {"source": {"identifier": "ethereum.homestead.vm.Evm.pc", "specifier": 0, "path": "src/ethereum/homestead/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["pc"]}}, {"source": {"identifier": "ethereum.homestead.vm.Evm.stack", "specifier": 0, "path": "src/ethereum/homestead/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["stack"]}}, {"source": {"identifier": "ethereum.homestead.vm.Evm.memory", "specifier": 0, "path": "src/ethereum/homestead/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["memory"]}}, {"source": {"identifier": "ethereum.homestead.vm.Evm.code", "specifier": 0, "path": "src/ethereum/homestead/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["code"]}}, {"source": {"identifier": "ethereum.homestead.vm.Evm.gas_left", "specifier": 0, "path": "src/ethereum/homestead/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["gas_left"]}}, {"source": {"identifier": "ethereum.homestead.vm.Evm.env", "specifier": 0, "path": "src/ethereum/homestead/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["env"]}}, {"source": {"identifier": "ethereum.homestead.vm.Evm.valid_jump_destinations", "specifier": 0, "path": "src/ethereum/homestead/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["valid_jump_destinations"]}}, {"source": {"identifier": "ethereum.homestead.vm.Evm.logs", "specifier": 0, "path": "src/ethereum/homestead/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["logs"]}}, {"source": {"identifier": "ethereum.homestead.vm.Evm.refund_counter", "specifier": 0, "path": "src/ethereum/homestead/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["refund_counter"]}}, {"source": {"identifier": "ethereum.homestead.vm.Evm.running", "specifier": 0, "path": "src/ethereum/homestead/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["running"]}}, {"source": {"identifier": "ethereum.homestead.vm.Evm.message", "specifier": 0, "path": "src/ethereum/homestead/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["message"]}}, {"source": {"identifier": "ethereum.homestead.vm.Evm.output", "specifier": 0, "path": "src/ethereum/homestead/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["output"]}}, {"source": {"identifier": "ethereum.homestead.vm.Evm.accounts_to_delete", "specifier": 0, "path": "src/ethereum/homestead/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["accounts_to_delete"]}}, {"source": {"identifier": "ethereum.homestead.vm.Evm.has_erred", "specifier": 0, "path": "src/ethereum/homestead/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["has_erred"]}}, {"source": {"identifier": "ethereum.homestead.vm.incorporate_child_on_success", "specifier": 0, "path": "src/ethereum/homestead/vm/__init__.py"}, "content": {"type": ["function"], "name": ["incorporate_child_on_success"], "text": ["Incorporate the state of a successful  child_evm  into the parent  evm . Parameters evm : The parent  EVM . child_evm : The child evm to incorporate."]}}, {"source": {"identifier": "ethereum.homestead.vm.incorporate_child_on_error", "specifier": 0, "path": "src/ethereum/homestead/vm/__init__.py"}, "content": {"type": ["function"], "name": ["incorporate_child_on_error"], "text": ["Incorporate the state of an unsuccessful  child_evm  into the parent  evm . Parameters evm : The parent  EVM . child_evm : The child evm to incorporate."]}}, {"source": {"identifier": "ethereum.paris.fork_types", "specifier": 0, "path": "src/ethereum/paris/fork_types.py"}, "content": {"type": ["module"], "name": ["ethereum.paris.fork_types"], "text": ["Ethereum Types ^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Types re-used throughout the specification, which are specific to Ethereum."]}}, {"source": {"identifier": "ethereum.paris.fork_types.Address", "specifier": 0, "path": "src/ethereum/paris/fork_types.py"}, "content": {"type": ["attribute"], "name": ["Address"]}}, {"source": {"identifier": "ethereum.paris.fork_types.Root", "specifier": 0, "path": "src/ethereum/paris/fork_types.py"}, "content": {"type": ["attribute"], "name": ["Root"]}}, {"source": {"identifier": "ethereum.paris.fork_types.Bloom", "specifier": 0, "path": "src/ethereum/paris/fork_types.py"}, "content": {"type": ["attribute"], "name": ["Bloom"]}}, {"source": {"identifier": "ethereum.paris.fork_types.TX_BASE_COST", "specifier": 0, "path": "src/ethereum/paris/fork_types.py"}, "content": {"type": ["attribute"], "name": ["TX_BASE_COST"]}}, {"source": {"identifier": "ethereum.paris.fork_types.TX_DATA_COST_PER_NON_ZERO", "specifier": 0, "path": "src/ethereum/paris/fork_types.py"}, "content": {"type": ["attribute"], "name": ["TX_DATA_COST_PER_NON_ZERO"]}}, {"source": {"identifier": "ethereum.paris.fork_types.TX_DATA_COST_PER_ZERO", "specifier": 0, "path": "src/ethereum/paris/fork_types.py"}, "content": {"type": ["attribute"], "name": ["TX_DATA_COST_PER_ZERO"]}}, {"source": {"identifier": "ethereum.paris.fork_types.TX_CREATE_COST", "specifier": 0, "path": "src/ethereum/paris/fork_types.py"}, "content": {"type": ["attribute"], "name": ["TX_CREATE_COST"]}}, {"source": {"identifier": "ethereum.paris.fork_types.TX_ACCESS_LIST_ADDRESS_COST", "specifier": 0, "path": "src/ethereum/paris/fork_types.py"}, "content": {"type": ["attribute"], "name": ["TX_ACCESS_LIST_ADDRESS_COST"]}}, {"source": {"identifier": "ethereum.paris.fork_types.TX_ACCESS_LIST_STORAGE_KEY_COST", "specifier": 0, "path": "src/ethereum/paris/fork_types.py"}, "content": {"type": ["attribute"], "name": ["TX_ACCESS_LIST_STORAGE_KEY_COST"]}}, {"source": {"identifier": "ethereum.paris.fork_types.LegacyTransaction", "specifier": 0, "path": "src/ethereum/paris/fork_types.py"}, "content": {"type": ["class"], "name": ["LegacyTransaction"], "text": ["Atomic operation performed on the block chain."]}}, {"source": {"identifier": "ethereum.paris.fork_types.LegacyTransaction.nonce", "specifier": 0, "path": "src/ethereum/paris/fork_types.py"}, "content": {"type": ["attribute"], "name": ["nonce"]}}, {"source": {"identifier": "ethereum.paris.fork_types.LegacyTransaction.gas_price", "specifier": 0, "path": "src/ethereum/paris/fork_types.py"}, "content": {"type": ["attribute"], "name": ["gas_price"]}}, {"source": {"identifier": "ethereum.paris.fork_types.LegacyTransaction.gas", "specifier": 0, "path": "src/ethereum/paris/fork_types.py"}, "content": {"type": ["attribute"], "name": ["gas"]}}, {"source": {"identifier": "ethereum.paris.fork_types.LegacyTransaction.to", "specifier": 0, "path": "src/ethereum/paris/fork_types.py"}, "content": {"type": ["attribute"], "name": ["to"]}}, {"source": {"identifier": "ethereum.paris.fork_types.LegacyTransaction.value", "specifier": 0, "path": "src/ethereum/paris/fork_types.py"}, "content": {"type": ["attribute"], "name": ["value"]}}, {"source": {"identifier": "ethereum.paris.fork_types.LegacyTransaction.data", "specifier": 0, "path": "src/ethereum/paris/fork_types.py"}, "content": {"type": ["attribute"], "name": ["data"]}}, {"source": {"identifier": "ethereum.paris.fork_types.LegacyTransaction.v", "specifier": 0, "path": "src/ethereum/paris/fork_types.py"}, "content": {"type": ["attribute"], "name": ["v"]}}, {"source": {"identifier": "ethereum.paris.fork_types.LegacyTransaction.r", "specifier": 0, "path": "src/ethereum/paris/fork_types.py"}, "content": {"type": ["attribute"], "name": ["r"]}}, {"source": {"identifier": "ethereum.paris.fork_types.LegacyTransaction.s", "specifier": 0, "path": "src/ethereum/paris/fork_types.py"}, "content": {"type": ["attribute"], "name": ["s"]}}, {"source": {"identifier": "ethereum.paris.fork_types.AccessListTransaction", "specifier": 0, "path": "src/ethereum/paris/fork_types.py"}, "content": {"type": ["class"], "name": ["AccessListTransaction"], "text": ["The transaction type added in EIP-2930 to support access lists."]}}, {"source": {"identifier": "ethereum.paris.fork_types.AccessListTransaction.chain_id", "specifier": 0, "path": "src/ethereum/paris/fork_types.py"}, "content": {"type": ["attribute"], "name": ["chain_id"]}}, {"source": {"identifier": "ethereum.paris.fork_types.AccessListTransaction.nonce", "specifier": 0, "path": "src/ethereum/paris/fork_types.py"}, "content": {"type": ["attribute"], "name": ["nonce"]}}, {"source": {"identifier": "ethereum.paris.fork_types.AccessListTransaction.gas_price", "specifier": 0, "path": "src/ethereum/paris/fork_types.py"}, "content": {"type": ["attribute"], "name": ["gas_price"]}}, {"source": {"identifier": "ethereum.paris.fork_types.AccessListTransaction.gas", "specifier": 0, "path": "src/ethereum/paris/fork_types.py"}, "content": {"type": ["attribute"], "name": ["gas"]}}, {"source": {"identifier": "ethereum.paris.fork_types.AccessListTransaction.to", "specifier": 0, "path": "src/ethereum/paris/fork_types.py"}, "content": {"type": ["attribute"], "name": ["to"]}}, {"source": {"identifier": "ethereum.paris.fork_types.AccessListTransaction.value", "specifier": 0, "path": "src/ethereum/paris/fork_types.py"}, "content": {"type": ["attribute"], "name": ["value"]}}, {"source": {"identifier": "ethereum.paris.fork_types.AccessListTransaction.data", "specifier": 0, "path": "src/ethereum/paris/fork_types.py"}, "content": {"type": ["attribute"], "name": ["data"]}}, {"source": {"identifier": "ethereum.paris.fork_types.AccessListTransaction.access_list", "specifier": 0, "path": "src/ethereum/paris/fork_types.py"}, "content": {"type": ["attribute"], "name": ["access_list"]}}, {"source": {"identifier": "ethereum.paris.fork_types.AccessListTransaction.v", "specifier": 0, "path": "src/ethereum/paris/fork_types.py"}, "content": {"type": ["attribute"], "name": ["v"]}}, {"source": {"identifier": "ethereum.paris.fork_types.AccessListTransaction.r", "specifier": 0, "path": "src/ethereum/paris/fork_types.py"}, "content": {"type": ["attribute"], "name": ["r"]}}, {"source": {"identifier": "ethereum.paris.fork_types.AccessListTransaction.s", "specifier": 0, "path": "src/ethereum/paris/fork_types.py"}, "content": {"type": ["attribute"], "name": ["s"]}}, {"source": {"identifier": "ethereum.paris.fork_types.FeeMarketTransaction", "specifier": 0, "path": "src/ethereum/paris/fork_types.py"}, "content": {"type": ["class"], "name": ["FeeMarketTransaction"], "text": ["The transaction type added in EIP-1559."]}}, {"source": {"identifier": "ethereum.paris.fork_types.FeeMarketTransaction.chain_id", "specifier": 0, "path": "src/ethereum/paris/fork_types.py"}, "content": {"type": ["attribute"], "name": ["chain_id"]}}, {"source": {"identifier": "ethereum.paris.fork_types.FeeMarketTransaction.nonce", "specifier": 0, "path": "src/ethereum/paris/fork_types.py"}, "content": {"type": ["attribute"], "name": ["nonce"]}}, {"source": {"identifier": "ethereum.paris.fork_types.FeeMarketTransaction.max_priority_fee_per_gas", "specifier": 0, "path": "src/ethereum/paris/fork_types.py"}, "content": {"type": ["attribute"], "name": ["max_priority_fee_per_gas"]}}, {"source": {"identifier": "ethereum.paris.fork_types.FeeMarketTransaction.max_fee_per_gas", "specifier": 0, "path": "src/ethereum/paris/fork_types.py"}, "content": {"type": ["attribute"], "name": ["max_fee_per_gas"]}}, {"source": {"identifier": "ethereum.paris.fork_types.FeeMarketTransaction.gas", "specifier": 0, "path": "src/ethereum/paris/fork_types.py"}, "content": {"type": ["attribute"], "name": ["gas"]}}, {"source": {"identifier": "ethereum.paris.fork_types.FeeMarketTransaction.to", "specifier": 0, "path": "src/ethereum/paris/fork_types.py"}, "content": {"type": ["attribute"], "name": ["to"]}}, {"source": {"identifier": "ethereum.paris.fork_types.FeeMarketTransaction.value", "specifier": 0, "path": "src/ethereum/paris/fork_types.py"}, "content": {"type": ["attribute"], "name": ["value"]}}, {"source": {"identifier": "ethereum.paris.fork_types.FeeMarketTransaction.data", "specifier": 0, "path": "src/ethereum/paris/fork_types.py"}, "content": {"type": ["attribute"], "name": ["data"]}}, {"source": {"identifier": "ethereum.paris.fork_types.FeeMarketTransaction.access_list", "specifier": 0, "path": "src/ethereum/paris/fork_types.py"}, "content": {"type": ["attribute"], "name": ["access_list"]}}, {"source": {"identifier": "ethereum.paris.fork_types.FeeMarketTransaction.v", "specifier": 0, "path": "src/ethereum/paris/fork_types.py"}, "content": {"type": ["attribute"], "name": ["v"]}}, {"source": {"identifier": "ethereum.paris.fork_types.FeeMarketTransaction.r", "specifier": 0, "path": "src/ethereum/paris/fork_types.py"}, "content": {"type": ["attribute"], "name": ["r"]}}, {"source": {"identifier": "ethereum.paris.fork_types.FeeMarketTransaction.s", "specifier": 0, "path": "src/ethereum/paris/fork_types.py"}, "content": {"type": ["attribute"], "name": ["s"]}}, {"source": {"identifier": "ethereum.paris.fork_types.Transaction", "specifier": 0, "path": "src/ethereum/paris/fork_types.py"}, "content": {"type": ["attribute"], "name": ["Transaction"]}}, {"source": {"identifier": "ethereum.paris.fork_types.encode_transaction", "specifier": 0, "path": "src/ethereum/paris/fork_types.py"}, "content": {"type": ["function"], "name": ["encode_transaction"], "text": ["Encode a transaction. Needed because non-legacy transactions aren't RLP."]}}, {"source": {"identifier": "ethereum.paris.fork_types.decode_transaction", "specifier": 0, "path": "src/ethereum/paris/fork_types.py"}, "content": {"type": ["function"], "name": ["decode_transaction"], "text": ["Decode a transaction. Needed because non-legacy transactions aren't RLP."]}}, {"source": {"identifier": "ethereum.paris.fork_types.Account", "specifier": 0, "path": "src/ethereum/paris/fork_types.py"}, "content": {"type": ["class"], "name": ["Account"], "text": ["State associated with an address."]}}, {"source": {"identifier": "ethereum.paris.fork_types.Account.nonce", "specifier": 0, "path": "src/ethereum/paris/fork_types.py"}, "content": {"type": ["attribute"], "name": ["nonce"]}}, {"source": {"identifier": "ethereum.paris.fork_types.Account.balance", "specifier": 0, "path": "src/ethereum/paris/fork_types.py"}, "content": {"type": ["attribute"], "name": ["balance"]}}, {"source": {"identifier": "ethereum.paris.fork_types.Account.code", "specifier": 0, "path": "src/ethereum/paris/fork_types.py"}, "content": {"type": ["attribute"], "name": ["code"]}}, {"source": {"identifier": "ethereum.paris.fork_types.EMPTY_ACCOUNT", "specifier": 0, "path": "src/ethereum/paris/fork_types.py"}, "content": {"type": ["attribute"], "name": ["EMPTY_ACCOUNT"]}}, {"source": {"identifier": "ethereum.paris.fork_types.encode_account", "specifier": 0, "path": "src/ethereum/paris/fork_types.py"}, "content": {"type": ["function"], "name": ["encode_account"], "text": ["Encode  Account  dataclass. Storage is not stored in the  Account  dataclass, so  Accounts  cannot be encoded with providing a storage root."]}}, {"source": {"identifier": "ethereum.paris.fork_types.Header", "specifier": 0, "path": "src/ethereum/paris/fork_types.py"}, "content": {"type": ["class"], "name": ["Header"], "text": ["Header portion of a block on the chain."]}}, {"source": {"identifier": "ethereum.paris.fork_types.Header.parent_hash", "specifier": 0, "path": "src/ethereum/paris/fork_types.py"}, "content": {"type": ["attribute"], "name": ["parent_hash"]}}, {"source": {"identifier": "ethereum.paris.fork_types.Header.ommers_hash", "specifier": 0, "path": "src/ethereum/paris/fork_types.py"}, "content": {"type": ["attribute"], "name": ["ommers_hash"]}}, {"source": {"identifier": "ethereum.paris.fork_types.Header.coinbase", "specifier": 0, "path": "src/ethereum/paris/fork_types.py"}, "content": {"type": ["attribute"], "name": ["coinbase"]}}, {"source": {"identifier": "ethereum.paris.fork_types.Header.state_root", "specifier": 0, "path": "src/ethereum/paris/fork_types.py"}, "content": {"type": ["attribute"], "name": ["state_root"]}}, {"source": {"identifier": "ethereum.paris.fork_types.Header.transactions_root", "specifier": 0, "path": "src/ethereum/paris/fork_types.py"}, "content": {"type": ["attribute"], "name": ["transactions_root"]}}, {"source": {"identifier": "ethereum.paris.fork_types.Header.receipt_root", "specifier": 0, "path": "src/ethereum/paris/fork_types.py"}, "content": {"type": ["attribute"], "name": ["receipt_root"]}}, {"source": {"identifier": "ethereum.paris.fork_types.Header.bloom", "specifier": 0, "path": "src/ethereum/paris/fork_types.py"}, "content": {"type": ["attribute"], "name": ["bloom"]}}, {"source": {"identifier": "ethereum.paris.fork_types.Header.difficulty", "specifier": 0, "path": "src/ethereum/paris/fork_types.py"}, "content": {"type": ["attribute"], "name": ["difficulty"]}}, {"source": {"identifier": "ethereum.paris.fork_types.Header.number", "specifier": 0, "path": "src/ethereum/paris/fork_types.py"}, "content": {"type": ["attribute"], "name": ["number"]}}, {"source": {"identifier": "ethereum.paris.fork_types.Header.gas_limit", "specifier": 0, "path": "src/ethereum/paris/fork_types.py"}, "content": {"type": ["attribute"], "name": ["gas_limit"]}}, {"source": {"identifier": "ethereum.paris.fork_types.Header.gas_used", "specifier": 0, "path": "src/ethereum/paris/fork_types.py"}, "content": {"type": ["attribute"], "name": ["gas_used"]}}, {"source": {"identifier": "ethereum.paris.fork_types.Header.timestamp", "specifier": 0, "path": "src/ethereum/paris/fork_types.py"}, "content": {"type": ["attribute"], "name": ["timestamp"]}}, {"source": {"identifier": "ethereum.paris.fork_types.Header.extra_data", "specifier": 0, "path": "src/ethereum/paris/fork_types.py"}, "content": {"type": ["attribute"], "name": ["extra_data"]}}, {"source": {"identifier": "ethereum.paris.fork_types.Header.prev_randao", "specifier": 0, "path": "src/ethereum/paris/fork_types.py"}, "content": {"type": ["attribute"], "name": ["prev_randao"]}}, {"source": {"identifier": "ethereum.paris.fork_types.Header.nonce", "specifier": 0, "path": "src/ethereum/paris/fork_types.py"}, "content": {"type": ["attribute"], "name": ["nonce"]}}, {"source": {"identifier": "ethereum.paris.fork_types.Header.base_fee_per_gas", "specifier": 0, "path": "src/ethereum/paris/fork_types.py"}, "content": {"type": ["attribute"], "name": ["base_fee_per_gas"]}}, {"source": {"identifier": "ethereum.paris.fork_types.Block", "specifier": 0, "path": "src/ethereum/paris/fork_types.py"}, "content": {"type": ["class"], "name": ["Block"], "text": ["A complete block."]}}, {"source": {"identifier": "ethereum.paris.fork_types.Block.header", "specifier": 0, "path": "src/ethereum/paris/fork_types.py"}, "content": {"type": ["attribute"], "name": ["header"]}}, {"source": {"identifier": "ethereum.paris.fork_types.Block.transactions", "specifier": 0, "path": "src/ethereum/paris/fork_types.py"}, "content": {"type": ["attribute"], "name": ["transactions"]}}, {"source": {"identifier": "ethereum.paris.fork_types.Block.ommers", "specifier": 0, "path": "src/ethereum/paris/fork_types.py"}, "content": {"type": ["attribute"], "name": ["ommers"]}}, {"source": {"identifier": "ethereum.paris.fork_types.Log", "specifier": 0, "path": "src/ethereum/paris/fork_types.py"}, "content": {"type": ["class"], "name": ["Log"], "text": ["Data record produced during the execution of a transaction."]}}, {"source": {"identifier": "ethereum.paris.fork_types.Log.address", "specifier": 0, "path": "src/ethereum/paris/fork_types.py"}, "content": {"type": ["attribute"], "name": ["address"]}}, {"source": {"identifier": "ethereum.paris.fork_types.Log.topics", "specifier": 0, "path": "src/ethereum/paris/fork_types.py"}, "content": {"type": ["attribute"], "name": ["topics"]}}, {"source": {"identifier": "ethereum.paris.fork_types.Log.data", "specifier": 0, "path": "src/ethereum/paris/fork_types.py"}, "content": {"type": ["attribute"], "name": ["data"]}}, {"source": {"identifier": "ethereum.paris.fork_types.Receipt", "specifier": 0, "path": "src/ethereum/paris/fork_types.py"}, "content": {"type": ["class"], "name": ["Receipt"], "text": ["Result of a transaction."]}}, {"source": {"identifier": "ethereum.paris.fork_types.Receipt.succeeded", "specifier": 0, "path": "src/ethereum/paris/fork_types.py"}, "content": {"type": ["attribute"], "name": ["succeeded"]}}, {"source": {"identifier": "ethereum.paris.fork_types.Receipt.cumulative_gas_used", "specifier": 0, "path": "src/ethereum/paris/fork_types.py"}, "content": {"type": ["attribute"], "name": ["cumulative_gas_used"]}}, {"source": {"identifier": "ethereum.paris.fork_types.Receipt.bloom", "specifier": 0, "path": "src/ethereum/paris/fork_types.py"}, "content": {"type": ["attribute"], "name": ["bloom"]}}, {"source": {"identifier": "ethereum.paris.fork_types.Receipt.logs", "specifier": 0, "path": "src/ethereum/paris/fork_types.py"}, "content": {"type": ["attribute"], "name": ["logs"]}}, {"source": {"identifier": "ethereum.homestead.vm.runtime", "specifier": 0, "path": "src/ethereum/homestead/vm/runtime.py"}, "content": {"type": ["module"], "name": ["ethereum.homestead.vm.runtime"], "text": ["Ethereum Virtual Machine (EVM) Runtime Operations ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Runtime related operations used while executing EVM code."]}}, {"source": {"identifier": "ethereum.homestead.vm.runtime.get_valid_jump_destinations", "specifier": 0, "path": "src/ethereum/homestead/vm/runtime.py"}, "content": {"type": ["function"], "name": ["get_valid_jump_destinations"], "text": ["Analyze the evm code to obtain the set of valid jump destinations. Valid jump destinations are defined as follows: * The jump destination is less than the length of the code. * The jump destination should have the  JUMPDEST  opcode (0x5B). * The jump destination shouldn't be part of the data corresponding to PUSH-N  opcodes. Note - Jump destinations are 0-indexed. Parameters code : The EVM code which is to be executed. Returns valid_jump_destinations:  Set[Uint] The set of valid jump destinations in the code."]}}, {"source": {"identifier": "ethereum.paris.trie", "specifier": 0, "path": "src/ethereum/paris/trie.py"}, "content": {"type": ["module"], "name": ["ethereum.paris.trie"], "text": ["State Trie ^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction The state trie is the structure responsible for storing .fork_types.Account  objects."]}}, {"source": {"identifier": "ethereum.paris.trie.EMPTY_TRIE_ROOT", "specifier": 0, "path": "src/ethereum/paris/trie.py"}, "content": {"type": ["attribute"], "name": ["EMPTY_TRIE_ROOT"]}}, {"source": {"identifier": "ethereum.paris.trie.Node", "specifier": 0, "path": "src/ethereum/paris/trie.py"}, "content": {"type": ["attribute"], "name": ["Node"]}}, {"source": {"identifier": "ethereum.paris.trie.K", "specifier": 0, "path": "src/ethereum/paris/trie.py"}, "content": {"type": ["attribute"], "name": ["K"]}}, {"source": {"identifier": "ethereum.paris.trie.V", "specifier": 0, "path": "src/ethereum/paris/trie.py"}, "content": {"type": ["attribute"], "name": ["V"]}}, {"source": {"identifier": "ethereum.paris.trie.LeafNode", "specifier": 0, "path": "src/ethereum/paris/trie.py"}, "content": {"type": ["class"], "name": ["LeafNode"], "text": ["Leaf node in the Merkle Trie"]}}, {"source": {"identifier": "ethereum.paris.trie.LeafNode.rest_of_key", "specifier": 0, "path": "src/ethereum/paris/trie.py"}, "content": {"type": ["attribute"], "name": ["rest_of_key"]}}, {"source": {"identifier": "ethereum.paris.trie.LeafNode.value", "specifier": 0, "path": "src/ethereum/paris/trie.py"}, "content": {"type": ["attribute"], "name": ["value"]}}, {"source": {"identifier": "ethereum.paris.trie.ExtensionNode", "specifier": 0, "path": "src/ethereum/paris/trie.py"}, "content": {"type": ["class"], "name": ["ExtensionNode"], "text": ["Extension node in the Merkle Trie"]}}, {"source": {"identifier": "ethereum.paris.trie.ExtensionNode.key_segment", "specifier": 0, "path": "src/ethereum/paris/trie.py"}, "content": {"type": ["attribute"], "name": ["key_segment"]}}, {"source": {"identifier": "ethereum.paris.trie.ExtensionNode.subnode", "specifier": 0, "path": "src/ethereum/paris/trie.py"}, "content": {"type": ["attribute"], "name": ["subnode"]}}, {"source": {"identifier": "ethereum.paris.trie.BranchNode", "specifier": 0, "path": "src/ethereum/paris/trie.py"}, "content": {"type": ["class"], "name": ["BranchNode"], "text": ["Branch node in the Merkle Trie"]}}, {"source": {"identifier": "ethereum.paris.trie.BranchNode.subnodes", "specifier": 0, "path": "src/ethereum/paris/trie.py"}, "content": {"type": ["attribute"], "name": ["subnodes"]}}, {"source": {"identifier": "ethereum.paris.trie.BranchNode.value", "specifier": 0, "path": "src/ethereum/paris/trie.py"}, "content": {"type": ["attribute"], "name": ["value"]}}, {"source": {"identifier": "ethereum.paris.trie.InternalNode", "specifier": 0, "path": "src/ethereum/paris/trie.py"}, "content": {"type": ["attribute"], "name": ["InternalNode"]}}, {"source": {"identifier": "ethereum.paris.trie.encode_internal_node", "specifier": 0, "path": "src/ethereum/paris/trie.py"}, "content": {"type": ["function"], "name": ["encode_internal_node"], "text": ["Encodes a Merkle Trie node into its RLP form. The RLP will then be serialized into a  Bytes  and hashed unless it is less that 32 bytes when serialized. This function also accepts  None , representing the absence of a node, which is encoded to  b\"\" . Parameters node : Optional[InternalNode] The node to encode. Returns encoded :  rlp.RLP The node encoded as RLP."]}}, {"source": {"identifier": "ethereum.paris.trie.encode_node", "specifier": 0, "path": "src/ethereum/paris/trie.py"}, "content": {"type": ["function"], "name": ["encode_node"], "text": ["Encode a Node for storage in the Merkle Trie. Currently mostly an unimplemented stub."]}}, {"source": {"identifier": "ethereum.paris.trie.Trie", "specifier": 0, "path": "src/ethereum/paris/trie.py"}, "content": {"type": ["class"], "name": ["Trie"], "text": ["The Merkle Trie."]}}, {"source": {"identifier": "ethereum.paris.trie.Trie.secured", "specifier": 0, "path": "src/ethereum/paris/trie.py"}, "content": {"type": ["attribute"], "name": ["secured"]}}, {"source": {"identifier": "ethereum.paris.trie.Trie.default", "specifier": 0, "path": "src/ethereum/paris/trie.py"}, "content": {"type": ["attribute"], "name": ["default"]}}, {"source": {"identifier": "ethereum.paris.trie.Trie._data", "specifier": 0, "path": "src/ethereum/paris/trie.py"}, "content": {"type": ["attribute"], "name": ["_data"]}}, {"source": {"identifier": "ethereum.paris.trie.copy_trie", "specifier": 0, "path": "src/ethereum/paris/trie.py"}, "content": {"type": ["function"], "name": ["copy_trie"], "text": ["Create a copy of  trie . Since only frozen objects may be stored in tries, the contents are reused. Parameters trie:  Trie Trie to copy. Returns new_trie :  Trie[K, V] A copy of the trie."]}}, {"source": {"identifier": "ethereum.paris.trie.trie_set", "specifier": 0, "path": "src/ethereum/paris/trie.py"}, "content": {"type": ["function"], "name": ["trie_set"], "text": ["Stores an item in a Merkle Trie. This method deletes the key if  value == trie.default , because the Merkle Trie represents the default value by omitting it from the trie. Parameters trie:  Trie Trie to store in. key :  Bytes Key to lookup. value :  V Node to insert at  key ."]}}, {"source": {"identifier": "ethereum.paris.trie.trie_get", "specifier": 0, "path": "src/ethereum/paris/trie.py"}, "content": {"type": ["function"], "name": ["trie_get"], "text": ["Gets an item from the Merkle Trie. This method returns  trie.default  if the key is missing. Parameters trie: Trie to lookup in. key : Key to lookup. Returns node :  V Node at  key  in the trie."]}}, {"source": {"identifier": "ethereum.paris.trie.common_prefix_length", "specifier": 0, "path": "src/ethereum/paris/trie.py"}, "content": {"type": ["function"], "name": ["common_prefix_length"], "text": ["Find the longest common prefix of two sequences."]}}, {"source": {"identifier": "ethereum.paris.trie.nibble_list_to_compact", "specifier": 0, "path": "src/ethereum/paris/trie.py"}, "content": {"type": ["function"], "name": ["nibble_list_to_compact"], "text": ["Compresses nibble-list into a standard byte array with a flag. A nibble-list is a list of byte values no greater than  15 . The flag is encoded in high nibble of the highest byte. The flag nibble can be broken down into two two-bit flags. Highest nibble:: +---+---+----------+--------+\n| _ | _ | is_leaf | parity |\n+---+---+----------+--------+\n  3   2      1         0\n The lowest bit of the nibble encodes the parity of the length of the remaining nibbles --  0  when even and  1  when odd. The second lowest bit is used to distinguish leaf and extension nodes. The other two bits are not used. Parameters x : Array of nibbles. is_leaf : True if this is part of a leaf node, or false if it is an extension node. Returns compressed :  bytearray Compact byte array."]}}, {"source": {"identifier": "ethereum.paris.trie.bytes_to_nibble_list", "specifier": 0, "path": "src/ethereum/paris/trie.py"}, "content": {"type": ["function"], "name": ["bytes_to_nibble_list"], "text": ["Converts a  Bytes  into to a sequence of nibbles (bytes with value < 16). Parameters bytes_: The  Bytes  to convert. Returns nibble_list :  Bytes The  Bytes  in nibble-list format."]}}, {"source": {"identifier": "ethereum.paris.trie._prepare_trie", "specifier": 0, "path": "src/ethereum/paris/trie.py"}, "content": {"type": ["function"], "name": ["_prepare_trie"], "text": ["Prepares the trie for root calculation. Removes values that are empty, hashes the keys (if  secured == True ) and encodes all the nodes. Parameters trie : The  Trie  to prepare. get_storage_root : Function to get the storage root of an account. Needed to encode Account  objects. Returns out :  Mapping[ethereum.base_types.Bytes, Node] Object with keys mapped to nibble-byte form."]}}, {"source": {"identifier": "ethereum.paris.trie.root", "specifier": 0, "path": "src/ethereum/paris/trie.py"}, "content": {"type": ["function"], "name": ["root"], "text": ["Computes the root of a modified merkle patricia trie (MPT). Parameters trie : Trie  to get the root of. get_storage_root : Function to get the storage root of an account. Needed to encode Account  objects. Returns root :  .fork_types.Root MPT root of the underlying key-value pairs."]}}, {"source": {"identifier": "ethereum.paris.trie.patricialize", "specifier": 0, "path": "src/ethereum/paris/trie.py"}, "content": {"type": ["function"], "name": ["patricialize"], "text": ["Structural composition function. Used to recursively patricialize and merkleize a dictionary. Includes memoization of the tree structure and hashes. Parameters obj : Underlying trie key-value pairs, with keys in nibble-list format. level : Current trie level. Returns node :  ethereum.base_types.Bytes Root node of  obj ."]}}, {"source": {"identifier": "ethereum.paris.fork", "specifier": 0, "path": "src/ethereum/paris/fork.py"}, "content": {"type": ["module"], "name": ["ethereum.paris.fork"], "text": ["Ethereum Specification ^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Entry point for the Ethereum specification."]}}, {"source": {"identifier": "ethereum.paris.fork.BASE_FEE_MAX_CHANGE_DENOMINATOR", "specifier": 0, "path": "src/ethereum/paris/fork.py"}, "content": {"type": ["attribute"], "name": ["BASE_FEE_MAX_CHANGE_DENOMINATOR"]}}, {"source": {"identifier": "ethereum.paris.fork.ELASTICITY_MULTIPLIER", "specifier": 0, "path": "src/ethereum/paris/fork.py"}, "content": {"type": ["attribute"], "name": ["ELASTICITY_MULTIPLIER"]}}, {"source": {"identifier": "ethereum.paris.fork.GAS_LIMIT_ADJUSTMENT_FACTOR", "specifier": 0, "path": "src/ethereum/paris/fork.py"}, "content": {"type": ["attribute"], "name": ["GAS_LIMIT_ADJUSTMENT_FACTOR"]}}, {"source": {"identifier": "ethereum.paris.fork.GAS_LIMIT_MINIMUM", "specifier": 0, "path": "src/ethereum/paris/fork.py"}, "content": {"type": ["attribute"], "name": ["GAS_LIMIT_MINIMUM"]}}, {"source": {"identifier": "ethereum.paris.fork.EMPTY_OMMER_HASH", "specifier": 0, "path": "src/ethereum/paris/fork.py"}, "content": {"type": ["attribute"], "name": ["EMPTY_OMMER_HASH"]}}, {"source": {"identifier": "ethereum.paris.fork.BlockChain", "specifier": 0, "path": "src/ethereum/paris/fork.py"}, "content": {"type": ["class"], "name": ["BlockChain"], "text": ["History and current state of the block chain."]}}, {"source": {"identifier": "ethereum.paris.fork.BlockChain.blocks", "specifier": 0, "path": "src/ethereum/paris/fork.py"}, "content": {"type": ["attribute"], "name": ["blocks"]}}, {"source": {"identifier": "ethereum.paris.fork.BlockChain.state", "specifier": 0, "path": "src/ethereum/paris/fork.py"}, "content": {"type": ["attribute"], "name": ["state"]}}, {"source": {"identifier": "ethereum.paris.fork.BlockChain.chain_id", "specifier": 0, "path": "src/ethereum/paris/fork.py"}, "content": {"type": ["attribute"], "name": ["chain_id"]}}, {"source": {"identifier": "ethereum.paris.fork.apply_fork", "specifier": 0, "path": "src/ethereum/paris/fork.py"}, "content": {"type": ["function"], "name": ["apply_fork"], "text": ["Transforms the state from the previous hard fork ( old ) into the block chain object for this hard fork and returns it. When forks need to implement an irregular state transition, this function is used to handle the irregularity. See the :ref: DAO Fork <dao-fork>  for an example. Parameters old : Previous block chain object. Returns new :  BlockChain Upgraded block chain object for this hard fork."]}}, {"source": {"identifier": "ethereum.paris.fork.get_last_256_block_hashes", "specifier": 0, "path": "src/ethereum/paris/fork.py"}, "content": {"type": ["function"], "name": ["get_last_256_block_hashes"], "text": ["Obtain the list of hashes of the previous 256 blocks in order of increasing block number. This function will return less hashes for the first 256 blocks. The  BLOCKHASH  opcode needs to access the latest hashes on the chain, therefore this function retrieves them. Parameters chain : History and current state. Returns recent_block_hashes :  List[Hash32] Hashes of the recent 256 blocks in order of increasing block number."]}}, {"source": {"identifier": "ethereum.paris.fork.state_transition", "specifier": 0, "path": "src/ethereum/paris/fork.py"}, "content": {"type": ["function"], "name": ["state_transition"], "text": ["Attempts to apply a block to an existing block chain. All parts of the block's contents need to be verified before being added to the chain. Blocks are verified by ensuring that the contents of the block make logical sense with the contents of the parent block. The information in the block's header must also match the corresponding information in the block. To implement Ethereum, in theory clients are only required to store the most recent 255 blocks of the chain since as far as execution is concerned, only those blocks are accessed. Practically, however, clients should store more blocks to handle reorgs. Parameters chain : History and current state. block : Block to apply to  chain ."]}}, {"source": {"identifier": "ethereum.paris.fork.calculate_base_fee_per_gas", "specifier": 0, "path": "src/ethereum/paris/fork.py"}, "content": {"type": ["function"], "name": ["calculate_base_fee_per_gas"], "text": ["Calculates the base fee per gas for the block. Parameters block_gas_limit : Gas limit of the block for which the base fee is being calculated. parent_gas_limit : Gas limit of the parent block. parent_gas_used : Gas used in the parent block. parent_base_fee_per_gas : Base fee per gas of the parent block. Returns base_fee_per_gas :  Uint Base fee per gas for the block."]}}, {"source": {"identifier": "ethereum.paris.fork.validate_header", "specifier": 0, "path": "src/ethereum/paris/fork.py"}, "content": {"type": ["function"], "name": ["validate_header"], "text": ["Verifies a block header. In order to consider a block's header valid, the logic for the quantities in the header should match the logic for the block itself. For example the header timestamp should be greater than the block's parent timestamp because the block was created  after  the parent block. Additionally, the block's number should be directly folowing the parent block's number since it is the next block in the sequence. Parameters header : Header to check for correctness. parent_header : Parent Header of the header to check for correctness"]}}, {"source": {"identifier": "ethereum.paris.fork.check_transaction", "specifier": 0, "path": "src/ethereum/paris/fork.py"}, "content": {"type": ["function"], "name": ["check_transaction"], "text": ["Check if the transaction is includable in the block. Parameters tx : The transaction. base_fee_per_gas : The block base fee. gas_available : The gas remaining in the block. chain_id : The ID of the current chain. Returns sender_address : The sender of the transaction. effective_gas_price : The price to charge for gas when the transaction is executed. Raises InvalidBlock : If the transaction is not includable."]}}, {"source": {"identifier": "ethereum.paris.fork.make_receipt", "specifier": 0, "path": "src/ethereum/paris/fork.py"}, "content": {"type": ["function"], "name": ["make_receipt"], "text": ["Make the receipt for a transaction that was executed. Parameters tx : The executed transaction. has_erred : Whether the top level frame of the transaction exited with an error. cumulative_gas_used : The total gas used so far in the block after the transaction was executed. logs : The logs produced by the transaction. Returns receipt : The receipt for the transaction."]}}, {"source": {"identifier": "ethereum.paris.fork.apply_body", "specifier": 0, "path": "src/ethereum/paris/fork.py"}, "content": {"type": ["function"], "name": ["apply_body"], "text": ["Executes a block. Many of the contents of a block are stored in data structures called tries. There is a transactions trie which is similar to a ledger of the transactions stored in the current block. There is also a receipts trie which stores the results of executing a transaction, like the post state and gas used. This function creates and executes the block that is to be added to the chain. Parameters state : Current account state. block_hashes : List of hashes of the previous 256 blocks in the order of increasing block number. coinbase : Address of account which receives block reward and transaction fees. block_number : Position of the block within the chain. base_fee_per_gas : Base fee per gas of within the block. block_gas_limit : Initial amount of gas available for execution in this block. block_time : Time the block was produced, measured in seconds since the epoch. prev_randao : The previous randao from the beacon chain. transactions : Transactions included in the block. ommers : Headers of ancestor blocks which are not direct parents (formerly uncles.) chain_id : ID of the executing chain. Returns gas_available :  ethereum.base_types.Uint Remaining gas after all transactions have been executed. transactions_root :  ethereum.fork_types.Root Trie root of all the transactions in the block. receipt_root :  ethereum.fork_types.Root Trie root of all the receipts in the block. block_logs_bloom :  Bloom Logs bloom of all the logs included in all the transactions of the block. state :  ethereum.fork_types.State State after all transactions have been executed."]}}, {"source": {"identifier": "ethereum.paris.fork.process_transaction", "specifier": 0, "path": "src/ethereum/paris/fork.py"}, "content": {"type": ["function"], "name": ["process_transaction"], "text": ["Execute a transaction against the provided environment. This function processes the actions needed to execute a transaction. It decrements the sender's account after calculating the gas fee and refunds them the proper amount after execution. Calling contracts, deploying code, and incrementing nonces are all examples of actions that happen within this function or from a call made within this function. Accounts that are marked for deletion are processed and destroyed after execution. Parameters env : Environment for the Ethereum Virtual Machine. tx : Transaction to execute. Returns gas_left :  ethereum.base_types.U256 Remaining gas after execution. logs :  Tuple[ethereum.fork_types.Log, ...] Logs generated during execution."]}}, {"source": {"identifier": "ethereum.paris.fork.validate_transaction", "specifier": 0, "path": "src/ethereum/paris/fork.py"}, "content": {"type": ["function"], "name": ["validate_transaction"], "text": ["Verifies a transaction. The gas in a transaction gets used to pay for the intrinsic cost of operations, therefore if there is insufficient gas then it would not be possible to execute a transaction and it will be declared invalid. Additionally, the nonce of a transaction must not equal or exceed the limit defined in  EIP-2681 <https://eips.ethereum.org/EIPS/eip-2681> _. In practice, defining the limit as  2**64-1  has no impact because sending  2**64-1  transactions is improbable. It's not strictly impossible though,  2**64-1  transactions is the entire capacity of the Ethereum blockchain at 2022 gas limits for a little over 22 years. Parameters tx : Transaction to validate. Returns verified :  bool True if the transaction can be executed, or False otherwise."]}}, {"source": {"identifier": "ethereum.paris.fork.calculate_intrinsic_cost", "specifier": 0, "path": "src/ethereum/paris/fork.py"}, "content": {"type": ["function"], "name": ["calculate_intrinsic_cost"], "text": ["Calculates the gas that is charged before execution is started. The intrinsic cost of the transaction is charged before execution has begun. Functions/operations in the EVM cost money to execute so this intrinsic cost is for the operations that need to be paid for as part of the transaction. Data transfer, for example, is part of this intrinsic cost. It costs ether to send data over the wire and that ether is accounted for in the intrinsic cost calculated in this function. This intrinsic cost must be calculated and paid for before execution in order for all operations to be implemented. Parameters tx : Transaction to compute the intrinsic cost of. Returns verified :  ethereum.base_types.Uint The intrinsic cost of the transaction."]}}, {"source": {"identifier": "ethereum.paris.fork.recover_sender", "specifier": 0, "path": "src/ethereum/paris/fork.py"}, "content": {"type": ["function"], "name": ["recover_sender"], "text": ["Extracts the sender address from a transaction. The v, r, and s values are the three parts that make up the signature of a transaction. In order to recover the sender of a transaction the two components needed are the signature ( v ,  r , and  s ) and the signing hash of the transaction. The sender's public key can be obtained with these two values and therefore the sender address can be retrieved. Parameters tx : Transaction of interest. chain_id : ID of the executing chain. Returns sender :  ethereum.fork_types.Address The address of the account that signed the transaction."]}}, {"source": {"identifier": "ethereum.paris.fork.signing_hash_pre155", "specifier": 0, "path": "src/ethereum/paris/fork.py"}, "content": {"type": ["function"], "name": ["signing_hash_pre155"], "text": ["Compute the hash of a transaction used in a legacy (pre EIP 155) signature. Parameters tx : Transaction of interest. Returns hash :  ethereum.crypto.hash.Hash32 Hash of the transaction."]}}, {"source": {"identifier": "ethereum.paris.fork.signing_hash_155", "specifier": 0, "path": "src/ethereum/paris/fork.py"}, "content": {"type": ["function"], "name": ["signing_hash_155"], "text": ["Compute the hash of a transaction used in a EIP 155 signature. Parameters tx : Transaction of interest. Returns hash :  ethereum.crypto.hash.Hash32 Hash of the transaction."]}}, {"source": {"identifier": "ethereum.paris.fork.signing_hash_2930", "specifier": 0, "path": "src/ethereum/paris/fork.py"}, "content": {"type": ["function"], "name": ["signing_hash_2930"], "text": ["Compute the hash of a transaction used in a EIP 2930 signature. Parameters tx : Transaction of interest. Returns hash :  ethereum.crypto.hash.Hash32 Hash of the transaction."]}}, {"source": {"identifier": "ethereum.paris.fork.signing_hash_1559", "specifier": 0, "path": "src/ethereum/paris/fork.py"}, "content": {"type": ["function"], "name": ["signing_hash_1559"], "text": ["Compute the hash of a transaction used in a EIP 1559 signature. Parameters tx : Transaction of interest. Returns hash :  ethereum.crypto.hash.Hash32 Hash of the transaction."]}}, {"source": {"identifier": "ethereum.paris.fork.compute_header_hash", "specifier": 0, "path": "src/ethereum/paris/fork.py"}, "content": {"type": ["function"], "name": ["compute_header_hash"], "text": ["Computes the hash of a block header. The header hash of a block is the canonical hash that is used to refer to a specific block and completely distinguishes a block from another. keccak256  is a function that produces a 256 bit hash of any input. It also takes in any number of bytes as an input and produces a single hash for them. A hash is a completely unique output for a single input. So an input corresponds to one unique hash that can be used to identify the input exactly. Prior to using the  keccak256  hash function, the header must be encoded using the Recursive-Length Prefix. See :ref: rlp . RLP encoding the header converts it into a space-efficient format that allows for easy transfer of data between nodes. The purpose of RLP is to encode arbitrarily nested arrays of binary data, and RLP is the primary encoding method used to serialize objects in Ethereum's execution layer. The only purpose of RLP is to encode structure; encoding specific data types (e.g. strings, floats) is left up to higher-order protocols. Parameters header : Header of interest. Returns hash :  ethereum.crypto.hash.Hash32 Hash of the header."]}}, {"source": {"identifier": "ethereum.paris.fork.check_gas_limit", "specifier": 0, "path": "src/ethereum/paris/fork.py"}, "content": {"type": ["function"], "name": ["check_gas_limit"], "text": ["Validates the gas limit for a block. The bounds of the gas limit,  max_adjustment_delta , is set as the quotient of the parent block's gas limit and the GAS_LIMIT_ADJUSTMENT_FACTOR . Therefore, if the gas limit that is passed through as a parameter is greater than or equal to the  sum  of the parent's gas and the adjustment delta then the limit for gas is too high and fails this function's check. Similarly, if the limit is less than or equal to the  difference  of the parent's gas and the adjustment delta  or  the predefined  GAS_LIMIT_MINIMUM  then this function's check fails because the gas limit doesn't allow for a sufficient or reasonable amount of gas to be used on a block. Parameters gas_limit : Gas limit to validate. parent_gas_limit : Gas limit of the parent block. Returns check :  bool True if gas limit constraints are satisfied, False otherwise."]}}, {"source": {"identifier": "ethereum.homestead.vm.interpreter", "specifier": 0, "path": "src/ethereum/homestead/vm/interpreter.py"}, "content": {"type": ["module"], "name": ["ethereum.homestead.vm.interpreter"], "text": ["Ethereum Virtual Machine (EVM) Interpreter ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction A straightforward interpreter that executes EVM code."]}}, {"source": {"identifier": "ethereum.homestead.vm.interpreter.STACK_DEPTH_LIMIT", "specifier": 0, "path": "src/ethereum/homestead/vm/interpreter.py"}, "content": {"type": ["attribute"], "name": ["STACK_DEPTH_LIMIT"]}}, {"source": {"identifier": "ethereum.homestead.vm.interpreter.MessageCallOutput", "specifier": 0, "path": "src/ethereum/homestead/vm/interpreter.py"}, "content": {"type": ["class"], "name": ["MessageCallOutput"], "text": ["Output of a particular message call Contains the following:   1. `gas_left`: remaining gas after execution.\n  2. `refund_counter`: gas to refund after execution.\n  3. `logs`: list of `Log` generated during execution.\n  4. `accounts_to_delete`: Contracts which have self-destructed.\n  5. `has_erred`: True if execution has caused an error.\n"]}}, {"source": {"identifier": "ethereum.homestead.vm.interpreter.MessageCallOutput.gas_left", "specifier": 0, "path": "src/ethereum/homestead/vm/interpreter.py"}, "content": {"type": ["attribute"], "name": ["gas_left"]}}, {"source": {"identifier": "ethereum.homestead.vm.interpreter.MessageCallOutput.refund_counter", "specifier": 0, "path": "src/ethereum/homestead/vm/interpreter.py"}, "content": {"type": ["attribute"], "name": ["refund_counter"]}}, {"source": {"identifier": "ethereum.homestead.vm.interpreter.MessageCallOutput.logs", "specifier": 0, "path": "src/ethereum/homestead/vm/interpreter.py"}, "content": {"type": ["attribute"], "name": ["logs"]}}, {"source": {"identifier": "ethereum.homestead.vm.interpreter.MessageCallOutput.accounts_to_delete", "specifier": 0, "path": "src/ethereum/homestead/vm/interpreter.py"}, "content": {"type": ["attribute"], "name": ["accounts_to_delete"]}}, {"source": {"identifier": "ethereum.homestead.vm.interpreter.MessageCallOutput.has_erred", "specifier": 0, "path": "src/ethereum/homestead/vm/interpreter.py"}, "content": {"type": ["attribute"], "name": ["has_erred"]}}, {"source": {"identifier": "ethereum.homestead.vm.interpreter.process_message_call", "specifier": 0, "path": "src/ethereum/homestead/vm/interpreter.py"}, "content": {"type": ["function"], "name": ["process_message_call"], "text": ["If  message.current  is empty then it creates a smart contract else it executes a call from the  message.caller  to the  message.target . Parameters message : Transaction specific items. env : External items required for EVM execution. Returns output :  MessageCallOutput Output of the message call"]}}, {"source": {"identifier": "ethereum.homestead.vm.interpreter.process_create_message", "specifier": 0, "path": "src/ethereum/homestead/vm/interpreter.py"}, "content": {"type": ["function"], "name": ["process_create_message"], "text": ["Executes a call to create a smart contract. Parameters message : Transaction specific items. env : External items required for EVM execution. Returns evm: :py:class: ~ethereum.homestead.vm.Evm Items containing execution specific objects."]}}, {"source": {"identifier": "ethereum.homestead.vm.interpreter.process_message", "specifier": 0, "path": "src/ethereum/homestead/vm/interpreter.py"}, "content": {"type": ["function"], "name": ["process_message"], "text": ["Executes a call to create a smart contract. Parameters message : Transaction specific items. env : External items required for EVM execution. Returns evm: :py:class: ~ethereum.homestead.vm.Evm Items containing execution specific objects"]}}, {"source": {"identifier": "ethereum.homestead.vm.interpreter.execute_code", "specifier": 0, "path": "src/ethereum/homestead/vm/interpreter.py"}, "content": {"type": ["function"], "name": ["execute_code"], "text": ["Executes bytecode present in the  message . Parameters message : Transaction specific items. env : External items required for EVM execution. Returns evm:  ethereum.vm.EVM Items containing execution specific objects"]}}, {"source": {"identifier": "ethereum.paris.vm.memory", "specifier": 0, "path": "src/ethereum/paris/vm/memory.py"}, "content": {"type": ["module"], "name": ["ethereum.paris.vm.memory"], "text": ["Ethereum Virtual Machine (EVM) Memory ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction EVM memory operations."]}}, {"source": {"identifier": "ethereum.paris.vm.memory.memory_write", "specifier": 0, "path": "src/ethereum/paris/vm/memory.py"}, "content": {"type": ["function"], "name": ["memory_write"], "text": ["Writes to memory. Parameters memory : Memory contents of the EVM. start_position : Starting pointer to the memory. value : Data to write to memory."]}}, {"source": {"identifier": "ethereum.paris.vm.memory.memory_read_bytes", "specifier": 0, "path": "src/ethereum/paris/vm/memory.py"}, "content": {"type": ["function"], "name": ["memory_read_bytes"], "text": ["Read bytes from memory. Parameters memory : Memory contents of the EVM. start_position : Starting pointer to the memory. size : Size of the data that needs to be read from  start_position . Returns data_bytes : Data read from memory."]}}, {"source": {"identifier": "ethereum.paris.vm.memory.buffer_read", "specifier": 0, "path": "src/ethereum/paris/vm/memory.py"}, "content": {"type": ["function"], "name": ["buffer_read"], "text": ["Read bytes from a buffer. Padding with zeros if neccesary. Parameters buffer : Memory contents of the EVM. start_position : Starting pointer to the memory. size : Size of the data that needs to be read from  start_position . Returns data_bytes : Data read from memory."]}}, {"source": {"identifier": "ethereum.homestead.vm.stack", "specifier": 0, "path": "src/ethereum/homestead/vm/stack.py"}, "content": {"type": ["module"], "name": ["ethereum.homestead.vm.stack"], "text": ["Ethereum Virtual Machine (EVM) Stack ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementation of the stack operators for the EVM."]}}, {"source": {"identifier": "ethereum.homestead.vm.stack.pop", "specifier": 0, "path": "src/ethereum/homestead/vm/stack.py"}, "content": {"type": ["function"], "name": ["pop"], "text": ["Pops the top item off of  stack . Parameters stack : EVM stack. Returns value :  U256 The top element on the stack."]}}, {"source": {"identifier": "ethereum.homestead.vm.stack.push", "specifier": 0, "path": "src/ethereum/homestead/vm/stack.py"}, "content": {"type": ["function"], "name": ["push"], "text": ["Pushes  value  onto  stack . Parameters stack : EVM stack. value : Item to be pushed onto  stack ."]}}, {"source": {"identifier": "ethereum.paris.vm.exceptions", "specifier": 0, "path": "src/ethereum/paris/vm/exceptions.py"}, "content": {"type": ["module"], "name": ["ethereum.paris.vm.exceptions"], "text": ["Ethereum Virtual Machine (EVM) Exceptions ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Exceptions which cause the EVM to halt exceptionally."]}}, {"source": {"identifier": "ethereum.paris.vm.exceptions.ExceptionalHalt", "specifier": 0, "path": "src/ethereum/paris/vm/exceptions.py"}, "content": {"type": ["class"], "name": ["ExceptionalHalt"], "text": ["Indicates that the EVM has experienced an exceptional halt. This causes execution to immediately end with all gas being consumed."]}}, {"source": {"identifier": "ethereum.paris.vm.exceptions.Revert", "specifier": 0, "path": "src/ethereum/paris/vm/exceptions.py"}, "content": {"type": ["class"], "name": ["Revert"], "text": ["Raised by the  REVERT  opcode. Unlike other EVM exceptions this does not result in the consumption of all gas."]}}, {"source": {"identifier": "ethereum.paris.vm.exceptions.StackUnderflowError", "specifier": 0, "path": "src/ethereum/paris/vm/exceptions.py"}, "content": {"type": ["class"], "name": ["StackUnderflowError"], "text": ["Occurs when a pop is executed on an empty stack."]}}, {"source": {"identifier": "ethereum.paris.vm.exceptions.StackOverflowError", "specifier": 0, "path": "src/ethereum/paris/vm/exceptions.py"}, "content": {"type": ["class"], "name": ["StackOverflowError"], "text": ["Occurs when a push is executed on a stack at max capacity."]}}, {"source": {"identifier": "ethereum.paris.vm.exceptions.OutOfGasError", "specifier": 0, "path": "src/ethereum/paris/vm/exceptions.py"}, "content": {"type": ["class"], "name": ["OutOfGasError"], "text": ["Occurs when an operation costs more than the amount of gas left in the frame."]}}, {"source": {"identifier": "ethereum.paris.vm.exceptions.InvalidOpcode", "specifier": 0, "path": "src/ethereum/paris/vm/exceptions.py"}, "content": {"type": ["class"], "name": ["InvalidOpcode"], "text": ["Raised when an invalid opcode is encountered."]}}, {"source": {"identifier": "ethereum.paris.vm.exceptions.InvalidJumpDestError", "specifier": 0, "path": "src/ethereum/paris/vm/exceptions.py"}, "content": {"type": ["class"], "name": ["InvalidJumpDestError"], "text": ["Occurs when the destination of a jump operation doesn't meet any of the following criteria: The jump destination is less than the length of the code. The jump destination should have the  JUMPDEST  opcode (0x5B). The jump destination shouldn't be part of the data corresponding to PUSH-N  opcodes."]}}, {"source": {"identifier": "ethereum.paris.vm.exceptions.StackDepthLimitError", "specifier": 0, "path": "src/ethereum/paris/vm/exceptions.py"}, "content": {"type": ["class"], "name": ["StackDepthLimitError"], "text": ["Raised when the message depth is greater than  1024"]}}, {"source": {"identifier": "ethereum.paris.vm.exceptions.WriteInStaticContext", "specifier": 0, "path": "src/ethereum/paris/vm/exceptions.py"}, "content": {"type": ["class"], "name": ["WriteInStaticContext"], "text": ["Raised when an attempt is made to modify the state while operating inside of a STATICCALL context."]}}, {"source": {"identifier": "ethereum.paris.vm.exceptions.OutOfBoundsRead", "specifier": 0, "path": "src/ethereum/paris/vm/exceptions.py"}, "content": {"type": ["class"], "name": ["OutOfBoundsRead"], "text": ["Raised when an attempt was made to read data beyond the boundaries of the buffer."]}}, {"source": {"identifier": "ethereum.paris.vm.exceptions.InvalidParameter", "specifier": 0, "path": "src/ethereum/paris/vm/exceptions.py"}, "content": {"type": ["class"], "name": ["InvalidParameter"], "text": ["Raised when invalid parameters are passed."]}}, {"source": {"identifier": "ethereum.paris.vm.exceptions.InvalidContractPrefix", "specifier": 0, "path": "src/ethereum/paris/vm/exceptions.py"}, "content": {"type": ["class"], "name": ["InvalidContractPrefix"], "text": ["Raised when the new contract code starts with 0xEF."]}}, {"source": {"identifier": "ethereum.homestead.vm.gas", "specifier": 0, "path": "src/ethereum/homestead/vm/gas.py"}, "content": {"type": ["module"], "name": ["ethereum.homestead.vm.gas"], "text": ["Ethereum Virtual Machine (EVM) Gas ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction EVM gas constants and calculators."]}}, {"source": {"identifier": "ethereum.homestead.vm.gas.GAS_JUMPDEST", "specifier": 0, "path": "src/ethereum/homestead/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_JUMPDEST"]}}, {"source": {"identifier": "ethereum.homestead.vm.gas.GAS_BASE", "specifier": 0, "path": "src/ethereum/homestead/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_BASE"]}}, {"source": {"identifier": "ethereum.homestead.vm.gas.GAS_VERY_LOW", "specifier": 0, "path": "src/ethereum/homestead/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_VERY_LOW"]}}, {"source": {"identifier": "ethereum.homestead.vm.gas.GAS_SLOAD", "specifier": 0, "path": "src/ethereum/homestead/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_SLOAD"]}}, {"source": {"identifier": "ethereum.homestead.vm.gas.GAS_STORAGE_SET", "specifier": 0, "path": "src/ethereum/homestead/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_STORAGE_SET"]}}, {"source": {"identifier": "ethereum.homestead.vm.gas.GAS_STORAGE_UPDATE", "specifier": 0, "path": "src/ethereum/homestead/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_STORAGE_UPDATE"]}}, {"source": {"identifier": "ethereum.homestead.vm.gas.GAS_STORAGE_CLEAR_REFUND", "specifier": 0, "path": "src/ethereum/homestead/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_STORAGE_CLEAR_REFUND"]}}, {"source": {"identifier": "ethereum.homestead.vm.gas.GAS_LOW", "specifier": 0, "path": "src/ethereum/homestead/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_LOW"]}}, {"source": {"identifier": "ethereum.homestead.vm.gas.GAS_MID", "specifier": 0, "path": "src/ethereum/homestead/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_MID"]}}, {"source": {"identifier": "ethereum.homestead.vm.gas.GAS_HIGH", "specifier": 0, "path": "src/ethereum/homestead/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_HIGH"]}}, {"source": {"identifier": "ethereum.homestead.vm.gas.GAS_EXPONENTIATION", "specifier": 0, "path": "src/ethereum/homestead/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_EXPONENTIATION"]}}, {"source": {"identifier": "ethereum.homestead.vm.gas.GAS_EXPONENTIATION_PER_BYTE", "specifier": 0, "path": "src/ethereum/homestead/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_EXPONENTIATION_PER_BYTE"]}}, {"source": {"identifier": "ethereum.homestead.vm.gas.GAS_MEMORY", "specifier": 0, "path": "src/ethereum/homestead/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_MEMORY"]}}, {"source": {"identifier": "ethereum.homestead.vm.gas.GAS_KECCAK256", "specifier": 0, "path": "src/ethereum/homestead/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_KECCAK256"]}}, {"source": {"identifier": "ethereum.homestead.vm.gas.GAS_KECCAK256_WORD", "specifier": 0, "path": "src/ethereum/homestead/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_KECCAK256_WORD"]}}, {"source": {"identifier": "ethereum.homestead.vm.gas.GAS_COPY", "specifier": 0, "path": "src/ethereum/homestead/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_COPY"]}}, {"source": {"identifier": "ethereum.homestead.vm.gas.GAS_BLOCK_HASH", "specifier": 0, "path": "src/ethereum/homestead/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_BLOCK_HASH"]}}, {"source": {"identifier": "ethereum.homestead.vm.gas.GAS_EXTERNAL", "specifier": 0, "path": "src/ethereum/homestead/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_EXTERNAL"]}}, {"source": {"identifier": "ethereum.homestead.vm.gas.GAS_BALANCE", "specifier": 0, "path": "src/ethereum/homestead/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_BALANCE"]}}, {"source": {"identifier": "ethereum.homestead.vm.gas.GAS_LOG", "specifier": 0, "path": "src/ethereum/homestead/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_LOG"]}}, {"source": {"identifier": "ethereum.homestead.vm.gas.GAS_LOG_DATA", "specifier": 0, "path": "src/ethereum/homestead/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_LOG_DATA"]}}, {"source": {"identifier": "ethereum.homestead.vm.gas.GAS_LOG_TOPIC", "specifier": 0, "path": "src/ethereum/homestead/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_LOG_TOPIC"]}}, {"source": {"identifier": "ethereum.homestead.vm.gas.GAS_CREATE", "specifier": 0, "path": "src/ethereum/homestead/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_CREATE"]}}, {"source": {"identifier": "ethereum.homestead.vm.gas.GAS_CODE_DEPOSIT", "specifier": 0, "path": "src/ethereum/homestead/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_CODE_DEPOSIT"]}}, {"source": {"identifier": "ethereum.homestead.vm.gas.GAS_ZERO", "specifier": 0, "path": "src/ethereum/homestead/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_ZERO"]}}, {"source": {"identifier": "ethereum.homestead.vm.gas.GAS_CALL", "specifier": 0, "path": "src/ethereum/homestead/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_CALL"]}}, {"source": {"identifier": "ethereum.homestead.vm.gas.GAS_NEW_ACCOUNT", "specifier": 0, "path": "src/ethereum/homestead/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_NEW_ACCOUNT"]}}, {"source": {"identifier": "ethereum.homestead.vm.gas.GAS_CALL_VALUE", "specifier": 0, "path": "src/ethereum/homestead/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_CALL_VALUE"]}}, {"source": {"identifier": "ethereum.homestead.vm.gas.GAS_CALL_STIPEND", "specifier": 0, "path": "src/ethereum/homestead/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_CALL_STIPEND"]}}, {"source": {"identifier": "ethereum.homestead.vm.gas.REFUND_SELF_DESTRUCT", "specifier": 0, "path": "src/ethereum/homestead/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["REFUND_SELF_DESTRUCT"]}}, {"source": {"identifier": "ethereum.homestead.vm.gas.GAS_ECRECOVER", "specifier": 0, "path": "src/ethereum/homestead/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_ECRECOVER"]}}, {"source": {"identifier": "ethereum.homestead.vm.gas.GAS_SHA256", "specifier": 0, "path": "src/ethereum/homestead/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_SHA256"]}}, {"source": {"identifier": "ethereum.homestead.vm.gas.GAS_SHA256_WORD", "specifier": 0, "path": "src/ethereum/homestead/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_SHA256_WORD"]}}, {"source": {"identifier": "ethereum.homestead.vm.gas.GAS_RIPEMD160", "specifier": 0, "path": "src/ethereum/homestead/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_RIPEMD160"]}}, {"source": {"identifier": "ethereum.homestead.vm.gas.GAS_RIPEMD160_WORD", "specifier": 0, "path": "src/ethereum/homestead/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_RIPEMD160_WORD"]}}, {"source": {"identifier": "ethereum.homestead.vm.gas.GAS_IDENTITY", "specifier": 0, "path": "src/ethereum/homestead/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_IDENTITY"]}}, {"source": {"identifier": "ethereum.homestead.vm.gas.GAS_IDENTITY_WORD", "specifier": 0, "path": "src/ethereum/homestead/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_IDENTITY_WORD"]}}, {"source": {"identifier": "ethereum.homestead.vm.gas.ExtendMemory", "specifier": 0, "path": "src/ethereum/homestead/vm/gas.py"}, "content": {"type": ["class"], "name": ["ExtendMemory"], "text": ["Define the parameters for memory extension in opcodes cost :  ethereum.base_types.Uint The gas required to perform the extension expand_by :  ethereum.base_types.Uint The size by which the memory will be extended"]}}, {"source": {"identifier": "ethereum.homestead.vm.gas.ExtendMemory.cost", "specifier": 0, "path": "src/ethereum/homestead/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["cost"]}}, {"source": {"identifier": "ethereum.homestead.vm.gas.ExtendMemory.expand_by", "specifier": 0, "path": "src/ethereum/homestead/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["expand_by"]}}, {"source": {"identifier": "ethereum.homestead.vm.gas.MessageCallGas", "specifier": 0, "path": "src/ethereum/homestead/vm/gas.py"}, "content": {"type": ["class"], "name": ["MessageCallGas"], "text": ["Define the gas cost and stipend for executing the call opcodes. cost :  ethereum.base_types.Uint The non-refundable portion of gas reserved for executing the call opcode. stipend :  ethereum.base_types.Uint The portion of gas available to sub-calls that is refundable if not consumed"]}}, {"source": {"identifier": "ethereum.homestead.vm.gas.MessageCallGas.cost", "specifier": 0, "path": "src/ethereum/homestead/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["cost"]}}, {"source": {"identifier": "ethereum.homestead.vm.gas.MessageCallGas.stipend", "specifier": 0, "path": "src/ethereum/homestead/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["stipend"]}}, {"source": {"identifier": "ethereum.homestead.vm.gas.charge_gas", "specifier": 0, "path": "src/ethereum/homestead/vm/gas.py"}, "content": {"type": ["function"], "name": ["charge_gas"], "text": ["Subtracts  amount  from  evm.gas_left . Parameters evm : The current EVM. amount : The amount of gas the current operation requires."]}}, {"source": {"identifier": "ethereum.homestead.vm.gas.calculate_memory_gas_cost", "specifier": 0, "path": "src/ethereum/homestead/vm/gas.py"}, "content": {"type": ["function"], "name": ["calculate_memory_gas_cost"], "text": ["Calculates the gas cost for allocating memory to the smallest multiple of 32 bytes, such that the allocated size is at least as big as the given size. Parameters size_in_bytes : The size of the data in bytes. Returns total_gas_cost :  ethereum.base_types.Uint The gas cost for storing data in memory."]}}, {"source": {"identifier": "ethereum.homestead.vm.gas.calculate_gas_extend_memory", "specifier": 0, "path": "src/ethereum/homestead/vm/gas.py"}, "content": {"type": ["function"], "name": ["calculate_gas_extend_memory"], "text": ["Calculates the gas amount to extend memory Parameters memory : Memory contents of the EVM. extensions: List of extensions to be made to the memory. Consists of a tuple of start position and size. Returns extend_memory:  ExtendMemory"]}}, {"source": {"identifier": "ethereum.homestead.vm.gas.calculate_message_call_gas", "specifier": 0, "path": "src/ethereum/homestead/vm/gas.py"}, "content": {"type": ["function"], "name": ["calculate_message_call_gas"], "text": ["Calculates the gas amount for executing Opcodes  CALL  and  CALLCODE . Parameters state : The current state. gas : The amount of gas provided to the message-call. to: The address of the recipient account. value: The amount of  ETH  that needs to be transferred. Returns message_call_gas:  MessageCallGas"]}}, {"source": {"identifier": "ethereum.paris.vm", "specifier": 0, "path": "src/ethereum/paris/vm/__init__.py"}, "content": {"type": ["module"], "name": ["ethereum.paris.vm"], "text": ["Ethereum Virtual Machine (EVM) ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction The abstract computer which runs the code stored in an .fork_types.Account ."]}}, {"source": {"identifier": "ethereum.paris.vm.__all__", "specifier": 0, "path": "src/ethereum/paris/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["__all__"]}}, {"source": {"identifier": "ethereum.paris.vm.Environment", "specifier": 0, "path": "src/ethereum/paris/vm/__init__.py"}, "content": {"type": ["class"], "name": ["Environment"], "text": ["Items external to the virtual machine itself, provided by the environment."]}}, {"source": {"identifier": "ethereum.paris.vm.Environment.caller", "specifier": 0, "path": "src/ethereum/paris/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["caller"]}}, {"source": {"identifier": "ethereum.paris.vm.Environment.block_hashes", "specifier": 0, "path": "src/ethereum/paris/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["block_hashes"]}}, {"source": {"identifier": "ethereum.paris.vm.Environment.origin", "specifier": 0, "path": "src/ethereum/paris/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["origin"]}}, {"source": {"identifier": "ethereum.paris.vm.Environment.coinbase", "specifier": 0, "path": "src/ethereum/paris/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["coinbase"]}}, {"source": {"identifier": "ethereum.paris.vm.Environment.number", "specifier": 0, "path": "src/ethereum/paris/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["number"]}}, {"source": {"identifier": "ethereum.paris.vm.Environment.base_fee_per_gas", "specifier": 0, "path": "src/ethereum/paris/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["base_fee_per_gas"]}}, {"source": {"identifier": "ethereum.paris.vm.Environment.gas_limit", "specifier": 0, "path": "src/ethereum/paris/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["gas_limit"]}}, {"source": {"identifier": "ethereum.paris.vm.Environment.gas_price", "specifier": 0, "path": "src/ethereum/paris/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["gas_price"]}}, {"source": {"identifier": "ethereum.paris.vm.Environment.time", "specifier": 0, "path": "src/ethereum/paris/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["time"]}}, {"source": {"identifier": "ethereum.paris.vm.Environment.prev_randao", "specifier": 0, "path": "src/ethereum/paris/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["prev_randao"]}}, {"source": {"identifier": "ethereum.paris.vm.Environment.state", "specifier": 0, "path": "src/ethereum/paris/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["state"]}}, {"source": {"identifier": "ethereum.paris.vm.Environment.chain_id", "specifier": 0, "path": "src/ethereum/paris/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["chain_id"]}}, {"source": {"identifier": "ethereum.paris.vm.Message", "specifier": 0, "path": "src/ethereum/paris/vm/__init__.py"}, "content": {"type": ["class"], "name": ["Message"], "text": ["Items that are used by contract creation or message call."]}}, {"source": {"identifier": "ethereum.paris.vm.Message.caller", "specifier": 0, "path": "src/ethereum/paris/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["caller"]}}, {"source": {"identifier": "ethereum.paris.vm.Message.target", "specifier": 0, "path": "src/ethereum/paris/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["target"]}}, {"source": {"identifier": "ethereum.paris.vm.Message.current_target", "specifier": 0, "path": "src/ethereum/paris/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["current_target"]}}, {"source": {"identifier": "ethereum.paris.vm.Message.gas", "specifier": 0, "path": "src/ethereum/paris/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["gas"]}}, {"source": {"identifier": "ethereum.paris.vm.Message.value", "specifier": 0, "path": "src/ethereum/paris/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["value"]}}, {"source": {"identifier": "ethereum.paris.vm.Message.data", "specifier": 0, "path": "src/ethereum/paris/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["data"]}}, {"source": {"identifier": "ethereum.paris.vm.Message.code_address", "specifier": 0, "path": "src/ethereum/paris/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["code_address"]}}, {"source": {"identifier": "ethereum.paris.vm.Message.code", "specifier": 0, "path": "src/ethereum/paris/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["code"]}}, {"source": {"identifier": "ethereum.paris.vm.Message.depth", "specifier": 0, "path": "src/ethereum/paris/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["depth"]}}, {"source": {"identifier": "ethereum.paris.vm.Message.should_transfer_value", "specifier": 0, "path": "src/ethereum/paris/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["should_transfer_value"]}}, {"source": {"identifier": "ethereum.paris.vm.Message.is_static", "specifier": 0, "path": "src/ethereum/paris/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["is_static"]}}, {"source": {"identifier": "ethereum.paris.vm.Message.accessed_addresses", "specifier": 0, "path": "src/ethereum/paris/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["accessed_addresses"]}}, {"source": {"identifier": "ethereum.paris.vm.Message.accessed_storage_keys", "specifier": 0, "path": "src/ethereum/paris/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["accessed_storage_keys"]}}, {"source": {"identifier": "ethereum.paris.vm.Evm", "specifier": 0, "path": "src/ethereum/paris/vm/__init__.py"}, "content": {"type": ["class"], "name": ["Evm"], "text": ["The internal state of the virtual machine."]}}, {"source": {"identifier": "ethereum.paris.vm.Evm.pc", "specifier": 0, "path": "src/ethereum/paris/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["pc"]}}, {"source": {"identifier": "ethereum.paris.vm.Evm.stack", "specifier": 0, "path": "src/ethereum/paris/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["stack"]}}, {"source": {"identifier": "ethereum.paris.vm.Evm.memory", "specifier": 0, "path": "src/ethereum/paris/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["memory"]}}, {"source": {"identifier": "ethereum.paris.vm.Evm.code", "specifier": 0, "path": "src/ethereum/paris/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["code"]}}, {"source": {"identifier": "ethereum.paris.vm.Evm.gas_left", "specifier": 0, "path": "src/ethereum/paris/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["gas_left"]}}, {"source": {"identifier": "ethereum.paris.vm.Evm.env", "specifier": 0, "path": "src/ethereum/paris/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["env"]}}, {"source": {"identifier": "ethereum.paris.vm.Evm.valid_jump_destinations", "specifier": 0, "path": "src/ethereum/paris/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["valid_jump_destinations"]}}, {"source": {"identifier": "ethereum.paris.vm.Evm.logs", "specifier": 0, "path": "src/ethereum/paris/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["logs"]}}, {"source": {"identifier": "ethereum.paris.vm.Evm.refund_counter", "specifier": 0, "path": "src/ethereum/paris/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["refund_counter"]}}, {"source": {"identifier": "ethereum.paris.vm.Evm.running", "specifier": 0, "path": "src/ethereum/paris/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["running"]}}, {"source": {"identifier": "ethereum.paris.vm.Evm.message", "specifier": 0, "path": "src/ethereum/paris/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["message"]}}, {"source": {"identifier": "ethereum.paris.vm.Evm.output", "specifier": 0, "path": "src/ethereum/paris/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["output"]}}, {"source": {"identifier": "ethereum.paris.vm.Evm.accounts_to_delete", "specifier": 0, "path": "src/ethereum/paris/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["accounts_to_delete"]}}, {"source": {"identifier": "ethereum.paris.vm.Evm.touched_accounts", "specifier": 0, "path": "src/ethereum/paris/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["touched_accounts"]}}, {"source": {"identifier": "ethereum.paris.vm.Evm.has_erred", "specifier": 0, "path": "src/ethereum/paris/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["has_erred"]}}, {"source": {"identifier": "ethereum.paris.vm.Evm.return_data", "specifier": 0, "path": "src/ethereum/paris/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["return_data"]}}, {"source": {"identifier": "ethereum.paris.vm.Evm.error", "specifier": 0, "path": "src/ethereum/paris/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["error"]}}, {"source": {"identifier": "ethereum.paris.vm.Evm.accessed_addresses", "specifier": 0, "path": "src/ethereum/paris/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["accessed_addresses"]}}, {"source": {"identifier": "ethereum.paris.vm.Evm.accessed_storage_keys", "specifier": 0, "path": "src/ethereum/paris/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["accessed_storage_keys"]}}, {"source": {"identifier": "ethereum.paris.vm.incorporate_child_on_success", "specifier": 0, "path": "src/ethereum/paris/vm/__init__.py"}, "content": {"type": ["function"], "name": ["incorporate_child_on_success"], "text": ["Incorporate the state of a successful  child_evm  into the parent  evm . Parameters evm : The parent  EVM . child_evm : The child evm to incorporate."]}}, {"source": {"identifier": "ethereum.paris.vm.incorporate_child_on_error", "specifier": 0, "path": "src/ethereum/paris/vm/__init__.py"}, "content": {"type": ["function"], "name": ["incorporate_child_on_error"], "text": ["Incorporate the state of an unsuccessful  child_evm  into the parent  evm . Parameters evm : The parent  EVM . child_evm : The child evm to incorporate."]}}, {"source": {"identifier": "ethereum.homestead.vm.precompiled_contracts.mapping", "specifier": 0, "path": "src/ethereum/homestead/vm/precompiled_contracts/mapping.py"}, "content": {"type": ["module"], "name": ["ethereum.homestead.vm.precompiled_contracts.mapping"], "text": ["Precompiled Contract Addresses ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Mapping of precompiled contracts their implementations."]}}, {"source": {"identifier": "ethereum.homestead.vm.precompiled_contracts.mapping.PRE_COMPILED_CONTRACTS", "specifier": 0, "path": "src/ethereum/homestead/vm/precompiled_contracts/mapping.py"}, "content": {"type": ["attribute"], "name": ["PRE_COMPILED_CONTRACTS"]}}, {"source": {"identifier": "ethereum.paris.vm.runtime", "specifier": 0, "path": "src/ethereum/paris/vm/runtime.py"}, "content": {"type": ["module"], "name": ["ethereum.paris.vm.runtime"], "text": ["Ethereum Virtual Machine (EVM) Runtime Operations ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Runtime related operations used while executing EVM code."]}}, {"source": {"identifier": "ethereum.paris.vm.runtime.get_valid_jump_destinations", "specifier": 0, "path": "src/ethereum/paris/vm/runtime.py"}, "content": {"type": ["function"], "name": ["get_valid_jump_destinations"], "text": ["Analyze the evm code to obtain the set of valid jump destinations. Valid jump destinations are defined as follows: * The jump destination is less than the length of the code. * The jump destination should have the  JUMPDEST  opcode (0x5B). * The jump destination shouldn't be part of the data corresponding to PUSH-N  opcodes. Note - Jump destinations are 0-indexed. Parameters code : The EVM code which is to be executed. Returns valid_jump_destinations:  Set[Uint] The set of valid jump destinations in the code."]}}, {"source": {"identifier": "ethereum.homestead.vm.precompiled_contracts", "specifier": 0, "path": "src/ethereum/homestead/vm/precompiled_contracts/__init__.py"}, "content": {"type": ["module"], "name": ["ethereum.homestead.vm.precompiled_contracts"], "text": ["Precompiled Contract Addresses ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Addresses of precompiled contracts and mappings to their implementations."]}}, {"source": {"identifier": "ethereum.homestead.vm.precompiled_contracts.__all__", "specifier": 0, "path": "src/ethereum/homestead/vm/precompiled_contracts/__init__.py"}, "content": {"type": ["attribute"], "name": ["__all__"]}}, {"source": {"identifier": "ethereum.homestead.vm.precompiled_contracts.ECRECOVER_ADDRESS", "specifier": 0, "path": "src/ethereum/homestead/vm/precompiled_contracts/__init__.py"}, "content": {"type": ["attribute"], "name": ["ECRECOVER_ADDRESS"]}}, {"source": {"identifier": "ethereum.homestead.vm.precompiled_contracts.SHA256_ADDRESS", "specifier": 0, "path": "src/ethereum/homestead/vm/precompiled_contracts/__init__.py"}, "content": {"type": ["attribute"], "name": ["SHA256_ADDRESS"]}}, {"source": {"identifier": "ethereum.homestead.vm.precompiled_contracts.RIPEMD160_ADDRESS", "specifier": 0, "path": "src/ethereum/homestead/vm/precompiled_contracts/__init__.py"}, "content": {"type": ["attribute"], "name": ["RIPEMD160_ADDRESS"]}}, {"source": {"identifier": "ethereum.homestead.vm.precompiled_contracts.IDENTITY_ADDRESS", "specifier": 0, "path": "src/ethereum/homestead/vm/precompiled_contracts/__init__.py"}, "content": {"type": ["attribute"], "name": ["IDENTITY_ADDRESS"]}}, {"source": {"identifier": "ethereum.paris.vm.interpreter", "specifier": 0, "path": "src/ethereum/paris/vm/interpreter.py"}, "content": {"type": ["module"], "name": ["ethereum.paris.vm.interpreter"], "text": ["Ethereum Virtual Machine (EVM) Interpreter ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction A straightforward interpreter that executes EVM code."]}}, {"source": {"identifier": "ethereum.paris.vm.interpreter.STACK_DEPTH_LIMIT", "specifier": 0, "path": "src/ethereum/paris/vm/interpreter.py"}, "content": {"type": ["attribute"], "name": ["STACK_DEPTH_LIMIT"]}}, {"source": {"identifier": "ethereum.paris.vm.interpreter.MAX_CODE_SIZE", "specifier": 0, "path": "src/ethereum/paris/vm/interpreter.py"}, "content": {"type": ["attribute"], "name": ["MAX_CODE_SIZE"]}}, {"source": {"identifier": "ethereum.paris.vm.interpreter.MessageCallOutput", "specifier": 0, "path": "src/ethereum/paris/vm/interpreter.py"}, "content": {"type": ["class"], "name": ["MessageCallOutput"], "text": ["Output of a particular message call Contains the following:   1. `gas_left`: remaining gas after execution.\n  2. `refund_counter`: gas to refund after execution.\n  3. `logs`: list of `Log` generated during execution.\n  4. `accounts_to_delete`: Contracts which have self-destructed.\n  5. `touched_accounts`: Accounts that have been touched.\n  6. `has_erred`: True if execution has caused an error.\n"]}}, {"source": {"identifier": "ethereum.paris.vm.interpreter.MessageCallOutput.gas_left", "specifier": 0, "path": "src/ethereum/paris/vm/interpreter.py"}, "content": {"type": ["attribute"], "name": ["gas_left"]}}, {"source": {"identifier": "ethereum.paris.vm.interpreter.MessageCallOutput.refund_counter", "specifier": 0, "path": "src/ethereum/paris/vm/interpreter.py"}, "content": {"type": ["attribute"], "name": ["refund_counter"]}}, {"source": {"identifier": "ethereum.paris.vm.interpreter.MessageCallOutput.logs", "specifier": 0, "path": "src/ethereum/paris/vm/interpreter.py"}, "content": {"type": ["attribute"], "name": ["logs"]}}, {"source": {"identifier": "ethereum.paris.vm.interpreter.MessageCallOutput.accounts_to_delete", "specifier": 0, "path": "src/ethereum/paris/vm/interpreter.py"}, "content": {"type": ["attribute"], "name": ["accounts_to_delete"]}}, {"source": {"identifier": "ethereum.paris.vm.interpreter.MessageCallOutput.touched_accounts", "specifier": 0, "path": "src/ethereum/paris/vm/interpreter.py"}, "content": {"type": ["attribute"], "name": ["touched_accounts"]}}, {"source": {"identifier": "ethereum.paris.vm.interpreter.MessageCallOutput.has_erred", "specifier": 0, "path": "src/ethereum/paris/vm/interpreter.py"}, "content": {"type": ["attribute"], "name": ["has_erred"]}}, {"source": {"identifier": "ethereum.paris.vm.interpreter.process_message_call", "specifier": 0, "path": "src/ethereum/paris/vm/interpreter.py"}, "content": {"type": ["function"], "name": ["process_message_call"], "text": ["If  message.current  is empty then it creates a smart contract else it executes a call from the  message.caller  to the  message.target . Parameters message : Transaction specific items. env : External items required for EVM execution. Returns output :  MessageCallOutput Output of the message call"]}}, {"source": {"identifier": "ethereum.paris.vm.interpreter.process_create_message", "specifier": 0, "path": "src/ethereum/paris/vm/interpreter.py"}, "content": {"type": ["function"], "name": ["process_create_message"], "text": ["Executes a call to create a smart contract. Parameters message : Transaction specific items. env : External items required for EVM execution. Returns evm: :py:class: ~ethereum.paris.vm.Evm Items containing execution specific objects."]}}, {"source": {"identifier": "ethereum.paris.vm.interpreter.process_message", "specifier": 0, "path": "src/ethereum/paris/vm/interpreter.py"}, "content": {"type": ["function"], "name": ["process_message"], "text": ["Executes a call to create a smart contract. Parameters message : Transaction specific items. env : External items required for EVM execution. Returns evm: :py:class: ~ethereum.paris.vm.Evm Items containing execution specific objects"]}}, {"source": {"identifier": "ethereum.paris.vm.interpreter.execute_code", "specifier": 0, "path": "src/ethereum/paris/vm/interpreter.py"}, "content": {"type": ["function"], "name": ["execute_code"], "text": ["Executes bytecode present in the  message . Parameters message : Transaction specific items. env : External items required for EVM execution. Returns evm:  ethereum.vm.EVM Items containing execution specific objects"]}}, {"source": {"identifier": "ethereum.homestead.vm.precompiled_contracts.ripemd160", "specifier": 0, "path": "src/ethereum/homestead/vm/precompiled_contracts/ripemd160.py"}, "content": {"type": ["module"], "name": ["ethereum.homestead.vm.precompiled_contracts.ripemd160"], "text": ["Ethereum Virtual Machine (EVM) RIPEMD160 PRECOMPILED CONTRACT ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementation of the  RIPEMD160  precompiled contract."]}}, {"source": {"identifier": "ethereum.homestead.vm.precompiled_contracts.ripemd160.ripemd160", "specifier": 0, "path": "src/ethereum/homestead/vm/precompiled_contracts/ripemd160.py"}, "content": {"type": ["function"], "name": ["ripemd160"], "text": ["Writes the ripemd160 hash to output. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.paris.vm.stack", "specifier": 0, "path": "src/ethereum/paris/vm/stack.py"}, "content": {"type": ["module"], "name": ["ethereum.paris.vm.stack"], "text": ["Ethereum Virtual Machine (EVM) Stack ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementation of the stack operators for the EVM."]}}, {"source": {"identifier": "ethereum.paris.vm.stack.pop", "specifier": 0, "path": "src/ethereum/paris/vm/stack.py"}, "content": {"type": ["function"], "name": ["pop"], "text": ["Pops the top item off of  stack . Parameters stack : EVM stack. Returns value :  U256 The top element on the stack."]}}, {"source": {"identifier": "ethereum.paris.vm.stack.push", "specifier": 0, "path": "src/ethereum/paris/vm/stack.py"}, "content": {"type": ["function"], "name": ["push"], "text": ["Pushes  value  onto  stack . Parameters stack : EVM stack. value : Item to be pushed onto  stack ."]}}, {"source": {"identifier": "ethereum.homestead.vm.precompiled_contracts.sha256", "specifier": 0, "path": "src/ethereum/homestead/vm/precompiled_contracts/sha256.py"}, "content": {"type": ["module"], "name": ["ethereum.homestead.vm.precompiled_contracts.sha256"], "text": ["Ethereum Virtual Machine (EVM) SHA256 PRECOMPILED CONTRACT ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementation of the  SHA256  precompiled contract."]}}, {"source": {"identifier": "ethereum.homestead.vm.precompiled_contracts.sha256.sha256", "specifier": 0, "path": "src/ethereum/homestead/vm/precompiled_contracts/sha256.py"}, "content": {"type": ["function"], "name": ["sha256"], "text": ["Writes the sha256 hash to output. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.paris.vm.gas", "specifier": 0, "path": "src/ethereum/paris/vm/gas.py"}, "content": {"type": ["module"], "name": ["ethereum.paris.vm.gas"], "text": ["Ethereum Virtual Machine (EVM) Gas ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction EVM gas constants and calculators."]}}, {"source": {"identifier": "ethereum.paris.vm.gas.GAS_JUMPDEST", "specifier": 0, "path": "src/ethereum/paris/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_JUMPDEST"]}}, {"source": {"identifier": "ethereum.paris.vm.gas.GAS_BASE", "specifier": 0, "path": "src/ethereum/paris/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_BASE"]}}, {"source": {"identifier": "ethereum.paris.vm.gas.GAS_VERY_LOW", "specifier": 0, "path": "src/ethereum/paris/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_VERY_LOW"]}}, {"source": {"identifier": "ethereum.paris.vm.gas.GAS_STORAGE_SET", "specifier": 0, "path": "src/ethereum/paris/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_STORAGE_SET"]}}, {"source": {"identifier": "ethereum.paris.vm.gas.GAS_STORAGE_UPDATE", "specifier": 0, "path": "src/ethereum/paris/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_STORAGE_UPDATE"]}}, {"source": {"identifier": "ethereum.paris.vm.gas.GAS_STORAGE_CLEAR_REFUND", "specifier": 0, "path": "src/ethereum/paris/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_STORAGE_CLEAR_REFUND"]}}, {"source": {"identifier": "ethereum.paris.vm.gas.GAS_LOW", "specifier": 0, "path": "src/ethereum/paris/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_LOW"]}}, {"source": {"identifier": "ethereum.paris.vm.gas.GAS_MID", "specifier": 0, "path": "src/ethereum/paris/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_MID"]}}, {"source": {"identifier": "ethereum.paris.vm.gas.GAS_HIGH", "specifier": 0, "path": "src/ethereum/paris/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_HIGH"]}}, {"source": {"identifier": "ethereum.paris.vm.gas.GAS_EXPONENTIATION", "specifier": 0, "path": "src/ethereum/paris/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_EXPONENTIATION"]}}, {"source": {"identifier": "ethereum.paris.vm.gas.GAS_EXPONENTIATION_PER_BYTE", "specifier": 0, "path": "src/ethereum/paris/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_EXPONENTIATION_PER_BYTE"]}}, {"source": {"identifier": "ethereum.paris.vm.gas.GAS_MEMORY", "specifier": 0, "path": "src/ethereum/paris/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_MEMORY"]}}, {"source": {"identifier": "ethereum.paris.vm.gas.GAS_KECCAK256", "specifier": 0, "path": "src/ethereum/paris/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_KECCAK256"]}}, {"source": {"identifier": "ethereum.paris.vm.gas.GAS_KECCAK256_WORD", "specifier": 0, "path": "src/ethereum/paris/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_KECCAK256_WORD"]}}, {"source": {"identifier": "ethereum.paris.vm.gas.GAS_COPY", "specifier": 0, "path": "src/ethereum/paris/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_COPY"]}}, {"source": {"identifier": "ethereum.paris.vm.gas.GAS_BLOCK_HASH", "specifier": 0, "path": "src/ethereum/paris/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_BLOCK_HASH"]}}, {"source": {"identifier": "ethereum.paris.vm.gas.GAS_LOG", "specifier": 0, "path": "src/ethereum/paris/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_LOG"]}}, {"source": {"identifier": "ethereum.paris.vm.gas.GAS_LOG_DATA", "specifier": 0, "path": "src/ethereum/paris/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_LOG_DATA"]}}, {"source": {"identifier": "ethereum.paris.vm.gas.GAS_LOG_TOPIC", "specifier": 0, "path": "src/ethereum/paris/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_LOG_TOPIC"]}}, {"source": {"identifier": "ethereum.paris.vm.gas.GAS_CREATE", "specifier": 0, "path": "src/ethereum/paris/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_CREATE"]}}, {"source": {"identifier": "ethereum.paris.vm.gas.GAS_CODE_DEPOSIT", "specifier": 0, "path": "src/ethereum/paris/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_CODE_DEPOSIT"]}}, {"source": {"identifier": "ethereum.paris.vm.gas.GAS_ZERO", "specifier": 0, "path": "src/ethereum/paris/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_ZERO"]}}, {"source": {"identifier": "ethereum.paris.vm.gas.GAS_NEW_ACCOUNT", "specifier": 0, "path": "src/ethereum/paris/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_NEW_ACCOUNT"]}}, {"source": {"identifier": "ethereum.paris.vm.gas.GAS_CALL_VALUE", "specifier": 0, "path": "src/ethereum/paris/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_CALL_VALUE"]}}, {"source": {"identifier": "ethereum.paris.vm.gas.GAS_CALL_STIPEND", "specifier": 0, "path": "src/ethereum/paris/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_CALL_STIPEND"]}}, {"source": {"identifier": "ethereum.paris.vm.gas.GAS_SELF_DESTRUCT", "specifier": 0, "path": "src/ethereum/paris/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_SELF_DESTRUCT"]}}, {"source": {"identifier": "ethereum.paris.vm.gas.GAS_SELF_DESTRUCT_NEW_ACCOUNT", "specifier": 0, "path": "src/ethereum/paris/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_SELF_DESTRUCT_NEW_ACCOUNT"]}}, {"source": {"identifier": "ethereum.paris.vm.gas.GAS_ECRECOVER", "specifier": 0, "path": "src/ethereum/paris/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_ECRECOVER"]}}, {"source": {"identifier": "ethereum.paris.vm.gas.GAS_SHA256", "specifier": 0, "path": "src/ethereum/paris/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_SHA256"]}}, {"source": {"identifier": "ethereum.paris.vm.gas.GAS_SHA256_WORD", "specifier": 0, "path": "src/ethereum/paris/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_SHA256_WORD"]}}, {"source": {"identifier": "ethereum.paris.vm.gas.GAS_RIPEMD160", "specifier": 0, "path": "src/ethereum/paris/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_RIPEMD160"]}}, {"source": {"identifier": "ethereum.paris.vm.gas.GAS_RIPEMD160_WORD", "specifier": 0, "path": "src/ethereum/paris/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_RIPEMD160_WORD"]}}, {"source": {"identifier": "ethereum.paris.vm.gas.GAS_IDENTITY", "specifier": 0, "path": "src/ethereum/paris/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_IDENTITY"]}}, {"source": {"identifier": "ethereum.paris.vm.gas.GAS_IDENTITY_WORD", "specifier": 0, "path": "src/ethereum/paris/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_IDENTITY_WORD"]}}, {"source": {"identifier": "ethereum.paris.vm.gas.GAS_RETURN_DATA_COPY", "specifier": 0, "path": "src/ethereum/paris/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_RETURN_DATA_COPY"]}}, {"source": {"identifier": "ethereum.paris.vm.gas.GAS_FAST_STEP", "specifier": 0, "path": "src/ethereum/paris/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_FAST_STEP"]}}, {"source": {"identifier": "ethereum.paris.vm.gas.GAS_BLAKE2_PER_ROUND", "specifier": 0, "path": "src/ethereum/paris/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_BLAKE2_PER_ROUND"]}}, {"source": {"identifier": "ethereum.paris.vm.gas.GAS_COLD_SLOAD", "specifier": 0, "path": "src/ethereum/paris/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_COLD_SLOAD"]}}, {"source": {"identifier": "ethereum.paris.vm.gas.GAS_COLD_ACCOUNT_ACCESS", "specifier": 0, "path": "src/ethereum/paris/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_COLD_ACCOUNT_ACCESS"]}}, {"source": {"identifier": "ethereum.paris.vm.gas.GAS_WARM_ACCESS", "specifier": 0, "path": "src/ethereum/paris/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_WARM_ACCESS"]}}, {"source": {"identifier": "ethereum.paris.vm.gas.ExtendMemory", "specifier": 0, "path": "src/ethereum/paris/vm/gas.py"}, "content": {"type": ["class"], "name": ["ExtendMemory"], "text": ["Define the parameters for memory extension in opcodes cost :  ethereum.base_types.Uint The gas required to perform the extension expand_by :  ethereum.base_types.Uint The size by which the memory will be extended"]}}, {"source": {"identifier": "ethereum.paris.vm.gas.ExtendMemory.cost", "specifier": 0, "path": "src/ethereum/paris/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["cost"]}}, {"source": {"identifier": "ethereum.paris.vm.gas.ExtendMemory.expand_by", "specifier": 0, "path": "src/ethereum/paris/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["expand_by"]}}, {"source": {"identifier": "ethereum.paris.vm.gas.MessageCallGas", "specifier": 0, "path": "src/ethereum/paris/vm/gas.py"}, "content": {"type": ["class"], "name": ["MessageCallGas"], "text": ["Define the gas cost and stipend for executing the call opcodes. cost :  ethereum.base_types.Uint The non-refundable portion of gas reserved for executing the call opcode. stipend :  ethereum.base_types.Uint The portion of gas available to sub-calls that is refundable if not consumed"]}}, {"source": {"identifier": "ethereum.paris.vm.gas.MessageCallGas.cost", "specifier": 0, "path": "src/ethereum/paris/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["cost"]}}, {"source": {"identifier": "ethereum.paris.vm.gas.MessageCallGas.stipend", "specifier": 0, "path": "src/ethereum/paris/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["stipend"]}}, {"source": {"identifier": "ethereum.paris.vm.gas.charge_gas", "specifier": 0, "path": "src/ethereum/paris/vm/gas.py"}, "content": {"type": ["function"], "name": ["charge_gas"], "text": ["Subtracts  amount  from  evm.gas_left . Parameters evm : The current EVM. amount : The amount of gas the current operation requires."]}}, {"source": {"identifier": "ethereum.paris.vm.gas.calculate_memory_gas_cost", "specifier": 0, "path": "src/ethereum/paris/vm/gas.py"}, "content": {"type": ["function"], "name": ["calculate_memory_gas_cost"], "text": ["Calculates the gas cost for allocating memory to the smallest multiple of 32 bytes, such that the allocated size is at least as big as the given size. Parameters size_in_bytes : The size of the data in bytes. Returns total_gas_cost :  ethereum.base_types.Uint The gas cost for storing data in memory."]}}, {"source": {"identifier": "ethereum.paris.vm.gas.calculate_gas_extend_memory", "specifier": 0, "path": "src/ethereum/paris/vm/gas.py"}, "content": {"type": ["function"], "name": ["calculate_gas_extend_memory"], "text": ["Calculates the gas amount to extend memory Parameters memory : Memory contents of the EVM. extensions: List of extensions to be made to the memory. Consists of a tuple of start position and size. Returns extend_memory:  ExtendMemory"]}}, {"source": {"identifier": "ethereum.paris.vm.gas.calculate_message_call_gas", "specifier": 0, "path": "src/ethereum/paris/vm/gas.py"}, "content": {"type": ["function"], "name": ["calculate_message_call_gas"], "text": ["Calculates the MessageCallGas (cost and stipend) for executing call Opcodes. Parameters value: The amount of  ETH  that needs to be transferred. gas : The amount of gas provided to the message-call. gas_left : The amount of gas left in the current frame. memory_cost : The amount needed to extend the memory in the current frame. extra_gas : The amount of gas needed for transferring value + creating a new account inside a message call. call_stipend : The amount of stipend provided to a message call to execute code while transferring value(ETH). Returns message_call_gas:  MessageCallGas"]}}, {"source": {"identifier": "ethereum.paris.vm.gas.max_message_call_gas", "specifier": 0, "path": "src/ethereum/paris/vm/gas.py"}, "content": {"type": ["function"], "name": ["max_message_call_gas"], "text": ["Calculates the maximum gas that is allowed for making a message call Parameters gas : The amount of gas provided to the message-call. Returns max_allowed_message_call_gas:  ethereum.base_types.Uint The maximum gas allowed for making the message-call."]}}, {"source": {"identifier": "ethereum.homestead.vm.precompiled_contracts.ecrecover", "specifier": 0, "path": "src/ethereum/homestead/vm/precompiled_contracts/ecrecover.py"}, "content": {"type": ["module"], "name": ["ethereum.homestead.vm.precompiled_contracts.ecrecover"], "text": ["Ethereum Virtual Machine (EVM) ECRECOVER PRECOMPILED CONTRACT ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementation of the ECRECOVER precompiled contract."]}}, {"source": {"identifier": "ethereum.homestead.vm.precompiled_contracts.ecrecover.ecrecover", "specifier": 0, "path": "src/ethereum/homestead/vm/precompiled_contracts/ecrecover.py"}, "content": {"type": ["function"], "name": ["ecrecover"], "text": ["Decrypts the address using elliptic curve DSA recovery mechanism and writes the address to output. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.paris.vm.precompiled_contracts.blake2f", "specifier": 0, "path": "src/ethereum/paris/vm/precompiled_contracts/blake2f.py"}, "content": {"type": ["module"], "name": ["ethereum.paris.vm.precompiled_contracts.blake2f"], "text": ["Ethereum Virtual Machine (EVM) Blake2 PRECOMPILED CONTRACT ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementation of the  Blake2  precompiled contract."]}}, {"source": {"identifier": "ethereum.paris.vm.precompiled_contracts.blake2f.blake2f", "specifier": 0, "path": "src/ethereum/paris/vm/precompiled_contracts/blake2f.py"}, "content": {"type": ["function"], "name": ["blake2f"], "text": ["Writes the Blake2 hash to output. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.homestead.vm.precompiled_contracts.identity", "specifier": 0, "path": "src/ethereum/homestead/vm/precompiled_contracts/identity.py"}, "content": {"type": ["module"], "name": ["ethereum.homestead.vm.precompiled_contracts.identity"], "text": ["Ethereum Virtual Machine (EVM) IDENTITY PRECOMPILED CONTRACT ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementation of the  IDENTITY  precompiled contract."]}}, {"source": {"identifier": "ethereum.homestead.vm.precompiled_contracts.identity.identity", "specifier": 0, "path": "src/ethereum/homestead/vm/precompiled_contracts/identity.py"}, "content": {"type": ["function"], "name": ["identity"], "text": ["Writes the message data to output. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.paris.vm.precompiled_contracts.mapping", "specifier": 0, "path": "src/ethereum/paris/vm/precompiled_contracts/mapping.py"}, "content": {"type": ["module"], "name": ["ethereum.paris.vm.precompiled_contracts.mapping"], "text": ["Precompiled Contract Addresses ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Mapping of precompiled contracts their implementations."]}}, {"source": {"identifier": "ethereum.paris.vm.precompiled_contracts.mapping.PRE_COMPILED_CONTRACTS", "specifier": 0, "path": "src/ethereum/paris/vm/precompiled_contracts/mapping.py"}, "content": {"type": ["attribute"], "name": ["PRE_COMPILED_CONTRACTS"]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.memory", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/memory.py"}, "content": {"type": ["module"], "name": ["ethereum.homestead.vm.instructions.memory"], "text": ["Ethereum Virtual Machine (EVM) Memory Instructions ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementations of the EVM Memory instructions."]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.memory.mstore", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/memory.py"}, "content": {"type": ["function"], "name": ["mstore"], "text": ["Stores a word to memory. This also expands the memory, if the memory is insufficient to store the word. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.memory.mstore8", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/memory.py"}, "content": {"type": ["function"], "name": ["mstore8"], "text": ["Stores a byte to memory. This also expands the memory, if the memory is insufficient to store the word. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.memory.mload", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/memory.py"}, "content": {"type": ["function"], "name": ["mload"], "text": ["Load word from memory. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.memory.msize", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/memory.py"}, "content": {"type": ["function"], "name": ["msize"], "text": ["Push the size of active memory in bytes onto the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.paris.vm.precompiled_contracts", "specifier": 0, "path": "src/ethereum/paris/vm/precompiled_contracts/__init__.py"}, "content": {"type": ["module"], "name": ["ethereum.paris.vm.precompiled_contracts"], "text": ["Precompiled Contract Addresses ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Addresses of precompiled contracts and mappings to their implementations."]}}, {"source": {"identifier": "ethereum.paris.vm.precompiled_contracts.__all__", "specifier": 0, "path": "src/ethereum/paris/vm/precompiled_contracts/__init__.py"}, "content": {"type": ["attribute"], "name": ["__all__"]}}, {"source": {"identifier": "ethereum.paris.vm.precompiled_contracts.ECRECOVER_ADDRESS", "specifier": 0, "path": "src/ethereum/paris/vm/precompiled_contracts/__init__.py"}, "content": {"type": ["attribute"], "name": ["ECRECOVER_ADDRESS"]}}, {"source": {"identifier": "ethereum.paris.vm.precompiled_contracts.SHA256_ADDRESS", "specifier": 0, "path": "src/ethereum/paris/vm/precompiled_contracts/__init__.py"}, "content": {"type": ["attribute"], "name": ["SHA256_ADDRESS"]}}, {"source": {"identifier": "ethereum.paris.vm.precompiled_contracts.RIPEMD160_ADDRESS", "specifier": 0, "path": "src/ethereum/paris/vm/precompiled_contracts/__init__.py"}, "content": {"type": ["attribute"], "name": ["RIPEMD160_ADDRESS"]}}, {"source": {"identifier": "ethereum.paris.vm.precompiled_contracts.IDENTITY_ADDRESS", "specifier": 0, "path": "src/ethereum/paris/vm/precompiled_contracts/__init__.py"}, "content": {"type": ["attribute"], "name": ["IDENTITY_ADDRESS"]}}, {"source": {"identifier": "ethereum.paris.vm.precompiled_contracts.MODEXP_ADDRESS", "specifier": 0, "path": "src/ethereum/paris/vm/precompiled_contracts/__init__.py"}, "content": {"type": ["attribute"], "name": ["MODEXP_ADDRESS"]}}, {"source": {"identifier": "ethereum.paris.vm.precompiled_contracts.ALT_BN128_ADD_ADDRESS", "specifier": 0, "path": "src/ethereum/paris/vm/precompiled_contracts/__init__.py"}, "content": {"type": ["attribute"], "name": ["ALT_BN128_ADD_ADDRESS"]}}, {"source": {"identifier": "ethereum.paris.vm.precompiled_contracts.ALT_BN128_MUL_ADDRESS", "specifier": 0, "path": "src/ethereum/paris/vm/precompiled_contracts/__init__.py"}, "content": {"type": ["attribute"], "name": ["ALT_BN128_MUL_ADDRESS"]}}, {"source": {"identifier": "ethereum.paris.vm.precompiled_contracts.ALT_BN128_PAIRING_CHECK_ADDRESS", "specifier": 0, "path": "src/ethereum/paris/vm/precompiled_contracts/__init__.py"}, "content": {"type": ["attribute"], "name": ["ALT_BN128_PAIRING_CHECK_ADDRESS"]}}, {"source": {"identifier": "ethereum.paris.vm.precompiled_contracts.BLAKE2F_ADDRESS", "specifier": 0, "path": "src/ethereum/paris/vm/precompiled_contracts/__init__.py"}, "content": {"type": ["attribute"], "name": ["BLAKE2F_ADDRESS"]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.system", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/system.py"}, "content": {"type": ["module"], "name": ["ethereum.homestead.vm.instructions.system"], "text": ["Ethereum Virtual Machine (EVM) System Instructions ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementations of the EVM system related instructions."]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.system.create", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/system.py"}, "content": {"type": ["function"], "name": ["create"], "text": ["Creates a new account with associated code. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.system.return_", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/system.py"}, "content": {"type": ["function"], "name": ["return_"], "text": ["Halts execution returning output data. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.system.generic_call", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/system.py"}, "content": {"type": ["function"], "name": ["generic_call"], "text": ["Perform the core logic of the  CALL*  family of opcodes."]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.system.call", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/system.py"}, "content": {"type": ["function"], "name": ["call"], "text": ["Message-call into an account. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.system.callcode", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/system.py"}, "content": {"type": ["function"], "name": ["callcode"], "text": ["Message-call into this account with alternative account\u2019s code. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.system.selfdestruct", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/system.py"}, "content": {"type": ["function"], "name": ["selfdestruct"], "text": ["Halt execution and register account for later deletion. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.system.delegatecall", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/system.py"}, "content": {"type": ["function"], "name": ["delegatecall"], "text": ["Message-call into an account. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.paris.vm.precompiled_contracts.alt_bn128", "specifier": 0, "path": "src/ethereum/paris/vm/precompiled_contracts/alt_bn128.py"}, "content": {"type": ["module"], "name": ["ethereum.paris.vm.precompiled_contracts.alt_bn128"], "text": ["Ethereum Virtual Machine (EVM) ALT_BN128 CONTRACTS ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementation of the ALT_BN128 precompiled contracts."]}}, {"source": {"identifier": "ethereum.paris.vm.precompiled_contracts.alt_bn128.alt_bn128_add", "specifier": 0, "path": "src/ethereum/paris/vm/precompiled_contracts/alt_bn128.py"}, "content": {"type": ["function"], "name": ["alt_bn128_add"], "text": ["The ALT_BN128 addition precompiled contract. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.paris.vm.precompiled_contracts.alt_bn128.alt_bn128_mul", "specifier": 0, "path": "src/ethereum/paris/vm/precompiled_contracts/alt_bn128.py"}, "content": {"type": ["function"], "name": ["alt_bn128_mul"], "text": ["The ALT_BN128 multiplication precompiled contract. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.paris.vm.precompiled_contracts.alt_bn128.alt_bn128_pairing_check", "specifier": 0, "path": "src/ethereum/paris/vm/precompiled_contracts/alt_bn128.py"}, "content": {"type": ["function"], "name": ["alt_bn128_pairing_check"], "text": ["The ALT_BN128 pairing check precompiled contract. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/__init__.py"}, "content": {"type": ["module"], "name": ["ethereum.homestead.vm.instructions"], "text": ["EVM Instruction Encoding (Opcodes) ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Machine readable representations of EVM instructions, and a mapping to their implementations."]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.Ops", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/__init__.py"}, "content": {"type": ["class"], "name": ["Ops"], "text": ["Enum for EVM Opcodes"]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.Ops.ADD", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["ADD"]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.Ops.MUL", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["MUL"]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.Ops.SUB", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SUB"]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.Ops.DIV", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DIV"]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.Ops.SDIV", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SDIV"]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.Ops.MOD", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["MOD"]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.Ops.SMOD", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SMOD"]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.Ops.ADDMOD", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["ADDMOD"]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.Ops.MULMOD", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["MULMOD"]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.Ops.EXP", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["EXP"]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.Ops.SIGNEXTEND", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SIGNEXTEND"]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.Ops.LT", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["LT"]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.Ops.GT", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["GT"]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.Ops.SLT", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SLT"]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.Ops.SGT", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SGT"]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.Ops.EQ", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["EQ"]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.Ops.ISZERO", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["ISZERO"]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.Ops.AND", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["AND"]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.Ops.OR", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["OR"]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.Ops.XOR", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["XOR"]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.Ops.NOT", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["NOT"]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.Ops.BYTE", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["BYTE"]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.Ops.KECCAK", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["KECCAK"]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.Ops.ADDRESS", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["ADDRESS"]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.Ops.BALANCE", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["BALANCE"]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.Ops.ORIGIN", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["ORIGIN"]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.Ops.CALLER", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["CALLER"]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.Ops.CALLVALUE", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["CALLVALUE"]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.Ops.CALLDATALOAD", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["CALLDATALOAD"]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.Ops.CALLDATASIZE", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["CALLDATASIZE"]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.Ops.CALLDATACOPY", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["CALLDATACOPY"]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.Ops.CODESIZE", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["CODESIZE"]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.Ops.CODECOPY", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["CODECOPY"]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.Ops.GASPRICE", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["GASPRICE"]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.Ops.EXTCODESIZE", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["EXTCODESIZE"]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.Ops.EXTCODECOPY", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["EXTCODECOPY"]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.Ops.BLOCKHASH", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["BLOCKHASH"]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.Ops.COINBASE", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["COINBASE"]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.Ops.TIMESTAMP", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["TIMESTAMP"]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.Ops.NUMBER", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["NUMBER"]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.Ops.DIFFICULTY", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DIFFICULTY"]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.Ops.GASLIMIT", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["GASLIMIT"]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.Ops.STOP", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["STOP"]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.Ops.JUMP", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["JUMP"]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.Ops.JUMPI", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["JUMPI"]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.Ops.PC", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PC"]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.Ops.GAS", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["GAS"]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.Ops.JUMPDEST", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["JUMPDEST"]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.Ops.SLOAD", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SLOAD"]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.Ops.SSTORE", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SSTORE"]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.Ops.POP", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["POP"]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.Ops.PUSH1", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH1"]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.Ops.PUSH2", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH2"]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.Ops.PUSH3", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH3"]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.Ops.PUSH4", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH4"]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.Ops.PUSH5", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH5"]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.Ops.PUSH6", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH6"]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.Ops.PUSH7", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH7"]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.Ops.PUSH8", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH8"]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.Ops.PUSH9", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH9"]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.Ops.PUSH10", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH10"]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.Ops.PUSH11", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH11"]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.Ops.PUSH12", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH12"]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.Ops.PUSH13", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH13"]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.Ops.PUSH14", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH14"]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.Ops.PUSH15", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH15"]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.Ops.PUSH16", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH16"]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.Ops.PUSH17", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH17"]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.Ops.PUSH18", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH18"]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.Ops.PUSH19", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH19"]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.Ops.PUSH20", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH20"]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.Ops.PUSH21", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH21"]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.Ops.PUSH22", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH22"]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.Ops.PUSH23", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH23"]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.Ops.PUSH24", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH24"]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.Ops.PUSH25", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH25"]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.Ops.PUSH26", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH26"]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.Ops.PUSH27", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH27"]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.Ops.PUSH28", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH28"]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.Ops.PUSH29", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH29"]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.Ops.PUSH30", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH30"]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.Ops.PUSH31", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH31"]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.Ops.PUSH32", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH32"]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.Ops.DUP1", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP1"]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.Ops.DUP2", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP2"]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.Ops.DUP3", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP3"]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.Ops.DUP4", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP4"]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.Ops.DUP5", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP5"]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.Ops.DUP6", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP6"]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.Ops.DUP7", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP7"]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.Ops.DUP8", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP8"]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.Ops.DUP9", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP9"]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.Ops.DUP10", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP10"]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.Ops.DUP11", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP11"]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.Ops.DUP12", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP12"]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.Ops.DUP13", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP13"]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.Ops.DUP14", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP14"]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.Ops.DUP15", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP15"]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.Ops.DUP16", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP16"]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.Ops.SWAP1", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP1"]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.Ops.SWAP2", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP2"]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.Ops.SWAP3", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP3"]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.Ops.SWAP4", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP4"]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.Ops.SWAP5", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP5"]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.Ops.SWAP6", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP6"]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.Ops.SWAP7", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP7"]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.Ops.SWAP8", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP8"]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.Ops.SWAP9", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP9"]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.Ops.SWAP10", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP10"]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.Ops.SWAP11", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP11"]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.Ops.SWAP12", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP12"]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.Ops.SWAP13", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP13"]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.Ops.SWAP14", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP14"]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.Ops.SWAP15", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP15"]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.Ops.SWAP16", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP16"]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.Ops.MLOAD", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["MLOAD"]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.Ops.MSTORE", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["MSTORE"]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.Ops.MSTORE8", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["MSTORE8"]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.Ops.MSIZE", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["MSIZE"]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.Ops.LOG0", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["LOG0"]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.Ops.LOG1", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["LOG1"]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.Ops.LOG2", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["LOG2"]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.Ops.LOG3", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["LOG3"]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.Ops.LOG4", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["LOG4"]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.Ops.CREATE", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["CREATE"]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.Ops.RETURN", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["RETURN"]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.Ops.CALL", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["CALL"]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.Ops.CALLCODE", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["CALLCODE"]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.Ops.DELEGATECALL", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DELEGATECALL"]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.Ops.SELFDESTRUCT", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SELFDESTRUCT"]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.op_implementation", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["op_implementation"]}}, {"source": {"identifier": "ethereum_optimized", "specifier": 0, "path": "src/ethereum_optimized/__init__.py"}, "content": {"type": ["module"], "name": ["ethereum_optimized"], "text": ["Optimized Implementations ^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction This module contains alternative implementations of routines in the spec that have been optimized for speed rather than clarity. They can be monkey patched in during start up by calling the  monkey_patch() function."]}}, {"source": {"identifier": "ethereum_optimized.monkey_patch", "specifier": 0, "path": "src/ethereum_optimized/__init__.py"}, "content": {"type": ["function"], "name": ["monkey_patch"], "text": ["Apply all monkey patches to the specification."]}}, {"source": {"identifier": "ethereum.paris.vm.precompiled_contracts.ripemd160", "specifier": 0, "path": "src/ethereum/paris/vm/precompiled_contracts/ripemd160.py"}, "content": {"type": ["module"], "name": ["ethereum.paris.vm.precompiled_contracts.ripemd160"], "text": ["Ethereum Virtual Machine (EVM) RIPEMD160 PRECOMPILED CONTRACT ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementation of the  RIPEMD160  precompiled contract."]}}, {"source": {"identifier": "ethereum.paris.vm.precompiled_contracts.ripemd160.ripemd160", "specifier": 0, "path": "src/ethereum/paris/vm/precompiled_contracts/ripemd160.py"}, "content": {"type": ["function"], "name": ["ripemd160"], "text": ["Writes the ripemd160 hash to output. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum_optimized.spurious_dragon", "specifier": 0, "path": "src/ethereum_optimized/spurious_dragon/__init__.py"}, "content": {"type": ["module"], "name": ["ethereum_optimized.spurious_dragon"], "text": ["Optimized Implementations (Spurious Dragon) ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local:"]}}, {"source": {"identifier": "ethereum_optimized.spurious_dragon.monkey_patch_optimized_state_db", "specifier": 0, "path": "src/ethereum_optimized/spurious_dragon/__init__.py"}, "content": {"type": ["function"], "name": ["monkey_patch_optimized_state_db"], "text": ["Replace the state interface with one that supports high performance updates and storing state in a database. This function must be called before the state interface is imported anywhere."]}}, {"source": {"identifier": "ethereum_optimized.spurious_dragon.monkey_patch_optimized_spec", "specifier": 0, "path": "src/ethereum_optimized/spurious_dragon/__init__.py"}, "content": {"type": ["function"], "name": ["monkey_patch_optimized_spec"], "text": ["Replace the ethash implementation with one that supports higher performance. This function must be called before the spec interface is imported anywhere."]}}, {"source": {"identifier": "ethereum_optimized.spurious_dragon.monkey_patch", "specifier": 0, "path": "src/ethereum_optimized/spurious_dragon/__init__.py"}, "content": {"type": ["function"], "name": ["monkey_patch"], "text": ["Apply all monkey patches to swap in high performance implementations. This function must be called before any of the ethereum modules are imported anywhere."]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.control_flow", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/control_flow.py"}, "content": {"type": ["module"], "name": ["ethereum.homestead.vm.instructions.control_flow"], "text": ["Ethereum Virtual Machine (EVM) Control Flow Instructions ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementations of the EVM control flow instructions."]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.control_flow.stop", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/control_flow.py"}, "content": {"type": ["function"], "name": ["stop"], "text": ["Stop further execution of EVM code. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.control_flow.jump", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/control_flow.py"}, "content": {"type": ["function"], "name": ["jump"], "text": ["Alter the program counter to the location specified by the top of the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.control_flow.jumpi", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/control_flow.py"}, "content": {"type": ["function"], "name": ["jumpi"], "text": ["Alter the program counter to the specified location if and only if a condition is true. If the condition is not true, then the program counter would increase only by 1. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.control_flow.pc", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/control_flow.py"}, "content": {"type": ["function"], "name": ["pc"], "text": ["Push onto the stack the value of the program counter after reaching the current instruction and without increasing it for the next instruction. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.control_flow.gas_left", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/control_flow.py"}, "content": {"type": ["function"], "name": ["gas_left"], "text": ["Push the amount of available gas (including the corresponding reduction for the cost of this instruction) onto the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.control_flow.jumpdest", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/control_flow.py"}, "content": {"type": ["function"], "name": ["jumpdest"], "text": ["Mark a valid destination for jumps. This is a noop, present only to be used by  JUMP  and  JUMPI  opcodes to verify that their jump is valid. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.paris.vm.precompiled_contracts.sha256", "specifier": 0, "path": "src/ethereum/paris/vm/precompiled_contracts/sha256.py"}, "content": {"type": ["module"], "name": ["ethereum.paris.vm.precompiled_contracts.sha256"], "text": ["Ethereum Virtual Machine (EVM) SHA256 PRECOMPILED CONTRACT ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementation of the  SHA256  precompiled contract."]}}, {"source": {"identifier": "ethereum.paris.vm.precompiled_contracts.sha256.sha256", "specifier": 0, "path": "src/ethereum/paris/vm/precompiled_contracts/sha256.py"}, "content": {"type": ["function"], "name": ["sha256"], "text": ["Writes the sha256 hash to output. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.comparison", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/comparison.py"}, "content": {"type": ["module"], "name": ["ethereum.homestead.vm.instructions.comparison"], "text": ["Ethereum Virtual Machine (EVM) Comparison Instructions ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementations of the EVM Comparison instructions."]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.comparison.less_than", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/comparison.py"}, "content": {"type": ["function"], "name": ["less_than"], "text": ["Checks if the top element is less than the next top element. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.comparison.signed_less_than", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/comparison.py"}, "content": {"type": ["function"], "name": ["signed_less_than"], "text": ["Signed less-than comparison. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.comparison.greater_than", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/comparison.py"}, "content": {"type": ["function"], "name": ["greater_than"], "text": ["Checks if the top element is greater than the next top element. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.comparison.signed_greater_than", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/comparison.py"}, "content": {"type": ["function"], "name": ["signed_greater_than"], "text": ["Signed greater-than comparison. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.comparison.equal", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/comparison.py"}, "content": {"type": ["function"], "name": ["equal"], "text": ["Checks if the top element is equal to the next top element. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.comparison.is_zero", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/comparison.py"}, "content": {"type": ["function"], "name": ["is_zero"], "text": ["Checks if the top element is equal to 0. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.paris.vm.precompiled_contracts.modexp", "specifier": 0, "path": "src/ethereum/paris/vm/precompiled_contracts/modexp.py"}, "content": {"type": ["module"], "name": ["ethereum.paris.vm.precompiled_contracts.modexp"], "text": ["Ethereum Virtual Machine (EVM) MODEXP PRECOMPILED CONTRACT ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementation of the  MODEXP  precompiled contract."]}}, {"source": {"identifier": "ethereum.paris.vm.precompiled_contracts.modexp.GQUADDIVISOR", "specifier": 0, "path": "src/ethereum/paris/vm/precompiled_contracts/modexp.py"}, "content": {"type": ["attribute"], "name": ["GQUADDIVISOR"]}}, {"source": {"identifier": "ethereum.paris.vm.precompiled_contracts.modexp.modexp", "specifier": 0, "path": "src/ethereum/paris/vm/precompiled_contracts/modexp.py"}, "content": {"type": ["function"], "name": ["modexp"], "text": ["Calculates  (base**exp) % modulus  for arbitary sized  base ,  exp  and. modulus . The return value is the same length as the modulus."]}}, {"source": {"identifier": "ethereum.paris.vm.precompiled_contracts.modexp.complexity", "specifier": 0, "path": "src/ethereum/paris/vm/precompiled_contracts/modexp.py"}, "content": {"type": ["function"], "name": ["complexity"], "text": ["Estimate the complexity of performing a modular exponentiation. Parameters base_length : Length of the array representing the base integer. modulus_length : Length of the array representing the modulus integer. Returns complexity :  Uint Complexity of performing the operation."]}}, {"source": {"identifier": "ethereum.paris.vm.precompiled_contracts.modexp.iterations", "specifier": 0, "path": "src/ethereum/paris/vm/precompiled_contracts/modexp.py"}, "content": {"type": ["function"], "name": ["iterations"], "text": ["Calculate the number of iterations required to perform a modular exponentiation. Parameters exponent_length : Length of the array representing the exponent integer. exponent_head : First 32 bytes of the exponent (with leading zero padding if it is shorter than 32 bytes), as an unsigned integer. Returns iterations :  Uint Number of iterations."]}}, {"source": {"identifier": "ethereum.paris.vm.precompiled_contracts.modexp.gas_cost", "specifier": 0, "path": "src/ethereum/paris/vm/precompiled_contracts/modexp.py"}, "content": {"type": ["function"], "name": ["gas_cost"], "text": ["Calculate the gas cost of performing a modular exponentiation. Parameters base_length : Length of the array representing the base integer. modulus_length : Length of the array representing the modulus integer. exponent_length : Length of the array representing the exponent integer. exponent_head : First 32 bytes of the exponent (with leading zero padding if it is shorter than 32 bytes), as an unsigned integer. Returns gas_cost :  Uint Gas required for performing the operation."]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.log", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/log.py"}, "content": {"type": ["module"], "name": ["ethereum.homestead.vm.instructions.log"], "text": ["Ethereum Virtual Machine (EVM) Logging Instructions ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementations of the EVM logging instructions."]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.log.log_n", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/log.py"}, "content": {"type": ["function"], "name": ["log_n"], "text": ["Appends a log entry, having  num_topics  topics, to the evm logs. This will also expand the memory if the data (required by the log entry) corresponding to the memory is not accessible. Parameters evm : The current EVM frame. num_topics : The number of topics to be included in the log entry."]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.log.log0", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/log.py"}, "content": {"type": ["attribute"], "name": ["log0"]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.log.log1", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/log.py"}, "content": {"type": ["attribute"], "name": ["log1"]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.log.log2", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/log.py"}, "content": {"type": ["attribute"], "name": ["log2"]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.log.log3", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/log.py"}, "content": {"type": ["attribute"], "name": ["log3"]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.log.log4", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/log.py"}, "content": {"type": ["attribute"], "name": ["log4"]}}, {"source": {"identifier": "ethereum.paris.vm.precompiled_contracts.ecrecover", "specifier": 0, "path": "src/ethereum/paris/vm/precompiled_contracts/ecrecover.py"}, "content": {"type": ["module"], "name": ["ethereum.paris.vm.precompiled_contracts.ecrecover"], "text": ["Ethereum Virtual Machine (EVM) ECRECOVER PRECOMPILED CONTRACT ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementation of the ECRECOVER precompiled contract."]}}, {"source": {"identifier": "ethereum.paris.vm.precompiled_contracts.ecrecover.ecrecover", "specifier": 0, "path": "src/ethereum/paris/vm/precompiled_contracts/ecrecover.py"}, "content": {"type": ["function"], "name": ["ecrecover"], "text": ["Decrypts the address using elliptic curve DSA recovery mechanism and writes the address to output. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.storage", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/storage.py"}, "content": {"type": ["module"], "name": ["ethereum.homestead.vm.instructions.storage"], "text": ["Ethereum Virtual Machine (EVM) Storage Instructions ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementations of the EVM storage related instructions."]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.storage.sload", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/storage.py"}, "content": {"type": ["function"], "name": ["sload"], "text": ["Loads to the stack, the value corresponding to a certain key from the storage of the current account. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.storage.sstore", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/storage.py"}, "content": {"type": ["function"], "name": ["sstore"], "text": ["Stores a value at a certain key in the current context's storage. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.paris.vm.precompiled_contracts.identity", "specifier": 0, "path": "src/ethereum/paris/vm/precompiled_contracts/identity.py"}, "content": {"type": ["module"], "name": ["ethereum.paris.vm.precompiled_contracts.identity"], "text": ["Ethereum Virtual Machine (EVM) IDENTITY PRECOMPILED CONTRACT ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementation of the  IDENTITY  precompiled contract."]}}, {"source": {"identifier": "ethereum.paris.vm.precompiled_contracts.identity.identity", "specifier": 0, "path": "src/ethereum/paris/vm/precompiled_contracts/identity.py"}, "content": {"type": ["function"], "name": ["identity"], "text": ["Writes the message data to output. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.block", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/block.py"}, "content": {"type": ["module"], "name": ["ethereum.homestead.vm.instructions.block"], "text": ["Ethereum Virtual Machine (EVM) Block Instructions ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementations of the EVM block instructions."]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.block.block_hash", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/block.py"}, "content": {"type": ["function"], "name": ["block_hash"], "text": ["Push the hash of one of the 256 most recent complete blocks onto the stack. The block number to hash is present at the top of the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.block.coinbase", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/block.py"}, "content": {"type": ["function"], "name": ["coinbase"], "text": ["Push the current block's beneficiary address (address of the block miner) onto the stack. Here the current block refers to the block in which the currently executing transaction/call resides. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.block.timestamp", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/block.py"}, "content": {"type": ["function"], "name": ["timestamp"], "text": ["Push the current block's timestamp onto the stack. Here the timestamp being referred is actually the unix timestamp in seconds. Here the current block refers to the block in which the currently executing transaction/call resides. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.block.number", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/block.py"}, "content": {"type": ["function"], "name": ["number"], "text": ["Push the current block's number onto the stack. Here the current block refers to the block in which the currently executing transaction/call resides. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.block.difficulty", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/block.py"}, "content": {"type": ["function"], "name": ["difficulty"], "text": ["Push the current block's difficulty onto the stack. Here the current block refers to the block in which the currently executing transaction/call resides. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.block.gas_limit", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/block.py"}, "content": {"type": ["function"], "name": ["gas_limit"], "text": ["Push the current block's gas limit onto the stack. Here the current block refers to the block in which the currently executing transaction/call resides. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.memory", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/memory.py"}, "content": {"type": ["module"], "name": ["ethereum.paris.vm.instructions.memory"], "text": ["Ethereum Virtual Machine (EVM) Memory Instructions ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementations of the EVM Memory instructions."]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.memory.mstore", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/memory.py"}, "content": {"type": ["function"], "name": ["mstore"], "text": ["Stores a word to memory. This also expands the memory, if the memory is insufficient to store the word. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.memory.mstore8", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/memory.py"}, "content": {"type": ["function"], "name": ["mstore8"], "text": ["Stores a byte to memory. This also expands the memory, if the memory is insufficient to store the word. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.memory.mload", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/memory.py"}, "content": {"type": ["function"], "name": ["mload"], "text": ["Load word from memory. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.memory.msize", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/memory.py"}, "content": {"type": ["function"], "name": ["msize"], "text": ["Push the size of active memory in bytes onto the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.arithmetic", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/arithmetic.py"}, "content": {"type": ["module"], "name": ["ethereum.homestead.vm.instructions.arithmetic"], "text": ["Ethereum Virtual Machine (EVM) Arithmetic Instructions ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementations of the EVM Arithmetic instructions."]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.arithmetic.add", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/arithmetic.py"}, "content": {"type": ["function"], "name": ["add"], "text": ["Adds the top two elements of the stack together, and pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.arithmetic.sub", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/arithmetic.py"}, "content": {"type": ["function"], "name": ["sub"], "text": ["Subtracts the top two elements of the stack, and pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.arithmetic.mul", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/arithmetic.py"}, "content": {"type": ["function"], "name": ["mul"], "text": ["Multiply the top two elements of the stack, and pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.arithmetic.div", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/arithmetic.py"}, "content": {"type": ["function"], "name": ["div"], "text": ["Integer division of the top two elements of the stack. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.arithmetic.sdiv", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/arithmetic.py"}, "content": {"type": ["function"], "name": ["sdiv"], "text": ["Signed integer division of the top two elements of the stack. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.arithmetic.mod", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/arithmetic.py"}, "content": {"type": ["function"], "name": ["mod"], "text": ["Modulo remainder of the top two elements of the stack. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.arithmetic.smod", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/arithmetic.py"}, "content": {"type": ["function"], "name": ["smod"], "text": ["Signed modulo remainder of the top two elements of the stack. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.arithmetic.addmod", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/arithmetic.py"}, "content": {"type": ["function"], "name": ["addmod"], "text": ["Modulo addition of the top 2 elements with the 3rd element. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.arithmetic.mulmod", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/arithmetic.py"}, "content": {"type": ["function"], "name": ["mulmod"], "text": ["Modulo multiplication of the top 2 elements with the 3rd element. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.arithmetic.exp", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/arithmetic.py"}, "content": {"type": ["function"], "name": ["exp"], "text": ["Exponential operation of the top 2 elements. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.arithmetic.signextend", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/arithmetic.py"}, "content": {"type": ["function"], "name": ["signextend"], "text": ["Sign extend operation. In other words, extend a signed number which fits in N bytes to 32 bytes. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.system", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/system.py"}, "content": {"type": ["module"], "name": ["ethereum.paris.vm.instructions.system"], "text": ["Ethereum Virtual Machine (EVM) System Instructions ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementations of the EVM system related instructions."]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.system.generic_create", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/system.py"}, "content": {"type": ["function"], "name": ["generic_create"], "text": ["Core logic used by the  CREATE*  family of opcodes."]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.system.create", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/system.py"}, "content": {"type": ["function"], "name": ["create"], "text": ["Creates a new account with associated code. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.system.create2", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/system.py"}, "content": {"type": ["function"], "name": ["create2"], "text": ["Creates a new account with associated code. It's similar to CREATE opcode except that the address of new account depends on the init_code instead of the nonce of sender. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.system.return_", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/system.py"}, "content": {"type": ["function"], "name": ["return_"], "text": ["Halts execution returning output data. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.system.generic_call", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/system.py"}, "content": {"type": ["function"], "name": ["generic_call"], "text": ["Perform the core logic of the  CALL*  family of opcodes."]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.system.call", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/system.py"}, "content": {"type": ["function"], "name": ["call"], "text": ["Message-call into an account. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.system.callcode", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/system.py"}, "content": {"type": ["function"], "name": ["callcode"], "text": ["Message-call into this account with alternative account\u2019s code. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.system.selfdestruct", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/system.py"}, "content": {"type": ["function"], "name": ["selfdestruct"], "text": ["Halt execution and register account for later deletion. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.system.delegatecall", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/system.py"}, "content": {"type": ["function"], "name": ["delegatecall"], "text": ["Message-call into an account. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.system.staticcall", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/system.py"}, "content": {"type": ["function"], "name": ["staticcall"], "text": ["Message-call into an account. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.system.revert", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/system.py"}, "content": {"type": ["function"], "name": ["revert"], "text": ["Stop execution and revert state changes, without consuming all provided gas and also has the ability to return a reason Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.keccak", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/keccak.py"}, "content": {"type": ["module"], "name": ["ethereum.homestead.vm.instructions.keccak"], "text": ["Ethereum Virtual Machine (EVM) Keccak Instructions ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementations of the EVM keccak instructions."]}}, {"source": {"identifier": "ethereum.homestead.vm.instructions.keccak.keccak", "specifier": 0, "path": "src/ethereum/homestead/vm/instructions/keccak.py"}, "content": {"type": ["function"], "name": ["keccak"], "text": ["Pushes to the stack the Keccak-256 hash of a region of memory. This also expands the memory, in case the memory is insufficient to access the data's memory location. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.log", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/log.py"}, "content": {"type": ["module"], "name": ["ethereum.tangerine_whistle.vm.instructions.log"], "text": ["Ethereum Virtual Machine (EVM) Logging Instructions ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementations of the EVM logging instructions."]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.log.log_n", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/log.py"}, "content": {"type": ["function"], "name": ["log_n"], "text": ["Appends a log entry, having  num_topics  topics, to the evm logs. This will also expand the memory if the data (required by the log entry) corresponding to the memory is not accessible. Parameters evm : The current EVM frame. num_topics : The number of topics to be included in the log entry."]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.log.log0", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/log.py"}, "content": {"type": ["attribute"], "name": ["log0"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.log.log1", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/log.py"}, "content": {"type": ["attribute"], "name": ["log1"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.log.log2", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/log.py"}, "content": {"type": ["attribute"], "name": ["log2"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.log.log3", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/log.py"}, "content": {"type": ["attribute"], "name": ["log3"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.log.log4", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/log.py"}, "content": {"type": ["attribute"], "name": ["log4"]}}, {"source": {"identifier": "ethereum.london.vm.precompiled_contracts", "specifier": 0, "path": "src/ethereum/london/vm/precompiled_contracts/__init__.py"}, "content": {"type": ["module"], "name": ["ethereum.london.vm.precompiled_contracts"], "text": ["Precompiled Contract Addresses ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Addresses of precompiled contracts and mappings to their implementations."]}}, {"source": {"identifier": "ethereum.london.vm.precompiled_contracts.__all__", "specifier": 0, "path": "src/ethereum/london/vm/precompiled_contracts/__init__.py"}, "content": {"type": ["attribute"], "name": ["__all__"]}}, {"source": {"identifier": "ethereum.london.vm.precompiled_contracts.ECRECOVER_ADDRESS", "specifier": 0, "path": "src/ethereum/london/vm/precompiled_contracts/__init__.py"}, "content": {"type": ["attribute"], "name": ["ECRECOVER_ADDRESS"]}}, {"source": {"identifier": "ethereum.london.vm.precompiled_contracts.SHA256_ADDRESS", "specifier": 0, "path": "src/ethereum/london/vm/precompiled_contracts/__init__.py"}, "content": {"type": ["attribute"], "name": ["SHA256_ADDRESS"]}}, {"source": {"identifier": "ethereum.london.vm.precompiled_contracts.RIPEMD160_ADDRESS", "specifier": 0, "path": "src/ethereum/london/vm/precompiled_contracts/__init__.py"}, "content": {"type": ["attribute"], "name": ["RIPEMD160_ADDRESS"]}}, {"source": {"identifier": "ethereum.london.vm.precompiled_contracts.IDENTITY_ADDRESS", "specifier": 0, "path": "src/ethereum/london/vm/precompiled_contracts/__init__.py"}, "content": {"type": ["attribute"], "name": ["IDENTITY_ADDRESS"]}}, {"source": {"identifier": "ethereum.london.vm.precompiled_contracts.MODEXP_ADDRESS", "specifier": 0, "path": "src/ethereum/london/vm/precompiled_contracts/__init__.py"}, "content": {"type": ["attribute"], "name": ["MODEXP_ADDRESS"]}}, {"source": {"identifier": "ethereum.london.vm.precompiled_contracts.ALT_BN128_ADD_ADDRESS", "specifier": 0, "path": "src/ethereum/london/vm/precompiled_contracts/__init__.py"}, "content": {"type": ["attribute"], "name": ["ALT_BN128_ADD_ADDRESS"]}}, {"source": {"identifier": "ethereum.london.vm.precompiled_contracts.ALT_BN128_MUL_ADDRESS", "specifier": 0, "path": "src/ethereum/london/vm/precompiled_contracts/__init__.py"}, "content": {"type": ["attribute"], "name": ["ALT_BN128_MUL_ADDRESS"]}}, {"source": {"identifier": "ethereum.london.vm.precompiled_contracts.ALT_BN128_PAIRING_CHECK_ADDRESS", "specifier": 0, "path": "src/ethereum/london/vm/precompiled_contracts/__init__.py"}, "content": {"type": ["attribute"], "name": ["ALT_BN128_PAIRING_CHECK_ADDRESS"]}}, {"source": {"identifier": "ethereum.london.vm.precompiled_contracts.BLAKE2F_ADDRESS", "specifier": 0, "path": "src/ethereum/london/vm/precompiled_contracts/__init__.py"}, "content": {"type": ["attribute"], "name": ["BLAKE2F_ADDRESS"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.storage", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/storage.py"}, "content": {"type": ["module"], "name": ["ethereum.tangerine_whistle.vm.instructions.storage"], "text": ["Ethereum Virtual Machine (EVM) Storage Instructions ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementations of the EVM storage related instructions."]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.storage.sload", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/storage.py"}, "content": {"type": ["function"], "name": ["sload"], "text": ["Loads to the stack, the value corresponding to a certain key from the storage of the current account. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.storage.sstore", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/storage.py"}, "content": {"type": ["function"], "name": ["sstore"], "text": ["Stores a value at a certain key in the current context's storage. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.london.vm.precompiled_contracts.alt_bn128", "specifier": 0, "path": "src/ethereum/london/vm/precompiled_contracts/alt_bn128.py"}, "content": {"type": ["module"], "name": ["ethereum.london.vm.precompiled_contracts.alt_bn128"], "text": ["Ethereum Virtual Machine (EVM) ALT_BN128 CONTRACTS ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementation of the ALT_BN128 precompiled contracts."]}}, {"source": {"identifier": "ethereum.london.vm.precompiled_contracts.alt_bn128.alt_bn128_add", "specifier": 0, "path": "src/ethereum/london/vm/precompiled_contracts/alt_bn128.py"}, "content": {"type": ["function"], "name": ["alt_bn128_add"], "text": ["The ALT_BN128 addition precompiled contract. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.london.vm.precompiled_contracts.alt_bn128.alt_bn128_mul", "specifier": 0, "path": "src/ethereum/london/vm/precompiled_contracts/alt_bn128.py"}, "content": {"type": ["function"], "name": ["alt_bn128_mul"], "text": ["The ALT_BN128 multiplication precompiled contract. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.london.vm.precompiled_contracts.alt_bn128.alt_bn128_pairing_check", "specifier": 0, "path": "src/ethereum/london/vm/precompiled_contracts/alt_bn128.py"}, "content": {"type": ["function"], "name": ["alt_bn128_pairing_check"], "text": ["The ALT_BN128 pairing check precompiled contract. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.block", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/block.py"}, "content": {"type": ["module"], "name": ["ethereum.tangerine_whistle.vm.instructions.block"], "text": ["Ethereum Virtual Machine (EVM) Block Instructions ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementations of the EVM block instructions."]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.block.block_hash", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/block.py"}, "content": {"type": ["function"], "name": ["block_hash"], "text": ["Push the hash of one of the 256 most recent complete blocks onto the stack. The block number to hash is present at the top of the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.block.coinbase", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/block.py"}, "content": {"type": ["function"], "name": ["coinbase"], "text": ["Push the current block's beneficiary address (address of the block miner) onto the stack. Here the current block refers to the block in which the currently executing transaction/call resides. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.block.timestamp", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/block.py"}, "content": {"type": ["function"], "name": ["timestamp"], "text": ["Push the current block's timestamp onto the stack. Here the timestamp being referred is actually the unix timestamp in seconds. Here the current block refers to the block in which the currently executing transaction/call resides. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.block.number", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/block.py"}, "content": {"type": ["function"], "name": ["number"], "text": ["Push the current block's number onto the stack. Here the current block refers to the block in which the currently executing transaction/call resides. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.block.difficulty", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/block.py"}, "content": {"type": ["function"], "name": ["difficulty"], "text": ["Push the current block's difficulty onto the stack. Here the current block refers to the block in which the currently executing transaction/call resides. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.block.gas_limit", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/block.py"}, "content": {"type": ["function"], "name": ["gas_limit"], "text": ["Push the current block's gas limit onto the stack. Here the current block refers to the block in which the currently executing transaction/call resides. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.london.vm.precompiled_contracts.ripemd160", "specifier": 0, "path": "src/ethereum/london/vm/precompiled_contracts/ripemd160.py"}, "content": {"type": ["module"], "name": ["ethereum.london.vm.precompiled_contracts.ripemd160"], "text": ["Ethereum Virtual Machine (EVM) RIPEMD160 PRECOMPILED CONTRACT ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementation of the  RIPEMD160  precompiled contract."]}}, {"source": {"identifier": "ethereum.london.vm.precompiled_contracts.ripemd160.ripemd160", "specifier": 0, "path": "src/ethereum/london/vm/precompiled_contracts/ripemd160.py"}, "content": {"type": ["function"], "name": ["ripemd160"], "text": ["Writes the ripemd160 hash to output. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.arithmetic", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/arithmetic.py"}, "content": {"type": ["module"], "name": ["ethereum.tangerine_whistle.vm.instructions.arithmetic"], "text": ["Ethereum Virtual Machine (EVM) Arithmetic Instructions ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementations of the EVM Arithmetic instructions."]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.arithmetic.add", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/arithmetic.py"}, "content": {"type": ["function"], "name": ["add"], "text": ["Adds the top two elements of the stack together, and pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.arithmetic.sub", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/arithmetic.py"}, "content": {"type": ["function"], "name": ["sub"], "text": ["Subtracts the top two elements of the stack, and pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.arithmetic.mul", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/arithmetic.py"}, "content": {"type": ["function"], "name": ["mul"], "text": ["Multiply the top two elements of the stack, and pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.arithmetic.div", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/arithmetic.py"}, "content": {"type": ["function"], "name": ["div"], "text": ["Integer division of the top two elements of the stack. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.arithmetic.sdiv", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/arithmetic.py"}, "content": {"type": ["function"], "name": ["sdiv"], "text": ["Signed integer division of the top two elements of the stack. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.arithmetic.mod", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/arithmetic.py"}, "content": {"type": ["function"], "name": ["mod"], "text": ["Modulo remainder of the top two elements of the stack. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.arithmetic.smod", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/arithmetic.py"}, "content": {"type": ["function"], "name": ["smod"], "text": ["Signed modulo remainder of the top two elements of the stack. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.arithmetic.addmod", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/arithmetic.py"}, "content": {"type": ["function"], "name": ["addmod"], "text": ["Modulo addition of the top 2 elements with the 3rd element. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.arithmetic.mulmod", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/arithmetic.py"}, "content": {"type": ["function"], "name": ["mulmod"], "text": ["Modulo multiplication of the top 2 elements with the 3rd element. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.arithmetic.exp", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/arithmetic.py"}, "content": {"type": ["function"], "name": ["exp"], "text": ["Exponential operation of the top 2 elements. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.arithmetic.signextend", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/arithmetic.py"}, "content": {"type": ["function"], "name": ["signextend"], "text": ["Sign extend operation. In other words, extend a signed number which fits in N bytes to 32 bytes. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.london.vm.precompiled_contracts.sha256", "specifier": 0, "path": "src/ethereum/london/vm/precompiled_contracts/sha256.py"}, "content": {"type": ["module"], "name": ["ethereum.london.vm.precompiled_contracts.sha256"], "text": ["Ethereum Virtual Machine (EVM) SHA256 PRECOMPILED CONTRACT ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementation of the  SHA256  precompiled contract."]}}, {"source": {"identifier": "ethereum.london.vm.precompiled_contracts.sha256.sha256", "specifier": 0, "path": "src/ethereum/london/vm/precompiled_contracts/sha256.py"}, "content": {"type": ["function"], "name": ["sha256"], "text": ["Writes the sha256 hash to output. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.keccak", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/keccak.py"}, "content": {"type": ["module"], "name": ["ethereum.tangerine_whistle.vm.instructions.keccak"], "text": ["Ethereum Virtual Machine (EVM) Keccak Instructions ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementations of the EVM keccak instructions."]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.keccak.keccak", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/keccak.py"}, "content": {"type": ["function"], "name": ["keccak"], "text": ["Pushes to the stack the Keccak-256 hash of a region of memory. This also expands the memory, in case the memory is insufficient to access the data's memory location. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.london.vm.precompiled_contracts.modexp", "specifier": 0, "path": "src/ethereum/london/vm/precompiled_contracts/modexp.py"}, "content": {"type": ["module"], "name": ["ethereum.london.vm.precompiled_contracts.modexp"], "text": ["Ethereum Virtual Machine (EVM) MODEXP PRECOMPILED CONTRACT ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementation of the  MODEXP  precompiled contract."]}}, {"source": {"identifier": "ethereum.london.vm.precompiled_contracts.modexp.GQUADDIVISOR", "specifier": 0, "path": "src/ethereum/london/vm/precompiled_contracts/modexp.py"}, "content": {"type": ["attribute"], "name": ["GQUADDIVISOR"]}}, {"source": {"identifier": "ethereum.london.vm.precompiled_contracts.modexp.modexp", "specifier": 0, "path": "src/ethereum/london/vm/precompiled_contracts/modexp.py"}, "content": {"type": ["function"], "name": ["modexp"], "text": ["Calculates  (base**exp) % modulus  for arbitary sized  base ,  exp  and. modulus . The return value is the same length as the modulus."]}}, {"source": {"identifier": "ethereum.london.vm.precompiled_contracts.modexp.complexity", "specifier": 0, "path": "src/ethereum/london/vm/precompiled_contracts/modexp.py"}, "content": {"type": ["function"], "name": ["complexity"], "text": ["Estimate the complexity of performing a modular exponentiation. Parameters base_length : Length of the array representing the base integer. modulus_length : Length of the array representing the modulus integer. Returns complexity :  Uint Complexity of performing the operation."]}}, {"source": {"identifier": "ethereum.london.vm.precompiled_contracts.modexp.iterations", "specifier": 0, "path": "src/ethereum/london/vm/precompiled_contracts/modexp.py"}, "content": {"type": ["function"], "name": ["iterations"], "text": ["Calculate the number of iterations required to perform a modular exponentiation. Parameters exponent_length : Length of the array representing the exponent integer. exponent_head : First 32 bytes of the exponent (with leading zero padding if it is shorter than 32 bytes), as an unsigned integer. Returns iterations :  Uint Number of iterations."]}}, {"source": {"identifier": "ethereum.london.vm.precompiled_contracts.modexp.gas_cost", "specifier": 0, "path": "src/ethereum/london/vm/precompiled_contracts/modexp.py"}, "content": {"type": ["function"], "name": ["gas_cost"], "text": ["Calculate the gas cost of performing a modular exponentiation. Parameters base_length : Length of the array representing the base integer. modulus_length : Length of the array representing the modulus integer. exponent_length : Length of the array representing the exponent integer. exponent_head : First 32 bytes of the exponent (with leading zero padding if it is shorter than 32 bytes), as an unsigned integer. Returns gas_cost :  Uint Gas required for performing the operation."]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.bitwise", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/bitwise.py"}, "content": {"type": ["module"], "name": ["ethereum.tangerine_whistle.vm.instructions.bitwise"], "text": ["Ethereum Virtual Machine (EVM) Bitwise Instructions ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementations of the EVM bitwise instructions."]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.bitwise.bitwise_and", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/bitwise.py"}, "content": {"type": ["function"], "name": ["bitwise_and"], "text": ["Bitwise AND operation of the top 2 elements of the stack. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.bitwise.bitwise_or", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/bitwise.py"}, "content": {"type": ["function"], "name": ["bitwise_or"], "text": ["Bitwise OR operation of the top 2 elements of the stack. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.bitwise.bitwise_xor", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/bitwise.py"}, "content": {"type": ["function"], "name": ["bitwise_xor"], "text": ["Bitwise XOR operation of the top 2 elements of the stack. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.bitwise.bitwise_not", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/bitwise.py"}, "content": {"type": ["function"], "name": ["bitwise_not"], "text": ["Bitwise NOT operation of the top element of the stack. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.bitwise.get_byte", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/bitwise.py"}, "content": {"type": ["function"], "name": ["get_byte"], "text": ["For a word (defined by next top element of the stack), retrieve the Nth byte (0-indexed and defined by top element of stack) from the left (most significant) to right (least significant). Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.london.vm.precompiled_contracts.ecrecover", "specifier": 0, "path": "src/ethereum/london/vm/precompiled_contracts/ecrecover.py"}, "content": {"type": ["module"], "name": ["ethereum.london.vm.precompiled_contracts.ecrecover"], "text": ["Ethereum Virtual Machine (EVM) ECRECOVER PRECOMPILED CONTRACT ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementation of the ECRECOVER precompiled contract."]}}, {"source": {"identifier": "ethereum.london.vm.precompiled_contracts.ecrecover.ecrecover", "specifier": 0, "path": "src/ethereum/london/vm/precompiled_contracts/ecrecover.py"}, "content": {"type": ["function"], "name": ["ecrecover"], "text": ["Decrypts the address using elliptic curve DSA recovery mechanism and writes the address to output. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.environment", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/environment.py"}, "content": {"type": ["module"], "name": ["ethereum.tangerine_whistle.vm.instructions.environment"], "text": ["Ethereum Virtual Machine (EVM) Environmental Instructions ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementations of the EVM environment related instructions."]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.environment.address", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["address"], "text": ["Pushes the address of the current executing account to the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.environment.balance", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["balance"], "text": ["Pushes the balance of the given account onto the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.environment.origin", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["origin"], "text": ["Pushes the address of the original transaction sender to the stack. The origin address can only be an EOA. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.environment.caller", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["caller"], "text": ["Pushes the address of the caller onto the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.environment.callvalue", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["callvalue"], "text": ["Push the value (in wei) sent with the call onto the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.environment.calldataload", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["calldataload"], "text": ["Push a word (32 bytes) of the input data belonging to the current environment onto the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.environment.calldatasize", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["calldatasize"], "text": ["Push the size of input data in current environment onto the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.environment.calldatacopy", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["calldatacopy"], "text": ["Copy a portion of the input data in current environment to memory. This will also expand the memory, in case that the memory is insufficient to store the data. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.environment.codesize", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["codesize"], "text": ["Push the size of code running in current environment onto the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.environment.codecopy", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["codecopy"], "text": ["Copy a portion of the code in current environment to memory. This will also expand the memory, in case that the memory is insufficient to store the data. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.environment.gasprice", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["gasprice"], "text": ["Push the gas price used in current environment onto the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.environment.extcodesize", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["extcodesize"], "text": ["Push the code size of a given account onto the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.environment.extcodecopy", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["extcodecopy"], "text": ["Copy a portion of an account's code to memory. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.london.vm.precompiled_contracts.identity", "specifier": 0, "path": "src/ethereum/london/vm/precompiled_contracts/identity.py"}, "content": {"type": ["module"], "name": ["ethereum.london.vm.precompiled_contracts.identity"], "text": ["Ethereum Virtual Machine (EVM) IDENTITY PRECOMPILED CONTRACT ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementation of the  IDENTITY  precompiled contract."]}}, {"source": {"identifier": "ethereum.london.vm.precompiled_contracts.identity.identity", "specifier": 0, "path": "src/ethereum/london/vm/precompiled_contracts/identity.py"}, "content": {"type": ["function"], "name": ["identity"], "text": ["Writes the message data to output. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.stack", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/stack.py"}, "content": {"type": ["module"], "name": ["ethereum.tangerine_whistle.vm.instructions.stack"], "text": ["Ethereum Virtual Machine (EVM) Stack Instructions ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementations of the EVM stack related instructions."]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.stack.pop", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/stack.py"}, "content": {"type": ["function"], "name": ["pop"], "text": ["Remove item from stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.stack.push_n", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/stack.py"}, "content": {"type": ["function"], "name": ["push_n"], "text": ["Pushes a N-byte immediate onto the stack. Parameters evm : The current EVM frame. num_bytes : The number of immediate bytes to be read from the code and pushed to the stack."]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.stack.dup_n", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/stack.py"}, "content": {"type": ["function"], "name": ["dup_n"], "text": ["Duplicate the Nth stack item (from top of the stack) to the top of stack. Parameters evm : The current EVM frame. item_number : The stack item number (0-indexed from top of stack) to be duplicated to the top of stack."]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.stack.swap_n", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/stack.py"}, "content": {"type": ["function"], "name": ["swap_n"], "text": ["Swap the top and the  item_number  element of the stack, where the top of the stack is position zero. If  item_number  is zero, this function does nothing (which should not be possible, since there is no  SWAP0  instruction). Parameters evm : The current EVM frame. item_number : The stack item number (0-indexed from top of stack) to be swapped with the top of stack element."]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.stack.push1", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push1"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.stack.push2", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push2"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.stack.push3", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push3"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.stack.push4", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push4"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.stack.push5", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push5"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.stack.push6", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push6"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.stack.push7", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push7"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.stack.push8", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push8"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.stack.push9", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push9"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.stack.push10", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push10"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.stack.push11", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push11"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.stack.push12", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push12"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.stack.push13", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push13"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.stack.push14", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push14"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.stack.push15", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push15"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.stack.push16", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push16"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.stack.push17", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push17"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.stack.push18", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push18"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.stack.push19", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push19"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.stack.push20", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push20"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.stack.push21", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push21"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.stack.push22", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push22"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.stack.push23", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push23"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.stack.push24", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push24"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.stack.push25", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push25"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.stack.push26", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push26"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.stack.push27", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push27"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.stack.push28", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push28"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.stack.push29", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push29"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.stack.push30", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push30"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.stack.push31", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push31"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.stack.push32", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push32"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.stack.dup1", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup1"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.stack.dup2", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup2"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.stack.dup3", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup3"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.stack.dup4", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup4"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.stack.dup5", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup5"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.stack.dup6", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup6"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.stack.dup7", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup7"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.stack.dup8", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup8"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.stack.dup9", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup9"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.stack.dup10", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup10"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.stack.dup11", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup11"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.stack.dup12", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup12"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.stack.dup13", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup13"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.stack.dup14", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup14"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.stack.dup15", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup15"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.stack.dup16", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup16"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.stack.swap1", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap1"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.stack.swap2", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap2"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.stack.swap3", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap3"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.stack.swap4", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap4"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.stack.swap5", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap5"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.stack.swap6", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap6"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.stack.swap7", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap7"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.stack.swap8", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap8"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.stack.swap9", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap9"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.stack.swap10", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap10"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.stack.swap11", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap11"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.stack.swap12", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap12"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.stack.swap13", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap13"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.stack.swap14", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap14"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.stack.swap15", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap15"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.vm.instructions.stack.swap16", "specifier": 0, "path": "src/ethereum/tangerine_whistle/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap16"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.memory", "specifier": 0, "path": "src/ethereum/london/vm/instructions/memory.py"}, "content": {"type": ["module"], "name": ["ethereum.london.vm.instructions.memory"], "text": ["Ethereum Virtual Machine (EVM) Memory Instructions ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementations of the EVM Memory instructions."]}}, {"source": {"identifier": "ethereum.london.vm.instructions.memory.mstore", "specifier": 0, "path": "src/ethereum/london/vm/instructions/memory.py"}, "content": {"type": ["function"], "name": ["mstore"], "text": ["Stores a word to memory. This also expands the memory, if the memory is insufficient to store the word. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.london.vm.instructions.memory.mstore8", "specifier": 0, "path": "src/ethereum/london/vm/instructions/memory.py"}, "content": {"type": ["function"], "name": ["mstore8"], "text": ["Stores a byte to memory. This also expands the memory, if the memory is insufficient to store the word. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.london.vm.instructions.memory.mload", "specifier": 0, "path": "src/ethereum/london/vm/instructions/memory.py"}, "content": {"type": ["function"], "name": ["mload"], "text": ["Load word from memory. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.london.vm.instructions.memory.msize", "specifier": 0, "path": "src/ethereum/london/vm/instructions/memory.py"}, "content": {"type": ["function"], "name": ["msize"], "text": ["Push the size of active memory in bytes onto the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.tangerine_whistle.utils", "specifier": 0, "path": "src/ethereum/tangerine_whistle/utils/__init__.py"}, "content": {"type": ["module"], "name": ["ethereum.tangerine_whistle.utils"], "text": ["Hardfork Utility Functions ^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Utility functions used in this tangerine whistle version of specification."]}}, {"source": {"identifier": "ethereum.london.vm.instructions.system", "specifier": 0, "path": "src/ethereum/london/vm/instructions/system.py"}, "content": {"type": ["module"], "name": ["ethereum.london.vm.instructions.system"], "text": ["Ethereum Virtual Machine (EVM) System Instructions ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementations of the EVM system related instructions."]}}, {"source": {"identifier": "ethereum.london.vm.instructions.system.generic_create", "specifier": 0, "path": "src/ethereum/london/vm/instructions/system.py"}, "content": {"type": ["function"], "name": ["generic_create"], "text": ["Core logic used by the  CREATE*  family of opcodes."]}}, {"source": {"identifier": "ethereum.london.vm.instructions.system.create", "specifier": 0, "path": "src/ethereum/london/vm/instructions/system.py"}, "content": {"type": ["function"], "name": ["create"], "text": ["Creates a new account with associated code. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.london.vm.instructions.system.create2", "specifier": 0, "path": "src/ethereum/london/vm/instructions/system.py"}, "content": {"type": ["function"], "name": ["create2"], "text": ["Creates a new account with associated code. It's similar to CREATE opcode except that the address of new account depends on the init_code instead of the nonce of sender. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.london.vm.instructions.system.return_", "specifier": 0, "path": "src/ethereum/london/vm/instructions/system.py"}, "content": {"type": ["function"], "name": ["return_"], "text": ["Halts execution returning output data. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.london.vm.instructions.system.generic_call", "specifier": 0, "path": "src/ethereum/london/vm/instructions/system.py"}, "content": {"type": ["function"], "name": ["generic_call"], "text": ["Perform the core logic of the  CALL*  family of opcodes."]}}, {"source": {"identifier": "ethereum.london.vm.instructions.system.call", "specifier": 0, "path": "src/ethereum/london/vm/instructions/system.py"}, "content": {"type": ["function"], "name": ["call"], "text": ["Message-call into an account. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.london.vm.instructions.system.callcode", "specifier": 0, "path": "src/ethereum/london/vm/instructions/system.py"}, "content": {"type": ["function"], "name": ["callcode"], "text": ["Message-call into this account with alternative account\u2019s code. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.london.vm.instructions.system.selfdestruct", "specifier": 0, "path": "src/ethereum/london/vm/instructions/system.py"}, "content": {"type": ["function"], "name": ["selfdestruct"], "text": ["Halt execution and register account for later deletion. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.london.vm.instructions.system.delegatecall", "specifier": 0, "path": "src/ethereum/london/vm/instructions/system.py"}, "content": {"type": ["function"], "name": ["delegatecall"], "text": ["Message-call into an account. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.london.vm.instructions.system.staticcall", "specifier": 0, "path": "src/ethereum/london/vm/instructions/system.py"}, "content": {"type": ["function"], "name": ["staticcall"], "text": ["Message-call into an account. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.london.vm.instructions.system.revert", "specifier": 0, "path": "src/ethereum/london/vm/instructions/system.py"}, "content": {"type": ["function"], "name": ["revert"], "text": ["Stop execution and revert state changes, without consuming all provided gas and also has the ability to return a reason Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.tangerine_whistle.utils.address", "specifier": 0, "path": "src/ethereum/tangerine_whistle/utils/address.py"}, "content": {"type": ["module"], "name": ["ethereum.tangerine_whistle.utils.address"], "text": ["Hardfork Utility Functions For Addresses ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Address specific functions used in this tangerine whistle version of specification."]}}, {"source": {"identifier": "ethereum.tangerine_whistle.utils.address.to_address", "specifier": 0, "path": "src/ethereum/tangerine_whistle/utils/address.py"}, "content": {"type": ["function"], "name": ["to_address"], "text": ["Convert a Uint or U256 value to a valid address (20 bytes). Parameters data : The string to be converted to bytes. Returns address :  Address The obtained address."]}}, {"source": {"identifier": "ethereum.tangerine_whistle.utils.address.compute_contract_address", "specifier": 0, "path": "src/ethereum/tangerine_whistle/utils/address.py"}, "content": {"type": ["function"], "name": ["compute_contract_address"], "text": ["Computes address of the new account that needs to be created. Parameters address : The address of the account that wants to create the new account. nonce : The transaction count of the account that wants to create the new account. Returns address:  ethereum.tangerine_whistle.fork_types.Address The computed address of the new account."]}}, {"source": {"identifier": "ethereum.london.vm.instructions", "specifier": 0, "path": "src/ethereum/london/vm/instructions/__init__.py"}, "content": {"type": ["module"], "name": ["ethereum.london.vm.instructions"], "text": ["EVM Instruction Encoding (Opcodes) ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Machine readable representations of EVM instructions, and a mapping to their implementations."]}}, {"source": {"identifier": "ethereum.london.vm.instructions.Ops", "specifier": 0, "path": "src/ethereum/london/vm/instructions/__init__.py"}, "content": {"type": ["class"], "name": ["Ops"], "text": ["Enum for EVM Opcodes"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.Ops.ADD", "specifier": 0, "path": "src/ethereum/london/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["ADD"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.Ops.MUL", "specifier": 0, "path": "src/ethereum/london/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["MUL"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.Ops.SUB", "specifier": 0, "path": "src/ethereum/london/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SUB"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.Ops.DIV", "specifier": 0, "path": "src/ethereum/london/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DIV"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.Ops.SDIV", "specifier": 0, "path": "src/ethereum/london/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SDIV"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.Ops.MOD", "specifier": 0, "path": "src/ethereum/london/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["MOD"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.Ops.SMOD", "specifier": 0, "path": "src/ethereum/london/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SMOD"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.Ops.ADDMOD", "specifier": 0, "path": "src/ethereum/london/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["ADDMOD"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.Ops.MULMOD", "specifier": 0, "path": "src/ethereum/london/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["MULMOD"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.Ops.EXP", "specifier": 0, "path": "src/ethereum/london/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["EXP"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.Ops.SIGNEXTEND", "specifier": 0, "path": "src/ethereum/london/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SIGNEXTEND"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.Ops.LT", "specifier": 0, "path": "src/ethereum/london/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["LT"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.Ops.GT", "specifier": 0, "path": "src/ethereum/london/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["GT"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.Ops.SLT", "specifier": 0, "path": "src/ethereum/london/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SLT"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.Ops.SGT", "specifier": 0, "path": "src/ethereum/london/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SGT"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.Ops.EQ", "specifier": 0, "path": "src/ethereum/london/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["EQ"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.Ops.ISZERO", "specifier": 0, "path": "src/ethereum/london/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["ISZERO"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.Ops.AND", "specifier": 0, "path": "src/ethereum/london/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["AND"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.Ops.OR", "specifier": 0, "path": "src/ethereum/london/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["OR"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.Ops.XOR", "specifier": 0, "path": "src/ethereum/london/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["XOR"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.Ops.NOT", "specifier": 0, "path": "src/ethereum/london/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["NOT"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.Ops.BYTE", "specifier": 0, "path": "src/ethereum/london/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["BYTE"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.Ops.SHL", "specifier": 0, "path": "src/ethereum/london/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SHL"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.Ops.SHR", "specifier": 0, "path": "src/ethereum/london/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SHR"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.Ops.SAR", "specifier": 0, "path": "src/ethereum/london/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SAR"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.Ops.KECCAK", "specifier": 0, "path": "src/ethereum/london/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["KECCAK"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.Ops.ADDRESS", "specifier": 0, "path": "src/ethereum/london/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["ADDRESS"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.Ops.BALANCE", "specifier": 0, "path": "src/ethereum/london/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["BALANCE"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.Ops.ORIGIN", "specifier": 0, "path": "src/ethereum/london/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["ORIGIN"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.Ops.CALLER", "specifier": 0, "path": "src/ethereum/london/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["CALLER"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.Ops.CALLVALUE", "specifier": 0, "path": "src/ethereum/london/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["CALLVALUE"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.Ops.CALLDATALOAD", "specifier": 0, "path": "src/ethereum/london/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["CALLDATALOAD"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.Ops.CALLDATASIZE", "specifier": 0, "path": "src/ethereum/london/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["CALLDATASIZE"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.Ops.CALLDATACOPY", "specifier": 0, "path": "src/ethereum/london/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["CALLDATACOPY"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.Ops.CODESIZE", "specifier": 0, "path": "src/ethereum/london/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["CODESIZE"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.Ops.CODECOPY", "specifier": 0, "path": "src/ethereum/london/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["CODECOPY"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.Ops.GASPRICE", "specifier": 0, "path": "src/ethereum/london/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["GASPRICE"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.Ops.EXTCODESIZE", "specifier": 0, "path": "src/ethereum/london/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["EXTCODESIZE"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.Ops.EXTCODECOPY", "specifier": 0, "path": "src/ethereum/london/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["EXTCODECOPY"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.Ops.RETURNDATASIZE", "specifier": 0, "path": "src/ethereum/london/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["RETURNDATASIZE"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.Ops.RETURNDATACOPY", "specifier": 0, "path": "src/ethereum/london/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["RETURNDATACOPY"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.Ops.EXTCODEHASH", "specifier": 0, "path": "src/ethereum/london/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["EXTCODEHASH"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.Ops.BLOCKHASH", "specifier": 0, "path": "src/ethereum/london/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["BLOCKHASH"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.Ops.COINBASE", "specifier": 0, "path": "src/ethereum/london/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["COINBASE"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.Ops.TIMESTAMP", "specifier": 0, "path": "src/ethereum/london/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["TIMESTAMP"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.Ops.NUMBER", "specifier": 0, "path": "src/ethereum/london/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["NUMBER"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.Ops.DIFFICULTY", "specifier": 0, "path": "src/ethereum/london/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DIFFICULTY"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.Ops.GASLIMIT", "specifier": 0, "path": "src/ethereum/london/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["GASLIMIT"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.Ops.CHAINID", "specifier": 0, "path": "src/ethereum/london/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["CHAINID"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.Ops.SELFBALANCE", "specifier": 0, "path": "src/ethereum/london/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SELFBALANCE"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.Ops.BASEFEE", "specifier": 0, "path": "src/ethereum/london/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["BASEFEE"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.Ops.STOP", "specifier": 0, "path": "src/ethereum/london/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["STOP"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.Ops.JUMP", "specifier": 0, "path": "src/ethereum/london/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["JUMP"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.Ops.JUMPI", "specifier": 0, "path": "src/ethereum/london/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["JUMPI"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.Ops.PC", "specifier": 0, "path": "src/ethereum/london/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PC"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.Ops.GAS", "specifier": 0, "path": "src/ethereum/london/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["GAS"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.Ops.JUMPDEST", "specifier": 0, "path": "src/ethereum/london/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["JUMPDEST"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.Ops.SLOAD", "specifier": 0, "path": "src/ethereum/london/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SLOAD"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.Ops.SSTORE", "specifier": 0, "path": "src/ethereum/london/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SSTORE"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.Ops.POP", "specifier": 0, "path": "src/ethereum/london/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["POP"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.Ops.PUSH1", "specifier": 0, "path": "src/ethereum/london/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH1"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.Ops.PUSH2", "specifier": 0, "path": "src/ethereum/london/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH2"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.Ops.PUSH3", "specifier": 0, "path": "src/ethereum/london/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH3"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.Ops.PUSH4", "specifier": 0, "path": "src/ethereum/london/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH4"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.Ops.PUSH5", "specifier": 0, "path": "src/ethereum/london/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH5"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.Ops.PUSH6", "specifier": 0, "path": "src/ethereum/london/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH6"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.Ops.PUSH7", "specifier": 0, "path": "src/ethereum/london/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH7"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.Ops.PUSH8", "specifier": 0, "path": "src/ethereum/london/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH8"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.Ops.PUSH9", "specifier": 0, "path": "src/ethereum/london/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH9"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.Ops.PUSH10", "specifier": 0, "path": "src/ethereum/london/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH10"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.Ops.PUSH11", "specifier": 0, "path": "src/ethereum/london/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH11"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.Ops.PUSH12", "specifier": 0, "path": "src/ethereum/london/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH12"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.Ops.PUSH13", "specifier": 0, "path": "src/ethereum/london/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH13"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.Ops.PUSH14", "specifier": 0, "path": "src/ethereum/london/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH14"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.Ops.PUSH15", "specifier": 0, "path": "src/ethereum/london/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH15"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.Ops.PUSH16", "specifier": 0, "path": "src/ethereum/london/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH16"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.Ops.PUSH17", "specifier": 0, "path": "src/ethereum/london/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH17"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.Ops.PUSH18", "specifier": 0, "path": "src/ethereum/london/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH18"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.Ops.PUSH19", "specifier": 0, "path": "src/ethereum/london/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH19"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.Ops.PUSH20", "specifier": 0, "path": "src/ethereum/london/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH20"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.Ops.PUSH21", "specifier": 0, "path": "src/ethereum/london/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH21"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.Ops.PUSH22", "specifier": 0, "path": "src/ethereum/london/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH22"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.Ops.PUSH23", "specifier": 0, "path": "src/ethereum/london/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH23"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.Ops.PUSH24", "specifier": 0, "path": "src/ethereum/london/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH24"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.Ops.PUSH25", "specifier": 0, "path": "src/ethereum/london/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH25"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.Ops.PUSH26", "specifier": 0, "path": "src/ethereum/london/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH26"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.Ops.PUSH27", "specifier": 0, "path": "src/ethereum/london/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH27"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.Ops.PUSH28", "specifier": 0, "path": "src/ethereum/london/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH28"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.Ops.PUSH29", "specifier": 0, "path": "src/ethereum/london/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH29"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.Ops.PUSH30", "specifier": 0, "path": "src/ethereum/london/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH30"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.Ops.PUSH31", "specifier": 0, "path": "src/ethereum/london/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH31"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.Ops.PUSH32", "specifier": 0, "path": "src/ethereum/london/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH32"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.Ops.DUP1", "specifier": 0, "path": "src/ethereum/london/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP1"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.Ops.DUP2", "specifier": 0, "path": "src/ethereum/london/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP2"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.Ops.DUP3", "specifier": 0, "path": "src/ethereum/london/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP3"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.Ops.DUP4", "specifier": 0, "path": "src/ethereum/london/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP4"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.Ops.DUP5", "specifier": 0, "path": "src/ethereum/london/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP5"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.Ops.DUP6", "specifier": 0, "path": "src/ethereum/london/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP6"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.Ops.DUP7", "specifier": 0, "path": "src/ethereum/london/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP7"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.Ops.DUP8", "specifier": 0, "path": "src/ethereum/london/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP8"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.Ops.DUP9", "specifier": 0, "path": "src/ethereum/london/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP9"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.Ops.DUP10", "specifier": 0, "path": "src/ethereum/london/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP10"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.Ops.DUP11", "specifier": 0, "path": "src/ethereum/london/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP11"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.Ops.DUP12", "specifier": 0, "path": "src/ethereum/london/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP12"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.Ops.DUP13", "specifier": 0, "path": "src/ethereum/london/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP13"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.Ops.DUP14", "specifier": 0, "path": "src/ethereum/london/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP14"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.Ops.DUP15", "specifier": 0, "path": "src/ethereum/london/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP15"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.Ops.DUP16", "specifier": 0, "path": "src/ethereum/london/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP16"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.Ops.SWAP1", "specifier": 0, "path": "src/ethereum/london/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP1"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.Ops.SWAP2", "specifier": 0, "path": "src/ethereum/london/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP2"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.Ops.SWAP3", "specifier": 0, "path": "src/ethereum/london/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP3"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.Ops.SWAP4", "specifier": 0, "path": "src/ethereum/london/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP4"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.Ops.SWAP5", "specifier": 0, "path": "src/ethereum/london/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP5"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.Ops.SWAP6", "specifier": 0, "path": "src/ethereum/london/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP6"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.Ops.SWAP7", "specifier": 0, "path": "src/ethereum/london/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP7"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.Ops.SWAP8", "specifier": 0, "path": "src/ethereum/london/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP8"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.Ops.SWAP9", "specifier": 0, "path": "src/ethereum/london/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP9"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.Ops.SWAP10", "specifier": 0, "path": "src/ethereum/london/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP10"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.Ops.SWAP11", "specifier": 0, "path": "src/ethereum/london/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP11"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.Ops.SWAP12", "specifier": 0, "path": "src/ethereum/london/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP12"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.Ops.SWAP13", "specifier": 0, "path": "src/ethereum/london/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP13"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.Ops.SWAP14", "specifier": 0, "path": "src/ethereum/london/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP14"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.Ops.SWAP15", "specifier": 0, "path": "src/ethereum/london/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP15"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.Ops.SWAP16", "specifier": 0, "path": "src/ethereum/london/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP16"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.Ops.MLOAD", "specifier": 0, "path": "src/ethereum/london/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["MLOAD"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.Ops.MSTORE", "specifier": 0, "path": "src/ethereum/london/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["MSTORE"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.Ops.MSTORE8", "specifier": 0, "path": "src/ethereum/london/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["MSTORE8"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.Ops.MSIZE", "specifier": 0, "path": "src/ethereum/london/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["MSIZE"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.Ops.LOG0", "specifier": 0, "path": "src/ethereum/london/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["LOG0"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.Ops.LOG1", "specifier": 0, "path": "src/ethereum/london/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["LOG1"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.Ops.LOG2", "specifier": 0, "path": "src/ethereum/london/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["LOG2"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.Ops.LOG3", "specifier": 0, "path": "src/ethereum/london/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["LOG3"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.Ops.LOG4", "specifier": 0, "path": "src/ethereum/london/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["LOG4"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.Ops.CREATE", "specifier": 0, "path": "src/ethereum/london/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["CREATE"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.Ops.RETURN", "specifier": 0, "path": "src/ethereum/london/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["RETURN"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.Ops.CALL", "specifier": 0, "path": "src/ethereum/london/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["CALL"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.Ops.CALLCODE", "specifier": 0, "path": "src/ethereum/london/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["CALLCODE"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.Ops.DELEGATECALL", "specifier": 0, "path": "src/ethereum/london/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DELEGATECALL"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.Ops.STATICCALL", "specifier": 0, "path": "src/ethereum/london/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["STATICCALL"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.Ops.REVERT", "specifier": 0, "path": "src/ethereum/london/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["REVERT"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.Ops.SELFDESTRUCT", "specifier": 0, "path": "src/ethereum/london/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SELFDESTRUCT"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.Ops.CREATE2", "specifier": 0, "path": "src/ethereum/london/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["CREATE2"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.op_implementation", "specifier": 0, "path": "src/ethereum/london/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["op_implementation"]}}, {"source": {"identifier": "ethereum.tangerine_whistle.utils.message", "specifier": 0, "path": "src/ethereum/tangerine_whistle/utils/message.py"}, "content": {"type": ["module"], "name": ["ethereum.tangerine_whistle.utils.message"], "text": ["Hardfork Utility Functions For The Message Data-structure ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Message specific functions used in this tangerine whistle version of specification."]}}, {"source": {"identifier": "ethereum.tangerine_whistle.utils.message.prepare_message", "specifier": 0, "path": "src/ethereum/tangerine_whistle/utils/message.py"}, "content": {"type": ["function"], "name": ["prepare_message"], "text": ["Execute a transaction against the provided environment. Parameters caller : Address which initiated the transaction target : Address whose code will be executed value : Value to be transferred. data : Array of bytes provided to the code in  target . gas : Gas provided for the code in  target . env : Environment for the Ethereum Virtual Machine. code_address : This is usually same as the  target  address except when an alternative accounts code needs to be executed. eg.  CALLCODE  calling a precompile. should_transfer_value : if True ETH should be transferred while executing a message call. Returns message:  ethereum.tangerine_whistle.vm.Message Items containing contract creation or message call specific data."]}}, {"source": {"identifier": "ethereum.london.vm.instructions.control_flow", "specifier": 0, "path": "src/ethereum/london/vm/instructions/control_flow.py"}, "content": {"type": ["module"], "name": ["ethereum.london.vm.instructions.control_flow"], "text": ["Ethereum Virtual Machine (EVM) Control Flow Instructions ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementations of the EVM control flow instructions."]}}, {"source": {"identifier": "ethereum.london.vm.instructions.control_flow.stop", "specifier": 0, "path": "src/ethereum/london/vm/instructions/control_flow.py"}, "content": {"type": ["function"], "name": ["stop"], "text": ["Stop further execution of EVM code. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.london.vm.instructions.control_flow.jump", "specifier": 0, "path": "src/ethereum/london/vm/instructions/control_flow.py"}, "content": {"type": ["function"], "name": ["jump"], "text": ["Alter the program counter to the location specified by the top of the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.london.vm.instructions.control_flow.jumpi", "specifier": 0, "path": "src/ethereum/london/vm/instructions/control_flow.py"}, "content": {"type": ["function"], "name": ["jumpi"], "text": ["Alter the program counter to the specified location if and only if a condition is true. If the condition is not true, then the program counter would increase only by 1. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.london.vm.instructions.control_flow.pc", "specifier": 0, "path": "src/ethereum/london/vm/instructions/control_flow.py"}, "content": {"type": ["function"], "name": ["pc"], "text": ["Push onto the stack the value of the program counter after reaching the current instruction and without increasing it for the next instruction. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.london.vm.instructions.control_flow.gas_left", "specifier": 0, "path": "src/ethereum/london/vm/instructions/control_flow.py"}, "content": {"type": ["function"], "name": ["gas_left"], "text": ["Push the amount of available gas (including the corresponding reduction for the cost of this instruction) onto the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.london.vm.instructions.control_flow.jumpdest", "specifier": 0, "path": "src/ethereum/london/vm/instructions/control_flow.py"}, "content": {"type": ["function"], "name": ["jumpdest"], "text": ["Mark a valid destination for jumps. This is a noop, present only to be used by  JUMP  and  JUMPI  opcodes to verify that their jump is valid. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.tangerine_whistle.utils.hexadecimal", "specifier": 0, "path": "src/ethereum/tangerine_whistle/utils/hexadecimal.py"}, "content": {"type": ["module"], "name": ["ethereum.tangerine_whistle.utils.hexadecimal"], "text": ["Utility Functions For Hexadecimal Strings ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Hexadecimal utility functions used in this specification, specific to Tangerine Whistle types."]}}, {"source": {"identifier": "ethereum.tangerine_whistle.utils.hexadecimal.hex_to_root", "specifier": 0, "path": "src/ethereum/tangerine_whistle/utils/hexadecimal.py"}, "content": {"type": ["function"], "name": ["hex_to_root"], "text": ["Convert hex string to trie root. Parameters hex_string : The hexadecimal string to be converted to trie root. Returns root :  Root Trie root obtained from the given hexadecimal string."]}}, {"source": {"identifier": "ethereum.tangerine_whistle.utils.hexadecimal.hex_to_bloom", "specifier": 0, "path": "src/ethereum/tangerine_whistle/utils/hexadecimal.py"}, "content": {"type": ["function"], "name": ["hex_to_bloom"], "text": ["Convert hex string to bloom. Parameters hex_string : The hexadecimal string to be converted to bloom. Returns bloom :  Bloom Bloom obtained from the given hexadecimal string."]}}, {"source": {"identifier": "ethereum.tangerine_whistle.utils.hexadecimal.hex_to_address", "specifier": 0, "path": "src/ethereum/tangerine_whistle/utils/hexadecimal.py"}, "content": {"type": ["function"], "name": ["hex_to_address"], "text": ["Convert hex string to Address (20 bytes). Parameters hex_string : The hexadecimal string to be converted to Address. Returns address :  Address The address obtained from the given hexadecimal string."]}}, {"source": {"identifier": "ethereum.london.vm.instructions.comparison", "specifier": 0, "path": "src/ethereum/london/vm/instructions/comparison.py"}, "content": {"type": ["module"], "name": ["ethereum.london.vm.instructions.comparison"], "text": ["Ethereum Virtual Machine (EVM) Comparison Instructions ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementations of the EVM Comparison instructions."]}}, {"source": {"identifier": "ethereum.london.vm.instructions.comparison.less_than", "specifier": 0, "path": "src/ethereum/london/vm/instructions/comparison.py"}, "content": {"type": ["function"], "name": ["less_than"], "text": ["Checks if the top element is less than the next top element. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.london.vm.instructions.comparison.signed_less_than", "specifier": 0, "path": "src/ethereum/london/vm/instructions/comparison.py"}, "content": {"type": ["function"], "name": ["signed_less_than"], "text": ["Signed less-than comparison. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.london.vm.instructions.comparison.greater_than", "specifier": 0, "path": "src/ethereum/london/vm/instructions/comparison.py"}, "content": {"type": ["function"], "name": ["greater_than"], "text": ["Checks if the top element is greater than the next top element. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.london.vm.instructions.comparison.signed_greater_than", "specifier": 0, "path": "src/ethereum/london/vm/instructions/comparison.py"}, "content": {"type": ["function"], "name": ["signed_greater_than"], "text": ["Signed greater-than comparison. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.london.vm.instructions.comparison.equal", "specifier": 0, "path": "src/ethereum/london/vm/instructions/comparison.py"}, "content": {"type": ["function"], "name": ["equal"], "text": ["Checks if the top element is equal to the next top element. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.london.vm.instructions.comparison.is_zero", "specifier": 0, "path": "src/ethereum/london/vm/instructions/comparison.py"}, "content": {"type": ["function"], "name": ["is_zero"], "text": ["Checks if the top element is equal to 0. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.utils.byte", "specifier": 0, "path": "src/ethereum/utils/byte.py"}, "content": {"type": ["module"], "name": ["ethereum.utils.byte"], "text": ["Utility Functions For Byte Strings ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Byte specific utility functions used in this specification."]}}, {"source": {"identifier": "ethereum.utils.byte.left_pad_zero_bytes", "specifier": 0, "path": "src/ethereum/utils/byte.py"}, "content": {"type": ["function"], "name": ["left_pad_zero_bytes"], "text": ["Left pad zeroes to  value  if it's length is less than the given  size . Parameters value : The byte string that needs to be padded. size : The number of bytes that need that need to be padded. Returns left_padded_value:  ethereum.base_types.Bytes left padded byte string of given  size ."]}}, {"source": {"identifier": "ethereum.utils.byte.right_pad_zero_bytes", "specifier": 0, "path": "src/ethereum/utils/byte.py"}, "content": {"type": ["function"], "name": ["right_pad_zero_bytes"], "text": ["Right pad zeroes to  value  if it's length is less than the given  size . Parameters value : The byte string that needs to be padded. size : The number of bytes that need that need to be padded. Returns right_padded_value:  ethereum.base_types.Bytes right padded byte string of given  size ."]}}, {"source": {"identifier": "ethereum.london.vm.instructions.log", "specifier": 0, "path": "src/ethereum/london/vm/instructions/log.py"}, "content": {"type": ["module"], "name": ["ethereum.london.vm.instructions.log"], "text": ["Ethereum Virtual Machine (EVM) Logging Instructions ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementations of the EVM logging instructions."]}}, {"source": {"identifier": "ethereum.london.vm.instructions.log.log_n", "specifier": 0, "path": "src/ethereum/london/vm/instructions/log.py"}, "content": {"type": ["function"], "name": ["log_n"], "text": ["Appends a log entry, having  num_topics  topics, to the evm logs. This will also expand the memory if the data (required by the log entry) corresponding to the memory is not accessible. Parameters evm : The current EVM frame. num_topics : The number of topics to be included in the log entry."]}}, {"source": {"identifier": "ethereum.london.vm.instructions.log.log0", "specifier": 0, "path": "src/ethereum/london/vm/instructions/log.py"}, "content": {"type": ["attribute"], "name": ["log0"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.log.log1", "specifier": 0, "path": "src/ethereum/london/vm/instructions/log.py"}, "content": {"type": ["attribute"], "name": ["log1"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.log.log2", "specifier": 0, "path": "src/ethereum/london/vm/instructions/log.py"}, "content": {"type": ["attribute"], "name": ["log2"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.log.log3", "specifier": 0, "path": "src/ethereum/london/vm/instructions/log.py"}, "content": {"type": ["attribute"], "name": ["log3"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.log.log4", "specifier": 0, "path": "src/ethereum/london/vm/instructions/log.py"}, "content": {"type": ["attribute"], "name": ["log4"]}}, {"source": {"identifier": "ethereum.utils", "specifier": 0, "path": "src/ethereum/utils/__init__.py"}, "content": {"type": ["module"], "name": ["ethereum.utils"], "text": ["Utility Functions ^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Utility functions used in this specification."]}}, {"source": {"identifier": "ethereum.utils.safe_arithmetic", "specifier": 0, "path": "src/ethereum/utils/safe_arithmetic.py"}, "content": {"type": ["module"], "name": ["ethereum.utils.safe_arithmetic"], "text": ["Safe Arithmetic for U256 Integer Type ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Safe arithmetic utility functions for U256 integer type."]}}, {"source": {"identifier": "ethereum.utils.safe_arithmetic.u256_safe_add", "specifier": 0, "path": "src/ethereum/utils/safe_arithmetic.py"}, "content": {"type": ["function"], "name": ["u256_safe_add"], "text": ["Adds together the given sequence of numbers. If the total sum of the numbers exceeds  U256.MAX_VALUE  then an exception is raised. If  exception_type  = None then the exception raised defaults to the one raised by  U256  when  U256.value > U256.MAX_VALUE else  exception_type  is raised. Parameters numbers : The sequence of numbers that need to be added together. exception_type: The exception that needs to be raised if the sum of the  numbers exceeds  U256.MAX_VALUE . Returns result :  ethereum.base_types.U256 The sum of the given sequence of numbers if the total is less than U256.MAX_VALUE  else an exception is raised. If  exception_type  = None then the exception raised defaults to the one raised by  U256  when  U256.value > U256.MAX_VALUE else  exception_type  is raised."]}}, {"source": {"identifier": "ethereum.utils.safe_arithmetic.u256_safe_multiply", "specifier": 0, "path": "src/ethereum/utils/safe_arithmetic.py"}, "content": {"type": ["function"], "name": ["u256_safe_multiply"], "text": ["Multiplies together the given sequence of numbers. If the net product of the numbers exceeds  U256.MAX_VALUE  then an exception is raised. If  exception_type  = None then the exception raised defaults to the one raised by  U256  when  U256.value > U256.MAX_VALUE  else exception_type  is raised. Parameters numbers : The sequence of numbers that need to be multiplies together. exception_type: The exception that needs to be raised if the sum of the  numbers exceeds  U256.MAX_VALUE . Returns result :  ethereum.base_types.U256 The multiplication product of the given sequence of numbers if the net product  is less than  U256.MAX_VALUE  else an exception is raised. If  exception_type  = None then the exception raised defaults to the one raised by  U256  when  U256.value > U256.MAX_VALUE else  exception_type  is raised."]}}, {"source": {"identifier": "ethereum.london.vm.instructions.storage", "specifier": 0, "path": "src/ethereum/london/vm/instructions/storage.py"}, "content": {"type": ["module"], "name": ["ethereum.london.vm.instructions.storage"], "text": ["Ethereum Virtual Machine (EVM) Storage Instructions ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementations of the EVM storage related instructions."]}}, {"source": {"identifier": "ethereum.london.vm.instructions.storage.sload", "specifier": 0, "path": "src/ethereum/london/vm/instructions/storage.py"}, "content": {"type": ["function"], "name": ["sload"], "text": ["Loads to the stack, the value corresponding to a certain key from the storage of the current account. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.london.vm.instructions.storage.sstore", "specifier": 0, "path": "src/ethereum/london/vm/instructions/storage.py"}, "content": {"type": ["function"], "name": ["sstore"], "text": ["Stores a value at a certain key in the current context's storage. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.utils.numeric", "specifier": 0, "path": "src/ethereum/utils/numeric.py"}, "content": {"type": ["module"], "name": ["ethereum.utils.numeric"], "text": ["Utility Functions For Numeric Operations ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Numeric operations specific utility functions used in this specification."]}}, {"source": {"identifier": "ethereum.utils.numeric.get_sign", "specifier": 0, "path": "src/ethereum/utils/numeric.py"}, "content": {"type": ["function"], "name": ["get_sign"], "text": ["Determines the sign of a number. Parameters value : The value whose sign is to be determined. Returns sign :  int The sign of the number (-1 or 0 or 1). The return value is based on math signum function."]}}, {"source": {"identifier": "ethereum.utils.numeric.ceil32", "specifier": 0, "path": "src/ethereum/utils/numeric.py"}, "content": {"type": ["function"], "name": ["ceil32"], "text": ["Converts a unsigned integer to the next closest multiple of 32. Parameters value : The value whose ceil32 is to be calculated. Returns ceil32 :  ethereum.base_types.U256 The same value if it's a perfect multiple of 32 else it returns the smallest multiple of 32 that is greater than  value ."]}}, {"source": {"identifier": "ethereum.utils.numeric.is_prime", "specifier": 0, "path": "src/ethereum/utils/numeric.py"}, "content": {"type": ["function"], "name": ["is_prime"], "text": ["Checks if  number  is a prime number. Parameters number : The number to check for primality. Returns is_number_prime :  bool Boolean indicating if  number  is prime or not."]}}, {"source": {"identifier": "ethereum.utils.numeric.le_bytes_to_uint32_sequence", "specifier": 0, "path": "src/ethereum/utils/numeric.py"}, "content": {"type": ["function"], "name": ["le_bytes_to_uint32_sequence"], "text": ["Convert little endian byte stream  data  to a little endian U32 sequence i.e., the first U32 number of the sequence is the least significant U32 number. Parameters data : The byte stream (little endian) which is to be converted to a U32 stream. Returns uint32_sequence :  Tuple[U32, ...] Sequence of U32 numbers obtained from the little endian byte stream."]}}, {"source": {"identifier": "ethereum.utils.numeric.le_uint32_sequence_to_bytes", "specifier": 0, "path": "src/ethereum/utils/numeric.py"}, "content": {"type": ["function"], "name": ["le_uint32_sequence_to_bytes"], "text": ["Obtain little endian byte stream from a little endian U32 sequence i.e., the first U32 number of the sequence is the least significant U32 number. Note - In this conversion, the most significant byte (byte at the end of the little endian stream) may have leading zeroes. This function doesn't take care of removing these leading zeroes as shown in below example. le_uint32_sequence_to_bytes([U32(8)]) b'\\x08\\x00\\x00\\x00' Parameters sequence : The U32 stream (little endian) which is to be converted to a little endian byte stream. Returns result :  bytes The byte stream obtained from the little endian U32 stream."]}}, {"source": {"identifier": "ethereum.utils.numeric.le_uint32_sequence_to_uint", "specifier": 0, "path": "src/ethereum/utils/numeric.py"}, "content": {"type": ["function"], "name": ["le_uint32_sequence_to_uint"], "text": ["Obtain Uint from a U32 sequence assuming that this sequence is little endian i.e., the first U32 number of the sequence is the least significant U32 number. Parameters sequence : The U32 stream (little endian) which is to be converted to a Uint. Returns value :  Uint The Uint number obtained from the conversion of the little endian U32 stream."]}}, {"source": {"identifier": "ethereum.london.vm.instructions.block", "specifier": 0, "path": "src/ethereum/london/vm/instructions/block.py"}, "content": {"type": ["module"], "name": ["ethereum.london.vm.instructions.block"], "text": ["Ethereum Virtual Machine (EVM) Block Instructions ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementations of the EVM block instructions."]}}, {"source": {"identifier": "ethereum.london.vm.instructions.block.block_hash", "specifier": 0, "path": "src/ethereum/london/vm/instructions/block.py"}, "content": {"type": ["function"], "name": ["block_hash"], "text": ["Push the hash of one of the 256 most recent complete blocks onto the stack. The block number to hash is present at the top of the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.london.vm.instructions.block.coinbase", "specifier": 0, "path": "src/ethereum/london/vm/instructions/block.py"}, "content": {"type": ["function"], "name": ["coinbase"], "text": ["Push the current block's beneficiary address (address of the block miner) onto the stack. Here the current block refers to the block in which the currently executing transaction/call resides. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.london.vm.instructions.block.timestamp", "specifier": 0, "path": "src/ethereum/london/vm/instructions/block.py"}, "content": {"type": ["function"], "name": ["timestamp"], "text": ["Push the current block's timestamp onto the stack. Here the timestamp being referred is actually the unix timestamp in seconds. Here the current block refers to the block in which the currently executing transaction/call resides. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.london.vm.instructions.block.number", "specifier": 0, "path": "src/ethereum/london/vm/instructions/block.py"}, "content": {"type": ["function"], "name": ["number"], "text": ["Push the current block's number onto the stack. Here the current block refers to the block in which the currently executing transaction/call resides. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.london.vm.instructions.block.difficulty", "specifier": 0, "path": "src/ethereum/london/vm/instructions/block.py"}, "content": {"type": ["function"], "name": ["difficulty"], "text": ["Push the current block's difficulty onto the stack. Here the current block refers to the block in which the currently executing transaction/call resides. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.london.vm.instructions.block.gas_limit", "specifier": 0, "path": "src/ethereum/london/vm/instructions/block.py"}, "content": {"type": ["function"], "name": ["gas_limit"], "text": ["Push the current block's gas limit onto the stack. Here the current block refers to the block in which the currently executing transaction/call resides. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.london.vm.instructions.block.chain_id", "specifier": 0, "path": "src/ethereum/london/vm/instructions/block.py"}, "content": {"type": ["function"], "name": ["chain_id"], "text": ["Push the chain id onto the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.utils.ensure", "specifier": 0, "path": "src/ethereum/utils/ensure.py"}, "content": {"type": ["module"], "name": ["ethereum.utils.ensure"], "text": ["Ensure (Assertion) Utilities ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Functions that simplify checking assertions and raising exceptions."]}}, {"source": {"identifier": "ethereum.utils.ensure.ensure", "specifier": 0, "path": "src/ethereum/utils/ensure.py"}, "content": {"type": ["function"], "name": ["ensure"], "text": ["Does nothing if  value  is truthy, otherwise raises the exception returned by  exception_class . Parameters value : Value that should be true. exception : Constructor for the exception to raise."]}}, {"source": {"identifier": "ethereum.utils.hexadecimal", "specifier": 0, "path": "src/ethereum/utils/hexadecimal.py"}, "content": {"type": ["module"], "name": ["ethereum.utils.hexadecimal"], "text": ["Utility Functions For Hexadecimal Strings ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Hexadecimal strings specific utility functions used in this specification."]}}, {"source": {"identifier": "ethereum.utils.hexadecimal.has_hex_prefix", "specifier": 0, "path": "src/ethereum/utils/hexadecimal.py"}, "content": {"type": ["function"], "name": ["has_hex_prefix"], "text": ["Check if a hex string starts with hex prefix (0x). Parameters hex_string : The hexadecimal string to be checked for presence of prefix. Returns has_prefix :  bool Boolean indicating whether the hex string has 0x prefix."]}}, {"source": {"identifier": "ethereum.utils.hexadecimal.remove_hex_prefix", "specifier": 0, "path": "src/ethereum/utils/hexadecimal.py"}, "content": {"type": ["function"], "name": ["remove_hex_prefix"], "text": ["Remove 0x prefix from a hex string if present. This function returns the passed hex string if it isn't prefixed with 0x. Parameters hex_string : The hexadecimal string whose prefix is to be removed. Returns modified_hex_string :  str The hexadecimal string with the 0x prefix removed if present."]}}, {"source": {"identifier": "ethereum.utils.hexadecimal.hex_to_bytes", "specifier": 0, "path": "src/ethereum/utils/hexadecimal.py"}, "content": {"type": ["function"], "name": ["hex_to_bytes"], "text": ["Convert hex string to bytes. Parameters hex_string : The hexadecimal string to be converted to bytes. Returns byte_stream :  bytes Byte stream corresponding to the given hexadecimal string."]}}, {"source": {"identifier": "ethereum.utils.hexadecimal.hex_to_bytes8", "specifier": 0, "path": "src/ethereum/utils/hexadecimal.py"}, "content": {"type": ["function"], "name": ["hex_to_bytes8"], "text": ["Convert hex string to 8 bytes. Parameters hex_string : The hexadecimal string to be converted to 8 bytes. Returns 8_byte_stream :  Bytes8 8-byte stream corresponding to the given hexadecimal string."]}}, {"source": {"identifier": "ethereum.utils.hexadecimal.hex_to_bytes20", "specifier": 0, "path": "src/ethereum/utils/hexadecimal.py"}, "content": {"type": ["function"], "name": ["hex_to_bytes20"], "text": ["Convert hex string to 20 bytes. Parameters hex_string : The hexadecimal string to be converted to 20 bytes. Returns 20_byte_stream :  Bytes20 20-byte stream corresponding to the given hexadecimal string."]}}, {"source": {"identifier": "ethereum.utils.hexadecimal.hex_to_bytes32", "specifier": 0, "path": "src/ethereum/utils/hexadecimal.py"}, "content": {"type": ["function"], "name": ["hex_to_bytes32"], "text": ["Convert hex string to 32 bytes. Parameters hex_string : The hexadecimal string to be converted to 32 bytes. Returns 32_byte_stream :  Bytes32 32-byte stream corresponding to the given hexadecimal string."]}}, {"source": {"identifier": "ethereum.utils.hexadecimal.hex_to_bytes256", "specifier": 0, "path": "src/ethereum/utils/hexadecimal.py"}, "content": {"type": ["function"], "name": ["hex_to_bytes256"], "text": ["Convert hex string to 256 bytes. Parameters hex_string : The hexadecimal string to be converted to 256 bytes. Returns 256_byte_stream :  Bytes256 256-byte stream corresponding to the given hexadecimal string."]}}, {"source": {"identifier": "ethereum.utils.hexadecimal.hex_to_hash", "specifier": 0, "path": "src/ethereum/utils/hexadecimal.py"}, "content": {"type": ["function"], "name": ["hex_to_hash"], "text": ["Convert hex string to hash32 (32 bytes). Parameters hex_string : The hexadecimal string to be converted to hash32. Returns hash :  Hash32 32-byte stream obtained from the given hexadecimal string."]}}, {"source": {"identifier": "ethereum.utils.hexadecimal.hex_to_uint", "specifier": 0, "path": "src/ethereum/utils/hexadecimal.py"}, "content": {"type": ["function"], "name": ["hex_to_uint"], "text": ["Convert hex string to Uint. Parameters hex_string : The hexadecimal string to be converted to Uint. Returns converted :  Uint The unsigned integer obtained from the given hexadecimal string."]}}, {"source": {"identifier": "ethereum.utils.hexadecimal.hex_to_u64", "specifier": 0, "path": "src/ethereum/utils/hexadecimal.py"}, "content": {"type": ["function"], "name": ["hex_to_u64"], "text": ["Convert hex string to U64. Parameters hex_string : The hexadecimal string to be converted to U256. Returns converted :  U64 The U64 integer obtained from the given hexadecimal string."]}}, {"source": {"identifier": "ethereum.utils.hexadecimal.hex_to_u256", "specifier": 0, "path": "src/ethereum/utils/hexadecimal.py"}, "content": {"type": ["function"], "name": ["hex_to_u256"], "text": ["Convert hex string to U256. Parameters hex_string : The hexadecimal string to be converted to U256. Returns converted :  U256 The U256 integer obtained from the given hexadecimal string."]}}, {"source": {"identifier": "ethereum.london.vm.instructions.arithmetic", "specifier": 0, "path": "src/ethereum/london/vm/instructions/arithmetic.py"}, "content": {"type": ["module"], "name": ["ethereum.london.vm.instructions.arithmetic"], "text": ["Ethereum Virtual Machine (EVM) Arithmetic Instructions ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementations of the EVM Arithmetic instructions."]}}, {"source": {"identifier": "ethereum.london.vm.instructions.arithmetic.add", "specifier": 0, "path": "src/ethereum/london/vm/instructions/arithmetic.py"}, "content": {"type": ["function"], "name": ["add"], "text": ["Adds the top two elements of the stack together, and pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.london.vm.instructions.arithmetic.sub", "specifier": 0, "path": "src/ethereum/london/vm/instructions/arithmetic.py"}, "content": {"type": ["function"], "name": ["sub"], "text": ["Subtracts the top two elements of the stack, and pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.london.vm.instructions.arithmetic.mul", "specifier": 0, "path": "src/ethereum/london/vm/instructions/arithmetic.py"}, "content": {"type": ["function"], "name": ["mul"], "text": ["Multiply the top two elements of the stack, and pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.london.vm.instructions.arithmetic.div", "specifier": 0, "path": "src/ethereum/london/vm/instructions/arithmetic.py"}, "content": {"type": ["function"], "name": ["div"], "text": ["Integer division of the top two elements of the stack. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.london.vm.instructions.arithmetic.sdiv", "specifier": 0, "path": "src/ethereum/london/vm/instructions/arithmetic.py"}, "content": {"type": ["function"], "name": ["sdiv"], "text": ["Signed integer division of the top two elements of the stack. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.london.vm.instructions.arithmetic.mod", "specifier": 0, "path": "src/ethereum/london/vm/instructions/arithmetic.py"}, "content": {"type": ["function"], "name": ["mod"], "text": ["Modulo remainder of the top two elements of the stack. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.london.vm.instructions.arithmetic.smod", "specifier": 0, "path": "src/ethereum/london/vm/instructions/arithmetic.py"}, "content": {"type": ["function"], "name": ["smod"], "text": ["Signed modulo remainder of the top two elements of the stack. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.london.vm.instructions.arithmetic.addmod", "specifier": 0, "path": "src/ethereum/london/vm/instructions/arithmetic.py"}, "content": {"type": ["function"], "name": ["addmod"], "text": ["Modulo addition of the top 2 elements with the 3rd element. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.london.vm.instructions.arithmetic.mulmod", "specifier": 0, "path": "src/ethereum/london/vm/instructions/arithmetic.py"}, "content": {"type": ["function"], "name": ["mulmod"], "text": ["Modulo multiplication of the top 2 elements with the 3rd element. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.london.vm.instructions.arithmetic.exp", "specifier": 0, "path": "src/ethereum/london/vm/instructions/arithmetic.py"}, "content": {"type": ["function"], "name": ["exp"], "text": ["Exponential operation of the top 2 elements. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.london.vm.instructions.arithmetic.signextend", "specifier": 0, "path": "src/ethereum/london/vm/instructions/arithmetic.py"}, "content": {"type": ["function"], "name": ["signextend"], "text": ["Sign extend operation. In other words, extend a signed number which fits in N bytes to 32 bytes. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.berlin.state", "specifier": 0, "path": "src/ethereum/berlin/state.py"}, "content": {"type": ["module"], "name": ["ethereum.berlin.state"], "text": ["State ^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction The state contains all information that is preserved between transactions. It consists of a main account trie and storage tries for each contract. There is a distinction between an account that does not exist and EMPTY_ACCOUNT ."]}}, {"source": {"identifier": "ethereum.berlin.state.State", "specifier": 0, "path": "src/ethereum/berlin/state.py"}, "content": {"type": ["class"], "name": ["State"], "text": ["Contains all information that is preserved between transactions."]}}, {"source": {"identifier": "ethereum.berlin.state.State._main_trie", "specifier": 0, "path": "src/ethereum/berlin/state.py"}, "content": {"type": ["attribute"], "name": ["_main_trie"]}}, {"source": {"identifier": "ethereum.berlin.state.State._storage_tries", "specifier": 0, "path": "src/ethereum/berlin/state.py"}, "content": {"type": ["attribute"], "name": ["_storage_tries"]}}, {"source": {"identifier": "ethereum.berlin.state.State._snapshots", "specifier": 0, "path": "src/ethereum/berlin/state.py"}, "content": {"type": ["attribute"], "name": ["_snapshots"]}}, {"source": {"identifier": "ethereum.berlin.state.close_state", "specifier": 0, "path": "src/ethereum/berlin/state.py"}, "content": {"type": ["function"], "name": ["close_state"], "text": ["Free resources held by the state. Used by optimized implementations to release file descriptors."]}}, {"source": {"identifier": "ethereum.berlin.state.begin_transaction", "specifier": 0, "path": "src/ethereum/berlin/state.py"}, "content": {"type": ["function"], "name": ["begin_transaction"], "text": ["Start a state transaction. Transactions are entirely implicit and can be nested. It is not possible to calculate the state root during a transaction. Parameters state : State The state."]}}, {"source": {"identifier": "ethereum.berlin.state.commit_transaction", "specifier": 0, "path": "src/ethereum/berlin/state.py"}, "content": {"type": ["function"], "name": ["commit_transaction"], "text": ["Commit a state transaction. Parameters state : State The state."]}}, {"source": {"identifier": "ethereum.berlin.state.rollback_transaction", "specifier": 0, "path": "src/ethereum/berlin/state.py"}, "content": {"type": ["function"], "name": ["rollback_transaction"], "text": ["Rollback a state transaction, resetting the state to the point when the corresponding  start_transaction()  call was made. Parameters state : State The state."]}}, {"source": {"identifier": "ethereum.berlin.state.get_account", "specifier": 0, "path": "src/ethereum/berlin/state.py"}, "content": {"type": ["function"], "name": ["get_account"], "text": ["Get the  Account  object at an address. Returns  EMPTY_ACCOUNT  if there is no account at the address. Use  get_account_optional()  if you care about the difference between a non-existent account and  EMPTY_ACCOUNT . Parameters state:  State The state address :  Address Address to lookup. Returns account :  Account Account at address."]}}, {"source": {"identifier": "ethereum.berlin.state.get_account_optional", "specifier": 0, "path": "src/ethereum/berlin/state.py"}, "content": {"type": ["function"], "name": ["get_account_optional"], "text": ["Get the  Account  object at an address. Returns  None  (rather than EMPTY_ACCOUNT ) if there is no account at the address. Parameters state:  State The state address :  Address Address to lookup. Returns account :  Account Account at address."]}}, {"source": {"identifier": "ethereum.berlin.state.set_account", "specifier": 0, "path": "src/ethereum/berlin/state.py"}, "content": {"type": ["function"], "name": ["set_account"], "text": ["Set the  Account  object at an address. Setting to  None  deletes the account (but not its storage, see  destroy_account() ). Parameters state:  State The state address :  Address Address to set. account :  Account Account to set at address."]}}, {"source": {"identifier": "ethereum.berlin.state.destroy_account", "specifier": 0, "path": "src/ethereum/berlin/state.py"}, "content": {"type": ["function"], "name": ["destroy_account"], "text": ["Completely remove the account at  address  and all of its storage. This function is made available exclusively for the  SELFDESTRUCT opcode. It is expected that  SELFDESTRUCT  will be disabled in a future hardfork and this function will be removed. Parameters state:  State The state address :  Address Address of account to destroy."]}}, {"source": {"identifier": "ethereum.berlin.state.destroy_storage", "specifier": 0, "path": "src/ethereum/berlin/state.py"}, "content": {"type": ["function"], "name": ["destroy_storage"], "text": ["Completely remove the storage at  address . Parameters state:  State The state address :  Address Address of account whose storage is to be deleted."]}}, {"source": {"identifier": "ethereum.berlin.state.get_storage", "specifier": 0, "path": "src/ethereum/berlin/state.py"}, "content": {"type": ["function"], "name": ["get_storage"], "text": ["Get a value at a storage key on an account. Returns  U256(0)  if the storage key has not been set previously. Parameters state:  State The state address :  Address Address of the account. key :  Bytes Key to lookup. Returns value :  U256 Value at the key."]}}, {"source": {"identifier": "ethereum.berlin.state.set_storage", "specifier": 0, "path": "src/ethereum/berlin/state.py"}, "content": {"type": ["function"], "name": ["set_storage"], "text": ["Set a value at a storage key on an account. Setting to  U256(0)  deletes the key. Parameters state:  State The state address :  Address Address of the account. key :  Bytes Key to set. value :  U256 Value to set at the key."]}}, {"source": {"identifier": "ethereum.berlin.state.storage_root", "specifier": 0, "path": "src/ethereum/berlin/state.py"}, "content": {"type": ["function"], "name": ["storage_root"], "text": ["Calculate the storage root of an account. Parameters state: The state address : Address of the account. Returns root :  Root Storage root of the account."]}}, {"source": {"identifier": "ethereum.berlin.state.state_root", "specifier": 0, "path": "src/ethereum/berlin/state.py"}, "content": {"type": ["function"], "name": ["state_root"], "text": ["Calculate the state root. Parameters state: The current state. Returns root :  Root The state root."]}}, {"source": {"identifier": "ethereum.berlin.state.account_exists", "specifier": 0, "path": "src/ethereum/berlin/state.py"}, "content": {"type": ["function"], "name": ["account_exists"], "text": ["Checks if an account exists in the state trie Parameters state: The state address: Address of the account that needs to be checked. Returns account_exists :  bool True if account exists in the state trie, False otherwise"]}}, {"source": {"identifier": "ethereum.berlin.state.account_has_code_or_nonce", "specifier": 0, "path": "src/ethereum/berlin/state.py"}, "content": {"type": ["function"], "name": ["account_has_code_or_nonce"], "text": ["Checks if an account has non zero nonce or non empty code Parameters state: The state address: Address of the account that needs to be checked. Returns has_code_or_nonce :  bool True if if an account has non zero nonce or non empty code, False otherwise."]}}, {"source": {"identifier": "ethereum.berlin.state.is_account_empty", "specifier": 0, "path": "src/ethereum/berlin/state.py"}, "content": {"type": ["function"], "name": ["is_account_empty"], "text": ["Checks if an account has zero nonce, empty code and zero balance. Parameters state: The state address: Address of the account that needs to be checked. Returns is_empty :  bool True if if an account has zero nonce, empty code and zero balance, False otherwise."]}}, {"source": {"identifier": "ethereum.berlin.state.account_exists_and_is_empty", "specifier": 0, "path": "src/ethereum/berlin/state.py"}, "content": {"type": ["function"], "name": ["account_exists_and_is_empty"], "text": ["Checks if an account exists and has zero nonce, empty code and zero balance. Parameters state: The state address: Address of the account that needs to be checked. Returns exists_and_is_empty :  bool True if an account exists and has zero nonce, empty code and zero balance, False otherwise."]}}, {"source": {"identifier": "ethereum.berlin.state.is_account_alive", "specifier": 0, "path": "src/ethereum/berlin/state.py"}, "content": {"type": ["function"], "name": ["is_account_alive"], "text": ["Check whether is an account is both in the state and non empty. Parameters state: The state address: Address of the account that needs to be checked. Returns is_alive :  bool True if the account is alive."]}}, {"source": {"identifier": "ethereum.berlin.state.modify_state", "specifier": 0, "path": "src/ethereum/berlin/state.py"}, "content": {"type": ["function"], "name": ["modify_state"], "text": ["Modify an  Account  in the  State ."]}}, {"source": {"identifier": "ethereum.berlin.state.move_ether", "specifier": 0, "path": "src/ethereum/berlin/state.py"}, "content": {"type": ["function"], "name": ["move_ether"], "text": ["Move funds between accounts."]}}, {"source": {"identifier": "ethereum.berlin.state.set_account_balance", "specifier": 0, "path": "src/ethereum/berlin/state.py"}, "content": {"type": ["function"], "name": ["set_account_balance"], "text": ["Sets the balance of an account. Parameters state: The current state. address: Address of the account whose nonce needs to be incremented. amount: The amount that needs to set in balance."]}}, {"source": {"identifier": "ethereum.berlin.state.touch_account", "specifier": 0, "path": "src/ethereum/berlin/state.py"}, "content": {"type": ["function"], "name": ["touch_account"], "text": ["Initializes an account to state. Parameters state: The current state. address: The address of the account that need to initialised."]}}, {"source": {"identifier": "ethereum.berlin.state.increment_nonce", "specifier": 0, "path": "src/ethereum/berlin/state.py"}, "content": {"type": ["function"], "name": ["increment_nonce"], "text": ["Increments the nonce of an account. Parameters state: The current state. address: Address of the account whose nonce needs to be incremented."]}}, {"source": {"identifier": "ethereum.berlin.state.set_code", "specifier": 0, "path": "src/ethereum/berlin/state.py"}, "content": {"type": ["function"], "name": ["set_code"], "text": ["Sets Account code. Parameters state: The current state. address: Address of the account whose code needs to be update. code: The bytecode that needs to be set."]}}, {"source": {"identifier": "ethereum.berlin.state.create_ether", "specifier": 0, "path": "src/ethereum/berlin/state.py"}, "content": {"type": ["function"], "name": ["create_ether"], "text": ["Add newly created ether to an account. Parameters state: The current state. address: Address of the account to which ether is added. amount: The amount of ether to be added to the account of interest."]}}, {"source": {"identifier": "ethereum.berlin.state.get_storage_original", "specifier": 0, "path": "src/ethereum/berlin/state.py"}, "content": {"type": ["function"], "name": ["get_storage_original"], "text": ["Get the original value in a storage slot i.e. the value before the current transaction began. This function reads the value from the snapshots taken before executing the transaction. Parameters state: The current state. address: Address of the account to read the value from. key: Key of the storage slot."]}}, {"source": {"identifier": "ethereum.london.vm.instructions.keccak", "specifier": 0, "path": "src/ethereum/london/vm/instructions/keccak.py"}, "content": {"type": ["module"], "name": ["ethereum.london.vm.instructions.keccak"], "text": ["Ethereum Virtual Machine (EVM) Keccak Instructions ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementations of the EVM keccak instructions."]}}, {"source": {"identifier": "ethereum.london.vm.instructions.keccak.keccak", "specifier": 0, "path": "src/ethereum/london/vm/instructions/keccak.py"}, "content": {"type": ["function"], "name": ["keccak"], "text": ["Pushes to the stack the Keccak-256 hash of a region of memory. This also expands the memory, in case the memory is insufficient to access the data's memory location. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.berlin", "specifier": 0, "path": "src/ethereum/berlin/__init__.py"}, "content": {"type": ["module"], "name": ["ethereum.berlin"], "text": ["Ethereum Berlin Hardfork ^^^^^^^^^^^^^^^^^^^^^^^^ The Tenth Ethereum hardfork."]}}, {"source": {"identifier": "ethereum.berlin.MAINNET_FORK_BLOCK", "specifier": 0, "path": "src/ethereum/berlin/__init__.py"}, "content": {"type": ["attribute"], "name": ["MAINNET_FORK_BLOCK"]}}, {"source": {"identifier": "ethereum.berlin.bloom", "specifier": 0, "path": "src/ethereum/berlin/bloom.py"}, "content": {"type": ["module"], "name": ["ethereum.berlin.bloom"], "text": ["Ethereum Logs Bloom ^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction This modules defines functions for calculating bloom filters of logs. For the general theory of bloom filters see e.g.  Wikipedia <https://en.wikipedia.org/wiki/Bloom_filter> _. Bloom filters are used to allow for efficient searching of logs by address and/or topic, by rapidly eliminating blocks and reciepts from their search."]}}, {"source": {"identifier": "ethereum.berlin.bloom.add_to_bloom", "specifier": 0, "path": "src/ethereum/berlin/bloom.py"}, "content": {"type": ["function"], "name": ["add_to_bloom"], "text": ["Add a bloom entry to the bloom filter ( bloom ). The number of hash functions used is 3. They are calculated by taking the least significant 11 bits from the first 3 16-bit words of the keccak_256()  hash of  bloom_entry . Parameters bloom : The bloom filter. bloom_entry : An entry which is to be added to bloom filter."]}}, {"source": {"identifier": "ethereum.berlin.bloom.logs_bloom", "specifier": 0, "path": "src/ethereum/berlin/bloom.py"}, "content": {"type": ["function"], "name": ["logs_bloom"], "text": ["Obtain the logs bloom from a list of log entries. The address and each topic of a log are added to the bloom filter. Parameters logs : List of logs for which the logs bloom is to be obtained. Returns logs_bloom :  Bloom The logs bloom obtained which is 256 bytes with some bits set as per the caller address and the log topics."]}}, {"source": {"identifier": "ethereum.london.vm.instructions.bitwise", "specifier": 0, "path": "src/ethereum/london/vm/instructions/bitwise.py"}, "content": {"type": ["module"], "name": ["ethereum.london.vm.instructions.bitwise"], "text": ["Ethereum Virtual Machine (EVM) Bitwise Instructions ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementations of the EVM bitwise instructions."]}}, {"source": {"identifier": "ethereum.london.vm.instructions.bitwise.bitwise_and", "specifier": 0, "path": "src/ethereum/london/vm/instructions/bitwise.py"}, "content": {"type": ["function"], "name": ["bitwise_and"], "text": ["Bitwise AND operation of the top 2 elements of the stack. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.london.vm.instructions.bitwise.bitwise_or", "specifier": 0, "path": "src/ethereum/london/vm/instructions/bitwise.py"}, "content": {"type": ["function"], "name": ["bitwise_or"], "text": ["Bitwise OR operation of the top 2 elements of the stack. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.london.vm.instructions.bitwise.bitwise_xor", "specifier": 0, "path": "src/ethereum/london/vm/instructions/bitwise.py"}, "content": {"type": ["function"], "name": ["bitwise_xor"], "text": ["Bitwise XOR operation of the top 2 elements of the stack. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.london.vm.instructions.bitwise.bitwise_not", "specifier": 0, "path": "src/ethereum/london/vm/instructions/bitwise.py"}, "content": {"type": ["function"], "name": ["bitwise_not"], "text": ["Bitwise NOT operation of the top element of the stack. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.london.vm.instructions.bitwise.get_byte", "specifier": 0, "path": "src/ethereum/london/vm/instructions/bitwise.py"}, "content": {"type": ["function"], "name": ["get_byte"], "text": ["For a word (defined by next top element of the stack), retrieve the Nth byte (0-indexed and defined by top element of stack) from the left (most significant) to right (least significant). Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.london.vm.instructions.bitwise.bitwise_shl", "specifier": 0, "path": "src/ethereum/london/vm/instructions/bitwise.py"}, "content": {"type": ["function"], "name": ["bitwise_shl"], "text": ["Logical shift left (SHL) operation of the top 2 elements of the stack. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.london.vm.instructions.bitwise.bitwise_shr", "specifier": 0, "path": "src/ethereum/london/vm/instructions/bitwise.py"}, "content": {"type": ["function"], "name": ["bitwise_shr"], "text": ["Logical shift right (SHR) operation of the top 2 elements of the stack. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.london.vm.instructions.bitwise.bitwise_sar", "specifier": 0, "path": "src/ethereum/london/vm/instructions/bitwise.py"}, "content": {"type": ["function"], "name": ["bitwise_sar"], "text": ["Arithmetic shift right (SAR) operation of the top 2 elements of the stack. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.berlin.fork_types", "specifier": 0, "path": "src/ethereum/berlin/fork_types.py"}, "content": {"type": ["module"], "name": ["ethereum.berlin.fork_types"], "text": ["Ethereum Types ^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Types re-used throughout the specification, which are specific to Ethereum."]}}, {"source": {"identifier": "ethereum.berlin.fork_types.Address", "specifier": 0, "path": "src/ethereum/berlin/fork_types.py"}, "content": {"type": ["attribute"], "name": ["Address"]}}, {"source": {"identifier": "ethereum.berlin.fork_types.Root", "specifier": 0, "path": "src/ethereum/berlin/fork_types.py"}, "content": {"type": ["attribute"], "name": ["Root"]}}, {"source": {"identifier": "ethereum.berlin.fork_types.Bloom", "specifier": 0, "path": "src/ethereum/berlin/fork_types.py"}, "content": {"type": ["attribute"], "name": ["Bloom"]}}, {"source": {"identifier": "ethereum.berlin.fork_types.TX_BASE_COST", "specifier": 0, "path": "src/ethereum/berlin/fork_types.py"}, "content": {"type": ["attribute"], "name": ["TX_BASE_COST"]}}, {"source": {"identifier": "ethereum.berlin.fork_types.TX_DATA_COST_PER_NON_ZERO", "specifier": 0, "path": "src/ethereum/berlin/fork_types.py"}, "content": {"type": ["attribute"], "name": ["TX_DATA_COST_PER_NON_ZERO"]}}, {"source": {"identifier": "ethereum.berlin.fork_types.TX_DATA_COST_PER_ZERO", "specifier": 0, "path": "src/ethereum/berlin/fork_types.py"}, "content": {"type": ["attribute"], "name": ["TX_DATA_COST_PER_ZERO"]}}, {"source": {"identifier": "ethereum.berlin.fork_types.TX_CREATE_COST", "specifier": 0, "path": "src/ethereum/berlin/fork_types.py"}, "content": {"type": ["attribute"], "name": ["TX_CREATE_COST"]}}, {"source": {"identifier": "ethereum.berlin.fork_types.TX_ACCESS_LIST_ADDRESS_COST", "specifier": 0, "path": "src/ethereum/berlin/fork_types.py"}, "content": {"type": ["attribute"], "name": ["TX_ACCESS_LIST_ADDRESS_COST"]}}, {"source": {"identifier": "ethereum.berlin.fork_types.TX_ACCESS_LIST_STORAGE_KEY_COST", "specifier": 0, "path": "src/ethereum/berlin/fork_types.py"}, "content": {"type": ["attribute"], "name": ["TX_ACCESS_LIST_STORAGE_KEY_COST"]}}, {"source": {"identifier": "ethereum.berlin.fork_types.LegacyTransaction", "specifier": 0, "path": "src/ethereum/berlin/fork_types.py"}, "content": {"type": ["class"], "name": ["LegacyTransaction"], "text": ["Atomic operation performed on the block chain."]}}, {"source": {"identifier": "ethereum.berlin.fork_types.LegacyTransaction.nonce", "specifier": 0, "path": "src/ethereum/berlin/fork_types.py"}, "content": {"type": ["attribute"], "name": ["nonce"]}}, {"source": {"identifier": "ethereum.berlin.fork_types.LegacyTransaction.gas_price", "specifier": 0, "path": "src/ethereum/berlin/fork_types.py"}, "content": {"type": ["attribute"], "name": ["gas_price"]}}, {"source": {"identifier": "ethereum.berlin.fork_types.LegacyTransaction.gas", "specifier": 0, "path": "src/ethereum/berlin/fork_types.py"}, "content": {"type": ["attribute"], "name": ["gas"]}}, {"source": {"identifier": "ethereum.berlin.fork_types.LegacyTransaction.to", "specifier": 0, "path": "src/ethereum/berlin/fork_types.py"}, "content": {"type": ["attribute"], "name": ["to"]}}, {"source": {"identifier": "ethereum.berlin.fork_types.LegacyTransaction.value", "specifier": 0, "path": "src/ethereum/berlin/fork_types.py"}, "content": {"type": ["attribute"], "name": ["value"]}}, {"source": {"identifier": "ethereum.berlin.fork_types.LegacyTransaction.data", "specifier": 0, "path": "src/ethereum/berlin/fork_types.py"}, "content": {"type": ["attribute"], "name": ["data"]}}, {"source": {"identifier": "ethereum.berlin.fork_types.LegacyTransaction.v", "specifier": 0, "path": "src/ethereum/berlin/fork_types.py"}, "content": {"type": ["attribute"], "name": ["v"]}}, {"source": {"identifier": "ethereum.berlin.fork_types.LegacyTransaction.r", "specifier": 0, "path": "src/ethereum/berlin/fork_types.py"}, "content": {"type": ["attribute"], "name": ["r"]}}, {"source": {"identifier": "ethereum.berlin.fork_types.LegacyTransaction.s", "specifier": 0, "path": "src/ethereum/berlin/fork_types.py"}, "content": {"type": ["attribute"], "name": ["s"]}}, {"source": {"identifier": "ethereum.berlin.fork_types.AccessListTransaction", "specifier": 0, "path": "src/ethereum/berlin/fork_types.py"}, "content": {"type": ["class"], "name": ["AccessListTransaction"], "text": ["The transaction type added in EIP-2930 to support access lists."]}}, {"source": {"identifier": "ethereum.berlin.fork_types.AccessListTransaction.chain_id", "specifier": 0, "path": "src/ethereum/berlin/fork_types.py"}, "content": {"type": ["attribute"], "name": ["chain_id"]}}, {"source": {"identifier": "ethereum.berlin.fork_types.AccessListTransaction.nonce", "specifier": 0, "path": "src/ethereum/berlin/fork_types.py"}, "content": {"type": ["attribute"], "name": ["nonce"]}}, {"source": {"identifier": "ethereum.berlin.fork_types.AccessListTransaction.gas_price", "specifier": 0, "path": "src/ethereum/berlin/fork_types.py"}, "content": {"type": ["attribute"], "name": ["gas_price"]}}, {"source": {"identifier": "ethereum.berlin.fork_types.AccessListTransaction.gas", "specifier": 0, "path": "src/ethereum/berlin/fork_types.py"}, "content": {"type": ["attribute"], "name": ["gas"]}}, {"source": {"identifier": "ethereum.berlin.fork_types.AccessListTransaction.to", "specifier": 0, "path": "src/ethereum/berlin/fork_types.py"}, "content": {"type": ["attribute"], "name": ["to"]}}, {"source": {"identifier": "ethereum.berlin.fork_types.AccessListTransaction.value", "specifier": 0, "path": "src/ethereum/berlin/fork_types.py"}, "content": {"type": ["attribute"], "name": ["value"]}}, {"source": {"identifier": "ethereum.berlin.fork_types.AccessListTransaction.data", "specifier": 0, "path": "src/ethereum/berlin/fork_types.py"}, "content": {"type": ["attribute"], "name": ["data"]}}, {"source": {"identifier": "ethereum.berlin.fork_types.AccessListTransaction.access_list", "specifier": 0, "path": "src/ethereum/berlin/fork_types.py"}, "content": {"type": ["attribute"], "name": ["access_list"]}}, {"source": {"identifier": "ethereum.berlin.fork_types.AccessListTransaction.v", "specifier": 0, "path": "src/ethereum/berlin/fork_types.py"}, "content": {"type": ["attribute"], "name": ["v"]}}, {"source": {"identifier": "ethereum.berlin.fork_types.AccessListTransaction.r", "specifier": 0, "path": "src/ethereum/berlin/fork_types.py"}, "content": {"type": ["attribute"], "name": ["r"]}}, {"source": {"identifier": "ethereum.berlin.fork_types.AccessListTransaction.s", "specifier": 0, "path": "src/ethereum/berlin/fork_types.py"}, "content": {"type": ["attribute"], "name": ["s"]}}, {"source": {"identifier": "ethereum.berlin.fork_types.Transaction", "specifier": 0, "path": "src/ethereum/berlin/fork_types.py"}, "content": {"type": ["attribute"], "name": ["Transaction"]}}, {"source": {"identifier": "ethereum.berlin.fork_types.encode_transaction", "specifier": 0, "path": "src/ethereum/berlin/fork_types.py"}, "content": {"type": ["function"], "name": ["encode_transaction"], "text": ["Encode a transaction. Needed because non-legacy transactions aren't RLP."]}}, {"source": {"identifier": "ethereum.berlin.fork_types.decode_transaction", "specifier": 0, "path": "src/ethereum/berlin/fork_types.py"}, "content": {"type": ["function"], "name": ["decode_transaction"], "text": ["Decode a transaction. Needed because non-legacy transactions aren't RLP."]}}, {"source": {"identifier": "ethereum.berlin.fork_types.Account", "specifier": 0, "path": "src/ethereum/berlin/fork_types.py"}, "content": {"type": ["class"], "name": ["Account"], "text": ["State associated with an address."]}}, {"source": {"identifier": "ethereum.berlin.fork_types.Account.nonce", "specifier": 0, "path": "src/ethereum/berlin/fork_types.py"}, "content": {"type": ["attribute"], "name": ["nonce"]}}, {"source": {"identifier": "ethereum.berlin.fork_types.Account.balance", "specifier": 0, "path": "src/ethereum/berlin/fork_types.py"}, "content": {"type": ["attribute"], "name": ["balance"]}}, {"source": {"identifier": "ethereum.berlin.fork_types.Account.code", "specifier": 0, "path": "src/ethereum/berlin/fork_types.py"}, "content": {"type": ["attribute"], "name": ["code"]}}, {"source": {"identifier": "ethereum.berlin.fork_types.EMPTY_ACCOUNT", "specifier": 0, "path": "src/ethereum/berlin/fork_types.py"}, "content": {"type": ["attribute"], "name": ["EMPTY_ACCOUNT"]}}, {"source": {"identifier": "ethereum.berlin.fork_types.encode_account", "specifier": 0, "path": "src/ethereum/berlin/fork_types.py"}, "content": {"type": ["function"], "name": ["encode_account"], "text": ["Encode  Account  dataclass. Storage is not stored in the  Account  dataclass, so  Accounts  cannot be encoded with providing a storage root."]}}, {"source": {"identifier": "ethereum.berlin.fork_types.Header", "specifier": 0, "path": "src/ethereum/berlin/fork_types.py"}, "content": {"type": ["class"], "name": ["Header"], "text": ["Header portion of a block on the chain."]}}, {"source": {"identifier": "ethereum.berlin.fork_types.Header.parent_hash", "specifier": 0, "path": "src/ethereum/berlin/fork_types.py"}, "content": {"type": ["attribute"], "name": ["parent_hash"]}}, {"source": {"identifier": "ethereum.berlin.fork_types.Header.ommers_hash", "specifier": 0, "path": "src/ethereum/berlin/fork_types.py"}, "content": {"type": ["attribute"], "name": ["ommers_hash"]}}, {"source": {"identifier": "ethereum.berlin.fork_types.Header.coinbase", "specifier": 0, "path": "src/ethereum/berlin/fork_types.py"}, "content": {"type": ["attribute"], "name": ["coinbase"]}}, {"source": {"identifier": "ethereum.berlin.fork_types.Header.state_root", "specifier": 0, "path": "src/ethereum/berlin/fork_types.py"}, "content": {"type": ["attribute"], "name": ["state_root"]}}, {"source": {"identifier": "ethereum.berlin.fork_types.Header.transactions_root", "specifier": 0, "path": "src/ethereum/berlin/fork_types.py"}, "content": {"type": ["attribute"], "name": ["transactions_root"]}}, {"source": {"identifier": "ethereum.berlin.fork_types.Header.receipt_root", "specifier": 0, "path": "src/ethereum/berlin/fork_types.py"}, "content": {"type": ["attribute"], "name": ["receipt_root"]}}, {"source": {"identifier": "ethereum.berlin.fork_types.Header.bloom", "specifier": 0, "path": "src/ethereum/berlin/fork_types.py"}, "content": {"type": ["attribute"], "name": ["bloom"]}}, {"source": {"identifier": "ethereum.berlin.fork_types.Header.difficulty", "specifier": 0, "path": "src/ethereum/berlin/fork_types.py"}, "content": {"type": ["attribute"], "name": ["difficulty"]}}, {"source": {"identifier": "ethereum.berlin.fork_types.Header.number", "specifier": 0, "path": "src/ethereum/berlin/fork_types.py"}, "content": {"type": ["attribute"], "name": ["number"]}}, {"source": {"identifier": "ethereum.berlin.fork_types.Header.gas_limit", "specifier": 0, "path": "src/ethereum/berlin/fork_types.py"}, "content": {"type": ["attribute"], "name": ["gas_limit"]}}, {"source": {"identifier": "ethereum.berlin.fork_types.Header.gas_used", "specifier": 0, "path": "src/ethereum/berlin/fork_types.py"}, "content": {"type": ["attribute"], "name": ["gas_used"]}}, {"source": {"identifier": "ethereum.berlin.fork_types.Header.timestamp", "specifier": 0, "path": "src/ethereum/berlin/fork_types.py"}, "content": {"type": ["attribute"], "name": ["timestamp"]}}, {"source": {"identifier": "ethereum.berlin.fork_types.Header.extra_data", "specifier": 0, "path": "src/ethereum/berlin/fork_types.py"}, "content": {"type": ["attribute"], "name": ["extra_data"]}}, {"source": {"identifier": "ethereum.berlin.fork_types.Header.mix_digest", "specifier": 0, "path": "src/ethereum/berlin/fork_types.py"}, "content": {"type": ["attribute"], "name": ["mix_digest"]}}, {"source": {"identifier": "ethereum.berlin.fork_types.Header.nonce", "specifier": 0, "path": "src/ethereum/berlin/fork_types.py"}, "content": {"type": ["attribute"], "name": ["nonce"]}}, {"source": {"identifier": "ethereum.berlin.fork_types.Block", "specifier": 0, "path": "src/ethereum/berlin/fork_types.py"}, "content": {"type": ["class"], "name": ["Block"], "text": ["A complete block."]}}, {"source": {"identifier": "ethereum.berlin.fork_types.Block.header", "specifier": 0, "path": "src/ethereum/berlin/fork_types.py"}, "content": {"type": ["attribute"], "name": ["header"]}}, {"source": {"identifier": "ethereum.berlin.fork_types.Block.transactions", "specifier": 0, "path": "src/ethereum/berlin/fork_types.py"}, "content": {"type": ["attribute"], "name": ["transactions"]}}, {"source": {"identifier": "ethereum.berlin.fork_types.Block.ommers", "specifier": 0, "path": "src/ethereum/berlin/fork_types.py"}, "content": {"type": ["attribute"], "name": ["ommers"]}}, {"source": {"identifier": "ethereum.berlin.fork_types.Log", "specifier": 0, "path": "src/ethereum/berlin/fork_types.py"}, "content": {"type": ["class"], "name": ["Log"], "text": ["Data record produced during the execution of a transaction."]}}, {"source": {"identifier": "ethereum.berlin.fork_types.Log.address", "specifier": 0, "path": "src/ethereum/berlin/fork_types.py"}, "content": {"type": ["attribute"], "name": ["address"]}}, {"source": {"identifier": "ethereum.berlin.fork_types.Log.topics", "specifier": 0, "path": "src/ethereum/berlin/fork_types.py"}, "content": {"type": ["attribute"], "name": ["topics"]}}, {"source": {"identifier": "ethereum.berlin.fork_types.Log.data", "specifier": 0, "path": "src/ethereum/berlin/fork_types.py"}, "content": {"type": ["attribute"], "name": ["data"]}}, {"source": {"identifier": "ethereum.berlin.fork_types.Receipt", "specifier": 0, "path": "src/ethereum/berlin/fork_types.py"}, "content": {"type": ["class"], "name": ["Receipt"], "text": ["Result of a transaction."]}}, {"source": {"identifier": "ethereum.berlin.fork_types.Receipt.succeeded", "specifier": 0, "path": "src/ethereum/berlin/fork_types.py"}, "content": {"type": ["attribute"], "name": ["succeeded"]}}, {"source": {"identifier": "ethereum.berlin.fork_types.Receipt.cumulative_gas_used", "specifier": 0, "path": "src/ethereum/berlin/fork_types.py"}, "content": {"type": ["attribute"], "name": ["cumulative_gas_used"]}}, {"source": {"identifier": "ethereum.berlin.fork_types.Receipt.bloom", "specifier": 0, "path": "src/ethereum/berlin/fork_types.py"}, "content": {"type": ["attribute"], "name": ["bloom"]}}, {"source": {"identifier": "ethereum.berlin.fork_types.Receipt.logs", "specifier": 0, "path": "src/ethereum/berlin/fork_types.py"}, "content": {"type": ["attribute"], "name": ["logs"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.environment", "specifier": 0, "path": "src/ethereum/london/vm/instructions/environment.py"}, "content": {"type": ["module"], "name": ["ethereum.london.vm.instructions.environment"], "text": ["Ethereum Virtual Machine (EVM) Environmental Instructions ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementations of the EVM environment related instructions."]}}, {"source": {"identifier": "ethereum.london.vm.instructions.environment.address", "specifier": 0, "path": "src/ethereum/london/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["address"], "text": ["Pushes the address of the current executing account to the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.london.vm.instructions.environment.balance", "specifier": 0, "path": "src/ethereum/london/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["balance"], "text": ["Pushes the balance of the given account onto the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.london.vm.instructions.environment.origin", "specifier": 0, "path": "src/ethereum/london/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["origin"], "text": ["Pushes the address of the original transaction sender to the stack. The origin address can only be an EOA. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.london.vm.instructions.environment.caller", "specifier": 0, "path": "src/ethereum/london/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["caller"], "text": ["Pushes the address of the caller onto the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.london.vm.instructions.environment.callvalue", "specifier": 0, "path": "src/ethereum/london/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["callvalue"], "text": ["Push the value (in wei) sent with the call onto the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.london.vm.instructions.environment.calldataload", "specifier": 0, "path": "src/ethereum/london/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["calldataload"], "text": ["Push a word (32 bytes) of the input data belonging to the current environment onto the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.london.vm.instructions.environment.calldatasize", "specifier": 0, "path": "src/ethereum/london/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["calldatasize"], "text": ["Push the size of input data in current environment onto the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.london.vm.instructions.environment.calldatacopy", "specifier": 0, "path": "src/ethereum/london/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["calldatacopy"], "text": ["Copy a portion of the input data in current environment to memory. This will also expand the memory, in case that the memory is insufficient to store the data. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.london.vm.instructions.environment.codesize", "specifier": 0, "path": "src/ethereum/london/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["codesize"], "text": ["Push the size of code running in current environment onto the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.london.vm.instructions.environment.codecopy", "specifier": 0, "path": "src/ethereum/london/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["codecopy"], "text": ["Copy a portion of the code in current environment to memory. This will also expand the memory, in case that the memory is insufficient to store the data. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.london.vm.instructions.environment.gasprice", "specifier": 0, "path": "src/ethereum/london/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["gasprice"], "text": ["Push the gas price used in current environment onto the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.london.vm.instructions.environment.extcodesize", "specifier": 0, "path": "src/ethereum/london/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["extcodesize"], "text": ["Push the code size of a given account onto the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.london.vm.instructions.environment.extcodecopy", "specifier": 0, "path": "src/ethereum/london/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["extcodecopy"], "text": ["Copy a portion of an account's code to memory. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.london.vm.instructions.environment.returndatasize", "specifier": 0, "path": "src/ethereum/london/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["returndatasize"], "text": ["Pushes the size of the return data buffer onto the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.london.vm.instructions.environment.returndatacopy", "specifier": 0, "path": "src/ethereum/london/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["returndatacopy"], "text": ["Copies data from the return data buffer code to memory Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.london.vm.instructions.environment.extcodehash", "specifier": 0, "path": "src/ethereum/london/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["extcodehash"], "text": ["Returns the keccak256 hash of a contract\u2019s bytecode Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.london.vm.instructions.environment.self_balance", "specifier": 0, "path": "src/ethereum/london/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["self_balance"], "text": ["Pushes the balance of the current address to the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.london.vm.instructions.environment.base_fee", "specifier": 0, "path": "src/ethereum/london/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["base_fee"], "text": ["Pushes the base fee of the current block on to the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.berlin.trie", "specifier": 0, "path": "src/ethereum/berlin/trie.py"}, "content": {"type": ["module"], "name": ["ethereum.berlin.trie"], "text": ["State Trie ^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction The state trie is the structure responsible for storing .fork_types.Account  objects."]}}, {"source": {"identifier": "ethereum.berlin.trie.EMPTY_TRIE_ROOT", "specifier": 0, "path": "src/ethereum/berlin/trie.py"}, "content": {"type": ["attribute"], "name": ["EMPTY_TRIE_ROOT"]}}, {"source": {"identifier": "ethereum.berlin.trie.Node", "specifier": 0, "path": "src/ethereum/berlin/trie.py"}, "content": {"type": ["attribute"], "name": ["Node"]}}, {"source": {"identifier": "ethereum.berlin.trie.K", "specifier": 0, "path": "src/ethereum/berlin/trie.py"}, "content": {"type": ["attribute"], "name": ["K"]}}, {"source": {"identifier": "ethereum.berlin.trie.V", "specifier": 0, "path": "src/ethereum/berlin/trie.py"}, "content": {"type": ["attribute"], "name": ["V"]}}, {"source": {"identifier": "ethereum.berlin.trie.LeafNode", "specifier": 0, "path": "src/ethereum/berlin/trie.py"}, "content": {"type": ["class"], "name": ["LeafNode"], "text": ["Leaf node in the Merkle Trie"]}}, {"source": {"identifier": "ethereum.berlin.trie.LeafNode.rest_of_key", "specifier": 0, "path": "src/ethereum/berlin/trie.py"}, "content": {"type": ["attribute"], "name": ["rest_of_key"]}}, {"source": {"identifier": "ethereum.berlin.trie.LeafNode.value", "specifier": 0, "path": "src/ethereum/berlin/trie.py"}, "content": {"type": ["attribute"], "name": ["value"]}}, {"source": {"identifier": "ethereum.berlin.trie.ExtensionNode", "specifier": 0, "path": "src/ethereum/berlin/trie.py"}, "content": {"type": ["class"], "name": ["ExtensionNode"], "text": ["Extension node in the Merkle Trie"]}}, {"source": {"identifier": "ethereum.berlin.trie.ExtensionNode.key_segment", "specifier": 0, "path": "src/ethereum/berlin/trie.py"}, "content": {"type": ["attribute"], "name": ["key_segment"]}}, {"source": {"identifier": "ethereum.berlin.trie.ExtensionNode.subnode", "specifier": 0, "path": "src/ethereum/berlin/trie.py"}, "content": {"type": ["attribute"], "name": ["subnode"]}}, {"source": {"identifier": "ethereum.berlin.trie.BranchNode", "specifier": 0, "path": "src/ethereum/berlin/trie.py"}, "content": {"type": ["class"], "name": ["BranchNode"], "text": ["Branch node in the Merkle Trie"]}}, {"source": {"identifier": "ethereum.berlin.trie.BranchNode.subnodes", "specifier": 0, "path": "src/ethereum/berlin/trie.py"}, "content": {"type": ["attribute"], "name": ["subnodes"]}}, {"source": {"identifier": "ethereum.berlin.trie.BranchNode.value", "specifier": 0, "path": "src/ethereum/berlin/trie.py"}, "content": {"type": ["attribute"], "name": ["value"]}}, {"source": {"identifier": "ethereum.berlin.trie.InternalNode", "specifier": 0, "path": "src/ethereum/berlin/trie.py"}, "content": {"type": ["attribute"], "name": ["InternalNode"]}}, {"source": {"identifier": "ethereum.berlin.trie.encode_internal_node", "specifier": 0, "path": "src/ethereum/berlin/trie.py"}, "content": {"type": ["function"], "name": ["encode_internal_node"], "text": ["Encodes a Merkle Trie node into its RLP form. The RLP will then be serialized into a  Bytes  and hashed unless it is less that 32 bytes when serialized. This function also accepts  None , representing the absence of a node, which is encoded to  b\"\" . Parameters node : Optional[InternalNode] The node to encode. Returns encoded :  rlp.RLP The node encoded as RLP."]}}, {"source": {"identifier": "ethereum.berlin.trie.encode_node", "specifier": 0, "path": "src/ethereum/berlin/trie.py"}, "content": {"type": ["function"], "name": ["encode_node"], "text": ["Encode a Node for storage in the Merkle Trie. Currently mostly an unimplemented stub."]}}, {"source": {"identifier": "ethereum.berlin.trie.Trie", "specifier": 0, "path": "src/ethereum/berlin/trie.py"}, "content": {"type": ["class"], "name": ["Trie"], "text": ["The Merkle Trie."]}}, {"source": {"identifier": "ethereum.berlin.trie.Trie.secured", "specifier": 0, "path": "src/ethereum/berlin/trie.py"}, "content": {"type": ["attribute"], "name": ["secured"]}}, {"source": {"identifier": "ethereum.berlin.trie.Trie.default", "specifier": 0, "path": "src/ethereum/berlin/trie.py"}, "content": {"type": ["attribute"], "name": ["default"]}}, {"source": {"identifier": "ethereum.berlin.trie.Trie._data", "specifier": 0, "path": "src/ethereum/berlin/trie.py"}, "content": {"type": ["attribute"], "name": ["_data"]}}, {"source": {"identifier": "ethereum.berlin.trie.copy_trie", "specifier": 0, "path": "src/ethereum/berlin/trie.py"}, "content": {"type": ["function"], "name": ["copy_trie"], "text": ["Create a copy of  trie . Since only frozen objects may be stored in tries, the contents are reused. Parameters trie:  Trie Trie to copy. Returns new_trie :  Trie[K, V] A copy of the trie."]}}, {"source": {"identifier": "ethereum.berlin.trie.trie_set", "specifier": 0, "path": "src/ethereum/berlin/trie.py"}, "content": {"type": ["function"], "name": ["trie_set"], "text": ["Stores an item in a Merkle Trie. This method deletes the key if  value == trie.default , because the Merkle Trie represents the default value by omitting it from the trie. Parameters trie:  Trie Trie to store in. key :  Bytes Key to lookup. value :  V Node to insert at  key ."]}}, {"source": {"identifier": "ethereum.berlin.trie.trie_get", "specifier": 0, "path": "src/ethereum/berlin/trie.py"}, "content": {"type": ["function"], "name": ["trie_get"], "text": ["Gets an item from the Merkle Trie. This method returns  trie.default  if the key is missing. Parameters trie: Trie to lookup in. key : Key to lookup. Returns node :  V Node at  key  in the trie."]}}, {"source": {"identifier": "ethereum.berlin.trie.common_prefix_length", "specifier": 0, "path": "src/ethereum/berlin/trie.py"}, "content": {"type": ["function"], "name": ["common_prefix_length"], "text": ["Find the longest common prefix of two sequences."]}}, {"source": {"identifier": "ethereum.berlin.trie.nibble_list_to_compact", "specifier": 0, "path": "src/ethereum/berlin/trie.py"}, "content": {"type": ["function"], "name": ["nibble_list_to_compact"], "text": ["Compresses nibble-list into a standard byte array with a flag. A nibble-list is a list of byte values no greater than  15 . The flag is encoded in high nibble of the highest byte. The flag nibble can be broken down into two two-bit flags. Highest nibble:: +---+---+----------+--------+\n| _ | _ | is_leaf | parity |\n+---+---+----------+--------+\n  3   2      1         0\n The lowest bit of the nibble encodes the parity of the length of the remaining nibbles --  0  when even and  1  when odd. The second lowest bit is used to distinguish leaf and extension nodes. The other two bits are not used. Parameters x : Array of nibbles. is_leaf : True if this is part of a leaf node, or false if it is an extension node. Returns compressed :  bytearray Compact byte array."]}}, {"source": {"identifier": "ethereum.berlin.trie.bytes_to_nibble_list", "specifier": 0, "path": "src/ethereum/berlin/trie.py"}, "content": {"type": ["function"], "name": ["bytes_to_nibble_list"], "text": ["Converts a  Bytes  into to a sequence of nibbles (bytes with value < 16). Parameters bytes_: The  Bytes  to convert. Returns nibble_list :  Bytes The  Bytes  in nibble-list format."]}}, {"source": {"identifier": "ethereum.berlin.trie._prepare_trie", "specifier": 0, "path": "src/ethereum/berlin/trie.py"}, "content": {"type": ["function"], "name": ["_prepare_trie"], "text": ["Prepares the trie for root calculation. Removes values that are empty, hashes the keys (if  secured == True ) and encodes all the nodes. Parameters trie : The  Trie  to prepare. get_storage_root : Function to get the storage root of an account. Needed to encode Account  objects. Returns out :  Mapping[ethereum.base_types.Bytes, Node] Object with keys mapped to nibble-byte form."]}}, {"source": {"identifier": "ethereum.berlin.trie.root", "specifier": 0, "path": "src/ethereum/berlin/trie.py"}, "content": {"type": ["function"], "name": ["root"], "text": ["Computes the root of a modified merkle patricia trie (MPT). Parameters trie : Trie  to get the root of. get_storage_root : Function to get the storage root of an account. Needed to encode Account  objects. Returns root :  eth1spec.fork_types.Root MPT root of the underlying key-value pairs."]}}, {"source": {"identifier": "ethereum.berlin.trie.patricialize", "specifier": 0, "path": "src/ethereum/berlin/trie.py"}, "content": {"type": ["function"], "name": ["patricialize"], "text": ["Structural composition function. Used to recursively patricialize and merkleize a dictionary. Includes memoization of the tree structure and hashes. Parameters obj : Underlying trie key-value pairs, with keys in nibble-list format. level : Current trie level. Returns node :  eth1spec.base_types.Bytes Root node of  obj ."]}}, {"source": {"identifier": "ethereum.berlin.fork", "specifier": 0, "path": "src/ethereum/berlin/fork.py"}, "content": {"type": ["module"], "name": ["ethereum.berlin.fork"], "text": ["Ethereum Specification ^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Entry point for the Ethereum specification."]}}, {"source": {"identifier": "ethereum.berlin.fork.BLOCK_REWARD", "specifier": 0, "path": "src/ethereum/berlin/fork.py"}, "content": {"type": ["attribute"], "name": ["BLOCK_REWARD"]}}, {"source": {"identifier": "ethereum.berlin.fork.GAS_LIMIT_ADJUSTMENT_FACTOR", "specifier": 0, "path": "src/ethereum/berlin/fork.py"}, "content": {"type": ["attribute"], "name": ["GAS_LIMIT_ADJUSTMENT_FACTOR"]}}, {"source": {"identifier": "ethereum.berlin.fork.GAS_LIMIT_MINIMUM", "specifier": 0, "path": "src/ethereum/berlin/fork.py"}, "content": {"type": ["attribute"], "name": ["GAS_LIMIT_MINIMUM"]}}, {"source": {"identifier": "ethereum.berlin.fork.MINIMUM_DIFFICULTY", "specifier": 0, "path": "src/ethereum/berlin/fork.py"}, "content": {"type": ["attribute"], "name": ["MINIMUM_DIFFICULTY"]}}, {"source": {"identifier": "ethereum.berlin.fork.MAX_OMMER_DEPTH", "specifier": 0, "path": "src/ethereum/berlin/fork.py"}, "content": {"type": ["attribute"], "name": ["MAX_OMMER_DEPTH"]}}, {"source": {"identifier": "ethereum.berlin.fork.BOMB_DELAY_BLOCKS", "specifier": 0, "path": "src/ethereum/berlin/fork.py"}, "content": {"type": ["attribute"], "name": ["BOMB_DELAY_BLOCKS"]}}, {"source": {"identifier": "ethereum.berlin.fork.EMPTY_OMMER_HASH", "specifier": 0, "path": "src/ethereum/berlin/fork.py"}, "content": {"type": ["attribute"], "name": ["EMPTY_OMMER_HASH"]}}, {"source": {"identifier": "ethereum.berlin.fork.BlockChain", "specifier": 0, "path": "src/ethereum/berlin/fork.py"}, "content": {"type": ["class"], "name": ["BlockChain"], "text": ["History and current state of the block chain."]}}, {"source": {"identifier": "ethereum.berlin.fork.BlockChain.blocks", "specifier": 0, "path": "src/ethereum/berlin/fork.py"}, "content": {"type": ["attribute"], "name": ["blocks"]}}, {"source": {"identifier": "ethereum.berlin.fork.BlockChain.state", "specifier": 0, "path": "src/ethereum/berlin/fork.py"}, "content": {"type": ["attribute"], "name": ["state"]}}, {"source": {"identifier": "ethereum.berlin.fork.BlockChain.chain_id", "specifier": 0, "path": "src/ethereum/berlin/fork.py"}, "content": {"type": ["attribute"], "name": ["chain_id"]}}, {"source": {"identifier": "ethereum.berlin.fork.apply_fork", "specifier": 0, "path": "src/ethereum/berlin/fork.py"}, "content": {"type": ["function"], "name": ["apply_fork"], "text": ["Transforms the state from the previous hard fork ( old ) into the block chain object for this hard fork and returns it. When forks need to implement an irregular state transition, this function is used to handle the irregularity. See the :ref: DAO Fork <dao-fork>  for an example. Parameters old : Previous block chain object. Returns new :  BlockChain Upgraded block chain object for this hard fork."]}}, {"source": {"identifier": "ethereum.berlin.fork.get_last_256_block_hashes", "specifier": 0, "path": "src/ethereum/berlin/fork.py"}, "content": {"type": ["function"], "name": ["get_last_256_block_hashes"], "text": ["Obtain the list of hashes of the previous 256 blocks in order of increasing block number. This function will return less hashes for the first 256 blocks. The  BLOCKHASH  opcode needs to access the latest hashes on the chain, therefore this function retrieves them. Parameters chain : History and current state. Returns recent_block_hashes :  List[Hash32] Hashes of the recent 256 blocks in order of increasing block number."]}}, {"source": {"identifier": "ethereum.berlin.fork.state_transition", "specifier": 0, "path": "src/ethereum/berlin/fork.py"}, "content": {"type": ["function"], "name": ["state_transition"], "text": ["Attempts to apply a block to an existing block chain. All parts of the block's contents need to be verified before being added to the chain. Blocks are verified by ensuring that the contents of the block make logical sense with the contents of the parent block. The information in the block's header must also match the corresponding information in the block. To implement Ethereum, in theory clients are only required to store the most recent 255 blocks of the chain since as far as execution is concerned, only those blocks are accessed. Practically, however, clients should store more blocks to handle reorgs. Parameters chain : History and current state. block : Block to apply to  chain ."]}}, {"source": {"identifier": "ethereum.berlin.fork.validate_header", "specifier": 0, "path": "src/ethereum/berlin/fork.py"}, "content": {"type": ["function"], "name": ["validate_header"], "text": ["Verifies a block header. In order to consider a block's header valid, the logic for the quantities in the header should match the logic for the block itself. For example the header timestamp should be greater than the block's parent timestamp because the block was created  after  the parent block. Additionally, the block's number should be directly folowing the parent block's number since it is the next block in the sequence. Parameters header : Header to check for correctness. parent_header : Parent Header of the header to check for correctness"]}}, {"source": {"identifier": "ethereum.berlin.fork.generate_header_hash_for_pow", "specifier": 0, "path": "src/ethereum/berlin/fork.py"}, "content": {"type": ["function"], "name": ["generate_header_hash_for_pow"], "text": ["Generate rlp hash of the header which is to be used for Proof-of-Work verification. In other words, the PoW artefacts  mix_digest  and  nonce  are ignored while calculating this hash. A particular PoW is valid for a single hash, that hash is computed by this function. The  nonce  and  mix_digest  are omitted from this hash because they are being changed by miners in their search for a sufficient proof-of-work. Parameters header : The header object for which the hash is to be generated. Returns hash :  Hash32 The PoW valid rlp hash of the passed in header."]}}, {"source": {"identifier": "ethereum.berlin.fork.validate_proof_of_work", "specifier": 0, "path": "src/ethereum/berlin/fork.py"}, "content": {"type": ["function"], "name": ["validate_proof_of_work"], "text": ["Validates the Proof of Work constraints. In order to verify that a miner's proof-of-work is valid for a block, a mix-digest  and  result  are calculated using the  hashimoto_light hash function. The mix digest is a hash of the header and the nonce that is passed through and it confirms whether or not proof-of-work was done on the correct block. The result is the actual hash value of the block. Parameters header : Header of interest."]}}, {"source": {"identifier": "ethereum.berlin.fork.check_transaction", "specifier": 0, "path": "src/ethereum/berlin/fork.py"}, "content": {"type": ["function"], "name": ["check_transaction"], "text": ["Check if the transaction is includable in the block. Parameters tx : The transaction. gas_available : The gas remaining in the block. chain_id : The ID of the current chain. Returns sender_address : The sender of the transaction. Raises InvalidBlock : If the transaction is not includable."]}}, {"source": {"identifier": "ethereum.berlin.fork.make_receipt", "specifier": 0, "path": "src/ethereum/berlin/fork.py"}, "content": {"type": ["function"], "name": ["make_receipt"], "text": ["Make the receipt for a transaction that was executed. Parameters tx : The executed transaction. has_erred : Whether the top level frame of the transaction exited with an error. cumulative_gas_used : The total gas used so far in the block after the transaction was executed. logs : The logs produced by the transaction. Returns receipt : The receipt for the transaction."]}}, {"source": {"identifier": "ethereum.berlin.fork.apply_body", "specifier": 0, "path": "src/ethereum/berlin/fork.py"}, "content": {"type": ["function"], "name": ["apply_body"], "text": ["Executes a block. Many of the contents of a block are stored in data structures called tries. There is a transactions trie which is similar to a ledger of the transactions stored in the current block. There is also a receipts trie which stores the results of executing a transaction, like the post state and gas used. This function creates and executes the block that is to be added to the chain. Parameters state : Current account state. block_hashes : List of hashes of the previous 256 blocks in the order of increasing block number. coinbase : Address of account which receives block reward and transaction fees. block_number : Position of the block within the chain. block_gas_limit : Initial amount of gas available for execution in this block. block_time : Time the block was produced, measured in seconds since the epoch. block_difficulty : Difficulty of the block. transactions : Transactions included in the block. ommers : Headers of ancestor blocks which are not direct parents (formerly uncles.) chain_id : ID of the executing chain. Returns gas_available :  ethereum.base_types.Uint Remaining gas after all transactions have been executed. transactions_root :  ethereum.fork_types.Root Trie root of all the transactions in the block. receipt_root :  ethereum.fork_types.Root Trie root of all the receipts in the block. block_logs_bloom :  Bloom Logs bloom of all the logs included in all the transactions of the block. state :  ethereum.fork_types.State State after all transactions have been executed."]}}, {"source": {"identifier": "ethereum.berlin.fork.validate_ommers", "specifier": 0, "path": "src/ethereum/berlin/fork.py"}, "content": {"type": ["function"], "name": ["validate_ommers"], "text": ["Validates the ommers mentioned in the block. An ommer block is a block that wasn't canonically added to the blockchain because it wasn't validated as fast as the canonical block but was mined at the same time. To be considered valid, the ommers must adhere to the rules defined in the Ethereum protocol. The maximum amount of ommers is 2 per block and there cannot be duplicate ommers in a block. Many of the other ommer contraints are listed in the in-line comments of this function. Parameters ommers : List of ommers mentioned in the current block. block_header: The header of current block. chain : History and current state."]}}, {"source": {"identifier": "ethereum.berlin.fork.pay_rewards", "specifier": 0, "path": "src/ethereum/berlin/fork.py"}, "content": {"type": ["function"], "name": ["pay_rewards"], "text": ["Pay rewards to the block miner as well as the ommers miners. The miner of the canonical block is rewarded with the predetermined block reward,  BLOCK_REWARD , plus a variable award based off of the number of ommer blocks that were mined around the same time, and included in the canonical block's header. An ommer block is a block that wasn't added to the canonical blockchain because it wasn't validated as fast as the accepted block but was mined at the same time. Although not all blocks that are mined are added to the canonical chain, miners are still paid a reward for their efforts. This reward is called an ommer reward and is calculated based on the number associated with the ommer block that they mined. Parameters state : Current account state. block_number : Position of the block within the chain. coinbase : Address of account which receives block reward and transaction fees. ommers : List of ommers mentioned in the current block."]}}, {"source": {"identifier": "ethereum.berlin.fork.process_transaction", "specifier": 0, "path": "src/ethereum/berlin/fork.py"}, "content": {"type": ["function"], "name": ["process_transaction"], "text": ["Execute a transaction against the provided environment. This function processes the actions needed to execute a transaction. It decrements the sender's account after calculating the gas fee and refunds them the proper amount after execution. Calling contracts, deploying code, and incrementing nonces are all examples of actions that happen within this function or from a call made within this function. Accounts that are marked for deletion are processed and destroyed after execution. Parameters env : Environment for the Ethereum Virtual Machine. tx : Transaction to execute. Returns gas_left :  ethereum.base_types.U256 Remaining gas after execution. logs :  Tuple[ethereum.fork_types.Log, ...] Logs generated during execution."]}}, {"source": {"identifier": "ethereum.berlin.fork.validate_transaction", "specifier": 0, "path": "src/ethereum/berlin/fork.py"}, "content": {"type": ["function"], "name": ["validate_transaction"], "text": ["Verifies a transaction. The gas in a transaction gets used to pay for the intrinsic cost of operations, therefore if there is insufficient gas then it would not be possible to execute a transaction and it will be declared invalid. Additionally, the nonce of a transaction must not equal or exceed the limit defined in  EIP-2681 <https://eips.ethereum.org/EIPS/eip-2681> _. In practice, defining the limit as  2**64-1  has no impact because sending  2**64-1  transactions is improbable. It's not strictly impossible though,  2**64-1  transactions is the entire capacity of the Ethereum blockchain at 2022 gas limits for a little over 22 years. Parameters tx : Transaction to validate. Returns verified :  bool True if the transaction can be executed, or False otherwise."]}}, {"source": {"identifier": "ethereum.berlin.fork.calculate_intrinsic_cost", "specifier": 0, "path": "src/ethereum/berlin/fork.py"}, "content": {"type": ["function"], "name": ["calculate_intrinsic_cost"], "text": ["Calculates the gas that is charged before execution is started. The intrinsic cost of the transaction is charged before execution has begun. Functions/operations in the EVM cost money to execute so this intrinsic cost is for the operations that need to be paid for as part of the transaction. Data transfer, for example, is part of this intrinsic cost. It costs ether to send data over the wire and that ether is accounted for in the intrinsic cost calculated in this function. This intrinsic cost must be calculated and paid for before execution in order for all operations to be implemented. Parameters tx : Transaction to compute the intrinsic cost of. Returns verified :  ethereum.base_types.Uint The intrinsic cost of the transaction."]}}, {"source": {"identifier": "ethereum.berlin.fork.recover_sender", "specifier": 0, "path": "src/ethereum/berlin/fork.py"}, "content": {"type": ["function"], "name": ["recover_sender"], "text": ["Extracts the sender address from a transaction. The v, r, and s values are the three parts that make up the signature of a transaction. In order to recover the sender of a transaction the two components needed are the signature ( v ,  r , and  s ) and the signing hash of the transaction. The sender's public key can be obtained with these two values and therefore the sender address can be retrieved. Parameters tx : Transaction of interest. chain_id : ID of the executing chain. Returns sender :  ethereum.fork_types.Address The address of the account that signed the transaction."]}}, {"source": {"identifier": "ethereum.berlin.fork.signing_hash_pre155", "specifier": 0, "path": "src/ethereum/berlin/fork.py"}, "content": {"type": ["function"], "name": ["signing_hash_pre155"], "text": ["Compute the hash of a transaction used in a legacy (pre EIP 155) signature. Parameters tx : Transaction of interest. Returns hash :  ethereum.crypto.hash.Hash32 Hash of the transaction."]}}, {"source": {"identifier": "ethereum.berlin.fork.signing_hash_155", "specifier": 0, "path": "src/ethereum/berlin/fork.py"}, "content": {"type": ["function"], "name": ["signing_hash_155"], "text": ["Compute the hash of a transaction used in a EIP 155 signature. Parameters tx : Transaction of interest. Returns hash :  ethereum.crypto.hash.Hash32 Hash of the transaction."]}}, {"source": {"identifier": "ethereum.berlin.fork.signing_hash_2930", "specifier": 0, "path": "src/ethereum/berlin/fork.py"}, "content": {"type": ["function"], "name": ["signing_hash_2930"], "text": ["Compute the hash of a transaction used in a EIP 2930 signature. Parameters tx : Transaction of interest. Returns hash :  ethereum.crypto.hash.Hash32 Hash of the transaction."]}}, {"source": {"identifier": "ethereum.berlin.fork.compute_header_hash", "specifier": 0, "path": "src/ethereum/berlin/fork.py"}, "content": {"type": ["function"], "name": ["compute_header_hash"], "text": ["Computes the hash of a block header. The header hash of a block is the canonical hash that is used to refer to a specific block and completely distinguishes a block from another. keccak256  is a function that produces a 256 bit hash of any input. It also takes in any number of bytes as an input and produces a single hash for them. A hash is a completely unique output for a single input. So an input corresponds to one unique hash that can be used to identify the input exactly. Prior to using the  keccak256  hash function, the header must be encoded using the Recursive-Length Prefix. See :ref: rlp . RLP encoding the header converts it into a space-efficient format that allows for easy transfer of data between nodes. The purpose of RLP is to encode arbitrarily nested arrays of binary data, and RLP is the primary encoding method used to serialize objects in Ethereum's execution layer. The only purpose of RLP is to encode structure; encoding specific data types (e.g. strings, floats) is left up to higher-order protocols. Parameters header : Header of interest. Returns hash :  ethereum.crypto.hash.Hash32 Hash of the header."]}}, {"source": {"identifier": "ethereum.berlin.fork.check_gas_limit", "specifier": 0, "path": "src/ethereum/berlin/fork.py"}, "content": {"type": ["function"], "name": ["check_gas_limit"], "text": ["Validates the gas limit for a block. The bounds of the gas limit,  max_adjustment_delta , is set as the quotient of the parent block's gas limit and the GAS_LIMIT_ADJUSTMENT_FACTOR . Therefore, if the gas limit that is passed through as a parameter is greater than or equal to the  sum  of the parent's gas and the adjustment delta then the limit for gas is too high and fails this function's check. Similarly, if the limit is less than or equal to the  difference  of the parent's gas and the adjustment delta  or  the predefined  GAS_LIMIT_MINIMUM  then this function's check fails because the gas limit doesn't allow for a sufficient or reasonable amount of gas to be used on a block. Parameters gas_limit : Gas limit to validate. parent_gas_limit : Gas limit of the parent block. Returns check :  bool True if gas limit constraints are satisfied, False otherwise."]}}, {"source": {"identifier": "ethereum.berlin.fork.calculate_block_difficulty", "specifier": 0, "path": "src/ethereum/berlin/fork.py"}, "content": {"type": ["function"], "name": ["calculate_block_difficulty"], "text": ["Computes difficulty of a block using its header and parent header. The difficulty is determined by the time the block was created after its parent. The  offset  is calculated using the parent block's difficulty, parent_difficulty , and the timestamp between blocks. This offset is then added to the parent difficulty and is stored as the  difficulty variable. If the time between the block and its parent is too short, the offset will result in a positive number thus making the sum of parent_difficulty  and  offset  to be a greater value in order to avoid mass forking. But, if the time is long enough, then the offset results in a negative value making the block less difficult than its parent. The base standard for a block's difficulty is the predefined value set for the genesis block since it has no parent. So, a block can't be less difficult than the genesis block, therefore each block's difficulty is set to the maximum value between the calculated difficulty and the  GENESIS_DIFFICULTY . Parameters block_number : Block number of the block. block_timestamp : Timestamp of the block. parent_timestamp : Timestamp of the parent block. parent_difficulty : difficulty of the parent block. parent_has_ommers: does the parent have ommers. Returns difficulty :  ethereum.base_types.Uint Computed difficulty for a block."]}}, {"source": {"identifier": "ethereum.london.vm.instructions.stack", "specifier": 0, "path": "src/ethereum/london/vm/instructions/stack.py"}, "content": {"type": ["module"], "name": ["ethereum.london.vm.instructions.stack"], "text": ["Ethereum Virtual Machine (EVM) Stack Instructions ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementations of the EVM stack related instructions."]}}, {"source": {"identifier": "ethereum.london.vm.instructions.stack.pop", "specifier": 0, "path": "src/ethereum/london/vm/instructions/stack.py"}, "content": {"type": ["function"], "name": ["pop"], "text": ["Remove item from stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.london.vm.instructions.stack.push_n", "specifier": 0, "path": "src/ethereum/london/vm/instructions/stack.py"}, "content": {"type": ["function"], "name": ["push_n"], "text": ["Pushes a N-byte immediate onto the stack. Parameters evm : The current EVM frame. num_bytes : The number of immediate bytes to be read from the code and pushed to the stack."]}}, {"source": {"identifier": "ethereum.london.vm.instructions.stack.dup_n", "specifier": 0, "path": "src/ethereum/london/vm/instructions/stack.py"}, "content": {"type": ["function"], "name": ["dup_n"], "text": ["Duplicate the Nth stack item (from top of the stack) to the top of stack. Parameters evm : The current EVM frame. item_number : The stack item number (0-indexed from top of stack) to be duplicated to the top of stack."]}}, {"source": {"identifier": "ethereum.london.vm.instructions.stack.swap_n", "specifier": 0, "path": "src/ethereum/london/vm/instructions/stack.py"}, "content": {"type": ["function"], "name": ["swap_n"], "text": ["Swap the top and the  item_number  element of the stack, where the top of the stack is position zero. If  item_number  is zero, this function does nothing (which should not be possible, since there is no  SWAP0  instruction). Parameters evm : The current EVM frame. item_number : The stack item number (0-indexed from top of stack) to be swapped with the top of stack element."]}}, {"source": {"identifier": "ethereum.london.vm.instructions.stack.push1", "specifier": 0, "path": "src/ethereum/london/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push1"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.stack.push2", "specifier": 0, "path": "src/ethereum/london/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push2"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.stack.push3", "specifier": 0, "path": "src/ethereum/london/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push3"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.stack.push4", "specifier": 0, "path": "src/ethereum/london/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push4"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.stack.push5", "specifier": 0, "path": "src/ethereum/london/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push5"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.stack.push6", "specifier": 0, "path": "src/ethereum/london/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push6"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.stack.push7", "specifier": 0, "path": "src/ethereum/london/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push7"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.stack.push8", "specifier": 0, "path": "src/ethereum/london/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push8"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.stack.push9", "specifier": 0, "path": "src/ethereum/london/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push9"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.stack.push10", "specifier": 0, "path": "src/ethereum/london/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push10"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.stack.push11", "specifier": 0, "path": "src/ethereum/london/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push11"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.stack.push12", "specifier": 0, "path": "src/ethereum/london/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push12"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.stack.push13", "specifier": 0, "path": "src/ethereum/london/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push13"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.stack.push14", "specifier": 0, "path": "src/ethereum/london/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push14"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.stack.push15", "specifier": 0, "path": "src/ethereum/london/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push15"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.stack.push16", "specifier": 0, "path": "src/ethereum/london/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push16"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.stack.push17", "specifier": 0, "path": "src/ethereum/london/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push17"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.stack.push18", "specifier": 0, "path": "src/ethereum/london/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push18"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.stack.push19", "specifier": 0, "path": "src/ethereum/london/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push19"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.stack.push20", "specifier": 0, "path": "src/ethereum/london/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push20"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.stack.push21", "specifier": 0, "path": "src/ethereum/london/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push21"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.stack.push22", "specifier": 0, "path": "src/ethereum/london/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push22"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.stack.push23", "specifier": 0, "path": "src/ethereum/london/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push23"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.stack.push24", "specifier": 0, "path": "src/ethereum/london/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push24"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.stack.push25", "specifier": 0, "path": "src/ethereum/london/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push25"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.stack.push26", "specifier": 0, "path": "src/ethereum/london/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push26"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.stack.push27", "specifier": 0, "path": "src/ethereum/london/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push27"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.stack.push28", "specifier": 0, "path": "src/ethereum/london/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push28"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.stack.push29", "specifier": 0, "path": "src/ethereum/london/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push29"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.stack.push30", "specifier": 0, "path": "src/ethereum/london/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push30"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.stack.push31", "specifier": 0, "path": "src/ethereum/london/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push31"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.stack.push32", "specifier": 0, "path": "src/ethereum/london/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push32"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.stack.dup1", "specifier": 0, "path": "src/ethereum/london/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup1"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.stack.dup2", "specifier": 0, "path": "src/ethereum/london/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup2"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.stack.dup3", "specifier": 0, "path": "src/ethereum/london/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup3"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.stack.dup4", "specifier": 0, "path": "src/ethereum/london/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup4"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.stack.dup5", "specifier": 0, "path": "src/ethereum/london/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup5"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.stack.dup6", "specifier": 0, "path": "src/ethereum/london/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup6"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.stack.dup7", "specifier": 0, "path": "src/ethereum/london/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup7"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.stack.dup8", "specifier": 0, "path": "src/ethereum/london/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup8"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.stack.dup9", "specifier": 0, "path": "src/ethereum/london/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup9"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.stack.dup10", "specifier": 0, "path": "src/ethereum/london/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup10"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.stack.dup11", "specifier": 0, "path": "src/ethereum/london/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup11"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.stack.dup12", "specifier": 0, "path": "src/ethereum/london/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup12"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.stack.dup13", "specifier": 0, "path": "src/ethereum/london/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup13"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.stack.dup14", "specifier": 0, "path": "src/ethereum/london/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup14"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.stack.dup15", "specifier": 0, "path": "src/ethereum/london/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup15"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.stack.dup16", "specifier": 0, "path": "src/ethereum/london/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup16"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.stack.swap1", "specifier": 0, "path": "src/ethereum/london/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap1"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.stack.swap2", "specifier": 0, "path": "src/ethereum/london/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap2"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.stack.swap3", "specifier": 0, "path": "src/ethereum/london/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap3"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.stack.swap4", "specifier": 0, "path": "src/ethereum/london/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap4"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.stack.swap5", "specifier": 0, "path": "src/ethereum/london/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap5"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.stack.swap6", "specifier": 0, "path": "src/ethereum/london/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap6"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.stack.swap7", "specifier": 0, "path": "src/ethereum/london/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap7"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.stack.swap8", "specifier": 0, "path": "src/ethereum/london/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap8"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.stack.swap9", "specifier": 0, "path": "src/ethereum/london/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap9"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.stack.swap10", "specifier": 0, "path": "src/ethereum/london/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap10"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.stack.swap11", "specifier": 0, "path": "src/ethereum/london/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap11"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.stack.swap12", "specifier": 0, "path": "src/ethereum/london/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap12"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.stack.swap13", "specifier": 0, "path": "src/ethereum/london/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap13"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.stack.swap14", "specifier": 0, "path": "src/ethereum/london/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap14"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.stack.swap15", "specifier": 0, "path": "src/ethereum/london/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap15"]}}, {"source": {"identifier": "ethereum.london.vm.instructions.stack.swap16", "specifier": 0, "path": "src/ethereum/london/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap16"]}}, {"source": {"identifier": "ethereum.berlin.vm.memory", "specifier": 0, "path": "src/ethereum/berlin/vm/memory.py"}, "content": {"type": ["module"], "name": ["ethereum.berlin.vm.memory"], "text": ["Ethereum Virtual Machine (EVM) Memory ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction EVM memory operations."]}}, {"source": {"identifier": "ethereum.berlin.vm.memory.memory_write", "specifier": 0, "path": "src/ethereum/berlin/vm/memory.py"}, "content": {"type": ["function"], "name": ["memory_write"], "text": ["Writes to memory. Parameters memory : Memory contents of the EVM. start_position : Starting pointer to the memory. value : Data to write to memory."]}}, {"source": {"identifier": "ethereum.berlin.vm.memory.memory_read_bytes", "specifier": 0, "path": "src/ethereum/berlin/vm/memory.py"}, "content": {"type": ["function"], "name": ["memory_read_bytes"], "text": ["Read bytes from memory. Parameters memory : Memory contents of the EVM. start_position : Starting pointer to the memory. size : Size of the data that needs to be read from  start_position . Returns data_bytes : Data read from memory."]}}, {"source": {"identifier": "ethereum.berlin.vm.memory.buffer_read", "specifier": 0, "path": "src/ethereum/berlin/vm/memory.py"}, "content": {"type": ["function"], "name": ["buffer_read"], "text": ["Read bytes from a buffer. Padding with zeros if neccesary. Parameters buffer : Memory contents of the EVM. start_position : Starting pointer to the memory. size : Size of the data that needs to be read from  start_position . Returns data_bytes : Data read from memory."]}}, {"source": {"identifier": "ethereum.london.utils", "specifier": 0, "path": "src/ethereum/london/utils/__init__.py"}, "content": {"type": ["module"], "name": ["ethereum.london.utils"], "text": ["Hardfork Utility Functions ^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Utility functions used in this london version of specification."]}}, {"source": {"identifier": "ethereum.berlin.vm.exceptions", "specifier": 0, "path": "src/ethereum/berlin/vm/exceptions.py"}, "content": {"type": ["module"], "name": ["ethereum.berlin.vm.exceptions"], "text": ["Ethereum Virtual Machine (EVM) Exceptions ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Exceptions which cause the EVM to halt exceptionally."]}}, {"source": {"identifier": "ethereum.berlin.vm.exceptions.ExceptionalHalt", "specifier": 0, "path": "src/ethereum/berlin/vm/exceptions.py"}, "content": {"type": ["class"], "name": ["ExceptionalHalt"], "text": ["Indicates that the EVM has experienced an exceptional halt. This causes execution to immediately end with all gas being consumed."]}}, {"source": {"identifier": "ethereum.berlin.vm.exceptions.Revert", "specifier": 0, "path": "src/ethereum/berlin/vm/exceptions.py"}, "content": {"type": ["class"], "name": ["Revert"], "text": ["Raised by the  REVERT  opcode. Unlike other EVM exceptions this does not result in the consumption of all gas."]}}, {"source": {"identifier": "ethereum.berlin.vm.exceptions.StackUnderflowError", "specifier": 0, "path": "src/ethereum/berlin/vm/exceptions.py"}, "content": {"type": ["class"], "name": ["StackUnderflowError"], "text": ["Occurs when a pop is executed on an empty stack."]}}, {"source": {"identifier": "ethereum.berlin.vm.exceptions.StackOverflowError", "specifier": 0, "path": "src/ethereum/berlin/vm/exceptions.py"}, "content": {"type": ["class"], "name": ["StackOverflowError"], "text": ["Occurs when a push is executed on a stack at max capacity."]}}, {"source": {"identifier": "ethereum.berlin.vm.exceptions.OutOfGasError", "specifier": 0, "path": "src/ethereum/berlin/vm/exceptions.py"}, "content": {"type": ["class"], "name": ["OutOfGasError"], "text": ["Occurs when an operation costs more than the amount of gas left in the frame."]}}, {"source": {"identifier": "ethereum.berlin.vm.exceptions.InvalidOpcode", "specifier": 0, "path": "src/ethereum/berlin/vm/exceptions.py"}, "content": {"type": ["class"], "name": ["InvalidOpcode"], "text": ["Raised when an invalid opcode is encountered."]}}, {"source": {"identifier": "ethereum.berlin.vm.exceptions.InvalidJumpDestError", "specifier": 0, "path": "src/ethereum/berlin/vm/exceptions.py"}, "content": {"type": ["class"], "name": ["InvalidJumpDestError"], "text": ["Occurs when the destination of a jump operation doesn't meet any of the following criteria: The jump destination is less than the length of the code. The jump destination should have the  JUMPDEST  opcode (0x5B). The jump destination shouldn't be part of the data corresponding to PUSH-N  opcodes."]}}, {"source": {"identifier": "ethereum.berlin.vm.exceptions.StackDepthLimitError", "specifier": 0, "path": "src/ethereum/berlin/vm/exceptions.py"}, "content": {"type": ["class"], "name": ["StackDepthLimitError"], "text": ["Raised when the message depth is greater than  1024"]}}, {"source": {"identifier": "ethereum.berlin.vm.exceptions.WriteInStaticContext", "specifier": 0, "path": "src/ethereum/berlin/vm/exceptions.py"}, "content": {"type": ["class"], "name": ["WriteInStaticContext"], "text": ["Raised when an attempt is made to modify the state while operating inside of a STATICCALL context."]}}, {"source": {"identifier": "ethereum.berlin.vm.exceptions.OutOfBoundsRead", "specifier": 0, "path": "src/ethereum/berlin/vm/exceptions.py"}, "content": {"type": ["class"], "name": ["OutOfBoundsRead"], "text": ["Raised when an attempt was made to read data beyond the boundaries of the buffer."]}}, {"source": {"identifier": "ethereum.berlin.vm.exceptions.InvalidParameter", "specifier": 0, "path": "src/ethereum/berlin/vm/exceptions.py"}, "content": {"type": ["class"], "name": ["InvalidParameter"], "text": ["Raised when invalid parameters are passed."]}}, {"source": {"identifier": "ethereum.london.utils.address", "specifier": 0, "path": "src/ethereum/london/utils/address.py"}, "content": {"type": ["module"], "name": ["ethereum.london.utils.address"], "text": ["Hardfork Utility Functions For Addresses ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Address specific functions used in this london version of specification."]}}, {"source": {"identifier": "ethereum.london.utils.address.to_address", "specifier": 0, "path": "src/ethereum/london/utils/address.py"}, "content": {"type": ["function"], "name": ["to_address"], "text": ["Convert a Uint or U256 value to a valid address (20 bytes). Parameters data : The string to be converted to bytes. Returns address :  Address The obtained address."]}}, {"source": {"identifier": "ethereum.london.utils.address.compute_contract_address", "specifier": 0, "path": "src/ethereum/london/utils/address.py"}, "content": {"type": ["function"], "name": ["compute_contract_address"], "text": ["Computes address of the new account that needs to be created. Parameters address : The address of the account that wants to create the new account. nonce : The transaction count of the account that wants to create the new account. Returns address:  Address The computed address of the new account."]}}, {"source": {"identifier": "ethereum.london.utils.address.compute_create2_contract_address", "specifier": 0, "path": "src/ethereum/london/utils/address.py"}, "content": {"type": ["function"], "name": ["compute_create2_contract_address"], "text": ["Computes address of the new account that needs to be created, which is based on the sender address, salt and the call data as well. Parameters address : The address of the account that wants to create the new account. salt : Address generation salt. call_data : The code of the new account which is to be created. Returns address:  ethereum.london.fork_types.Address The computed address of the new account."]}}, {"source": {"identifier": "ethereum.berlin.vm", "specifier": 0, "path": "src/ethereum/berlin/vm/__init__.py"}, "content": {"type": ["module"], "name": ["ethereum.berlin.vm"], "text": ["Ethereum Virtual Machine (EVM) ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction The abstract computer which runs the code stored in an .fork_types.Account ."]}}, {"source": {"identifier": "ethereum.berlin.vm.__all__", "specifier": 0, "path": "src/ethereum/berlin/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["__all__"]}}, {"source": {"identifier": "ethereum.berlin.vm.Environment", "specifier": 0, "path": "src/ethereum/berlin/vm/__init__.py"}, "content": {"type": ["class"], "name": ["Environment"], "text": ["Items external to the virtual machine itself, provided by the environment."]}}, {"source": {"identifier": "ethereum.berlin.vm.Environment.caller", "specifier": 0, "path": "src/ethereum/berlin/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["caller"]}}, {"source": {"identifier": "ethereum.berlin.vm.Environment.block_hashes", "specifier": 0, "path": "src/ethereum/berlin/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["block_hashes"]}}, {"source": {"identifier": "ethereum.berlin.vm.Environment.origin", "specifier": 0, "path": "src/ethereum/berlin/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["origin"]}}, {"source": {"identifier": "ethereum.berlin.vm.Environment.coinbase", "specifier": 0, "path": "src/ethereum/berlin/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["coinbase"]}}, {"source": {"identifier": "ethereum.berlin.vm.Environment.number", "specifier": 0, "path": "src/ethereum/berlin/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["number"]}}, {"source": {"identifier": "ethereum.berlin.vm.Environment.gas_limit", "specifier": 0, "path": "src/ethereum/berlin/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["gas_limit"]}}, {"source": {"identifier": "ethereum.berlin.vm.Environment.gas_price", "specifier": 0, "path": "src/ethereum/berlin/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["gas_price"]}}, {"source": {"identifier": "ethereum.berlin.vm.Environment.time", "specifier": 0, "path": "src/ethereum/berlin/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["time"]}}, {"source": {"identifier": "ethereum.berlin.vm.Environment.difficulty", "specifier": 0, "path": "src/ethereum/berlin/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["difficulty"]}}, {"source": {"identifier": "ethereum.berlin.vm.Environment.state", "specifier": 0, "path": "src/ethereum/berlin/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["state"]}}, {"source": {"identifier": "ethereum.berlin.vm.Environment.chain_id", "specifier": 0, "path": "src/ethereum/berlin/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["chain_id"]}}, {"source": {"identifier": "ethereum.berlin.vm.Message", "specifier": 0, "path": "src/ethereum/berlin/vm/__init__.py"}, "content": {"type": ["class"], "name": ["Message"], "text": ["Items that are used by contract creation or message call."]}}, {"source": {"identifier": "ethereum.berlin.vm.Message.caller", "specifier": 0, "path": "src/ethereum/berlin/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["caller"]}}, {"source": {"identifier": "ethereum.berlin.vm.Message.target", "specifier": 0, "path": "src/ethereum/berlin/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["target"]}}, {"source": {"identifier": "ethereum.berlin.vm.Message.current_target", "specifier": 0, "path": "src/ethereum/berlin/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["current_target"]}}, {"source": {"identifier": "ethereum.berlin.vm.Message.gas", "specifier": 0, "path": "src/ethereum/berlin/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["gas"]}}, {"source": {"identifier": "ethereum.berlin.vm.Message.value", "specifier": 0, "path": "src/ethereum/berlin/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["value"]}}, {"source": {"identifier": "ethereum.berlin.vm.Message.data", "specifier": 0, "path": "src/ethereum/berlin/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["data"]}}, {"source": {"identifier": "ethereum.berlin.vm.Message.code_address", "specifier": 0, "path": "src/ethereum/berlin/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["code_address"]}}, {"source": {"identifier": "ethereum.berlin.vm.Message.code", "specifier": 0, "path": "src/ethereum/berlin/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["code"]}}, {"source": {"identifier": "ethereum.berlin.vm.Message.depth", "specifier": 0, "path": "src/ethereum/berlin/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["depth"]}}, {"source": {"identifier": "ethereum.berlin.vm.Message.should_transfer_value", "specifier": 0, "path": "src/ethereum/berlin/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["should_transfer_value"]}}, {"source": {"identifier": "ethereum.berlin.vm.Message.is_static", "specifier": 0, "path": "src/ethereum/berlin/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["is_static"]}}, {"source": {"identifier": "ethereum.berlin.vm.Message.accessed_addresses", "specifier": 0, "path": "src/ethereum/berlin/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["accessed_addresses"]}}, {"source": {"identifier": "ethereum.berlin.vm.Message.accessed_storage_keys", "specifier": 0, "path": "src/ethereum/berlin/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["accessed_storage_keys"]}}, {"source": {"identifier": "ethereum.berlin.vm.Evm", "specifier": 0, "path": "src/ethereum/berlin/vm/__init__.py"}, "content": {"type": ["class"], "name": ["Evm"], "text": ["The internal state of the virtual machine."]}}, {"source": {"identifier": "ethereum.berlin.vm.Evm.pc", "specifier": 0, "path": "src/ethereum/berlin/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["pc"]}}, {"source": {"identifier": "ethereum.berlin.vm.Evm.stack", "specifier": 0, "path": "src/ethereum/berlin/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["stack"]}}, {"source": {"identifier": "ethereum.berlin.vm.Evm.memory", "specifier": 0, "path": "src/ethereum/berlin/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["memory"]}}, {"source": {"identifier": "ethereum.berlin.vm.Evm.code", "specifier": 0, "path": "src/ethereum/berlin/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["code"]}}, {"source": {"identifier": "ethereum.berlin.vm.Evm.gas_left", "specifier": 0, "path": "src/ethereum/berlin/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["gas_left"]}}, {"source": {"identifier": "ethereum.berlin.vm.Evm.env", "specifier": 0, "path": "src/ethereum/berlin/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["env"]}}, {"source": {"identifier": "ethereum.berlin.vm.Evm.valid_jump_destinations", "specifier": 0, "path": "src/ethereum/berlin/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["valid_jump_destinations"]}}, {"source": {"identifier": "ethereum.berlin.vm.Evm.logs", "specifier": 0, "path": "src/ethereum/berlin/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["logs"]}}, {"source": {"identifier": "ethereum.berlin.vm.Evm.refund_counter", "specifier": 0, "path": "src/ethereum/berlin/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["refund_counter"]}}, {"source": {"identifier": "ethereum.berlin.vm.Evm.running", "specifier": 0, "path": "src/ethereum/berlin/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["running"]}}, {"source": {"identifier": "ethereum.berlin.vm.Evm.message", "specifier": 0, "path": "src/ethereum/berlin/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["message"]}}, {"source": {"identifier": "ethereum.berlin.vm.Evm.output", "specifier": 0, "path": "src/ethereum/berlin/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["output"]}}, {"source": {"identifier": "ethereum.berlin.vm.Evm.accounts_to_delete", "specifier": 0, "path": "src/ethereum/berlin/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["accounts_to_delete"]}}, {"source": {"identifier": "ethereum.berlin.vm.Evm.touched_accounts", "specifier": 0, "path": "src/ethereum/berlin/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["touched_accounts"]}}, {"source": {"identifier": "ethereum.berlin.vm.Evm.has_erred", "specifier": 0, "path": "src/ethereum/berlin/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["has_erred"]}}, {"source": {"identifier": "ethereum.berlin.vm.Evm.return_data", "specifier": 0, "path": "src/ethereum/berlin/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["return_data"]}}, {"source": {"identifier": "ethereum.berlin.vm.Evm.error", "specifier": 0, "path": "src/ethereum/berlin/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["error"]}}, {"source": {"identifier": "ethereum.berlin.vm.Evm.accessed_addresses", "specifier": 0, "path": "src/ethereum/berlin/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["accessed_addresses"]}}, {"source": {"identifier": "ethereum.berlin.vm.Evm.accessed_storage_keys", "specifier": 0, "path": "src/ethereum/berlin/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["accessed_storage_keys"]}}, {"source": {"identifier": "ethereum.berlin.vm.incorporate_child_on_success", "specifier": 0, "path": "src/ethereum/berlin/vm/__init__.py"}, "content": {"type": ["function"], "name": ["incorporate_child_on_success"], "text": ["Incorporate the state of a successful  child_evm  into the parent  evm . Parameters evm : The parent  EVM . child_evm : The child evm to incorporate."]}}, {"source": {"identifier": "ethereum.berlin.vm.incorporate_child_on_error", "specifier": 0, "path": "src/ethereum/berlin/vm/__init__.py"}, "content": {"type": ["function"], "name": ["incorporate_child_on_error"], "text": ["Incorporate the state of an unsuccessful  child_evm  into the parent  evm . Parameters evm : The parent  EVM . child_evm : The child evm to incorporate."]}}, {"source": {"identifier": "ethereum.london.utils.message", "specifier": 0, "path": "src/ethereum/london/utils/message.py"}, "content": {"type": ["module"], "name": ["ethereum.london.utils.message"], "text": ["Hardfork Utility Functions For The Message Data-structure ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Message specific functions used in this london version of specification."]}}, {"source": {"identifier": "ethereum.london.utils.message.prepare_message", "specifier": 0, "path": "src/ethereum/london/utils/message.py"}, "content": {"type": ["function"], "name": ["prepare_message"], "text": ["Execute a transaction against the provided environment. Parameters caller : Address which initiated the transaction target : Address whose code will be executed value : Value to be transferred. data : Array of bytes provided to the code in  target . gas : Gas provided for the code in  target . env : Environment for the Ethereum Virtual Machine. code_address : This is usually same as the  target  address except when an alternative accounts code needs to be executed. eg.  CALLCODE  calling a precompile. should_transfer_value : if True ETH should be transferred while executing a message call. is_static: if True then it prevents all state-changing operations from being executed. preaccessed_addresses: Addresses that should be marked as accessed prior to the message call preaccessed_storage_keys: Storage keys that should be marked as accessed prior to the message call Returns message:  ethereum.london.vm.Message Items containing contract creation or message call specific data."]}}, {"source": {"identifier": "ethereum.berlin.vm.runtime", "specifier": 0, "path": "src/ethereum/berlin/vm/runtime.py"}, "content": {"type": ["module"], "name": ["ethereum.berlin.vm.runtime"], "text": ["Ethereum Virtual Machine (EVM) Runtime Operations ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Runtime related operations used while executing EVM code."]}}, {"source": {"identifier": "ethereum.berlin.vm.runtime.get_valid_jump_destinations", "specifier": 0, "path": "src/ethereum/berlin/vm/runtime.py"}, "content": {"type": ["function"], "name": ["get_valid_jump_destinations"], "text": ["Analyze the evm code to obtain the set of valid jump destinations. Valid jump destinations are defined as follows: * The jump destination is less than the length of the code. * The jump destination should have the  JUMPDEST  opcode (0x5B). * The jump destination shouldn't be part of the data corresponding to PUSH-N  opcodes. Note - Jump destinations are 0-indexed. Parameters code : The EVM code which is to be executed. Returns valid_jump_destinations:  Set[Uint] The set of valid jump destinations in the code."]}}, {"source": {"identifier": "ethereum.london.utils.hexadecimal", "specifier": 0, "path": "src/ethereum/london/utils/hexadecimal.py"}, "content": {"type": ["module"], "name": ["ethereum.london.utils.hexadecimal"], "text": ["Utility Functions For Hexadecimal Strings ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Hexadecimal utility functions used in this specification, specific to London types."]}}, {"source": {"identifier": "ethereum.london.utils.hexadecimal.hex_to_root", "specifier": 0, "path": "src/ethereum/london/utils/hexadecimal.py"}, "content": {"type": ["function"], "name": ["hex_to_root"], "text": ["Convert hex string to trie root. Parameters hex_string : The hexadecimal string to be converted to trie root. Returns root :  Root Trie root obtained from the given hexadecimal string."]}}, {"source": {"identifier": "ethereum.london.utils.hexadecimal.hex_to_bloom", "specifier": 0, "path": "src/ethereum/london/utils/hexadecimal.py"}, "content": {"type": ["function"], "name": ["hex_to_bloom"], "text": ["Convert hex string to bloom. Parameters hex_string : The hexadecimal string to be converted to bloom. Returns bloom :  Bloom Bloom obtained from the given hexadecimal string."]}}, {"source": {"identifier": "ethereum.london.utils.hexadecimal.hex_to_address", "specifier": 0, "path": "src/ethereum/london/utils/hexadecimal.py"}, "content": {"type": ["function"], "name": ["hex_to_address"], "text": ["Convert hex string to Address (20 bytes). Parameters hex_string : The hexadecimal string to be converted to Address. Returns address :  Address The address obtained from the given hexadecimal string."]}}, {"source": {"identifier": "ethereum.gray_glacier.state", "specifier": 0, "path": "src/ethereum/gray_glacier/state.py"}, "content": {"type": ["module"], "name": ["ethereum.gray_glacier.state"], "text": ["State ^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction The state contains all information that is preserved between transactions. It consists of a main account trie and storage tries for each contract. There is a distinction between an account that does not exist and EMPTY_ACCOUNT ."]}}, {"source": {"identifier": "ethereum.gray_glacier.state.State", "specifier": 0, "path": "src/ethereum/gray_glacier/state.py"}, "content": {"type": ["class"], "name": ["State"], "text": ["Contains all information that is preserved between transactions."]}}, {"source": {"identifier": "ethereum.gray_glacier.state.State._main_trie", "specifier": 0, "path": "src/ethereum/gray_glacier/state.py"}, "content": {"type": ["attribute"], "name": ["_main_trie"]}}, {"source": {"identifier": "ethereum.gray_glacier.state.State._storage_tries", "specifier": 0, "path": "src/ethereum/gray_glacier/state.py"}, "content": {"type": ["attribute"], "name": ["_storage_tries"]}}, {"source": {"identifier": "ethereum.gray_glacier.state.State._snapshots", "specifier": 0, "path": "src/ethereum/gray_glacier/state.py"}, "content": {"type": ["attribute"], "name": ["_snapshots"]}}, {"source": {"identifier": "ethereum.gray_glacier.state.close_state", "specifier": 0, "path": "src/ethereum/gray_glacier/state.py"}, "content": {"type": ["function"], "name": ["close_state"], "text": ["Free resources held by the state. Used by optimized implementations to release file descriptors."]}}, {"source": {"identifier": "ethereum.gray_glacier.state.begin_transaction", "specifier": 0, "path": "src/ethereum/gray_glacier/state.py"}, "content": {"type": ["function"], "name": ["begin_transaction"], "text": ["Start a state transaction. Transactions are entirely implicit and can be nested. It is not possible to calculate the state root during a transaction. Parameters state : State The state."]}}, {"source": {"identifier": "ethereum.gray_glacier.state.commit_transaction", "specifier": 0, "path": "src/ethereum/gray_glacier/state.py"}, "content": {"type": ["function"], "name": ["commit_transaction"], "text": ["Commit a state transaction. Parameters state : State The state."]}}, {"source": {"identifier": "ethereum.gray_glacier.state.rollback_transaction", "specifier": 0, "path": "src/ethereum/gray_glacier/state.py"}, "content": {"type": ["function"], "name": ["rollback_transaction"], "text": ["Rollback a state transaction, resetting the state to the point when the corresponding  start_transaction()  call was made. Parameters state : State The state."]}}, {"source": {"identifier": "ethereum.gray_glacier.state.get_account", "specifier": 0, "path": "src/ethereum/gray_glacier/state.py"}, "content": {"type": ["function"], "name": ["get_account"], "text": ["Get the  Account  object at an address. Returns  EMPTY_ACCOUNT  if there is no account at the address. Use  get_account_optional()  if you care about the difference between a non-existent account and  EMPTY_ACCOUNT . Parameters state:  State The state address :  Address Address to lookup. Returns account :  Account Account at address."]}}, {"source": {"identifier": "ethereum.gray_glacier.state.get_account_optional", "specifier": 0, "path": "src/ethereum/gray_glacier/state.py"}, "content": {"type": ["function"], "name": ["get_account_optional"], "text": ["Get the  Account  object at an address. Returns  None  (rather than EMPTY_ACCOUNT ) if there is no account at the address. Parameters state:  State The state address :  Address Address to lookup. Returns account :  Account Account at address."]}}, {"source": {"identifier": "ethereum.gray_glacier.state.set_account", "specifier": 0, "path": "src/ethereum/gray_glacier/state.py"}, "content": {"type": ["function"], "name": ["set_account"], "text": ["Set the  Account  object at an address. Setting to  None  deletes the account (but not its storage, see  destroy_account() ). Parameters state:  State The state address :  Address Address to set. account :  Account Account to set at address."]}}, {"source": {"identifier": "ethereum.gray_glacier.state.destroy_account", "specifier": 0, "path": "src/ethereum/gray_glacier/state.py"}, "content": {"type": ["function"], "name": ["destroy_account"], "text": ["Completely remove the account at  address  and all of its storage. This function is made available exclusively for the  SELFDESTRUCT opcode. It is expected that  SELFDESTRUCT  will be disabled in a future hardfork and this function will be removed. Parameters state:  State The state address :  Address Address of account to destroy."]}}, {"source": {"identifier": "ethereum.gray_glacier.state.destroy_storage", "specifier": 0, "path": "src/ethereum/gray_glacier/state.py"}, "content": {"type": ["function"], "name": ["destroy_storage"], "text": ["Completely remove the storage at  address . Parameters state:  State The state address :  Address Address of account whose storage is to be deleted."]}}, {"source": {"identifier": "ethereum.gray_glacier.state.get_storage", "specifier": 0, "path": "src/ethereum/gray_glacier/state.py"}, "content": {"type": ["function"], "name": ["get_storage"], "text": ["Get a value at a storage key on an account. Returns  U256(0)  if the storage key has not been set previously. Parameters state:  State The state address :  Address Address of the account. key :  Bytes Key to lookup. Returns value :  U256 Value at the key."]}}, {"source": {"identifier": "ethereum.gray_glacier.state.set_storage", "specifier": 0, "path": "src/ethereum/gray_glacier/state.py"}, "content": {"type": ["function"], "name": ["set_storage"], "text": ["Set a value at a storage key on an account. Setting to  U256(0)  deletes the key. Parameters state:  State The state address :  Address Address of the account. key :  Bytes Key to set. value :  U256 Value to set at the key."]}}, {"source": {"identifier": "ethereum.gray_glacier.state.storage_root", "specifier": 0, "path": "src/ethereum/gray_glacier/state.py"}, "content": {"type": ["function"], "name": ["storage_root"], "text": ["Calculate the storage root of an account. Parameters state: The state address : Address of the account. Returns root :  Root Storage root of the account."]}}, {"source": {"identifier": "ethereum.gray_glacier.state.state_root", "specifier": 0, "path": "src/ethereum/gray_glacier/state.py"}, "content": {"type": ["function"], "name": ["state_root"], "text": ["Calculate the state root. Parameters state: The current state. Returns root :  Root The state root."]}}, {"source": {"identifier": "ethereum.gray_glacier.state.account_exists", "specifier": 0, "path": "src/ethereum/gray_glacier/state.py"}, "content": {"type": ["function"], "name": ["account_exists"], "text": ["Checks if an account exists in the state trie Parameters state: The state address: Address of the account that needs to be checked. Returns account_exists :  bool True if account exists in the state trie, False otherwise"]}}, {"source": {"identifier": "ethereum.gray_glacier.state.account_has_code_or_nonce", "specifier": 0, "path": "src/ethereum/gray_glacier/state.py"}, "content": {"type": ["function"], "name": ["account_has_code_or_nonce"], "text": ["Checks if an account has non zero nonce or non empty code Parameters state: The state address: Address of the account that needs to be checked. Returns has_code_or_nonce :  bool True if if an account has non zero nonce or non empty code, False otherwise."]}}, {"source": {"identifier": "ethereum.gray_glacier.state.is_account_empty", "specifier": 0, "path": "src/ethereum/gray_glacier/state.py"}, "content": {"type": ["function"], "name": ["is_account_empty"], "text": ["Checks if an account has zero nonce, empty code and zero balance. Parameters state: The state address: Address of the account that needs to be checked. Returns is_empty :  bool True if if an account has zero nonce, empty code and zero balance, False otherwise."]}}, {"source": {"identifier": "ethereum.gray_glacier.state.account_exists_and_is_empty", "specifier": 0, "path": "src/ethereum/gray_glacier/state.py"}, "content": {"type": ["function"], "name": ["account_exists_and_is_empty"], "text": ["Checks if an account exists and has zero nonce, empty code and zero balance. Parameters state: The state address: Address of the account that needs to be checked. Returns exists_and_is_empty :  bool True if an account exists and has zero nonce, empty code and zero balance, False otherwise."]}}, {"source": {"identifier": "ethereum.gray_glacier.state.is_account_alive", "specifier": 0, "path": "src/ethereum/gray_glacier/state.py"}, "content": {"type": ["function"], "name": ["is_account_alive"], "text": ["Check whether is an account is both in the state and non empty. Parameters state: The state address: Address of the account that needs to be checked. Returns is_alive :  bool True if the account is alive."]}}, {"source": {"identifier": "ethereum.gray_glacier.state.modify_state", "specifier": 0, "path": "src/ethereum/gray_glacier/state.py"}, "content": {"type": ["function"], "name": ["modify_state"], "text": ["Modify an  Account  in the  State ."]}}, {"source": {"identifier": "ethereum.gray_glacier.state.move_ether", "specifier": 0, "path": "src/ethereum/gray_glacier/state.py"}, "content": {"type": ["function"], "name": ["move_ether"], "text": ["Move funds between accounts."]}}, {"source": {"identifier": "ethereum.gray_glacier.state.set_account_balance", "specifier": 0, "path": "src/ethereum/gray_glacier/state.py"}, "content": {"type": ["function"], "name": ["set_account_balance"], "text": ["Sets the balance of an account. Parameters state: The current state. address: Address of the account whose nonce needs to be incremented. amount: The amount that needs to set in balance."]}}, {"source": {"identifier": "ethereum.gray_glacier.state.touch_account", "specifier": 0, "path": "src/ethereum/gray_glacier/state.py"}, "content": {"type": ["function"], "name": ["touch_account"], "text": ["Initializes an account to state. Parameters state: The current state. address: The address of the account that need to initialised."]}}, {"source": {"identifier": "ethereum.gray_glacier.state.increment_nonce", "specifier": 0, "path": "src/ethereum/gray_glacier/state.py"}, "content": {"type": ["function"], "name": ["increment_nonce"], "text": ["Increments the nonce of an account. Parameters state: The current state. address: Address of the account whose nonce needs to be incremented."]}}, {"source": {"identifier": "ethereum.gray_glacier.state.set_code", "specifier": 0, "path": "src/ethereum/gray_glacier/state.py"}, "content": {"type": ["function"], "name": ["set_code"], "text": ["Sets Account code. Parameters state: The current state. address: Address of the account whose code needs to be update. code: The bytecode that needs to be set."]}}, {"source": {"identifier": "ethereum.gray_glacier.state.create_ether", "specifier": 0, "path": "src/ethereum/gray_glacier/state.py"}, "content": {"type": ["function"], "name": ["create_ether"], "text": ["Add newly created ether to an account. Parameters state: The current state. address: Address of the account to which ether is added. amount: The amount of ether to be added to the account of interest."]}}, {"source": {"identifier": "ethereum.gray_glacier.state.get_storage_original", "specifier": 0, "path": "src/ethereum/gray_glacier/state.py"}, "content": {"type": ["function"], "name": ["get_storage_original"], "text": ["Get the original value in a storage slot i.e. the value before the current transaction began. This function reads the value from the snapshots taken before executing the transaction. Parameters state: The current state. address: Address of the account to read the value from. key: Key of the storage slot."]}}, {"source": {"identifier": "ethereum.berlin.vm.interpreter", "specifier": 0, "path": "src/ethereum/berlin/vm/interpreter.py"}, "content": {"type": ["module"], "name": ["ethereum.berlin.vm.interpreter"], "text": ["Ethereum Virtual Machine (EVM) Interpreter ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction A straightforward interpreter that executes EVM code."]}}, {"source": {"identifier": "ethereum.berlin.vm.interpreter.STACK_DEPTH_LIMIT", "specifier": 0, "path": "src/ethereum/berlin/vm/interpreter.py"}, "content": {"type": ["attribute"], "name": ["STACK_DEPTH_LIMIT"]}}, {"source": {"identifier": "ethereum.berlin.vm.interpreter.MAX_CODE_SIZE", "specifier": 0, "path": "src/ethereum/berlin/vm/interpreter.py"}, "content": {"type": ["attribute"], "name": ["MAX_CODE_SIZE"]}}, {"source": {"identifier": "ethereum.berlin.vm.interpreter.MessageCallOutput", "specifier": 0, "path": "src/ethereum/berlin/vm/interpreter.py"}, "content": {"type": ["class"], "name": ["MessageCallOutput"], "text": ["Output of a particular message call Contains the following:   1. `gas_left`: remaining gas after execution.\n  2. `refund_counter`: gas to refund after execution.\n  3. `logs`: list of `Log` generated during execution.\n  4. `accounts_to_delete`: Contracts which have self-destructed.\n  5. `touched_accounts`: Accounts that have been touched.\n  6. `has_erred`: True if execution has caused an error.\n"]}}, {"source": {"identifier": "ethereum.berlin.vm.interpreter.MessageCallOutput.gas_left", "specifier": 0, "path": "src/ethereum/berlin/vm/interpreter.py"}, "content": {"type": ["attribute"], "name": ["gas_left"]}}, {"source": {"identifier": "ethereum.berlin.vm.interpreter.MessageCallOutput.refund_counter", "specifier": 0, "path": "src/ethereum/berlin/vm/interpreter.py"}, "content": {"type": ["attribute"], "name": ["refund_counter"]}}, {"source": {"identifier": "ethereum.berlin.vm.interpreter.MessageCallOutput.logs", "specifier": 0, "path": "src/ethereum/berlin/vm/interpreter.py"}, "content": {"type": ["attribute"], "name": ["logs"]}}, {"source": {"identifier": "ethereum.berlin.vm.interpreter.MessageCallOutput.accounts_to_delete", "specifier": 0, "path": "src/ethereum/berlin/vm/interpreter.py"}, "content": {"type": ["attribute"], "name": ["accounts_to_delete"]}}, {"source": {"identifier": "ethereum.berlin.vm.interpreter.MessageCallOutput.touched_accounts", "specifier": 0, "path": "src/ethereum/berlin/vm/interpreter.py"}, "content": {"type": ["attribute"], "name": ["touched_accounts"]}}, {"source": {"identifier": "ethereum.berlin.vm.interpreter.MessageCallOutput.has_erred", "specifier": 0, "path": "src/ethereum/berlin/vm/interpreter.py"}, "content": {"type": ["attribute"], "name": ["has_erred"]}}, {"source": {"identifier": "ethereum.berlin.vm.interpreter.process_message_call", "specifier": 0, "path": "src/ethereum/berlin/vm/interpreter.py"}, "content": {"type": ["function"], "name": ["process_message_call"], "text": ["If  message.current  is empty then it creates a smart contract else it executes a call from the  message.caller  to the  message.target . Parameters message : Transaction specific items. env : External items required for EVM execution. Returns output :  MessageCallOutput Output of the message call"]}}, {"source": {"identifier": "ethereum.berlin.vm.interpreter.process_create_message", "specifier": 0, "path": "src/ethereum/berlin/vm/interpreter.py"}, "content": {"type": ["function"], "name": ["process_create_message"], "text": ["Executes a call to create a smart contract. Parameters message : Transaction specific items. env : External items required for EVM execution. Returns evm: :py:class: ~ethereum.berlin.vm.Evm Items containing execution specific objects."]}}, {"source": {"identifier": "ethereum.berlin.vm.interpreter.process_message", "specifier": 0, "path": "src/ethereum/berlin/vm/interpreter.py"}, "content": {"type": ["function"], "name": ["process_message"], "text": ["Executes a call to create a smart contract. Parameters message : Transaction specific items. env : External items required for EVM execution. Returns evm: :py:class: ~ethereum.berlin.vm.Evm Items containing execution specific objects"]}}, {"source": {"identifier": "ethereum.berlin.vm.interpreter.execute_code", "specifier": 0, "path": "src/ethereum/berlin/vm/interpreter.py"}, "content": {"type": ["function"], "name": ["execute_code"], "text": ["Executes bytecode present in the  message . Parameters message : Transaction specific items. env : External items required for EVM execution. Returns evm:  ethereum.vm.EVM Items containing execution specific objects"]}}, {"source": {"identifier": "ethereum.gray_glacier", "specifier": 0, "path": "src/ethereum/gray_glacier/__init__.py"}, "content": {"type": ["module"], "name": ["ethereum.gray_glacier"], "text": ["Ethereum Gray Glacier Hardfork ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ The Thirteenth Ethereum hardfork."]}}, {"source": {"identifier": "ethereum.gray_glacier.MAINNET_FORK_BLOCK", "specifier": 0, "path": "src/ethereum/gray_glacier/__init__.py"}, "content": {"type": ["attribute"], "name": ["MAINNET_FORK_BLOCK"]}}, {"source": {"identifier": "ethereum.berlin.vm.stack", "specifier": 0, "path": "src/ethereum/berlin/vm/stack.py"}, "content": {"type": ["module"], "name": ["ethereum.berlin.vm.stack"], "text": ["Ethereum Virtual Machine (EVM) Stack ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementation of the stack operators for the EVM."]}}, {"source": {"identifier": "ethereum.berlin.vm.stack.pop", "specifier": 0, "path": "src/ethereum/berlin/vm/stack.py"}, "content": {"type": ["function"], "name": ["pop"], "text": ["Pops the top item off of  stack . Parameters stack : EVM stack. Returns value :  U256 The top element on the stack."]}}, {"source": {"identifier": "ethereum.berlin.vm.stack.push", "specifier": 0, "path": "src/ethereum/berlin/vm/stack.py"}, "content": {"type": ["function"], "name": ["push"], "text": ["Pushes  value  onto  stack . Parameters stack : EVM stack. value : Item to be pushed onto  stack ."]}}, {"source": {"identifier": "ethereum.gray_glacier.bloom", "specifier": 0, "path": "src/ethereum/gray_glacier/bloom.py"}, "content": {"type": ["module"], "name": ["ethereum.gray_glacier.bloom"], "text": ["Ethereum Logs Bloom ^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction This modules defines functions for calculating bloom filters of logs. For the general theory of bloom filters see e.g.  Wikipedia <https://en.wikipedia.org/wiki/Bloom_filter> _. Bloom filters are used to allow for efficient searching of logs by address and/or topic, by rapidly eliminating blocks and reciepts from their search."]}}, {"source": {"identifier": "ethereum.gray_glacier.bloom.add_to_bloom", "specifier": 0, "path": "src/ethereum/gray_glacier/bloom.py"}, "content": {"type": ["function"], "name": ["add_to_bloom"], "text": ["Add a bloom entry to the bloom filter ( bloom ). The number of hash functions used is 3. They are calculated by taking the least significant 11 bits from the first 3 16-bit words of the keccak_256()  hash of  bloom_entry . Parameters bloom : The bloom filter. bloom_entry : An entry which is to be added to bloom filter."]}}, {"source": {"identifier": "ethereum.gray_glacier.bloom.logs_bloom", "specifier": 0, "path": "src/ethereum/gray_glacier/bloom.py"}, "content": {"type": ["function"], "name": ["logs_bloom"], "text": ["Obtain the logs bloom from a list of log entries. The address and each topic of a log are added to the bloom filter. Parameters logs : List of logs for which the logs bloom is to be obtained. Returns logs_bloom :  Bloom The logs bloom obtained which is 256 bytes with some bits set as per the caller address and the log topics."]}}, {"source": {"identifier": "ethereum.gray_glacier.fork_types", "specifier": 0, "path": "src/ethereum/gray_glacier/fork_types.py"}, "content": {"type": ["module"], "name": ["ethereum.gray_glacier.fork_types"], "text": ["Ethereum Types ^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Types re-used throughout the specification, which are specific to Ethereum."]}}, {"source": {"identifier": "ethereum.gray_glacier.fork_types.Address", "specifier": 0, "path": "src/ethereum/gray_glacier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["Address"]}}, {"source": {"identifier": "ethereum.gray_glacier.fork_types.Root", "specifier": 0, "path": "src/ethereum/gray_glacier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["Root"]}}, {"source": {"identifier": "ethereum.gray_glacier.fork_types.Bloom", "specifier": 0, "path": "src/ethereum/gray_glacier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["Bloom"]}}, {"source": {"identifier": "ethereum.gray_glacier.fork_types.TX_BASE_COST", "specifier": 0, "path": "src/ethereum/gray_glacier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["TX_BASE_COST"]}}, {"source": {"identifier": "ethereum.gray_glacier.fork_types.TX_DATA_COST_PER_NON_ZERO", "specifier": 0, "path": "src/ethereum/gray_glacier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["TX_DATA_COST_PER_NON_ZERO"]}}, {"source": {"identifier": "ethereum.gray_glacier.fork_types.TX_DATA_COST_PER_ZERO", "specifier": 0, "path": "src/ethereum/gray_glacier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["TX_DATA_COST_PER_ZERO"]}}, {"source": {"identifier": "ethereum.gray_glacier.fork_types.TX_CREATE_COST", "specifier": 0, "path": "src/ethereum/gray_glacier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["TX_CREATE_COST"]}}, {"source": {"identifier": "ethereum.gray_glacier.fork_types.TX_ACCESS_LIST_ADDRESS_COST", "specifier": 0, "path": "src/ethereum/gray_glacier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["TX_ACCESS_LIST_ADDRESS_COST"]}}, {"source": {"identifier": "ethereum.gray_glacier.fork_types.TX_ACCESS_LIST_STORAGE_KEY_COST", "specifier": 0, "path": "src/ethereum/gray_glacier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["TX_ACCESS_LIST_STORAGE_KEY_COST"]}}, {"source": {"identifier": "ethereum.gray_glacier.fork_types.LegacyTransaction", "specifier": 0, "path": "src/ethereum/gray_glacier/fork_types.py"}, "content": {"type": ["class"], "name": ["LegacyTransaction"], "text": ["Atomic operation performed on the block chain."]}}, {"source": {"identifier": "ethereum.gray_glacier.fork_types.LegacyTransaction.nonce", "specifier": 0, "path": "src/ethereum/gray_glacier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["nonce"]}}, {"source": {"identifier": "ethereum.gray_glacier.fork_types.LegacyTransaction.gas_price", "specifier": 0, "path": "src/ethereum/gray_glacier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["gas_price"]}}, {"source": {"identifier": "ethereum.gray_glacier.fork_types.LegacyTransaction.gas", "specifier": 0, "path": "src/ethereum/gray_glacier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["gas"]}}, {"source": {"identifier": "ethereum.gray_glacier.fork_types.LegacyTransaction.to", "specifier": 0, "path": "src/ethereum/gray_glacier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["to"]}}, {"source": {"identifier": "ethereum.gray_glacier.fork_types.LegacyTransaction.value", "specifier": 0, "path": "src/ethereum/gray_glacier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["value"]}}, {"source": {"identifier": "ethereum.gray_glacier.fork_types.LegacyTransaction.data", "specifier": 0, "path": "src/ethereum/gray_glacier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["data"]}}, {"source": {"identifier": "ethereum.gray_glacier.fork_types.LegacyTransaction.v", "specifier": 0, "path": "src/ethereum/gray_glacier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["v"]}}, {"source": {"identifier": "ethereum.gray_glacier.fork_types.LegacyTransaction.r", "specifier": 0, "path": "src/ethereum/gray_glacier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["r"]}}, {"source": {"identifier": "ethereum.gray_glacier.fork_types.LegacyTransaction.s", "specifier": 0, "path": "src/ethereum/gray_glacier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["s"]}}, {"source": {"identifier": "ethereum.gray_glacier.fork_types.AccessListTransaction", "specifier": 0, "path": "src/ethereum/gray_glacier/fork_types.py"}, "content": {"type": ["class"], "name": ["AccessListTransaction"], "text": ["The transaction type added in EIP-2930 to support access lists."]}}, {"source": {"identifier": "ethereum.gray_glacier.fork_types.AccessListTransaction.chain_id", "specifier": 0, "path": "src/ethereum/gray_glacier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["chain_id"]}}, {"source": {"identifier": "ethereum.gray_glacier.fork_types.AccessListTransaction.nonce", "specifier": 0, "path": "src/ethereum/gray_glacier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["nonce"]}}, {"source": {"identifier": "ethereum.gray_glacier.fork_types.AccessListTransaction.gas_price", "specifier": 0, "path": "src/ethereum/gray_glacier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["gas_price"]}}, {"source": {"identifier": "ethereum.gray_glacier.fork_types.AccessListTransaction.gas", "specifier": 0, "path": "src/ethereum/gray_glacier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["gas"]}}, {"source": {"identifier": "ethereum.gray_glacier.fork_types.AccessListTransaction.to", "specifier": 0, "path": "src/ethereum/gray_glacier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["to"]}}, {"source": {"identifier": "ethereum.gray_glacier.fork_types.AccessListTransaction.value", "specifier": 0, "path": "src/ethereum/gray_glacier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["value"]}}, {"source": {"identifier": "ethereum.gray_glacier.fork_types.AccessListTransaction.data", "specifier": 0, "path": "src/ethereum/gray_glacier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["data"]}}, {"source": {"identifier": "ethereum.gray_glacier.fork_types.AccessListTransaction.access_list", "specifier": 0, "path": "src/ethereum/gray_glacier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["access_list"]}}, {"source": {"identifier": "ethereum.gray_glacier.fork_types.AccessListTransaction.v", "specifier": 0, "path": "src/ethereum/gray_glacier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["v"]}}, {"source": {"identifier": "ethereum.gray_glacier.fork_types.AccessListTransaction.r", "specifier": 0, "path": "src/ethereum/gray_glacier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["r"]}}, {"source": {"identifier": "ethereum.gray_glacier.fork_types.AccessListTransaction.s", "specifier": 0, "path": "src/ethereum/gray_glacier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["s"]}}, {"source": {"identifier": "ethereum.gray_glacier.fork_types.FeeMarketTransaction", "specifier": 0, "path": "src/ethereum/gray_glacier/fork_types.py"}, "content": {"type": ["class"], "name": ["FeeMarketTransaction"], "text": ["The transaction type added in EIP-1559."]}}, {"source": {"identifier": "ethereum.gray_glacier.fork_types.FeeMarketTransaction.chain_id", "specifier": 0, "path": "src/ethereum/gray_glacier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["chain_id"]}}, {"source": {"identifier": "ethereum.gray_glacier.fork_types.FeeMarketTransaction.nonce", "specifier": 0, "path": "src/ethereum/gray_glacier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["nonce"]}}, {"source": {"identifier": "ethereum.gray_glacier.fork_types.FeeMarketTransaction.max_priority_fee_per_gas", "specifier": 0, "path": "src/ethereum/gray_glacier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["max_priority_fee_per_gas"]}}, {"source": {"identifier": "ethereum.gray_glacier.fork_types.FeeMarketTransaction.max_fee_per_gas", "specifier": 0, "path": "src/ethereum/gray_glacier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["max_fee_per_gas"]}}, {"source": {"identifier": "ethereum.gray_glacier.fork_types.FeeMarketTransaction.gas", "specifier": 0, "path": "src/ethereum/gray_glacier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["gas"]}}, {"source": {"identifier": "ethereum.gray_glacier.fork_types.FeeMarketTransaction.to", "specifier": 0, "path": "src/ethereum/gray_glacier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["to"]}}, {"source": {"identifier": "ethereum.gray_glacier.fork_types.FeeMarketTransaction.value", "specifier": 0, "path": "src/ethereum/gray_glacier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["value"]}}, {"source": {"identifier": "ethereum.gray_glacier.fork_types.FeeMarketTransaction.data", "specifier": 0, "path": "src/ethereum/gray_glacier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["data"]}}, {"source": {"identifier": "ethereum.gray_glacier.fork_types.FeeMarketTransaction.access_list", "specifier": 0, "path": "src/ethereum/gray_glacier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["access_list"]}}, {"source": {"identifier": "ethereum.gray_glacier.fork_types.FeeMarketTransaction.v", "specifier": 0, "path": "src/ethereum/gray_glacier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["v"]}}, {"source": {"identifier": "ethereum.gray_glacier.fork_types.FeeMarketTransaction.r", "specifier": 0, "path": "src/ethereum/gray_glacier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["r"]}}, {"source": {"identifier": "ethereum.gray_glacier.fork_types.FeeMarketTransaction.s", "specifier": 0, "path": "src/ethereum/gray_glacier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["s"]}}, {"source": {"identifier": "ethereum.gray_glacier.fork_types.Transaction", "specifier": 0, "path": "src/ethereum/gray_glacier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["Transaction"]}}, {"source": {"identifier": "ethereum.gray_glacier.fork_types.encode_transaction", "specifier": 0, "path": "src/ethereum/gray_glacier/fork_types.py"}, "content": {"type": ["function"], "name": ["encode_transaction"], "text": ["Encode a transaction. Needed because non-legacy transactions aren't RLP."]}}, {"source": {"identifier": "ethereum.gray_glacier.fork_types.decode_transaction", "specifier": 0, "path": "src/ethereum/gray_glacier/fork_types.py"}, "content": {"type": ["function"], "name": ["decode_transaction"], "text": ["Decode a transaction. Needed because non-legacy transactions aren't RLP."]}}, {"source": {"identifier": "ethereum.gray_glacier.fork_types.Account", "specifier": 0, "path": "src/ethereum/gray_glacier/fork_types.py"}, "content": {"type": ["class"], "name": ["Account"], "text": ["State associated with an address."]}}, {"source": {"identifier": "ethereum.gray_glacier.fork_types.Account.nonce", "specifier": 0, "path": "src/ethereum/gray_glacier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["nonce"]}}, {"source": {"identifier": "ethereum.gray_glacier.fork_types.Account.balance", "specifier": 0, "path": "src/ethereum/gray_glacier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["balance"]}}, {"source": {"identifier": "ethereum.gray_glacier.fork_types.Account.code", "specifier": 0, "path": "src/ethereum/gray_glacier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["code"]}}, {"source": {"identifier": "ethereum.gray_glacier.fork_types.EMPTY_ACCOUNT", "specifier": 0, "path": "src/ethereum/gray_glacier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["EMPTY_ACCOUNT"]}}, {"source": {"identifier": "ethereum.gray_glacier.fork_types.encode_account", "specifier": 0, "path": "src/ethereum/gray_glacier/fork_types.py"}, "content": {"type": ["function"], "name": ["encode_account"], "text": ["Encode  Account  dataclass. Storage is not stored in the  Account  dataclass, so  Accounts  cannot be encoded with providing a storage root."]}}, {"source": {"identifier": "ethereum.gray_glacier.fork_types.Header", "specifier": 0, "path": "src/ethereum/gray_glacier/fork_types.py"}, "content": {"type": ["class"], "name": ["Header"], "text": ["Header portion of a block on the chain."]}}, {"source": {"identifier": "ethereum.gray_glacier.fork_types.Header.parent_hash", "specifier": 0, "path": "src/ethereum/gray_glacier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["parent_hash"]}}, {"source": {"identifier": "ethereum.gray_glacier.fork_types.Header.ommers_hash", "specifier": 0, "path": "src/ethereum/gray_glacier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["ommers_hash"]}}, {"source": {"identifier": "ethereum.gray_glacier.fork_types.Header.coinbase", "specifier": 0, "path": "src/ethereum/gray_glacier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["coinbase"]}}, {"source": {"identifier": "ethereum.gray_glacier.fork_types.Header.state_root", "specifier": 0, "path": "src/ethereum/gray_glacier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["state_root"]}}, {"source": {"identifier": "ethereum.gray_glacier.fork_types.Header.transactions_root", "specifier": 0, "path": "src/ethereum/gray_glacier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["transactions_root"]}}, {"source": {"identifier": "ethereum.gray_glacier.fork_types.Header.receipt_root", "specifier": 0, "path": "src/ethereum/gray_glacier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["receipt_root"]}}, {"source": {"identifier": "ethereum.gray_glacier.fork_types.Header.bloom", "specifier": 0, "path": "src/ethereum/gray_glacier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["bloom"]}}, {"source": {"identifier": "ethereum.gray_glacier.fork_types.Header.difficulty", "specifier": 0, "path": "src/ethereum/gray_glacier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["difficulty"]}}, {"source": {"identifier": "ethereum.gray_glacier.fork_types.Header.number", "specifier": 0, "path": "src/ethereum/gray_glacier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["number"]}}, {"source": {"identifier": "ethereum.gray_glacier.fork_types.Header.gas_limit", "specifier": 0, "path": "src/ethereum/gray_glacier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["gas_limit"]}}, {"source": {"identifier": "ethereum.gray_glacier.fork_types.Header.gas_used", "specifier": 0, "path": "src/ethereum/gray_glacier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["gas_used"]}}, {"source": {"identifier": "ethereum.gray_glacier.fork_types.Header.timestamp", "specifier": 0, "path": "src/ethereum/gray_glacier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["timestamp"]}}, {"source": {"identifier": "ethereum.gray_glacier.fork_types.Header.extra_data", "specifier": 0, "path": "src/ethereum/gray_glacier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["extra_data"]}}, {"source": {"identifier": "ethereum.gray_glacier.fork_types.Header.mix_digest", "specifier": 0, "path": "src/ethereum/gray_glacier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["mix_digest"]}}, {"source": {"identifier": "ethereum.gray_glacier.fork_types.Header.nonce", "specifier": 0, "path": "src/ethereum/gray_glacier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["nonce"]}}, {"source": {"identifier": "ethereum.gray_glacier.fork_types.Header.base_fee_per_gas", "specifier": 0, "path": "src/ethereum/gray_glacier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["base_fee_per_gas"]}}, {"source": {"identifier": "ethereum.gray_glacier.fork_types.Block", "specifier": 0, "path": "src/ethereum/gray_glacier/fork_types.py"}, "content": {"type": ["class"], "name": ["Block"], "text": ["A complete block."]}}, {"source": {"identifier": "ethereum.gray_glacier.fork_types.Block.header", "specifier": 0, "path": "src/ethereum/gray_glacier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["header"]}}, {"source": {"identifier": "ethereum.gray_glacier.fork_types.Block.transactions", "specifier": 0, "path": "src/ethereum/gray_glacier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["transactions"]}}, {"source": {"identifier": "ethereum.gray_glacier.fork_types.Block.ommers", "specifier": 0, "path": "src/ethereum/gray_glacier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["ommers"]}}, {"source": {"identifier": "ethereum.gray_glacier.fork_types.Log", "specifier": 0, "path": "src/ethereum/gray_glacier/fork_types.py"}, "content": {"type": ["class"], "name": ["Log"], "text": ["Data record produced during the execution of a transaction."]}}, {"source": {"identifier": "ethereum.gray_glacier.fork_types.Log.address", "specifier": 0, "path": "src/ethereum/gray_glacier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["address"]}}, {"source": {"identifier": "ethereum.gray_glacier.fork_types.Log.topics", "specifier": 0, "path": "src/ethereum/gray_glacier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["topics"]}}, {"source": {"identifier": "ethereum.gray_glacier.fork_types.Log.data", "specifier": 0, "path": "src/ethereum/gray_glacier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["data"]}}, {"source": {"identifier": "ethereum.gray_glacier.fork_types.Receipt", "specifier": 0, "path": "src/ethereum/gray_glacier/fork_types.py"}, "content": {"type": ["class"], "name": ["Receipt"], "text": ["Result of a transaction."]}}, {"source": {"identifier": "ethereum.gray_glacier.fork_types.Receipt.succeeded", "specifier": 0, "path": "src/ethereum/gray_glacier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["succeeded"]}}, {"source": {"identifier": "ethereum.gray_glacier.fork_types.Receipt.cumulative_gas_used", "specifier": 0, "path": "src/ethereum/gray_glacier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["cumulative_gas_used"]}}, {"source": {"identifier": "ethereum.gray_glacier.fork_types.Receipt.bloom", "specifier": 0, "path": "src/ethereum/gray_glacier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["bloom"]}}, {"source": {"identifier": "ethereum.gray_glacier.fork_types.Receipt.logs", "specifier": 0, "path": "src/ethereum/gray_glacier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["logs"]}}, {"source": {"identifier": "ethereum.berlin.vm.gas", "specifier": 0, "path": "src/ethereum/berlin/vm/gas.py"}, "content": {"type": ["module"], "name": ["ethereum.berlin.vm.gas"], "text": ["Ethereum Virtual Machine (EVM) Gas ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction EVM gas constants and calculators."]}}, {"source": {"identifier": "ethereum.berlin.vm.gas.GAS_JUMPDEST", "specifier": 0, "path": "src/ethereum/berlin/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_JUMPDEST"]}}, {"source": {"identifier": "ethereum.berlin.vm.gas.GAS_BASE", "specifier": 0, "path": "src/ethereum/berlin/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_BASE"]}}, {"source": {"identifier": "ethereum.berlin.vm.gas.GAS_VERY_LOW", "specifier": 0, "path": "src/ethereum/berlin/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_VERY_LOW"]}}, {"source": {"identifier": "ethereum.berlin.vm.gas.GAS_STORAGE_SET", "specifier": 0, "path": "src/ethereum/berlin/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_STORAGE_SET"]}}, {"source": {"identifier": "ethereum.berlin.vm.gas.GAS_STORAGE_UPDATE", "specifier": 0, "path": "src/ethereum/berlin/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_STORAGE_UPDATE"]}}, {"source": {"identifier": "ethereum.berlin.vm.gas.GAS_STORAGE_CLEAR_REFUND", "specifier": 0, "path": "src/ethereum/berlin/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_STORAGE_CLEAR_REFUND"]}}, {"source": {"identifier": "ethereum.berlin.vm.gas.GAS_LOW", "specifier": 0, "path": "src/ethereum/berlin/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_LOW"]}}, {"source": {"identifier": "ethereum.berlin.vm.gas.GAS_MID", "specifier": 0, "path": "src/ethereum/berlin/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_MID"]}}, {"source": {"identifier": "ethereum.berlin.vm.gas.GAS_HIGH", "specifier": 0, "path": "src/ethereum/berlin/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_HIGH"]}}, {"source": {"identifier": "ethereum.berlin.vm.gas.GAS_EXPONENTIATION", "specifier": 0, "path": "src/ethereum/berlin/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_EXPONENTIATION"]}}, {"source": {"identifier": "ethereum.berlin.vm.gas.GAS_EXPONENTIATION_PER_BYTE", "specifier": 0, "path": "src/ethereum/berlin/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_EXPONENTIATION_PER_BYTE"]}}, {"source": {"identifier": "ethereum.berlin.vm.gas.GAS_MEMORY", "specifier": 0, "path": "src/ethereum/berlin/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_MEMORY"]}}, {"source": {"identifier": "ethereum.berlin.vm.gas.GAS_KECCAK256", "specifier": 0, "path": "src/ethereum/berlin/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_KECCAK256"]}}, {"source": {"identifier": "ethereum.berlin.vm.gas.GAS_KECCAK256_WORD", "specifier": 0, "path": "src/ethereum/berlin/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_KECCAK256_WORD"]}}, {"source": {"identifier": "ethereum.berlin.vm.gas.GAS_COPY", "specifier": 0, "path": "src/ethereum/berlin/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_COPY"]}}, {"source": {"identifier": "ethereum.berlin.vm.gas.GAS_BLOCK_HASH", "specifier": 0, "path": "src/ethereum/berlin/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_BLOCK_HASH"]}}, {"source": {"identifier": "ethereum.berlin.vm.gas.GAS_LOG", "specifier": 0, "path": "src/ethereum/berlin/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_LOG"]}}, {"source": {"identifier": "ethereum.berlin.vm.gas.GAS_LOG_DATA", "specifier": 0, "path": "src/ethereum/berlin/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_LOG_DATA"]}}, {"source": {"identifier": "ethereum.berlin.vm.gas.GAS_LOG_TOPIC", "specifier": 0, "path": "src/ethereum/berlin/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_LOG_TOPIC"]}}, {"source": {"identifier": "ethereum.berlin.vm.gas.GAS_CREATE", "specifier": 0, "path": "src/ethereum/berlin/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_CREATE"]}}, {"source": {"identifier": "ethereum.berlin.vm.gas.GAS_CODE_DEPOSIT", "specifier": 0, "path": "src/ethereum/berlin/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_CODE_DEPOSIT"]}}, {"source": {"identifier": "ethereum.berlin.vm.gas.GAS_ZERO", "specifier": 0, "path": "src/ethereum/berlin/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_ZERO"]}}, {"source": {"identifier": "ethereum.berlin.vm.gas.GAS_NEW_ACCOUNT", "specifier": 0, "path": "src/ethereum/berlin/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_NEW_ACCOUNT"]}}, {"source": {"identifier": "ethereum.berlin.vm.gas.GAS_CALL_VALUE", "specifier": 0, "path": "src/ethereum/berlin/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_CALL_VALUE"]}}, {"source": {"identifier": "ethereum.berlin.vm.gas.GAS_CALL_STIPEND", "specifier": 0, "path": "src/ethereum/berlin/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_CALL_STIPEND"]}}, {"source": {"identifier": "ethereum.berlin.vm.gas.GAS_SELF_DESTRUCT", "specifier": 0, "path": "src/ethereum/berlin/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_SELF_DESTRUCT"]}}, {"source": {"identifier": "ethereum.berlin.vm.gas.GAS_SELF_DESTRUCT_NEW_ACCOUNT", "specifier": 0, "path": "src/ethereum/berlin/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_SELF_DESTRUCT_NEW_ACCOUNT"]}}, {"source": {"identifier": "ethereum.berlin.vm.gas.REFUND_SELF_DESTRUCT", "specifier": 0, "path": "src/ethereum/berlin/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["REFUND_SELF_DESTRUCT"]}}, {"source": {"identifier": "ethereum.berlin.vm.gas.GAS_ECRECOVER", "specifier": 0, "path": "src/ethereum/berlin/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_ECRECOVER"]}}, {"source": {"identifier": "ethereum.berlin.vm.gas.GAS_SHA256", "specifier": 0, "path": "src/ethereum/berlin/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_SHA256"]}}, {"source": {"identifier": "ethereum.berlin.vm.gas.GAS_SHA256_WORD", "specifier": 0, "path": "src/ethereum/berlin/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_SHA256_WORD"]}}, {"source": {"identifier": "ethereum.berlin.vm.gas.GAS_RIPEMD160", "specifier": 0, "path": "src/ethereum/berlin/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_RIPEMD160"]}}, {"source": {"identifier": "ethereum.berlin.vm.gas.GAS_RIPEMD160_WORD", "specifier": 0, "path": "src/ethereum/berlin/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_RIPEMD160_WORD"]}}, {"source": {"identifier": "ethereum.berlin.vm.gas.GAS_IDENTITY", "specifier": 0, "path": "src/ethereum/berlin/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_IDENTITY"]}}, {"source": {"identifier": "ethereum.berlin.vm.gas.GAS_IDENTITY_WORD", "specifier": 0, "path": "src/ethereum/berlin/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_IDENTITY_WORD"]}}, {"source": {"identifier": "ethereum.berlin.vm.gas.GAS_RETURN_DATA_COPY", "specifier": 0, "path": "src/ethereum/berlin/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_RETURN_DATA_COPY"]}}, {"source": {"identifier": "ethereum.berlin.vm.gas.GAS_FAST_STEP", "specifier": 0, "path": "src/ethereum/berlin/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_FAST_STEP"]}}, {"source": {"identifier": "ethereum.berlin.vm.gas.GAS_BLAKE2_PER_ROUND", "specifier": 0, "path": "src/ethereum/berlin/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_BLAKE2_PER_ROUND"]}}, {"source": {"identifier": "ethereum.berlin.vm.gas.GAS_COLD_SLOAD", "specifier": 0, "path": "src/ethereum/berlin/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_COLD_SLOAD"]}}, {"source": {"identifier": "ethereum.berlin.vm.gas.GAS_COLD_ACCOUNT_ACCESS", "specifier": 0, "path": "src/ethereum/berlin/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_COLD_ACCOUNT_ACCESS"]}}, {"source": {"identifier": "ethereum.berlin.vm.gas.GAS_WARM_ACCESS", "specifier": 0, "path": "src/ethereum/berlin/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_WARM_ACCESS"]}}, {"source": {"identifier": "ethereum.berlin.vm.gas.ExtendMemory", "specifier": 0, "path": "src/ethereum/berlin/vm/gas.py"}, "content": {"type": ["class"], "name": ["ExtendMemory"], "text": ["Define the parameters for memory extension in opcodes cost :  ethereum.base_types.Uint The gas required to perform the extension expand_by :  ethereum.base_types.Uint The size by which the memory will be extended"]}}, {"source": {"identifier": "ethereum.berlin.vm.gas.ExtendMemory.cost", "specifier": 0, "path": "src/ethereum/berlin/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["cost"]}}, {"source": {"identifier": "ethereum.berlin.vm.gas.ExtendMemory.expand_by", "specifier": 0, "path": "src/ethereum/berlin/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["expand_by"]}}, {"source": {"identifier": "ethereum.berlin.vm.gas.MessageCallGas", "specifier": 0, "path": "src/ethereum/berlin/vm/gas.py"}, "content": {"type": ["class"], "name": ["MessageCallGas"], "text": ["Define the gas cost and stipend for executing the call opcodes. cost :  ethereum.base_types.Uint The non-refundable portion of gas reserved for executing the call opcode. stipend :  ethereum.base_types.Uint The portion of gas available to sub-calls that is refundable if not consumed"]}}, {"source": {"identifier": "ethereum.berlin.vm.gas.MessageCallGas.cost", "specifier": 0, "path": "src/ethereum/berlin/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["cost"]}}, {"source": {"identifier": "ethereum.berlin.vm.gas.MessageCallGas.stipend", "specifier": 0, "path": "src/ethereum/berlin/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["stipend"]}}, {"source": {"identifier": "ethereum.berlin.vm.gas.charge_gas", "specifier": 0, "path": "src/ethereum/berlin/vm/gas.py"}, "content": {"type": ["function"], "name": ["charge_gas"], "text": ["Subtracts  amount  from  evm.gas_left . Parameters evm : The current EVM. amount : The amount of gas the current operation requires."]}}, {"source": {"identifier": "ethereum.berlin.vm.gas.calculate_memory_gas_cost", "specifier": 0, "path": "src/ethereum/berlin/vm/gas.py"}, "content": {"type": ["function"], "name": ["calculate_memory_gas_cost"], "text": ["Calculates the gas cost for allocating memory to the smallest multiple of 32 bytes, such that the allocated size is at least as big as the given size. Parameters size_in_bytes : The size of the data in bytes. Returns total_gas_cost :  ethereum.base_types.Uint The gas cost for storing data in memory."]}}, {"source": {"identifier": "ethereum.berlin.vm.gas.calculate_gas_extend_memory", "specifier": 0, "path": "src/ethereum/berlin/vm/gas.py"}, "content": {"type": ["function"], "name": ["calculate_gas_extend_memory"], "text": ["Calculates the gas amount to extend memory Parameters memory : Memory contents of the EVM. extensions: List of extensions to be made to the memory. Consists of a tuple of start position and size. Returns extend_memory:  ExtendMemory"]}}, {"source": {"identifier": "ethereum.berlin.vm.gas.calculate_message_call_gas", "specifier": 0, "path": "src/ethereum/berlin/vm/gas.py"}, "content": {"type": ["function"], "name": ["calculate_message_call_gas"], "text": ["Calculates the MessageCallGas (cost and stipend) for executing call Opcodes. Parameters value: The amount of  ETH  that needs to be transferred. gas : The amount of gas provided to the message-call. gas_left : The amount of gas left in the current frame. memory_cost : The amount needed to extend the memory in the current frame. extra_gas : The amount of gas needed for transferring value + creating a new account inside a message call. call_stipend : The amount of stipend provided to a message call to execute code while transferring value(ETH). Returns message_call_gas:  MessageCallGas"]}}, {"source": {"identifier": "ethereum.berlin.vm.gas.max_message_call_gas", "specifier": 0, "path": "src/ethereum/berlin/vm/gas.py"}, "content": {"type": ["function"], "name": ["max_message_call_gas"], "text": ["Calculates the maximum gas that is allowed for making a message call Parameters gas : The amount of gas provided to the message-call. Returns max_allowed_message_call_gas:  ethereum.base_types.Uint The maximum gas allowed for making the message-call."]}}, {"source": {"identifier": "ethereum.gray_glacier.trie", "specifier": 0, "path": "src/ethereum/gray_glacier/trie.py"}, "content": {"type": ["module"], "name": ["ethereum.gray_glacier.trie"], "text": ["State Trie ^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction The state trie is the structure responsible for storing .fork_types.Account  objects."]}}, {"source": {"identifier": "ethereum.gray_glacier.trie.EMPTY_TRIE_ROOT", "specifier": 0, "path": "src/ethereum/gray_glacier/trie.py"}, "content": {"type": ["attribute"], "name": ["EMPTY_TRIE_ROOT"]}}, {"source": {"identifier": "ethereum.gray_glacier.trie.Node", "specifier": 0, "path": "src/ethereum/gray_glacier/trie.py"}, "content": {"type": ["attribute"], "name": ["Node"]}}, {"source": {"identifier": "ethereum.gray_glacier.trie.K", "specifier": 0, "path": "src/ethereum/gray_glacier/trie.py"}, "content": {"type": ["attribute"], "name": ["K"]}}, {"source": {"identifier": "ethereum.gray_glacier.trie.V", "specifier": 0, "path": "src/ethereum/gray_glacier/trie.py"}, "content": {"type": ["attribute"], "name": ["V"]}}, {"source": {"identifier": "ethereum.gray_glacier.trie.LeafNode", "specifier": 0, "path": "src/ethereum/gray_glacier/trie.py"}, "content": {"type": ["class"], "name": ["LeafNode"], "text": ["Leaf node in the Merkle Trie"]}}, {"source": {"identifier": "ethereum.gray_glacier.trie.LeafNode.rest_of_key", "specifier": 0, "path": "src/ethereum/gray_glacier/trie.py"}, "content": {"type": ["attribute"], "name": ["rest_of_key"]}}, {"source": {"identifier": "ethereum.gray_glacier.trie.LeafNode.value", "specifier": 0, "path": "src/ethereum/gray_glacier/trie.py"}, "content": {"type": ["attribute"], "name": ["value"]}}, {"source": {"identifier": "ethereum.gray_glacier.trie.ExtensionNode", "specifier": 0, "path": "src/ethereum/gray_glacier/trie.py"}, "content": {"type": ["class"], "name": ["ExtensionNode"], "text": ["Extension node in the Merkle Trie"]}}, {"source": {"identifier": "ethereum.gray_glacier.trie.ExtensionNode.key_segment", "specifier": 0, "path": "src/ethereum/gray_glacier/trie.py"}, "content": {"type": ["attribute"], "name": ["key_segment"]}}, {"source": {"identifier": "ethereum.gray_glacier.trie.ExtensionNode.subnode", "specifier": 0, "path": "src/ethereum/gray_glacier/trie.py"}, "content": {"type": ["attribute"], "name": ["subnode"]}}, {"source": {"identifier": "ethereum.gray_glacier.trie.BranchNode", "specifier": 0, "path": "src/ethereum/gray_glacier/trie.py"}, "content": {"type": ["class"], "name": ["BranchNode"], "text": ["Branch node in the Merkle Trie"]}}, {"source": {"identifier": "ethereum.gray_glacier.trie.BranchNode.subnodes", "specifier": 0, "path": "src/ethereum/gray_glacier/trie.py"}, "content": {"type": ["attribute"], "name": ["subnodes"]}}, {"source": {"identifier": "ethereum.gray_glacier.trie.BranchNode.value", "specifier": 0, "path": "src/ethereum/gray_glacier/trie.py"}, "content": {"type": ["attribute"], "name": ["value"]}}, {"source": {"identifier": "ethereum.gray_glacier.trie.InternalNode", "specifier": 0, "path": "src/ethereum/gray_glacier/trie.py"}, "content": {"type": ["attribute"], "name": ["InternalNode"]}}, {"source": {"identifier": "ethereum.gray_glacier.trie.encode_internal_node", "specifier": 0, "path": "src/ethereum/gray_glacier/trie.py"}, "content": {"type": ["function"], "name": ["encode_internal_node"], "text": ["Encodes a Merkle Trie node into its RLP form. The RLP will then be serialized into a  Bytes  and hashed unless it is less that 32 bytes when serialized. This function also accepts  None , representing the absence of a node, which is encoded to  b\"\" . Parameters node : Optional[InternalNode] The node to encode. Returns encoded :  rlp.RLP The node encoded as RLP."]}}, {"source": {"identifier": "ethereum.gray_glacier.trie.encode_node", "specifier": 0, "path": "src/ethereum/gray_glacier/trie.py"}, "content": {"type": ["function"], "name": ["encode_node"], "text": ["Encode a Node for storage in the Merkle Trie. Currently mostly an unimplemented stub."]}}, {"source": {"identifier": "ethereum.gray_glacier.trie.Trie", "specifier": 0, "path": "src/ethereum/gray_glacier/trie.py"}, "content": {"type": ["class"], "name": ["Trie"], "text": ["The Merkle Trie."]}}, {"source": {"identifier": "ethereum.gray_glacier.trie.Trie.secured", "specifier": 0, "path": "src/ethereum/gray_glacier/trie.py"}, "content": {"type": ["attribute"], "name": ["secured"]}}, {"source": {"identifier": "ethereum.gray_glacier.trie.Trie.default", "specifier": 0, "path": "src/ethereum/gray_glacier/trie.py"}, "content": {"type": ["attribute"], "name": ["default"]}}, {"source": {"identifier": "ethereum.gray_glacier.trie.Trie._data", "specifier": 0, "path": "src/ethereum/gray_glacier/trie.py"}, "content": {"type": ["attribute"], "name": ["_data"]}}, {"source": {"identifier": "ethereum.gray_glacier.trie.copy_trie", "specifier": 0, "path": "src/ethereum/gray_glacier/trie.py"}, "content": {"type": ["function"], "name": ["copy_trie"], "text": ["Create a copy of  trie . Since only frozen objects may be stored in tries, the contents are reused. Parameters trie:  Trie Trie to copy. Returns new_trie :  Trie[K, V] A copy of the trie."]}}, {"source": {"identifier": "ethereum.gray_glacier.trie.trie_set", "specifier": 0, "path": "src/ethereum/gray_glacier/trie.py"}, "content": {"type": ["function"], "name": ["trie_set"], "text": ["Stores an item in a Merkle Trie. This method deletes the key if  value == trie.default , because the Merkle Trie represents the default value by omitting it from the trie. Parameters trie:  Trie Trie to store in. key :  Bytes Key to lookup. value :  V Node to insert at  key ."]}}, {"source": {"identifier": "ethereum.gray_glacier.trie.trie_get", "specifier": 0, "path": "src/ethereum/gray_glacier/trie.py"}, "content": {"type": ["function"], "name": ["trie_get"], "text": ["Gets an item from the Merkle Trie. This method returns  trie.default  if the key is missing. Parameters trie: Trie to lookup in. key : Key to lookup. Returns node :  V Node at  key  in the trie."]}}, {"source": {"identifier": "ethereum.gray_glacier.trie.common_prefix_length", "specifier": 0, "path": "src/ethereum/gray_glacier/trie.py"}, "content": {"type": ["function"], "name": ["common_prefix_length"], "text": ["Find the longest common prefix of two sequences."]}}, {"source": {"identifier": "ethereum.gray_glacier.trie.nibble_list_to_compact", "specifier": 0, "path": "src/ethereum/gray_glacier/trie.py"}, "content": {"type": ["function"], "name": ["nibble_list_to_compact"], "text": ["Compresses nibble-list into a standard byte array with a flag. A nibble-list is a list of byte values no greater than  15 . The flag is encoded in high nibble of the highest byte. The flag nibble can be broken down into two two-bit flags. Highest nibble:: +---+---+----------+--------+\n| _ | _ | is_leaf | parity |\n+---+---+----------+--------+\n  3   2      1         0\n The lowest bit of the nibble encodes the parity of the length of the remaining nibbles --  0  when even and  1  when odd. The second lowest bit is used to distinguish leaf and extension nodes. The other two bits are not used. Parameters x : Array of nibbles. is_leaf : True if this is part of a leaf node, or false if it is an extension node. Returns compressed :  bytearray Compact byte array."]}}, {"source": {"identifier": "ethereum.gray_glacier.trie.bytes_to_nibble_list", "specifier": 0, "path": "src/ethereum/gray_glacier/trie.py"}, "content": {"type": ["function"], "name": ["bytes_to_nibble_list"], "text": ["Converts a  Bytes  into to a sequence of nibbles (bytes with value < 16). Parameters bytes_: The  Bytes  to convert. Returns nibble_list :  Bytes The  Bytes  in nibble-list format."]}}, {"source": {"identifier": "ethereum.gray_glacier.trie._prepare_trie", "specifier": 0, "path": "src/ethereum/gray_glacier/trie.py"}, "content": {"type": ["function"], "name": ["_prepare_trie"], "text": ["Prepares the trie for root calculation. Removes values that are empty, hashes the keys (if  secured == True ) and encodes all the nodes. Parameters trie : The  Trie  to prepare. get_storage_root : Function to get the storage root of an account. Needed to encode Account  objects. Returns out :  Mapping[ethereum.base_types.Bytes, Node] Object with keys mapped to nibble-byte form."]}}, {"source": {"identifier": "ethereum.gray_glacier.trie.root", "specifier": 0, "path": "src/ethereum/gray_glacier/trie.py"}, "content": {"type": ["function"], "name": ["root"], "text": ["Computes the root of a modified merkle patricia trie (MPT). Parameters trie : Trie  to get the root of. get_storage_root : Function to get the storage root of an account. Needed to encode Account  objects. Returns root :  .fork_types.Root MPT root of the underlying key-value pairs."]}}, {"source": {"identifier": "ethereum.gray_glacier.trie.patricialize", "specifier": 0, "path": "src/ethereum/gray_glacier/trie.py"}, "content": {"type": ["function"], "name": ["patricialize"], "text": ["Structural composition function. Used to recursively patricialize and merkleize a dictionary. Includes memoization of the tree structure and hashes. Parameters obj : Underlying trie key-value pairs, with keys in nibble-list format. level : Current trie level. Returns node :  ethereum.base_types.Bytes Root node of  obj ."]}}, {"source": {"identifier": "ethereum.berlin.vm.precompiled_contracts.blake2f", "specifier": 0, "path": "src/ethereum/berlin/vm/precompiled_contracts/blake2f.py"}, "content": {"type": ["module"], "name": ["ethereum.berlin.vm.precompiled_contracts.blake2f"], "text": ["Ethereum Virtual Machine (EVM) Blake2 PRECOMPILED CONTRACT ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementation of the  Blake2  precompiled contract."]}}, {"source": {"identifier": "ethereum.berlin.vm.precompiled_contracts.blake2f.blake2f", "specifier": 0, "path": "src/ethereum/berlin/vm/precompiled_contracts/blake2f.py"}, "content": {"type": ["function"], "name": ["blake2f"], "text": ["Writes the Blake2 hash to output. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.gray_glacier.fork", "specifier": 0, "path": "src/ethereum/gray_glacier/fork.py"}, "content": {"type": ["module"], "name": ["ethereum.gray_glacier.fork"], "text": ["Ethereum Specification ^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Entry point for the Ethereum specification."]}}, {"source": {"identifier": "ethereum.gray_glacier.fork.BLOCK_REWARD", "specifier": 0, "path": "src/ethereum/gray_glacier/fork.py"}, "content": {"type": ["attribute"], "name": ["BLOCK_REWARD"]}}, {"source": {"identifier": "ethereum.gray_glacier.fork.BASE_FEE_MAX_CHANGE_DENOMINATOR", "specifier": 0, "path": "src/ethereum/gray_glacier/fork.py"}, "content": {"type": ["attribute"], "name": ["BASE_FEE_MAX_CHANGE_DENOMINATOR"]}}, {"source": {"identifier": "ethereum.gray_glacier.fork.ELASTICITY_MULTIPLIER", "specifier": 0, "path": "src/ethereum/gray_glacier/fork.py"}, "content": {"type": ["attribute"], "name": ["ELASTICITY_MULTIPLIER"]}}, {"source": {"identifier": "ethereum.gray_glacier.fork.GAS_LIMIT_ADJUSTMENT_FACTOR", "specifier": 0, "path": "src/ethereum/gray_glacier/fork.py"}, "content": {"type": ["attribute"], "name": ["GAS_LIMIT_ADJUSTMENT_FACTOR"]}}, {"source": {"identifier": "ethereum.gray_glacier.fork.GAS_LIMIT_MINIMUM", "specifier": 0, "path": "src/ethereum/gray_glacier/fork.py"}, "content": {"type": ["attribute"], "name": ["GAS_LIMIT_MINIMUM"]}}, {"source": {"identifier": "ethereum.gray_glacier.fork.MINIMUM_DIFFICULTY", "specifier": 0, "path": "src/ethereum/gray_glacier/fork.py"}, "content": {"type": ["attribute"], "name": ["MINIMUM_DIFFICULTY"]}}, {"source": {"identifier": "ethereum.gray_glacier.fork.MAX_OMMER_DEPTH", "specifier": 0, "path": "src/ethereum/gray_glacier/fork.py"}, "content": {"type": ["attribute"], "name": ["MAX_OMMER_DEPTH"]}}, {"source": {"identifier": "ethereum.gray_glacier.fork.BOMB_DELAY_BLOCKS", "specifier": 0, "path": "src/ethereum/gray_glacier/fork.py"}, "content": {"type": ["attribute"], "name": ["BOMB_DELAY_BLOCKS"]}}, {"source": {"identifier": "ethereum.gray_glacier.fork.EMPTY_OMMER_HASH", "specifier": 0, "path": "src/ethereum/gray_glacier/fork.py"}, "content": {"type": ["attribute"], "name": ["EMPTY_OMMER_HASH"]}}, {"source": {"identifier": "ethereum.gray_glacier.fork.BlockChain", "specifier": 0, "path": "src/ethereum/gray_glacier/fork.py"}, "content": {"type": ["class"], "name": ["BlockChain"], "text": ["History and current state of the block chain."]}}, {"source": {"identifier": "ethereum.gray_glacier.fork.BlockChain.blocks", "specifier": 0, "path": "src/ethereum/gray_glacier/fork.py"}, "content": {"type": ["attribute"], "name": ["blocks"]}}, {"source": {"identifier": "ethereum.gray_glacier.fork.BlockChain.state", "specifier": 0, "path": "src/ethereum/gray_glacier/fork.py"}, "content": {"type": ["attribute"], "name": ["state"]}}, {"source": {"identifier": "ethereum.gray_glacier.fork.BlockChain.chain_id", "specifier": 0, "path": "src/ethereum/gray_glacier/fork.py"}, "content": {"type": ["attribute"], "name": ["chain_id"]}}, {"source": {"identifier": "ethereum.gray_glacier.fork.apply_fork", "specifier": 0, "path": "src/ethereum/gray_glacier/fork.py"}, "content": {"type": ["function"], "name": ["apply_fork"], "text": ["Transforms the state from the previous hard fork ( old ) into the block chain object for this hard fork and returns it. When forks need to implement an irregular state transition, this function is used to handle the irregularity. See the :ref: DAO Fork <dao-fork>  for an example. Parameters old : Previous block chain object. Returns new :  BlockChain Upgraded block chain object for this hard fork."]}}, {"source": {"identifier": "ethereum.gray_glacier.fork.get_last_256_block_hashes", "specifier": 0, "path": "src/ethereum/gray_glacier/fork.py"}, "content": {"type": ["function"], "name": ["get_last_256_block_hashes"], "text": ["Obtain the list of hashes of the previous 256 blocks in order of increasing block number. This function will return less hashes for the first 256 blocks. The  BLOCKHASH  opcode needs to access the latest hashes on the chain, therefore this function retrieves them. Parameters chain : History and current state. Returns recent_block_hashes :  List[Hash32] Hashes of the recent 256 blocks in order of increasing block number."]}}, {"source": {"identifier": "ethereum.gray_glacier.fork.state_transition", "specifier": 0, "path": "src/ethereum/gray_glacier/fork.py"}, "content": {"type": ["function"], "name": ["state_transition"], "text": ["Attempts to apply a block to an existing block chain. All parts of the block's contents need to be verified before being added to the chain. Blocks are verified by ensuring that the contents of the block make logical sense with the contents of the parent block. The information in the block's header must also match the corresponding information in the block. To implement Ethereum, in theory clients are only required to store the most recent 255 blocks of the chain since as far as execution is concerned, only those blocks are accessed. Practically, however, clients should store more blocks to handle reorgs. Parameters chain : History and current state. block : Block to apply to  chain ."]}}, {"source": {"identifier": "ethereum.gray_glacier.fork.calculate_base_fee_per_gas", "specifier": 0, "path": "src/ethereum/gray_glacier/fork.py"}, "content": {"type": ["function"], "name": ["calculate_base_fee_per_gas"], "text": ["Calculates the base fee per gas for the block. Parameters block_gas_limit : Gas limit of the block for which the base fee is being calculated. parent_gas_limit : Gas limit of the parent block. parent_gas_used : Gas used in the parent block. parent_base_fee_per_gas : Base fee per gas of the parent block. Returns base_fee_per_gas :  Uint Base fee per gas for the block."]}}, {"source": {"identifier": "ethereum.gray_glacier.fork.validate_header", "specifier": 0, "path": "src/ethereum/gray_glacier/fork.py"}, "content": {"type": ["function"], "name": ["validate_header"], "text": ["Verifies a block header. In order to consider a block's header valid, the logic for the quantities in the header should match the logic for the block itself. For example the header timestamp should be greater than the block's parent timestamp because the block was created  after  the parent block. Additionally, the block's number should be directly folowing the parent block's number since it is the next block in the sequence. Parameters header : Header to check for correctness. parent_header : Parent Header of the header to check for correctness"]}}, {"source": {"identifier": "ethereum.gray_glacier.fork.generate_header_hash_for_pow", "specifier": 0, "path": "src/ethereum/gray_glacier/fork.py"}, "content": {"type": ["function"], "name": ["generate_header_hash_for_pow"], "text": ["Generate rlp hash of the header which is to be used for Proof-of-Work verification. In other words, the PoW artefacts  mix_digest  and  nonce  are ignored while calculating this hash. A particular PoW is valid for a single hash, that hash is computed by this function. The  nonce  and  mix_digest  are omitted from this hash because they are being changed by miners in their search for a sufficient proof-of-work. Parameters header : The header object for which the hash is to be generated. Returns hash :  Hash32 The PoW valid rlp hash of the passed in header."]}}, {"source": {"identifier": "ethereum.gray_glacier.fork.validate_proof_of_work", "specifier": 0, "path": "src/ethereum/gray_glacier/fork.py"}, "content": {"type": ["function"], "name": ["validate_proof_of_work"], "text": ["Validates the Proof of Work constraints. In order to verify that a miner's proof-of-work is valid for a block, a mix-digest  and  result  are calculated using the  hashimoto_light hash function. The mix digest is a hash of the header and the nonce that is passed through and it confirms whether or not proof-of-work was done on the correct block. The result is the actual hash value of the block. Parameters header : Header of interest."]}}, {"source": {"identifier": "ethereum.gray_glacier.fork.check_transaction", "specifier": 0, "path": "src/ethereum/gray_glacier/fork.py"}, "content": {"type": ["function"], "name": ["check_transaction"], "text": ["Check if the transaction is includable in the block. Parameters tx : The transaction. base_fee_per_gas : The block base fee. gas_available : The gas remaining in the block. chain_id : The ID of the current chain. Returns sender_address : The sender of the transaction. effective_gas_price : The price to charge for gas when the transaction is executed. Raises InvalidBlock : If the transaction is not includable."]}}, {"source": {"identifier": "ethereum.gray_glacier.fork.make_receipt", "specifier": 0, "path": "src/ethereum/gray_glacier/fork.py"}, "content": {"type": ["function"], "name": ["make_receipt"], "text": ["Make the receipt for a transaction that was executed. Parameters tx : The executed transaction. has_erred : Whether the top level frame of the transaction exited with an error. cumulative_gas_used : The total gas used so far in the block after the transaction was executed. logs : The logs produced by the transaction. Returns receipt : The receipt for the transaction."]}}, {"source": {"identifier": "ethereum.gray_glacier.fork.apply_body", "specifier": 0, "path": "src/ethereum/gray_glacier/fork.py"}, "content": {"type": ["function"], "name": ["apply_body"], "text": ["Executes a block. Many of the contents of a block are stored in data structures called tries. There is a transactions trie which is similar to a ledger of the transactions stored in the current block. There is also a receipts trie which stores the results of executing a transaction, like the post state and gas used. This function creates and executes the block that is to be added to the chain. Parameters state : Current account state. block_hashes : List of hashes of the previous 256 blocks in the order of increasing block number. coinbase : Address of account which receives block reward and transaction fees. block_number : Position of the block within the chain. base_fee_per_gas : Base fee per gas of within the block. block_gas_limit : Initial amount of gas available for execution in this block. block_time : Time the block was produced, measured in seconds since the epoch. block_difficulty : Difficulty of the block. transactions : Transactions included in the block. ommers : Headers of ancestor blocks which are not direct parents (formerly uncles.) chain_id : ID of the executing chain. Returns gas_available :  ethereum.base_types.Uint Remaining gas after all transactions have been executed. transactions_root :  ethereum.fork_types.Root Trie root of all the transactions in the block. receipt_root :  ethereum.fork_types.Root Trie root of all the receipts in the block. block_logs_bloom :  Bloom Logs bloom of all the logs included in all the transactions of the block. state :  ethereum.fork_types.State State after all transactions have been executed."]}}, {"source": {"identifier": "ethereum.gray_glacier.fork.validate_ommers", "specifier": 0, "path": "src/ethereum/gray_glacier/fork.py"}, "content": {"type": ["function"], "name": ["validate_ommers"], "text": ["Validates the ommers mentioned in the block. An ommer block is a block that wasn't canonically added to the blockchain because it wasn't validated as fast as the canonical block but was mined at the same time. To be considered valid, the ommers must adhere to the rules defined in the Ethereum protocol. The maximum amount of ommers is 2 per block and there cannot be duplicate ommers in a block. Many of the other ommer contraints are listed in the in-line comments of this function. Parameters ommers : List of ommers mentioned in the current block. block_header: The header of current block. chain : History and current state."]}}, {"source": {"identifier": "ethereum.gray_glacier.fork.pay_rewards", "specifier": 0, "path": "src/ethereum/gray_glacier/fork.py"}, "content": {"type": ["function"], "name": ["pay_rewards"], "text": ["Pay rewards to the block miner as well as the ommers miners. The miner of the canonical block is rewarded with the predetermined block reward,  BLOCK_REWARD , plus a variable award based off of the number of ommer blocks that were mined around the same time, and included in the canonical block's header. An ommer block is a block that wasn't added to the canonical blockchain because it wasn't validated as fast as the accepted block but was mined at the same time. Although not all blocks that are mined are added to the canonical chain, miners are still paid a reward for their efforts. This reward is called an ommer reward and is calculated based on the number associated with the ommer block that they mined. Parameters state : Current account state. block_number : Position of the block within the chain. coinbase : Address of account which receives block reward and transaction fees. ommers : List of ommers mentioned in the current block."]}}, {"source": {"identifier": "ethereum.gray_glacier.fork.process_transaction", "specifier": 0, "path": "src/ethereum/gray_glacier/fork.py"}, "content": {"type": ["function"], "name": ["process_transaction"], "text": ["Execute a transaction against the provided environment. This function processes the actions needed to execute a transaction. It decrements the sender's account after calculating the gas fee and refunds them the proper amount after execution. Calling contracts, deploying code, and incrementing nonces are all examples of actions that happen within this function or from a call made within this function. Accounts that are marked for deletion are processed and destroyed after execution. Parameters env : Environment for the Ethereum Virtual Machine. tx : Transaction to execute. Returns gas_left :  ethereum.base_types.U256 Remaining gas after execution. logs :  Tuple[ethereum.fork_types.Log, ...] Logs generated during execution."]}}, {"source": {"identifier": "ethereum.gray_glacier.fork.validate_transaction", "specifier": 0, "path": "src/ethereum/gray_glacier/fork.py"}, "content": {"type": ["function"], "name": ["validate_transaction"], "text": ["Verifies a transaction. The gas in a transaction gets used to pay for the intrinsic cost of operations, therefore if there is insufficient gas then it would not be possible to execute a transaction and it will be declared invalid. Additionally, the nonce of a transaction must not equal or exceed the limit defined in  EIP-2681 <https://eips.ethereum.org/EIPS/eip-2681> _. In practice, defining the limit as  2**64-1  has no impact because sending  2**64-1  transactions is improbable. It's not strictly impossible though,  2**64-1  transactions is the entire capacity of the Ethereum blockchain at 2022 gas limits for a little over 22 years. Parameters tx : Transaction to validate. Returns verified :  bool True if the transaction can be executed, or False otherwise."]}}, {"source": {"identifier": "ethereum.gray_glacier.fork.calculate_intrinsic_cost", "specifier": 0, "path": "src/ethereum/gray_glacier/fork.py"}, "content": {"type": ["function"], "name": ["calculate_intrinsic_cost"], "text": ["Calculates the gas that is charged before execution is started. The intrinsic cost of the transaction is charged before execution has begun. Functions/operations in the EVM cost money to execute so this intrinsic cost is for the operations that need to be paid for as part of the transaction. Data transfer, for example, is part of this intrinsic cost. It costs ether to send data over the wire and that ether is accounted for in the intrinsic cost calculated in this function. This intrinsic cost must be calculated and paid for before execution in order for all operations to be implemented. Parameters tx : Transaction to compute the intrinsic cost of. Returns verified :  ethereum.base_types.Uint The intrinsic cost of the transaction."]}}, {"source": {"identifier": "ethereum.gray_glacier.fork.recover_sender", "specifier": 0, "path": "src/ethereum/gray_glacier/fork.py"}, "content": {"type": ["function"], "name": ["recover_sender"], "text": ["Extracts the sender address from a transaction. The v, r, and s values are the three parts that make up the signature of a transaction. In order to recover the sender of a transaction the two components needed are the signature ( v ,  r , and  s ) and the signing hash of the transaction. The sender's public key can be obtained with these two values and therefore the sender address can be retrieved. Parameters tx : Transaction of interest. chain_id : ID of the executing chain. Returns sender :  ethereum.fork_types.Address The address of the account that signed the transaction."]}}, {"source": {"identifier": "ethereum.gray_glacier.fork.signing_hash_pre155", "specifier": 0, "path": "src/ethereum/gray_glacier/fork.py"}, "content": {"type": ["function"], "name": ["signing_hash_pre155"], "text": ["Compute the hash of a transaction used in a legacy (pre EIP 155) signature. Parameters tx : Transaction of interest. Returns hash :  ethereum.crypto.hash.Hash32 Hash of the transaction."]}}, {"source": {"identifier": "ethereum.gray_glacier.fork.signing_hash_155", "specifier": 0, "path": "src/ethereum/gray_glacier/fork.py"}, "content": {"type": ["function"], "name": ["signing_hash_155"], "text": ["Compute the hash of a transaction used in a EIP 155 signature. Parameters tx : Transaction of interest. Returns hash :  ethereum.crypto.hash.Hash32 Hash of the transaction."]}}, {"source": {"identifier": "ethereum.gray_glacier.fork.signing_hash_2930", "specifier": 0, "path": "src/ethereum/gray_glacier/fork.py"}, "content": {"type": ["function"], "name": ["signing_hash_2930"], "text": ["Compute the hash of a transaction used in a EIP 2930 signature. Parameters tx : Transaction of interest. Returns hash :  ethereum.crypto.hash.Hash32 Hash of the transaction."]}}, {"source": {"identifier": "ethereum.gray_glacier.fork.signing_hash_1559", "specifier": 0, "path": "src/ethereum/gray_glacier/fork.py"}, "content": {"type": ["function"], "name": ["signing_hash_1559"], "text": ["Compute the hash of a transaction used in a EIP 1559 signature. Parameters tx : Transaction of interest. Returns hash :  ethereum.crypto.hash.Hash32 Hash of the transaction."]}}, {"source": {"identifier": "ethereum.gray_glacier.fork.compute_header_hash", "specifier": 0, "path": "src/ethereum/gray_glacier/fork.py"}, "content": {"type": ["function"], "name": ["compute_header_hash"], "text": ["Computes the hash of a block header. The header hash of a block is the canonical hash that is used to refer to a specific block and completely distinguishes a block from another. keccak256  is a function that produces a 256 bit hash of any input. It also takes in any number of bytes as an input and produces a single hash for them. A hash is a completely unique output for a single input. So an input corresponds to one unique hash that can be used to identify the input exactly. Prior to using the  keccak256  hash function, the header must be encoded using the Recursive-Length Prefix. See :ref: rlp . RLP encoding the header converts it into a space-efficient format that allows for easy transfer of data between nodes. The purpose of RLP is to encode arbitrarily nested arrays of binary data, and RLP is the primary encoding method used to serialize objects in Ethereum's execution layer. The only purpose of RLP is to encode structure; encoding specific data types (e.g. strings, floats) is left up to higher-order protocols. Parameters header : Header of interest. Returns hash :  ethereum.crypto.hash.Hash32 Hash of the header."]}}, {"source": {"identifier": "ethereum.gray_glacier.fork.check_gas_limit", "specifier": 0, "path": "src/ethereum/gray_glacier/fork.py"}, "content": {"type": ["function"], "name": ["check_gas_limit"], "text": ["Validates the gas limit for a block. The bounds of the gas limit,  max_adjustment_delta , is set as the quotient of the parent block's gas limit and the GAS_LIMIT_ADJUSTMENT_FACTOR . Therefore, if the gas limit that is passed through as a parameter is greater than or equal to the  sum  of the parent's gas and the adjustment delta then the limit for gas is too high and fails this function's check. Similarly, if the limit is less than or equal to the  difference  of the parent's gas and the adjustment delta  or  the predefined  GAS_LIMIT_MINIMUM  then this function's check fails because the gas limit doesn't allow for a sufficient or reasonable amount of gas to be used on a block. Parameters gas_limit : Gas limit to validate. parent_gas_limit : Gas limit of the parent block. Returns check :  bool True if gas limit constraints are satisfied, False otherwise."]}}, {"source": {"identifier": "ethereum.gray_glacier.fork.calculate_block_difficulty", "specifier": 0, "path": "src/ethereum/gray_glacier/fork.py"}, "content": {"type": ["function"], "name": ["calculate_block_difficulty"], "text": ["Computes difficulty of a block using its header and parent header. The difficulty is determined by the time the block was created after its parent. The  offset  is calculated using the parent block's difficulty, parent_difficulty , and the timestamp between blocks. This offset is then added to the parent difficulty and is stored as the  difficulty variable. If the time between the block and its parent is too short, the offset will result in a positive number thus making the sum of parent_difficulty  and  offset  to be a greater value in order to avoid mass forking. But, if the time is long enough, then the offset results in a negative value making the block less difficult than its parent. The base standard for a block's difficulty is the predefined value set for the genesis block since it has no parent. So, a block can't be less difficult than the genesis block, therefore each block's difficulty is set to the maximum value between the calculated difficulty and the  GENESIS_DIFFICULTY . Parameters block_number : Block number of the block. block_timestamp : Timestamp of the block. parent_timestamp : Timestamp of the parent block. parent_difficulty : difficulty of the parent block. parent_has_ommers: does the parent have ommers. Returns difficulty :  ethereum.base_types.Uint Computed difficulty for a block."]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.log", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/log.py"}, "content": {"type": ["module"], "name": ["ethereum.spurious_dragon.vm.instructions.log"], "text": ["Ethereum Virtual Machine (EVM) Logging Instructions ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementations of the EVM logging instructions."]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.log.log_n", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/log.py"}, "content": {"type": ["function"], "name": ["log_n"], "text": ["Appends a log entry, having  num_topics  topics, to the evm logs. This will also expand the memory if the data (required by the log entry) corresponding to the memory is not accessible. Parameters evm : The current EVM frame. num_topics : The number of topics to be included in the log entry."]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.log.log0", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/log.py"}, "content": {"type": ["attribute"], "name": ["log0"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.log.log1", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/log.py"}, "content": {"type": ["attribute"], "name": ["log1"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.log.log2", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/log.py"}, "content": {"type": ["attribute"], "name": ["log2"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.log.log3", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/log.py"}, "content": {"type": ["attribute"], "name": ["log3"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.log.log4", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/log.py"}, "content": {"type": ["attribute"], "name": ["log4"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.stack", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/stack.py"}, "content": {"type": ["module"], "name": ["ethereum.gray_glacier.vm.instructions.stack"], "text": ["Ethereum Virtual Machine (EVM) Stack Instructions ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementations of the EVM stack related instructions."]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.stack.pop", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/stack.py"}, "content": {"type": ["function"], "name": ["pop"], "text": ["Remove item from stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.stack.push_n", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/stack.py"}, "content": {"type": ["function"], "name": ["push_n"], "text": ["Pushes a N-byte immediate onto the stack. Parameters evm : The current EVM frame. num_bytes : The number of immediate bytes to be read from the code and pushed to the stack."]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.stack.dup_n", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/stack.py"}, "content": {"type": ["function"], "name": ["dup_n"], "text": ["Duplicate the Nth stack item (from top of the stack) to the top of stack. Parameters evm : The current EVM frame. item_number : The stack item number (0-indexed from top of stack) to be duplicated to the top of stack."]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.stack.swap_n", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/stack.py"}, "content": {"type": ["function"], "name": ["swap_n"], "text": ["Swap the top and the  item_number  element of the stack, where the top of the stack is position zero. If  item_number  is zero, this function does nothing (which should not be possible, since there is no  SWAP0  instruction). Parameters evm : The current EVM frame. item_number : The stack item number (0-indexed from top of stack) to be swapped with the top of stack element."]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.stack.push1", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push1"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.stack.push2", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push2"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.stack.push3", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push3"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.stack.push4", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push4"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.stack.push5", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push5"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.stack.push6", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push6"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.stack.push7", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push7"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.stack.push8", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push8"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.stack.push9", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push9"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.stack.push10", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push10"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.stack.push11", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push11"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.stack.push12", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push12"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.stack.push13", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push13"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.stack.push14", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push14"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.stack.push15", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push15"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.stack.push16", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push16"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.stack.push17", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push17"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.stack.push18", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push18"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.stack.push19", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push19"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.stack.push20", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push20"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.stack.push21", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push21"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.stack.push22", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push22"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.stack.push23", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push23"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.stack.push24", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push24"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.stack.push25", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push25"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.stack.push26", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push26"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.stack.push27", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push27"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.stack.push28", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push28"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.stack.push29", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push29"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.stack.push30", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push30"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.stack.push31", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push31"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.stack.push32", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push32"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.stack.dup1", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup1"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.stack.dup2", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup2"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.stack.dup3", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup3"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.stack.dup4", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup4"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.stack.dup5", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup5"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.stack.dup6", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup6"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.stack.dup7", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup7"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.stack.dup8", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup8"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.stack.dup9", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup9"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.stack.dup10", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup10"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.stack.dup11", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup11"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.stack.dup12", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup12"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.stack.dup13", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup13"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.stack.dup14", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup14"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.stack.dup15", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup15"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.stack.dup16", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup16"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.stack.swap1", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap1"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.stack.swap2", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap2"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.stack.swap3", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap3"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.stack.swap4", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap4"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.stack.swap5", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap5"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.stack.swap6", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap6"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.stack.swap7", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap7"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.stack.swap8", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap8"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.stack.swap9", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap9"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.stack.swap10", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap10"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.stack.swap11", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap11"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.stack.swap12", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap12"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.stack.swap13", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap13"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.stack.swap14", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap14"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.stack.swap15", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap15"]}}, {"source": {"identifier": "ethereum.gray_glacier.vm.instructions.stack.swap16", "specifier": 0, "path": "src/ethereum/gray_glacier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap16"]}}, {"source": {"identifier": "ethereum.frontier.vm.exceptions", "specifier": 0, "path": "src/ethereum/frontier/vm/exceptions.py"}, "content": {"type": ["module"], "name": ["ethereum.frontier.vm.exceptions"], "text": ["Ethereum Virtual Machine (EVM) Exceptions ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Exceptions which cause the EVM to halt exceptionally."]}}, {"source": {"identifier": "ethereum.frontier.vm.exceptions.ExceptionalHalt", "specifier": 0, "path": "src/ethereum/frontier/vm/exceptions.py"}, "content": {"type": ["class"], "name": ["ExceptionalHalt"], "text": ["Indicates that the EVM has experienced an exceptional halt. This causes execution to immediately end with all gas being consumed."]}}, {"source": {"identifier": "ethereum.frontier.vm.exceptions.StackUnderflowError", "specifier": 0, "path": "src/ethereum/frontier/vm/exceptions.py"}, "content": {"type": ["class"], "name": ["StackUnderflowError"], "text": ["Occurs when a pop is executed on an empty stack."]}}, {"source": {"identifier": "ethereum.frontier.vm.exceptions.StackOverflowError", "specifier": 0, "path": "src/ethereum/frontier/vm/exceptions.py"}, "content": {"type": ["class"], "name": ["StackOverflowError"], "text": ["Occurs when a push is executed on a stack at max capacity."]}}, {"source": {"identifier": "ethereum.frontier.vm.exceptions.OutOfGasError", "specifier": 0, "path": "src/ethereum/frontier/vm/exceptions.py"}, "content": {"type": ["class"], "name": ["OutOfGasError"], "text": ["Occurs when an operation costs more than the amount of gas left in the frame."]}}, {"source": {"identifier": "ethereum.frontier.vm.exceptions.InvalidOpcode", "specifier": 0, "path": "src/ethereum/frontier/vm/exceptions.py"}, "content": {"type": ["class"], "name": ["InvalidOpcode"], "text": ["Raised when an invalid opcode is encountered."]}}, {"source": {"identifier": "ethereum.frontier.vm.exceptions.InvalidJumpDestError", "specifier": 0, "path": "src/ethereum/frontier/vm/exceptions.py"}, "content": {"type": ["class"], "name": ["InvalidJumpDestError"], "text": ["Occurs when the destination of a jump operation doesn't meet any of the following criteria: The jump destination is less than the length of the code. The jump destination should have the  JUMPDEST  opcode (0x5B). The jump destination shouldn't be part of the data corresponding to PUSH-N  opcodes."]}}, {"source": {"identifier": "ethereum.frontier.vm.exceptions.StackDepthLimitError", "specifier": 0, "path": "src/ethereum/frontier/vm/exceptions.py"}, "content": {"type": ["class"], "name": ["StackDepthLimitError"], "text": ["Raised when the message depth is greater than  1024"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.storage", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/storage.py"}, "content": {"type": ["module"], "name": ["ethereum.spurious_dragon.vm.instructions.storage"], "text": ["Ethereum Virtual Machine (EVM) Storage Instructions ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementations of the EVM storage related instructions."]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.storage.sload", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/storage.py"}, "content": {"type": ["function"], "name": ["sload"], "text": ["Loads to the stack, the value corresponding to a certain key from the storage of the current account. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.storage.sstore", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/storage.py"}, "content": {"type": ["function"], "name": ["sstore"], "text": ["Stores a value at a certain key in the current context's storage. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.gray_glacier.utils", "specifier": 0, "path": "src/ethereum/gray_glacier/utils/__init__.py"}, "content": {"type": ["module"], "name": ["ethereum.gray_glacier.utils"], "text": ["Hardfork Utility Functions ^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Utility functions used in this gray_glacier version of specification."]}}, {"source": {"identifier": "ethereum.frontier.vm", "specifier": 0, "path": "src/ethereum/frontier/vm/__init__.py"}, "content": {"type": ["module"], "name": ["ethereum.frontier.vm"], "text": ["Ethereum Virtual Machine (EVM) ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction The abstract computer which runs the code stored in an .fork_types.Account ."]}}, {"source": {"identifier": "ethereum.frontier.vm.__all__", "specifier": 0, "path": "src/ethereum/frontier/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["__all__"]}}, {"source": {"identifier": "ethereum.frontier.vm.Environment", "specifier": 0, "path": "src/ethereum/frontier/vm/__init__.py"}, "content": {"type": ["class"], "name": ["Environment"], "text": ["Items external to the virtual machine itself, provided by the environment."]}}, {"source": {"identifier": "ethereum.frontier.vm.Environment.caller", "specifier": 0, "path": "src/ethereum/frontier/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["caller"]}}, {"source": {"identifier": "ethereum.frontier.vm.Environment.block_hashes", "specifier": 0, "path": "src/ethereum/frontier/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["block_hashes"]}}, {"source": {"identifier": "ethereum.frontier.vm.Environment.origin", "specifier": 0, "path": "src/ethereum/frontier/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["origin"]}}, {"source": {"identifier": "ethereum.frontier.vm.Environment.coinbase", "specifier": 0, "path": "src/ethereum/frontier/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["coinbase"]}}, {"source": {"identifier": "ethereum.frontier.vm.Environment.number", "specifier": 0, "path": "src/ethereum/frontier/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["number"]}}, {"source": {"identifier": "ethereum.frontier.vm.Environment.gas_limit", "specifier": 0, "path": "src/ethereum/frontier/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["gas_limit"]}}, {"source": {"identifier": "ethereum.frontier.vm.Environment.gas_price", "specifier": 0, "path": "src/ethereum/frontier/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["gas_price"]}}, {"source": {"identifier": "ethereum.frontier.vm.Environment.time", "specifier": 0, "path": "src/ethereum/frontier/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["time"]}}, {"source": {"identifier": "ethereum.frontier.vm.Environment.difficulty", "specifier": 0, "path": "src/ethereum/frontier/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["difficulty"]}}, {"source": {"identifier": "ethereum.frontier.vm.Environment.state", "specifier": 0, "path": "src/ethereum/frontier/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["state"]}}, {"source": {"identifier": "ethereum.frontier.vm.Message", "specifier": 0, "path": "src/ethereum/frontier/vm/__init__.py"}, "content": {"type": ["class"], "name": ["Message"], "text": ["Items that are used by contract creation or message call."]}}, {"source": {"identifier": "ethereum.frontier.vm.Message.caller", "specifier": 0, "path": "src/ethereum/frontier/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["caller"]}}, {"source": {"identifier": "ethereum.frontier.vm.Message.target", "specifier": 0, "path": "src/ethereum/frontier/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["target"]}}, {"source": {"identifier": "ethereum.frontier.vm.Message.current_target", "specifier": 0, "path": "src/ethereum/frontier/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["current_target"]}}, {"source": {"identifier": "ethereum.frontier.vm.Message.gas", "specifier": 0, "path": "src/ethereum/frontier/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["gas"]}}, {"source": {"identifier": "ethereum.frontier.vm.Message.value", "specifier": 0, "path": "src/ethereum/frontier/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["value"]}}, {"source": {"identifier": "ethereum.frontier.vm.Message.data", "specifier": 0, "path": "src/ethereum/frontier/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["data"]}}, {"source": {"identifier": "ethereum.frontier.vm.Message.code_address", "specifier": 0, "path": "src/ethereum/frontier/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["code_address"]}}, {"source": {"identifier": "ethereum.frontier.vm.Message.code", "specifier": 0, "path": "src/ethereum/frontier/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["code"]}}, {"source": {"identifier": "ethereum.frontier.vm.Message.depth", "specifier": 0, "path": "src/ethereum/frontier/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["depth"]}}, {"source": {"identifier": "ethereum.frontier.vm.Evm", "specifier": 0, "path": "src/ethereum/frontier/vm/__init__.py"}, "content": {"type": ["class"], "name": ["Evm"], "text": ["The internal state of the virtual machine."]}}, {"source": {"identifier": "ethereum.frontier.vm.Evm.pc", "specifier": 0, "path": "src/ethereum/frontier/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["pc"]}}, {"source": {"identifier": "ethereum.frontier.vm.Evm.stack", "specifier": 0, "path": "src/ethereum/frontier/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["stack"]}}, {"source": {"identifier": "ethereum.frontier.vm.Evm.memory", "specifier": 0, "path": "src/ethereum/frontier/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["memory"]}}, {"source": {"identifier": "ethereum.frontier.vm.Evm.code", "specifier": 0, "path": "src/ethereum/frontier/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["code"]}}, {"source": {"identifier": "ethereum.frontier.vm.Evm.gas_left", "specifier": 0, "path": "src/ethereum/frontier/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["gas_left"]}}, {"source": {"identifier": "ethereum.frontier.vm.Evm.env", "specifier": 0, "path": "src/ethereum/frontier/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["env"]}}, {"source": {"identifier": "ethereum.frontier.vm.Evm.valid_jump_destinations", "specifier": 0, "path": "src/ethereum/frontier/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["valid_jump_destinations"]}}, {"source": {"identifier": "ethereum.frontier.vm.Evm.logs", "specifier": 0, "path": "src/ethereum/frontier/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["logs"]}}, {"source": {"identifier": "ethereum.frontier.vm.Evm.refund_counter", "specifier": 0, "path": "src/ethereum/frontier/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["refund_counter"]}}, {"source": {"identifier": "ethereum.frontier.vm.Evm.running", "specifier": 0, "path": "src/ethereum/frontier/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["running"]}}, {"source": {"identifier": "ethereum.frontier.vm.Evm.message", "specifier": 0, "path": "src/ethereum/frontier/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["message"]}}, {"source": {"identifier": "ethereum.frontier.vm.Evm.output", "specifier": 0, "path": "src/ethereum/frontier/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["output"]}}, {"source": {"identifier": "ethereum.frontier.vm.Evm.accounts_to_delete", "specifier": 0, "path": "src/ethereum/frontier/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["accounts_to_delete"]}}, {"source": {"identifier": "ethereum.frontier.vm.Evm.has_erred", "specifier": 0, "path": "src/ethereum/frontier/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["has_erred"]}}, {"source": {"identifier": "ethereum.frontier.vm.incorporate_child_on_success", "specifier": 0, "path": "src/ethereum/frontier/vm/__init__.py"}, "content": {"type": ["function"], "name": ["incorporate_child_on_success"], "text": ["Incorporate the state of a successful  child_evm  into the parent  evm . Parameters evm : The parent  EVM . child_evm : The child evm to incorporate."]}}, {"source": {"identifier": "ethereum.frontier.vm.incorporate_child_on_error", "specifier": 0, "path": "src/ethereum/frontier/vm/__init__.py"}, "content": {"type": ["function"], "name": ["incorporate_child_on_error"], "text": ["Incorporate the state of an unsuccessful  child_evm  into the parent  evm . Parameters evm : The parent  EVM . child_evm : The child evm to incorporate."]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.block", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/block.py"}, "content": {"type": ["module"], "name": ["ethereum.spurious_dragon.vm.instructions.block"], "text": ["Ethereum Virtual Machine (EVM) Block Instructions ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementations of the EVM block instructions."]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.block.block_hash", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/block.py"}, "content": {"type": ["function"], "name": ["block_hash"], "text": ["Push the hash of one of the 256 most recent complete blocks onto the stack. The block number to hash is present at the top of the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.block.coinbase", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/block.py"}, "content": {"type": ["function"], "name": ["coinbase"], "text": ["Push the current block's beneficiary address (address of the block miner) onto the stack. Here the current block refers to the block in which the currently executing transaction/call resides. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.block.timestamp", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/block.py"}, "content": {"type": ["function"], "name": ["timestamp"], "text": ["Push the current block's timestamp onto the stack. Here the timestamp being referred is actually the unix timestamp in seconds. Here the current block refers to the block in which the currently executing transaction/call resides. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.block.number", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/block.py"}, "content": {"type": ["function"], "name": ["number"], "text": ["Push the current block's number onto the stack. Here the current block refers to the block in which the currently executing transaction/call resides. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.block.difficulty", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/block.py"}, "content": {"type": ["function"], "name": ["difficulty"], "text": ["Push the current block's difficulty onto the stack. Here the current block refers to the block in which the currently executing transaction/call resides. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.block.gas_limit", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/block.py"}, "content": {"type": ["function"], "name": ["gas_limit"], "text": ["Push the current block's gas limit onto the stack. Here the current block refers to the block in which the currently executing transaction/call resides. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.gray_glacier.utils.address", "specifier": 0, "path": "src/ethereum/gray_glacier/utils/address.py"}, "content": {"type": ["module"], "name": ["ethereum.gray_glacier.utils.address"], "text": ["Hardfork Utility Functions For Addresses ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Address specific functions used in this gray_glacier version of specification."]}}, {"source": {"identifier": "ethereum.gray_glacier.utils.address.to_address", "specifier": 0, "path": "src/ethereum/gray_glacier/utils/address.py"}, "content": {"type": ["function"], "name": ["to_address"], "text": ["Convert a Uint or U256 value to a valid address (20 bytes). Parameters data : The string to be converted to bytes. Returns address :  Address The obtained address."]}}, {"source": {"identifier": "ethereum.gray_glacier.utils.address.compute_contract_address", "specifier": 0, "path": "src/ethereum/gray_glacier/utils/address.py"}, "content": {"type": ["function"], "name": ["compute_contract_address"], "text": ["Computes address of the new account that needs to be created. Parameters address : The address of the account that wants to create the new account. nonce : The transaction count of the account that wants to create the new account. Returns address:  Address The computed address of the new account."]}}, {"source": {"identifier": "ethereum.gray_glacier.utils.address.compute_create2_contract_address", "specifier": 0, "path": "src/ethereum/gray_glacier/utils/address.py"}, "content": {"type": ["function"], "name": ["compute_create2_contract_address"], "text": ["Computes address of the new account that needs to be created, which is based on the sender address, salt and the call data as well. Parameters address : The address of the account that wants to create the new account. salt : Address generation salt. call_data : The code of the new account which is to be created. Returns address:  ethereum.gray_glacier.fork_types.Address The computed address of the new account."]}}, {"source": {"identifier": "ethereum.frontier.vm.runtime", "specifier": 0, "path": "src/ethereum/frontier/vm/runtime.py"}, "content": {"type": ["module"], "name": ["ethereum.frontier.vm.runtime"], "text": ["Ethereum Virtual Machine (EVM) Runtime Operations ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Runtime related operations used while executing EVM code."]}}, {"source": {"identifier": "ethereum.frontier.vm.runtime.get_valid_jump_destinations", "specifier": 0, "path": "src/ethereum/frontier/vm/runtime.py"}, "content": {"type": ["function"], "name": ["get_valid_jump_destinations"], "text": ["Analyze the evm code to obtain the set of valid jump destinations. Valid jump destinations are defined as follows: * The jump destination is less than the length of the code. * The jump destination should have the  JUMPDEST  opcode (0x5B). * The jump destination shouldn't be part of the data corresponding to PUSH-N  opcodes. Note - Jump destinations are 0-indexed. Parameters code : The EVM code which is to be executed. Returns valid_jump_destinations:  Set[Uint] The set of valid jump destinations in the code."]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.arithmetic", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/arithmetic.py"}, "content": {"type": ["module"], "name": ["ethereum.spurious_dragon.vm.instructions.arithmetic"], "text": ["Ethereum Virtual Machine (EVM) Arithmetic Instructions ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementations of the EVM Arithmetic instructions."]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.arithmetic.add", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/arithmetic.py"}, "content": {"type": ["function"], "name": ["add"], "text": ["Adds the top two elements of the stack together, and pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.arithmetic.sub", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/arithmetic.py"}, "content": {"type": ["function"], "name": ["sub"], "text": ["Subtracts the top two elements of the stack, and pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.arithmetic.mul", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/arithmetic.py"}, "content": {"type": ["function"], "name": ["mul"], "text": ["Multiply the top two elements of the stack, and pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.arithmetic.div", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/arithmetic.py"}, "content": {"type": ["function"], "name": ["div"], "text": ["Integer division of the top two elements of the stack. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.arithmetic.sdiv", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/arithmetic.py"}, "content": {"type": ["function"], "name": ["sdiv"], "text": ["Signed integer division of the top two elements of the stack. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.arithmetic.mod", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/arithmetic.py"}, "content": {"type": ["function"], "name": ["mod"], "text": ["Modulo remainder of the top two elements of the stack. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.arithmetic.smod", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/arithmetic.py"}, "content": {"type": ["function"], "name": ["smod"], "text": ["Signed modulo remainder of the top two elements of the stack. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.arithmetic.addmod", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/arithmetic.py"}, "content": {"type": ["function"], "name": ["addmod"], "text": ["Modulo addition of the top 2 elements with the 3rd element. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.arithmetic.mulmod", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/arithmetic.py"}, "content": {"type": ["function"], "name": ["mulmod"], "text": ["Modulo multiplication of the top 2 elements with the 3rd element. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.arithmetic.exp", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/arithmetic.py"}, "content": {"type": ["function"], "name": ["exp"], "text": ["Exponential operation of the top 2 elements. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.arithmetic.signextend", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/arithmetic.py"}, "content": {"type": ["function"], "name": ["signextend"], "text": ["Sign extend operation. In other words, extend a signed number which fits in N bytes to 32 bytes. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.gray_glacier.utils.message", "specifier": 0, "path": "src/ethereum/gray_glacier/utils/message.py"}, "content": {"type": ["module"], "name": ["ethereum.gray_glacier.utils.message"], "text": ["Hardfork Utility Functions For The Message Data-structure ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Message specific functions used in this gray_glacier version of specification."]}}, {"source": {"identifier": "ethereum.gray_glacier.utils.message.prepare_message", "specifier": 0, "path": "src/ethereum/gray_glacier/utils/message.py"}, "content": {"type": ["function"], "name": ["prepare_message"], "text": ["Execute a transaction against the provided environment. Parameters caller : Address which initiated the transaction target : Address whose code will be executed value : Value to be transferred. data : Array of bytes provided to the code in  target . gas : Gas provided for the code in  target . env : Environment for the Ethereum Virtual Machine. code_address : This is usually same as the  target  address except when an alternative accounts code needs to be executed. eg.  CALLCODE  calling a precompile. should_transfer_value : if True ETH should be transferred while executing a message call. is_static: if True then it prevents all state-changing operations from being executed. preaccessed_addresses: Addresses that should be marked as accessed prior to the message call preaccessed_storage_keys: Storage keys that should be marked as accessed prior to the message call Returns message:  ethereum.gray_glacier.vm.Message Items containing contract creation or message call specific data."]}}, {"source": {"identifier": "ethereum.frontier.vm.interpreter", "specifier": 0, "path": "src/ethereum/frontier/vm/interpreter.py"}, "content": {"type": ["module"], "name": ["ethereum.frontier.vm.interpreter"], "text": ["Ethereum Virtual Machine (EVM) Interpreter ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction A straightforward interpreter that executes EVM code."]}}, {"source": {"identifier": "ethereum.frontier.vm.interpreter.STACK_DEPTH_LIMIT", "specifier": 0, "path": "src/ethereum/frontier/vm/interpreter.py"}, "content": {"type": ["attribute"], "name": ["STACK_DEPTH_LIMIT"]}}, {"source": {"identifier": "ethereum.frontier.vm.interpreter.MessageCallOutput", "specifier": 0, "path": "src/ethereum/frontier/vm/interpreter.py"}, "content": {"type": ["class"], "name": ["MessageCallOutput"], "text": ["Output of a particular message call Contains the following:   1. `gas_left`: remaining gas after execution.\n  2. `refund_counter`: gas to refund after execution.\n  3. `logs`: list of `Log` generated during execution.\n  4. `accounts_to_delete`: Contracts which have self-destructed.\n  5. `has_erred`: True if execution has caused an error.\n"]}}, {"source": {"identifier": "ethereum.frontier.vm.interpreter.MessageCallOutput.gas_left", "specifier": 0, "path": "src/ethereum/frontier/vm/interpreter.py"}, "content": {"type": ["attribute"], "name": ["gas_left"]}}, {"source": {"identifier": "ethereum.frontier.vm.interpreter.MessageCallOutput.refund_counter", "specifier": 0, "path": "src/ethereum/frontier/vm/interpreter.py"}, "content": {"type": ["attribute"], "name": ["refund_counter"]}}, {"source": {"identifier": "ethereum.frontier.vm.interpreter.MessageCallOutput.logs", "specifier": 0, "path": "src/ethereum/frontier/vm/interpreter.py"}, "content": {"type": ["attribute"], "name": ["logs"]}}, {"source": {"identifier": "ethereum.frontier.vm.interpreter.MessageCallOutput.accounts_to_delete", "specifier": 0, "path": "src/ethereum/frontier/vm/interpreter.py"}, "content": {"type": ["attribute"], "name": ["accounts_to_delete"]}}, {"source": {"identifier": "ethereum.frontier.vm.interpreter.MessageCallOutput.has_erred", "specifier": 0, "path": "src/ethereum/frontier/vm/interpreter.py"}, "content": {"type": ["attribute"], "name": ["has_erred"]}}, {"source": {"identifier": "ethereum.frontier.vm.interpreter.process_message_call", "specifier": 0, "path": "src/ethereum/frontier/vm/interpreter.py"}, "content": {"type": ["function"], "name": ["process_message_call"], "text": ["If  message.current  is empty then it creates a smart contract else it executes a call from the  message.caller  to the  message.target . Parameters message : Transaction specific items. env : External items required for EVM execution. Returns output :  MessageCallOutput Output of the message call"]}}, {"source": {"identifier": "ethereum.frontier.vm.interpreter.process_create_message", "specifier": 0, "path": "src/ethereum/frontier/vm/interpreter.py"}, "content": {"type": ["function"], "name": ["process_create_message"], "text": ["Executes a call to create a smart contract. Parameters message : Transaction specific items. env : External items required for EVM execution. Returns evm: :py:class: ~ethereum.frontier.vm.Evm Items containing execution specific objects."]}}, {"source": {"identifier": "ethereum.frontier.vm.interpreter.process_message", "specifier": 0, "path": "src/ethereum/frontier/vm/interpreter.py"}, "content": {"type": ["function"], "name": ["process_message"], "text": ["Executes a call to create a smart contract. Parameters message : Transaction specific items. env : External items required for EVM execution. Returns evm: :py:class: ~ethereum.frontier.vm.Evm Items containing execution specific objects"]}}, {"source": {"identifier": "ethereum.frontier.vm.interpreter.execute_code", "specifier": 0, "path": "src/ethereum/frontier/vm/interpreter.py"}, "content": {"type": ["function"], "name": ["execute_code"], "text": ["Executes bytecode present in the  message . Parameters message : Transaction specific items. env : External items required for EVM execution. Returns evm:  ethereum.vm.EVM Items containing execution specific objects"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.keccak", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/keccak.py"}, "content": {"type": ["module"], "name": ["ethereum.spurious_dragon.vm.instructions.keccak"], "text": ["Ethereum Virtual Machine (EVM) Keccak Instructions ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementations of the EVM keccak instructions."]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.keccak.keccak", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/keccak.py"}, "content": {"type": ["function"], "name": ["keccak"], "text": ["Pushes to the stack the Keccak-256 hash of a region of memory. This also expands the memory, in case the memory is insufficient to access the data's memory location. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.gray_glacier.utils.hexadecimal", "specifier": 0, "path": "src/ethereum/gray_glacier/utils/hexadecimal.py"}, "content": {"type": ["module"], "name": ["ethereum.gray_glacier.utils.hexadecimal"], "text": ["Utility Functions For Hexadecimal Strings ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Hexadecimal utility functions used in this specification, specific to Gray Glacier types."]}}, {"source": {"identifier": "ethereum.gray_glacier.utils.hexadecimal.hex_to_root", "specifier": 0, "path": "src/ethereum/gray_glacier/utils/hexadecimal.py"}, "content": {"type": ["function"], "name": ["hex_to_root"], "text": ["Convert hex string to trie root. Parameters hex_string : The hexadecimal string to be converted to trie root. Returns root :  Root Trie root obtained from the given hexadecimal string."]}}, {"source": {"identifier": "ethereum.gray_glacier.utils.hexadecimal.hex_to_bloom", "specifier": 0, "path": "src/ethereum/gray_glacier/utils/hexadecimal.py"}, "content": {"type": ["function"], "name": ["hex_to_bloom"], "text": ["Convert hex string to bloom. Parameters hex_string : The hexadecimal string to be converted to bloom. Returns bloom :  Bloom Bloom obtained from the given hexadecimal string."]}}, {"source": {"identifier": "ethereum.gray_glacier.utils.hexadecimal.hex_to_address", "specifier": 0, "path": "src/ethereum/gray_glacier/utils/hexadecimal.py"}, "content": {"type": ["function"], "name": ["hex_to_address"], "text": ["Convert hex string to Address (20 bytes). Parameters hex_string : The hexadecimal string to be converted to Address. Returns address :  Address The address obtained from the given hexadecimal string."]}}, {"source": {"identifier": "ethereum.frontier.vm.stack", "specifier": 0, "path": "src/ethereum/frontier/vm/stack.py"}, "content": {"type": ["module"], "name": ["ethereum.frontier.vm.stack"], "text": ["Ethereum Virtual Machine (EVM) Stack ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementation of the stack operators for the EVM."]}}, {"source": {"identifier": "ethereum.frontier.vm.stack.pop", "specifier": 0, "path": "src/ethereum/frontier/vm/stack.py"}, "content": {"type": ["function"], "name": ["pop"], "text": ["Pops the top item off of  stack . Parameters stack : EVM stack. Returns value :  U256 The top element on the stack."]}}, {"source": {"identifier": "ethereum.frontier.vm.stack.push", "specifier": 0, "path": "src/ethereum/frontier/vm/stack.py"}, "content": {"type": ["function"], "name": ["push"], "text": ["Pushes  value  onto  stack . Parameters stack : EVM stack. value : Item to be pushed onto  stack ."]}}, {"source": {"identifier": "ethereum.arrow_glacier.state", "specifier": 0, "path": "src/ethereum/arrow_glacier/state.py"}, "content": {"type": ["module"], "name": ["ethereum.arrow_glacier.state"], "text": ["State ^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction The state contains all information that is preserved between transactions. It consists of a main account trie and storage tries for each contract. There is a distinction between an account that does not exist and EMPTY_ACCOUNT ."]}}, {"source": {"identifier": "ethereum.arrow_glacier.state.State", "specifier": 0, "path": "src/ethereum/arrow_glacier/state.py"}, "content": {"type": ["class"], "name": ["State"], "text": ["Contains all information that is preserved between transactions."]}}, {"source": {"identifier": "ethereum.arrow_glacier.state.State._main_trie", "specifier": 0, "path": "src/ethereum/arrow_glacier/state.py"}, "content": {"type": ["attribute"], "name": ["_main_trie"]}}, {"source": {"identifier": "ethereum.arrow_glacier.state.State._storage_tries", "specifier": 0, "path": "src/ethereum/arrow_glacier/state.py"}, "content": {"type": ["attribute"], "name": ["_storage_tries"]}}, {"source": {"identifier": "ethereum.arrow_glacier.state.State._snapshots", "specifier": 0, "path": "src/ethereum/arrow_glacier/state.py"}, "content": {"type": ["attribute"], "name": ["_snapshots"]}}, {"source": {"identifier": "ethereum.arrow_glacier.state.close_state", "specifier": 0, "path": "src/ethereum/arrow_glacier/state.py"}, "content": {"type": ["function"], "name": ["close_state"], "text": ["Free resources held by the state. Used by optimized implementations to release file descriptors."]}}, {"source": {"identifier": "ethereum.arrow_glacier.state.begin_transaction", "specifier": 0, "path": "src/ethereum/arrow_glacier/state.py"}, "content": {"type": ["function"], "name": ["begin_transaction"], "text": ["Start a state transaction. Transactions are entirely implicit and can be nested. It is not possible to calculate the state root during a transaction. Parameters state : State The state."]}}, {"source": {"identifier": "ethereum.arrow_glacier.state.commit_transaction", "specifier": 0, "path": "src/ethereum/arrow_glacier/state.py"}, "content": {"type": ["function"], "name": ["commit_transaction"], "text": ["Commit a state transaction. Parameters state : State The state."]}}, {"source": {"identifier": "ethereum.arrow_glacier.state.rollback_transaction", "specifier": 0, "path": "src/ethereum/arrow_glacier/state.py"}, "content": {"type": ["function"], "name": ["rollback_transaction"], "text": ["Rollback a state transaction, resetting the state to the point when the corresponding  start_transaction()  call was made. Parameters state : State The state."]}}, {"source": {"identifier": "ethereum.arrow_glacier.state.get_account", "specifier": 0, "path": "src/ethereum/arrow_glacier/state.py"}, "content": {"type": ["function"], "name": ["get_account"], "text": ["Get the  Account  object at an address. Returns  EMPTY_ACCOUNT  if there is no account at the address. Use  get_account_optional()  if you care about the difference between a non-existent account and  EMPTY_ACCOUNT . Parameters state:  State The state address :  Address Address to lookup. Returns account :  Account Account at address."]}}, {"source": {"identifier": "ethereum.arrow_glacier.state.get_account_optional", "specifier": 0, "path": "src/ethereum/arrow_glacier/state.py"}, "content": {"type": ["function"], "name": ["get_account_optional"], "text": ["Get the  Account  object at an address. Returns  None  (rather than EMPTY_ACCOUNT ) if there is no account at the address. Parameters state:  State The state address :  Address Address to lookup. Returns account :  Account Account at address."]}}, {"source": {"identifier": "ethereum.arrow_glacier.state.set_account", "specifier": 0, "path": "src/ethereum/arrow_glacier/state.py"}, "content": {"type": ["function"], "name": ["set_account"], "text": ["Set the  Account  object at an address. Setting to  None  deletes the account (but not its storage, see  destroy_account() ). Parameters state:  State The state address :  Address Address to set. account :  Account Account to set at address."]}}, {"source": {"identifier": "ethereum.arrow_glacier.state.destroy_account", "specifier": 0, "path": "src/ethereum/arrow_glacier/state.py"}, "content": {"type": ["function"], "name": ["destroy_account"], "text": ["Completely remove the account at  address  and all of its storage. This function is made available exclusively for the  SELFDESTRUCT opcode. It is expected that  SELFDESTRUCT  will be disabled in a future hardfork and this function will be removed. Parameters state:  State The state address :  Address Address of account to destroy."]}}, {"source": {"identifier": "ethereum.arrow_glacier.state.destroy_storage", "specifier": 0, "path": "src/ethereum/arrow_glacier/state.py"}, "content": {"type": ["function"], "name": ["destroy_storage"], "text": ["Completely remove the storage at  address . Parameters state:  State The state address :  Address Address of account whose storage is to be deleted."]}}, {"source": {"identifier": "ethereum.arrow_glacier.state.get_storage", "specifier": 0, "path": "src/ethereum/arrow_glacier/state.py"}, "content": {"type": ["function"], "name": ["get_storage"], "text": ["Get a value at a storage key on an account. Returns  U256(0)  if the storage key has not been set previously. Parameters state:  State The state address :  Address Address of the account. key :  Bytes Key to lookup. Returns value :  U256 Value at the key."]}}, {"source": {"identifier": "ethereum.arrow_glacier.state.set_storage", "specifier": 0, "path": "src/ethereum/arrow_glacier/state.py"}, "content": {"type": ["function"], "name": ["set_storage"], "text": ["Set a value at a storage key on an account. Setting to  U256(0)  deletes the key. Parameters state:  State The state address :  Address Address of the account. key :  Bytes Key to set. value :  U256 Value to set at the key."]}}, {"source": {"identifier": "ethereum.arrow_glacier.state.storage_root", "specifier": 0, "path": "src/ethereum/arrow_glacier/state.py"}, "content": {"type": ["function"], "name": ["storage_root"], "text": ["Calculate the storage root of an account. Parameters state: The state address : Address of the account. Returns root :  Root Storage root of the account."]}}, {"source": {"identifier": "ethereum.arrow_glacier.state.state_root", "specifier": 0, "path": "src/ethereum/arrow_glacier/state.py"}, "content": {"type": ["function"], "name": ["state_root"], "text": ["Calculate the state root. Parameters state: The current state. Returns root :  Root The state root."]}}, {"source": {"identifier": "ethereum.arrow_glacier.state.account_exists", "specifier": 0, "path": "src/ethereum/arrow_glacier/state.py"}, "content": {"type": ["function"], "name": ["account_exists"], "text": ["Checks if an account exists in the state trie Parameters state: The state address: Address of the account that needs to be checked. Returns account_exists :  bool True if account exists in the state trie, False otherwise"]}}, {"source": {"identifier": "ethereum.arrow_glacier.state.account_has_code_or_nonce", "specifier": 0, "path": "src/ethereum/arrow_glacier/state.py"}, "content": {"type": ["function"], "name": ["account_has_code_or_nonce"], "text": ["Checks if an account has non zero nonce or non empty code Parameters state: The state address: Address of the account that needs to be checked. Returns has_code_or_nonce :  bool True if if an account has non zero nonce or non empty code, False otherwise."]}}, {"source": {"identifier": "ethereum.arrow_glacier.state.is_account_empty", "specifier": 0, "path": "src/ethereum/arrow_glacier/state.py"}, "content": {"type": ["function"], "name": ["is_account_empty"], "text": ["Checks if an account has zero nonce, empty code and zero balance. Parameters state: The state address: Address of the account that needs to be checked. Returns is_empty :  bool True if if an account has zero nonce, empty code and zero balance, False otherwise."]}}, {"source": {"identifier": "ethereum.arrow_glacier.state.account_exists_and_is_empty", "specifier": 0, "path": "src/ethereum/arrow_glacier/state.py"}, "content": {"type": ["function"], "name": ["account_exists_and_is_empty"], "text": ["Checks if an account exists and has zero nonce, empty code and zero balance. Parameters state: The state address: Address of the account that needs to be checked. Returns exists_and_is_empty :  bool True if an account exists and has zero nonce, empty code and zero balance, False otherwise."]}}, {"source": {"identifier": "ethereum.arrow_glacier.state.is_account_alive", "specifier": 0, "path": "src/ethereum/arrow_glacier/state.py"}, "content": {"type": ["function"], "name": ["is_account_alive"], "text": ["Check whether is an account is both in the state and non empty. Parameters state: The state address: Address of the account that needs to be checked. Returns is_alive :  bool True if the account is alive."]}}, {"source": {"identifier": "ethereum.arrow_glacier.state.modify_state", "specifier": 0, "path": "src/ethereum/arrow_glacier/state.py"}, "content": {"type": ["function"], "name": ["modify_state"], "text": ["Modify an  Account  in the  State ."]}}, {"source": {"identifier": "ethereum.arrow_glacier.state.move_ether", "specifier": 0, "path": "src/ethereum/arrow_glacier/state.py"}, "content": {"type": ["function"], "name": ["move_ether"], "text": ["Move funds between accounts."]}}, {"source": {"identifier": "ethereum.arrow_glacier.state.set_account_balance", "specifier": 0, "path": "src/ethereum/arrow_glacier/state.py"}, "content": {"type": ["function"], "name": ["set_account_balance"], "text": ["Sets the balance of an account. Parameters state: The current state. address: Address of the account whose nonce needs to be incremented. amount: The amount that needs to set in balance."]}}, {"source": {"identifier": "ethereum.arrow_glacier.state.touch_account", "specifier": 0, "path": "src/ethereum/arrow_glacier/state.py"}, "content": {"type": ["function"], "name": ["touch_account"], "text": ["Initializes an account to state. Parameters state: The current state. address: The address of the account that need to initialised."]}}, {"source": {"identifier": "ethereum.arrow_glacier.state.increment_nonce", "specifier": 0, "path": "src/ethereum/arrow_glacier/state.py"}, "content": {"type": ["function"], "name": ["increment_nonce"], "text": ["Increments the nonce of an account. Parameters state: The current state. address: Address of the account whose nonce needs to be incremented."]}}, {"source": {"identifier": "ethereum.arrow_glacier.state.set_code", "specifier": 0, "path": "src/ethereum/arrow_glacier/state.py"}, "content": {"type": ["function"], "name": ["set_code"], "text": ["Sets Account code. Parameters state: The current state. address: Address of the account whose code needs to be update. code: The bytecode that needs to be set."]}}, {"source": {"identifier": "ethereum.arrow_glacier.state.create_ether", "specifier": 0, "path": "src/ethereum/arrow_glacier/state.py"}, "content": {"type": ["function"], "name": ["create_ether"], "text": ["Add newly created ether to an account. Parameters state: The current state. address: Address of the account to which ether is added. amount: The amount of ether to be added to the account of interest."]}}, {"source": {"identifier": "ethereum.arrow_glacier.state.get_storage_original", "specifier": 0, "path": "src/ethereum/arrow_glacier/state.py"}, "content": {"type": ["function"], "name": ["get_storage_original"], "text": ["Get the original value in a storage slot i.e. the value before the current transaction began. This function reads the value from the snapshots taken before executing the transaction. Parameters state: The current state. address: Address of the account to read the value from. key: Key of the storage slot."]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.bitwise", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/bitwise.py"}, "content": {"type": ["module"], "name": ["ethereum.spurious_dragon.vm.instructions.bitwise"], "text": ["Ethereum Virtual Machine (EVM) Bitwise Instructions ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementations of the EVM bitwise instructions."]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.bitwise.bitwise_and", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/bitwise.py"}, "content": {"type": ["function"], "name": ["bitwise_and"], "text": ["Bitwise AND operation of the top 2 elements of the stack. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.bitwise.bitwise_or", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/bitwise.py"}, "content": {"type": ["function"], "name": ["bitwise_or"], "text": ["Bitwise OR operation of the top 2 elements of the stack. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.bitwise.bitwise_xor", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/bitwise.py"}, "content": {"type": ["function"], "name": ["bitwise_xor"], "text": ["Bitwise XOR operation of the top 2 elements of the stack. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.bitwise.bitwise_not", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/bitwise.py"}, "content": {"type": ["function"], "name": ["bitwise_not"], "text": ["Bitwise NOT operation of the top element of the stack. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.bitwise.get_byte", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/bitwise.py"}, "content": {"type": ["function"], "name": ["get_byte"], "text": ["For a word (defined by next top element of the stack), retrieve the Nth byte (0-indexed and defined by top element of stack) from the left (most significant) to right (least significant). Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.frontier.vm.gas", "specifier": 0, "path": "src/ethereum/frontier/vm/gas.py"}, "content": {"type": ["module"], "name": ["ethereum.frontier.vm.gas"], "text": ["Ethereum Virtual Machine (EVM) Gas ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction EVM gas constants and calculators."]}}, {"source": {"identifier": "ethereum.frontier.vm.gas.GAS_JUMPDEST", "specifier": 0, "path": "src/ethereum/frontier/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_JUMPDEST"]}}, {"source": {"identifier": "ethereum.frontier.vm.gas.GAS_BASE", "specifier": 0, "path": "src/ethereum/frontier/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_BASE"]}}, {"source": {"identifier": "ethereum.frontier.vm.gas.GAS_VERY_LOW", "specifier": 0, "path": "src/ethereum/frontier/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_VERY_LOW"]}}, {"source": {"identifier": "ethereum.frontier.vm.gas.GAS_SLOAD", "specifier": 0, "path": "src/ethereum/frontier/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_SLOAD"]}}, {"source": {"identifier": "ethereum.frontier.vm.gas.GAS_STORAGE_SET", "specifier": 0, "path": "src/ethereum/frontier/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_STORAGE_SET"]}}, {"source": {"identifier": "ethereum.frontier.vm.gas.GAS_STORAGE_UPDATE", "specifier": 0, "path": "src/ethereum/frontier/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_STORAGE_UPDATE"]}}, {"source": {"identifier": "ethereum.frontier.vm.gas.GAS_STORAGE_CLEAR_REFUND", "specifier": 0, "path": "src/ethereum/frontier/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_STORAGE_CLEAR_REFUND"]}}, {"source": {"identifier": "ethereum.frontier.vm.gas.GAS_LOW", "specifier": 0, "path": "src/ethereum/frontier/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_LOW"]}}, {"source": {"identifier": "ethereum.frontier.vm.gas.GAS_MID", "specifier": 0, "path": "src/ethereum/frontier/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_MID"]}}, {"source": {"identifier": "ethereum.frontier.vm.gas.GAS_HIGH", "specifier": 0, "path": "src/ethereum/frontier/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_HIGH"]}}, {"source": {"identifier": "ethereum.frontier.vm.gas.GAS_EXPONENTIATION", "specifier": 0, "path": "src/ethereum/frontier/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_EXPONENTIATION"]}}, {"source": {"identifier": "ethereum.frontier.vm.gas.GAS_EXPONENTIATION_PER_BYTE", "specifier": 0, "path": "src/ethereum/frontier/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_EXPONENTIATION_PER_BYTE"]}}, {"source": {"identifier": "ethereum.frontier.vm.gas.GAS_MEMORY", "specifier": 0, "path": "src/ethereum/frontier/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_MEMORY"]}}, {"source": {"identifier": "ethereum.frontier.vm.gas.GAS_KECCAK256", "specifier": 0, "path": "src/ethereum/frontier/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_KECCAK256"]}}, {"source": {"identifier": "ethereum.frontier.vm.gas.GAS_KECCAK256_WORD", "specifier": 0, "path": "src/ethereum/frontier/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_KECCAK256_WORD"]}}, {"source": {"identifier": "ethereum.frontier.vm.gas.GAS_COPY", "specifier": 0, "path": "src/ethereum/frontier/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_COPY"]}}, {"source": {"identifier": "ethereum.frontier.vm.gas.GAS_BLOCK_HASH", "specifier": 0, "path": "src/ethereum/frontier/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_BLOCK_HASH"]}}, {"source": {"identifier": "ethereum.frontier.vm.gas.GAS_EXTERNAL", "specifier": 0, "path": "src/ethereum/frontier/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_EXTERNAL"]}}, {"source": {"identifier": "ethereum.frontier.vm.gas.GAS_BALANCE", "specifier": 0, "path": "src/ethereum/frontier/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_BALANCE"]}}, {"source": {"identifier": "ethereum.frontier.vm.gas.GAS_LOG", "specifier": 0, "path": "src/ethereum/frontier/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_LOG"]}}, {"source": {"identifier": "ethereum.frontier.vm.gas.GAS_LOG_DATA", "specifier": 0, "path": "src/ethereum/frontier/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_LOG_DATA"]}}, {"source": {"identifier": "ethereum.frontier.vm.gas.GAS_LOG_TOPIC", "specifier": 0, "path": "src/ethereum/frontier/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_LOG_TOPIC"]}}, {"source": {"identifier": "ethereum.frontier.vm.gas.GAS_CREATE", "specifier": 0, "path": "src/ethereum/frontier/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_CREATE"]}}, {"source": {"identifier": "ethereum.frontier.vm.gas.GAS_CODE_DEPOSIT", "specifier": 0, "path": "src/ethereum/frontier/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_CODE_DEPOSIT"]}}, {"source": {"identifier": "ethereum.frontier.vm.gas.GAS_ZERO", "specifier": 0, "path": "src/ethereum/frontier/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_ZERO"]}}, {"source": {"identifier": "ethereum.frontier.vm.gas.GAS_CALL", "specifier": 0, "path": "src/ethereum/frontier/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_CALL"]}}, {"source": {"identifier": "ethereum.frontier.vm.gas.GAS_NEW_ACCOUNT", "specifier": 0, "path": "src/ethereum/frontier/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_NEW_ACCOUNT"]}}, {"source": {"identifier": "ethereum.frontier.vm.gas.GAS_CALL_VALUE", "specifier": 0, "path": "src/ethereum/frontier/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_CALL_VALUE"]}}, {"source": {"identifier": "ethereum.frontier.vm.gas.GAS_CALL_STIPEND", "specifier": 0, "path": "src/ethereum/frontier/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_CALL_STIPEND"]}}, {"source": {"identifier": "ethereum.frontier.vm.gas.REFUND_SELF_DESTRUCT", "specifier": 0, "path": "src/ethereum/frontier/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["REFUND_SELF_DESTRUCT"]}}, {"source": {"identifier": "ethereum.frontier.vm.gas.GAS_ECRECOVER", "specifier": 0, "path": "src/ethereum/frontier/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_ECRECOVER"]}}, {"source": {"identifier": "ethereum.frontier.vm.gas.GAS_SHA256", "specifier": 0, "path": "src/ethereum/frontier/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_SHA256"]}}, {"source": {"identifier": "ethereum.frontier.vm.gas.GAS_SHA256_WORD", "specifier": 0, "path": "src/ethereum/frontier/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_SHA256_WORD"]}}, {"source": {"identifier": "ethereum.frontier.vm.gas.GAS_RIPEMD160", "specifier": 0, "path": "src/ethereum/frontier/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_RIPEMD160"]}}, {"source": {"identifier": "ethereum.frontier.vm.gas.GAS_RIPEMD160_WORD", "specifier": 0, "path": "src/ethereum/frontier/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_RIPEMD160_WORD"]}}, {"source": {"identifier": "ethereum.frontier.vm.gas.GAS_IDENTITY", "specifier": 0, "path": "src/ethereum/frontier/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_IDENTITY"]}}, {"source": {"identifier": "ethereum.frontier.vm.gas.GAS_IDENTITY_WORD", "specifier": 0, "path": "src/ethereum/frontier/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_IDENTITY_WORD"]}}, {"source": {"identifier": "ethereum.frontier.vm.gas.ExtendMemory", "specifier": 0, "path": "src/ethereum/frontier/vm/gas.py"}, "content": {"type": ["class"], "name": ["ExtendMemory"], "text": ["Define the parameters for memory extension in opcodes cost :  ethereum.base_types.Uint The gas required to perform the extension expand_by :  ethereum.base_types.Uint The size by which the memory will be extended"]}}, {"source": {"identifier": "ethereum.frontier.vm.gas.ExtendMemory.cost", "specifier": 0, "path": "src/ethereum/frontier/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["cost"]}}, {"source": {"identifier": "ethereum.frontier.vm.gas.ExtendMemory.expand_by", "specifier": 0, "path": "src/ethereum/frontier/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["expand_by"]}}, {"source": {"identifier": "ethereum.frontier.vm.gas.MessageCallGas", "specifier": 0, "path": "src/ethereum/frontier/vm/gas.py"}, "content": {"type": ["class"], "name": ["MessageCallGas"], "text": ["Define the gas cost and stipend for executing the call opcodes. cost :  ethereum.base_types.Uint The non-refundable portion of gas reserved for executing the call opcode. stipend :  ethereum.base_types.Uint The portion of gas available to sub-calls that is refundable if not consumed"]}}, {"source": {"identifier": "ethereum.frontier.vm.gas.MessageCallGas.cost", "specifier": 0, "path": "src/ethereum/frontier/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["cost"]}}, {"source": {"identifier": "ethereum.frontier.vm.gas.MessageCallGas.stipend", "specifier": 0, "path": "src/ethereum/frontier/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["stipend"]}}, {"source": {"identifier": "ethereum.frontier.vm.gas.charge_gas", "specifier": 0, "path": "src/ethereum/frontier/vm/gas.py"}, "content": {"type": ["function"], "name": ["charge_gas"], "text": ["Subtracts  amount  from  evm.gas_left . Parameters evm : The current EVM. amount : The amount of gas the current operation requires."]}}, {"source": {"identifier": "ethereum.frontier.vm.gas.calculate_memory_gas_cost", "specifier": 0, "path": "src/ethereum/frontier/vm/gas.py"}, "content": {"type": ["function"], "name": ["calculate_memory_gas_cost"], "text": ["Calculates the gas cost for allocating memory to the smallest multiple of 32 bytes, such that the allocated size is at least as big as the given size. Parameters size_in_bytes : The size of the data in bytes. Returns total_gas_cost :  ethereum.base_types.Uint The gas cost for storing data in memory."]}}, {"source": {"identifier": "ethereum.frontier.vm.gas.calculate_gas_extend_memory", "specifier": 0, "path": "src/ethereum/frontier/vm/gas.py"}, "content": {"type": ["function"], "name": ["calculate_gas_extend_memory"], "text": ["Calculates the gas amount to extend memory Parameters memory : Memory contents of the EVM. extensions: List of extensions to be made to the memory. Consists of a tuple of start position and size. Returns extend_memory:  ExtendMemory"]}}, {"source": {"identifier": "ethereum.frontier.vm.gas.calculate_message_call_gas", "specifier": 0, "path": "src/ethereum/frontier/vm/gas.py"}, "content": {"type": ["function"], "name": ["calculate_message_call_gas"], "text": ["Calculates the gas amount for executing Opcodes  CALL  and  CALLCODE . Parameters state : The current state. gas : The amount of gas provided to the message-call. to: The address of the recipient account. value: The amount of  ETH  that needs to be transferred. Returns message_call_gas:  MessageCallGas"]}}, {"source": {"identifier": "ethereum.arrow_glacier", "specifier": 0, "path": "src/ethereum/arrow_glacier/__init__.py"}, "content": {"type": ["module"], "name": ["ethereum.arrow_glacier"], "text": ["Ethereum Arrow Glacier Hardfork ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ The Twelfth Ethereum hardfork."]}}, {"source": {"identifier": "ethereum.arrow_glacier.MAINNET_FORK_BLOCK", "specifier": 0, "path": "src/ethereum/arrow_glacier/__init__.py"}, "content": {"type": ["attribute"], "name": ["MAINNET_FORK_BLOCK"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.environment", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/environment.py"}, "content": {"type": ["module"], "name": ["ethereum.spurious_dragon.vm.instructions.environment"], "text": ["Ethereum Virtual Machine (EVM) Environmental Instructions ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementations of the EVM environment related instructions."]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.environment.address", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["address"], "text": ["Pushes the address of the current executing account to the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.environment.balance", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["balance"], "text": ["Pushes the balance of the given account onto the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.environment.origin", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["origin"], "text": ["Pushes the address of the original transaction sender to the stack. The origin address can only be an EOA. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.environment.caller", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["caller"], "text": ["Pushes the address of the caller onto the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.environment.callvalue", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["callvalue"], "text": ["Push the value (in wei) sent with the call onto the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.environment.calldataload", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["calldataload"], "text": ["Push a word (32 bytes) of the input data belonging to the current environment onto the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.environment.calldatasize", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["calldatasize"], "text": ["Push the size of input data in current environment onto the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.environment.calldatacopy", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["calldatacopy"], "text": ["Copy a portion of the input data in current environment to memory. This will also expand the memory, in case that the memory is insufficient to store the data. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.environment.codesize", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["codesize"], "text": ["Push the size of code running in current environment onto the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.environment.codecopy", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["codecopy"], "text": ["Copy a portion of the code in current environment to memory. This will also expand the memory, in case that the memory is insufficient to store the data. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.environment.gasprice", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["gasprice"], "text": ["Push the gas price used in current environment onto the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.environment.extcodesize", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["extcodesize"], "text": ["Push the code size of a given account onto the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.environment.extcodecopy", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["extcodecopy"], "text": ["Copy a portion of an account's code to memory. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.arrow_glacier.bloom", "specifier": 0, "path": "src/ethereum/arrow_glacier/bloom.py"}, "content": {"type": ["module"], "name": ["ethereum.arrow_glacier.bloom"], "text": ["Ethereum Logs Bloom ^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction This modules defines functions for calculating bloom filters of logs. For the general theory of bloom filters see e.g.  Wikipedia <https://en.wikipedia.org/wiki/Bloom_filter> _. Bloom filters are used to allow for efficient searching of logs by address and/or topic, by rapidly eliminating blocks and reciepts from their search."]}}, {"source": {"identifier": "ethereum.arrow_glacier.bloom.add_to_bloom", "specifier": 0, "path": "src/ethereum/arrow_glacier/bloom.py"}, "content": {"type": ["function"], "name": ["add_to_bloom"], "text": ["Add a bloom entry to the bloom filter ( bloom ). The number of hash functions used is 3. They are calculated by taking the least significant 11 bits from the first 3 16-bit words of the keccak_256()  hash of  bloom_entry . Parameters bloom : The bloom filter. bloom_entry : An entry which is to be added to bloom filter."]}}, {"source": {"identifier": "ethereum.arrow_glacier.bloom.logs_bloom", "specifier": 0, "path": "src/ethereum/arrow_glacier/bloom.py"}, "content": {"type": ["function"], "name": ["logs_bloom"], "text": ["Obtain the logs bloom from a list of log entries. The address and each topic of a log are added to the bloom filter. Parameters logs : List of logs for which the logs bloom is to be obtained. Returns logs_bloom :  Bloom The logs bloom obtained which is 256 bytes with some bits set as per the caller address and the log topics."]}}, {"source": {"identifier": "ethereum.frontier.vm.precompiled_contracts.mapping", "specifier": 0, "path": "src/ethereum/frontier/vm/precompiled_contracts/mapping.py"}, "content": {"type": ["module"], "name": ["ethereum.frontier.vm.precompiled_contracts.mapping"], "text": ["Precompiled Contract Addresses ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Mapping of precompiled contracts their implementations."]}}, {"source": {"identifier": "ethereum.frontier.vm.precompiled_contracts.mapping.PRE_COMPILED_CONTRACTS", "specifier": 0, "path": "src/ethereum/frontier/vm/precompiled_contracts/mapping.py"}, "content": {"type": ["attribute"], "name": ["PRE_COMPILED_CONTRACTS"]}}, {"source": {"identifier": "ethereum.arrow_glacier.fork_types", "specifier": 0, "path": "src/ethereum/arrow_glacier/fork_types.py"}, "content": {"type": ["module"], "name": ["ethereum.arrow_glacier.fork_types"], "text": ["Ethereum Types ^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Types re-used throughout the specification, which are specific to Ethereum."]}}, {"source": {"identifier": "ethereum.arrow_glacier.fork_types.Address", "specifier": 0, "path": "src/ethereum/arrow_glacier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["Address"]}}, {"source": {"identifier": "ethereum.arrow_glacier.fork_types.Root", "specifier": 0, "path": "src/ethereum/arrow_glacier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["Root"]}}, {"source": {"identifier": "ethereum.arrow_glacier.fork_types.Bloom", "specifier": 0, "path": "src/ethereum/arrow_glacier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["Bloom"]}}, {"source": {"identifier": "ethereum.arrow_glacier.fork_types.TX_BASE_COST", "specifier": 0, "path": "src/ethereum/arrow_glacier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["TX_BASE_COST"]}}, {"source": {"identifier": "ethereum.arrow_glacier.fork_types.TX_DATA_COST_PER_NON_ZERO", "specifier": 0, "path": "src/ethereum/arrow_glacier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["TX_DATA_COST_PER_NON_ZERO"]}}, {"source": {"identifier": "ethereum.arrow_glacier.fork_types.TX_DATA_COST_PER_ZERO", "specifier": 0, "path": "src/ethereum/arrow_glacier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["TX_DATA_COST_PER_ZERO"]}}, {"source": {"identifier": "ethereum.arrow_glacier.fork_types.TX_CREATE_COST", "specifier": 0, "path": "src/ethereum/arrow_glacier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["TX_CREATE_COST"]}}, {"source": {"identifier": "ethereum.arrow_glacier.fork_types.TX_ACCESS_LIST_ADDRESS_COST", "specifier": 0, "path": "src/ethereum/arrow_glacier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["TX_ACCESS_LIST_ADDRESS_COST"]}}, {"source": {"identifier": "ethereum.arrow_glacier.fork_types.TX_ACCESS_LIST_STORAGE_KEY_COST", "specifier": 0, "path": "src/ethereum/arrow_glacier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["TX_ACCESS_LIST_STORAGE_KEY_COST"]}}, {"source": {"identifier": "ethereum.arrow_glacier.fork_types.LegacyTransaction", "specifier": 0, "path": "src/ethereum/arrow_glacier/fork_types.py"}, "content": {"type": ["class"], "name": ["LegacyTransaction"], "text": ["Atomic operation performed on the block chain."]}}, {"source": {"identifier": "ethereum.arrow_glacier.fork_types.LegacyTransaction.nonce", "specifier": 0, "path": "src/ethereum/arrow_glacier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["nonce"]}}, {"source": {"identifier": "ethereum.arrow_glacier.fork_types.LegacyTransaction.gas_price", "specifier": 0, "path": "src/ethereum/arrow_glacier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["gas_price"]}}, {"source": {"identifier": "ethereum.arrow_glacier.fork_types.LegacyTransaction.gas", "specifier": 0, "path": "src/ethereum/arrow_glacier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["gas"]}}, {"source": {"identifier": "ethereum.arrow_glacier.fork_types.LegacyTransaction.to", "specifier": 0, "path": "src/ethereum/arrow_glacier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["to"]}}, {"source": {"identifier": "ethereum.arrow_glacier.fork_types.LegacyTransaction.value", "specifier": 0, "path": "src/ethereum/arrow_glacier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["value"]}}, {"source": {"identifier": "ethereum.arrow_glacier.fork_types.LegacyTransaction.data", "specifier": 0, "path": "src/ethereum/arrow_glacier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["data"]}}, {"source": {"identifier": "ethereum.arrow_glacier.fork_types.LegacyTransaction.v", "specifier": 0, "path": "src/ethereum/arrow_glacier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["v"]}}, {"source": {"identifier": "ethereum.arrow_glacier.fork_types.LegacyTransaction.r", "specifier": 0, "path": "src/ethereum/arrow_glacier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["r"]}}, {"source": {"identifier": "ethereum.arrow_glacier.fork_types.LegacyTransaction.s", "specifier": 0, "path": "src/ethereum/arrow_glacier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["s"]}}, {"source": {"identifier": "ethereum.arrow_glacier.fork_types.AccessListTransaction", "specifier": 0, "path": "src/ethereum/arrow_glacier/fork_types.py"}, "content": {"type": ["class"], "name": ["AccessListTransaction"], "text": ["The transaction type added in EIP-2930 to support access lists."]}}, {"source": {"identifier": "ethereum.arrow_glacier.fork_types.AccessListTransaction.chain_id", "specifier": 0, "path": "src/ethereum/arrow_glacier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["chain_id"]}}, {"source": {"identifier": "ethereum.arrow_glacier.fork_types.AccessListTransaction.nonce", "specifier": 0, "path": "src/ethereum/arrow_glacier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["nonce"]}}, {"source": {"identifier": "ethereum.arrow_glacier.fork_types.AccessListTransaction.gas_price", "specifier": 0, "path": "src/ethereum/arrow_glacier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["gas_price"]}}, {"source": {"identifier": "ethereum.arrow_glacier.fork_types.AccessListTransaction.gas", "specifier": 0, "path": "src/ethereum/arrow_glacier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["gas"]}}, {"source": {"identifier": "ethereum.arrow_glacier.fork_types.AccessListTransaction.to", "specifier": 0, "path": "src/ethereum/arrow_glacier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["to"]}}, {"source": {"identifier": "ethereum.arrow_glacier.fork_types.AccessListTransaction.value", "specifier": 0, "path": "src/ethereum/arrow_glacier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["value"]}}, {"source": {"identifier": "ethereum.arrow_glacier.fork_types.AccessListTransaction.data", "specifier": 0, "path": "src/ethereum/arrow_glacier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["data"]}}, {"source": {"identifier": "ethereum.arrow_glacier.fork_types.AccessListTransaction.access_list", "specifier": 0, "path": "src/ethereum/arrow_glacier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["access_list"]}}, {"source": {"identifier": "ethereum.arrow_glacier.fork_types.AccessListTransaction.v", "specifier": 0, "path": "src/ethereum/arrow_glacier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["v"]}}, {"source": {"identifier": "ethereum.arrow_glacier.fork_types.AccessListTransaction.r", "specifier": 0, "path": "src/ethereum/arrow_glacier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["r"]}}, {"source": {"identifier": "ethereum.arrow_glacier.fork_types.AccessListTransaction.s", "specifier": 0, "path": "src/ethereum/arrow_glacier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["s"]}}, {"source": {"identifier": "ethereum.arrow_glacier.fork_types.FeeMarketTransaction", "specifier": 0, "path": "src/ethereum/arrow_glacier/fork_types.py"}, "content": {"type": ["class"], "name": ["FeeMarketTransaction"], "text": ["The transaction type added in EIP-1559."]}}, {"source": {"identifier": "ethereum.arrow_glacier.fork_types.FeeMarketTransaction.chain_id", "specifier": 0, "path": "src/ethereum/arrow_glacier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["chain_id"]}}, {"source": {"identifier": "ethereum.arrow_glacier.fork_types.FeeMarketTransaction.nonce", "specifier": 0, "path": "src/ethereum/arrow_glacier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["nonce"]}}, {"source": {"identifier": "ethereum.arrow_glacier.fork_types.FeeMarketTransaction.max_priority_fee_per_gas", "specifier": 0, "path": "src/ethereum/arrow_glacier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["max_priority_fee_per_gas"]}}, {"source": {"identifier": "ethereum.arrow_glacier.fork_types.FeeMarketTransaction.max_fee_per_gas", "specifier": 0, "path": "src/ethereum/arrow_glacier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["max_fee_per_gas"]}}, {"source": {"identifier": "ethereum.arrow_glacier.fork_types.FeeMarketTransaction.gas", "specifier": 0, "path": "src/ethereum/arrow_glacier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["gas"]}}, {"source": {"identifier": "ethereum.arrow_glacier.fork_types.FeeMarketTransaction.to", "specifier": 0, "path": "src/ethereum/arrow_glacier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["to"]}}, {"source": {"identifier": "ethereum.arrow_glacier.fork_types.FeeMarketTransaction.value", "specifier": 0, "path": "src/ethereum/arrow_glacier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["value"]}}, {"source": {"identifier": "ethereum.arrow_glacier.fork_types.FeeMarketTransaction.data", "specifier": 0, "path": "src/ethereum/arrow_glacier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["data"]}}, {"source": {"identifier": "ethereum.arrow_glacier.fork_types.FeeMarketTransaction.access_list", "specifier": 0, "path": "src/ethereum/arrow_glacier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["access_list"]}}, {"source": {"identifier": "ethereum.arrow_glacier.fork_types.FeeMarketTransaction.v", "specifier": 0, "path": "src/ethereum/arrow_glacier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["v"]}}, {"source": {"identifier": "ethereum.arrow_glacier.fork_types.FeeMarketTransaction.r", "specifier": 0, "path": "src/ethereum/arrow_glacier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["r"]}}, {"source": {"identifier": "ethereum.arrow_glacier.fork_types.FeeMarketTransaction.s", "specifier": 0, "path": "src/ethereum/arrow_glacier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["s"]}}, {"source": {"identifier": "ethereum.arrow_glacier.fork_types.Transaction", "specifier": 0, "path": "src/ethereum/arrow_glacier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["Transaction"]}}, {"source": {"identifier": "ethereum.arrow_glacier.fork_types.encode_transaction", "specifier": 0, "path": "src/ethereum/arrow_glacier/fork_types.py"}, "content": {"type": ["function"], "name": ["encode_transaction"], "text": ["Encode a transaction. Needed because non-legacy transactions aren't RLP."]}}, {"source": {"identifier": "ethereum.arrow_glacier.fork_types.decode_transaction", "specifier": 0, "path": "src/ethereum/arrow_glacier/fork_types.py"}, "content": {"type": ["function"], "name": ["decode_transaction"], "text": ["Decode a transaction. Needed because non-legacy transactions aren't RLP."]}}, {"source": {"identifier": "ethereum.arrow_glacier.fork_types.Account", "specifier": 0, "path": "src/ethereum/arrow_glacier/fork_types.py"}, "content": {"type": ["class"], "name": ["Account"], "text": ["State associated with an address."]}}, {"source": {"identifier": "ethereum.arrow_glacier.fork_types.Account.nonce", "specifier": 0, "path": "src/ethereum/arrow_glacier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["nonce"]}}, {"source": {"identifier": "ethereum.arrow_glacier.fork_types.Account.balance", "specifier": 0, "path": "src/ethereum/arrow_glacier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["balance"]}}, {"source": {"identifier": "ethereum.arrow_glacier.fork_types.Account.code", "specifier": 0, "path": "src/ethereum/arrow_glacier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["code"]}}, {"source": {"identifier": "ethereum.arrow_glacier.fork_types.EMPTY_ACCOUNT", "specifier": 0, "path": "src/ethereum/arrow_glacier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["EMPTY_ACCOUNT"]}}, {"source": {"identifier": "ethereum.arrow_glacier.fork_types.encode_account", "specifier": 0, "path": "src/ethereum/arrow_glacier/fork_types.py"}, "content": {"type": ["function"], "name": ["encode_account"], "text": ["Encode  Account  dataclass. Storage is not stored in the  Account  dataclass, so  Accounts  cannot be encoded with providing a storage root."]}}, {"source": {"identifier": "ethereum.arrow_glacier.fork_types.Header", "specifier": 0, "path": "src/ethereum/arrow_glacier/fork_types.py"}, "content": {"type": ["class"], "name": ["Header"], "text": ["Header portion of a block on the chain."]}}, {"source": {"identifier": "ethereum.arrow_glacier.fork_types.Header.parent_hash", "specifier": 0, "path": "src/ethereum/arrow_glacier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["parent_hash"]}}, {"source": {"identifier": "ethereum.arrow_glacier.fork_types.Header.ommers_hash", "specifier": 0, "path": "src/ethereum/arrow_glacier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["ommers_hash"]}}, {"source": {"identifier": "ethereum.arrow_glacier.fork_types.Header.coinbase", "specifier": 0, "path": "src/ethereum/arrow_glacier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["coinbase"]}}, {"source": {"identifier": "ethereum.arrow_glacier.fork_types.Header.state_root", "specifier": 0, "path": "src/ethereum/arrow_glacier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["state_root"]}}, {"source": {"identifier": "ethereum.arrow_glacier.fork_types.Header.transactions_root", "specifier": 0, "path": "src/ethereum/arrow_glacier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["transactions_root"]}}, {"source": {"identifier": "ethereum.arrow_glacier.fork_types.Header.receipt_root", "specifier": 0, "path": "src/ethereum/arrow_glacier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["receipt_root"]}}, {"source": {"identifier": "ethereum.arrow_glacier.fork_types.Header.bloom", "specifier": 0, "path": "src/ethereum/arrow_glacier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["bloom"]}}, {"source": {"identifier": "ethereum.arrow_glacier.fork_types.Header.difficulty", "specifier": 0, "path": "src/ethereum/arrow_glacier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["difficulty"]}}, {"source": {"identifier": "ethereum.arrow_glacier.fork_types.Header.number", "specifier": 0, "path": "src/ethereum/arrow_glacier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["number"]}}, {"source": {"identifier": "ethereum.arrow_glacier.fork_types.Header.gas_limit", "specifier": 0, "path": "src/ethereum/arrow_glacier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["gas_limit"]}}, {"source": {"identifier": "ethereum.arrow_glacier.fork_types.Header.gas_used", "specifier": 0, "path": "src/ethereum/arrow_glacier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["gas_used"]}}, {"source": {"identifier": "ethereum.arrow_glacier.fork_types.Header.timestamp", "specifier": 0, "path": "src/ethereum/arrow_glacier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["timestamp"]}}, {"source": {"identifier": "ethereum.arrow_glacier.fork_types.Header.extra_data", "specifier": 0, "path": "src/ethereum/arrow_glacier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["extra_data"]}}, {"source": {"identifier": "ethereum.arrow_glacier.fork_types.Header.mix_digest", "specifier": 0, "path": "src/ethereum/arrow_glacier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["mix_digest"]}}, {"source": {"identifier": "ethereum.arrow_glacier.fork_types.Header.nonce", "specifier": 0, "path": "src/ethereum/arrow_glacier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["nonce"]}}, {"source": {"identifier": "ethereum.arrow_glacier.fork_types.Header.base_fee_per_gas", "specifier": 0, "path": "src/ethereum/arrow_glacier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["base_fee_per_gas"]}}, {"source": {"identifier": "ethereum.arrow_glacier.fork_types.Block", "specifier": 0, "path": "src/ethereum/arrow_glacier/fork_types.py"}, "content": {"type": ["class"], "name": ["Block"], "text": ["A complete block."]}}, {"source": {"identifier": "ethereum.arrow_glacier.fork_types.Block.header", "specifier": 0, "path": "src/ethereum/arrow_glacier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["header"]}}, {"source": {"identifier": "ethereum.arrow_glacier.fork_types.Block.transactions", "specifier": 0, "path": "src/ethereum/arrow_glacier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["transactions"]}}, {"source": {"identifier": "ethereum.arrow_glacier.fork_types.Block.ommers", "specifier": 0, "path": "src/ethereum/arrow_glacier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["ommers"]}}, {"source": {"identifier": "ethereum.arrow_glacier.fork_types.Log", "specifier": 0, "path": "src/ethereum/arrow_glacier/fork_types.py"}, "content": {"type": ["class"], "name": ["Log"], "text": ["Data record produced during the execution of a transaction."]}}, {"source": {"identifier": "ethereum.arrow_glacier.fork_types.Log.address", "specifier": 0, "path": "src/ethereum/arrow_glacier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["address"]}}, {"source": {"identifier": "ethereum.arrow_glacier.fork_types.Log.topics", "specifier": 0, "path": "src/ethereum/arrow_glacier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["topics"]}}, {"source": {"identifier": "ethereum.arrow_glacier.fork_types.Log.data", "specifier": 0, "path": "src/ethereum/arrow_glacier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["data"]}}, {"source": {"identifier": "ethereum.arrow_glacier.fork_types.Receipt", "specifier": 0, "path": "src/ethereum/arrow_glacier/fork_types.py"}, "content": {"type": ["class"], "name": ["Receipt"], "text": ["Result of a transaction."]}}, {"source": {"identifier": "ethereum.arrow_glacier.fork_types.Receipt.succeeded", "specifier": 0, "path": "src/ethereum/arrow_glacier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["succeeded"]}}, {"source": {"identifier": "ethereum.arrow_glacier.fork_types.Receipt.cumulative_gas_used", "specifier": 0, "path": "src/ethereum/arrow_glacier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["cumulative_gas_used"]}}, {"source": {"identifier": "ethereum.arrow_glacier.fork_types.Receipt.bloom", "specifier": 0, "path": "src/ethereum/arrow_glacier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["bloom"]}}, {"source": {"identifier": "ethereum.arrow_glacier.fork_types.Receipt.logs", "specifier": 0, "path": "src/ethereum/arrow_glacier/fork_types.py"}, "content": {"type": ["attribute"], "name": ["logs"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.stack", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/stack.py"}, "content": {"type": ["module"], "name": ["ethereum.spurious_dragon.vm.instructions.stack"], "text": ["Ethereum Virtual Machine (EVM) Stack Instructions ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementations of the EVM stack related instructions."]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.stack.pop", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/stack.py"}, "content": {"type": ["function"], "name": ["pop"], "text": ["Remove item from stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.stack.push_n", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/stack.py"}, "content": {"type": ["function"], "name": ["push_n"], "text": ["Pushes a N-byte immediate onto the stack. Parameters evm : The current EVM frame. num_bytes : The number of immediate bytes to be read from the code and pushed to the stack."]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.stack.dup_n", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/stack.py"}, "content": {"type": ["function"], "name": ["dup_n"], "text": ["Duplicate the Nth stack item (from top of the stack) to the top of stack. Parameters evm : The current EVM frame. item_number : The stack item number (0-indexed from top of stack) to be duplicated to the top of stack."]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.stack.swap_n", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/stack.py"}, "content": {"type": ["function"], "name": ["swap_n"], "text": ["Swap the top and the  item_number  element of the stack, where the top of the stack is position zero. If  item_number  is zero, this function does nothing (which should not be possible, since there is no  SWAP0  instruction). Parameters evm : The current EVM frame. item_number : The stack item number (0-indexed from top of stack) to be swapped with the top of stack element."]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.stack.push1", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push1"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.stack.push2", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push2"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.stack.push3", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push3"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.stack.push4", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push4"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.stack.push5", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push5"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.stack.push6", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push6"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.stack.push7", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push7"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.stack.push8", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push8"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.stack.push9", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push9"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.stack.push10", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push10"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.stack.push11", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push11"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.stack.push12", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push12"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.stack.push13", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push13"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.stack.push14", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push14"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.stack.push15", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push15"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.stack.push16", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push16"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.stack.push17", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push17"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.stack.push18", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push18"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.stack.push19", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push19"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.stack.push20", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push20"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.stack.push21", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push21"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.stack.push22", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push22"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.stack.push23", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push23"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.stack.push24", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push24"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.stack.push25", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push25"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.stack.push26", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push26"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.stack.push27", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push27"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.stack.push28", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push28"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.stack.push29", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push29"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.stack.push30", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push30"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.stack.push31", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push31"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.stack.push32", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push32"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.stack.dup1", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup1"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.stack.dup2", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup2"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.stack.dup3", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup3"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.stack.dup4", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup4"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.stack.dup5", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup5"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.stack.dup6", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup6"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.stack.dup7", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup7"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.stack.dup8", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup8"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.stack.dup9", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup9"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.stack.dup10", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup10"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.stack.dup11", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup11"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.stack.dup12", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup12"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.stack.dup13", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup13"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.stack.dup14", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup14"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.stack.dup15", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup15"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.stack.dup16", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup16"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.stack.swap1", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap1"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.stack.swap2", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap2"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.stack.swap3", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap3"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.stack.swap4", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap4"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.stack.swap5", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap5"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.stack.swap6", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap6"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.stack.swap7", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap7"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.stack.swap8", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap8"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.stack.swap9", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap9"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.stack.swap10", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap10"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.stack.swap11", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap11"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.stack.swap12", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap12"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.stack.swap13", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap13"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.stack.swap14", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap14"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.stack.swap15", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap15"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.stack.swap16", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap16"]}}, {"source": {"identifier": "ethereum.frontier.vm.precompiled_contracts", "specifier": 0, "path": "src/ethereum/frontier/vm/precompiled_contracts/__init__.py"}, "content": {"type": ["module"], "name": ["ethereum.frontier.vm.precompiled_contracts"], "text": ["Precompiled Contract Addresses ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Addresses of precompiled contracts and mappings to their implementations."]}}, {"source": {"identifier": "ethereum.frontier.vm.precompiled_contracts.__all__", "specifier": 0, "path": "src/ethereum/frontier/vm/precompiled_contracts/__init__.py"}, "content": {"type": ["attribute"], "name": ["__all__"]}}, {"source": {"identifier": "ethereum.frontier.vm.precompiled_contracts.ECRECOVER_ADDRESS", "specifier": 0, "path": "src/ethereum/frontier/vm/precompiled_contracts/__init__.py"}, "content": {"type": ["attribute"], "name": ["ECRECOVER_ADDRESS"]}}, {"source": {"identifier": "ethereum.frontier.vm.precompiled_contracts.SHA256_ADDRESS", "specifier": 0, "path": "src/ethereum/frontier/vm/precompiled_contracts/__init__.py"}, "content": {"type": ["attribute"], "name": ["SHA256_ADDRESS"]}}, {"source": {"identifier": "ethereum.frontier.vm.precompiled_contracts.RIPEMD160_ADDRESS", "specifier": 0, "path": "src/ethereum/frontier/vm/precompiled_contracts/__init__.py"}, "content": {"type": ["attribute"], "name": ["RIPEMD160_ADDRESS"]}}, {"source": {"identifier": "ethereum.frontier.vm.precompiled_contracts.IDENTITY_ADDRESS", "specifier": 0, "path": "src/ethereum/frontier/vm/precompiled_contracts/__init__.py"}, "content": {"type": ["attribute"], "name": ["IDENTITY_ADDRESS"]}}, {"source": {"identifier": "ethereum.arrow_glacier.trie", "specifier": 0, "path": "src/ethereum/arrow_glacier/trie.py"}, "content": {"type": ["module"], "name": ["ethereum.arrow_glacier.trie"], "text": ["State Trie ^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction The state trie is the structure responsible for storing .fork_types.Account  objects."]}}, {"source": {"identifier": "ethereum.arrow_glacier.trie.EMPTY_TRIE_ROOT", "specifier": 0, "path": "src/ethereum/arrow_glacier/trie.py"}, "content": {"type": ["attribute"], "name": ["EMPTY_TRIE_ROOT"]}}, {"source": {"identifier": "ethereum.arrow_glacier.trie.Node", "specifier": 0, "path": "src/ethereum/arrow_glacier/trie.py"}, "content": {"type": ["attribute"], "name": ["Node"]}}, {"source": {"identifier": "ethereum.arrow_glacier.trie.K", "specifier": 0, "path": "src/ethereum/arrow_glacier/trie.py"}, "content": {"type": ["attribute"], "name": ["K"]}}, {"source": {"identifier": "ethereum.arrow_glacier.trie.V", "specifier": 0, "path": "src/ethereum/arrow_glacier/trie.py"}, "content": {"type": ["attribute"], "name": ["V"]}}, {"source": {"identifier": "ethereum.arrow_glacier.trie.LeafNode", "specifier": 0, "path": "src/ethereum/arrow_glacier/trie.py"}, "content": {"type": ["class"], "name": ["LeafNode"], "text": ["Leaf node in the Merkle Trie"]}}, {"source": {"identifier": "ethereum.arrow_glacier.trie.LeafNode.rest_of_key", "specifier": 0, "path": "src/ethereum/arrow_glacier/trie.py"}, "content": {"type": ["attribute"], "name": ["rest_of_key"]}}, {"source": {"identifier": "ethereum.arrow_glacier.trie.LeafNode.value", "specifier": 0, "path": "src/ethereum/arrow_glacier/trie.py"}, "content": {"type": ["attribute"], "name": ["value"]}}, {"source": {"identifier": "ethereum.arrow_glacier.trie.ExtensionNode", "specifier": 0, "path": "src/ethereum/arrow_glacier/trie.py"}, "content": {"type": ["class"], "name": ["ExtensionNode"], "text": ["Extension node in the Merkle Trie"]}}, {"source": {"identifier": "ethereum.arrow_glacier.trie.ExtensionNode.key_segment", "specifier": 0, "path": "src/ethereum/arrow_glacier/trie.py"}, "content": {"type": ["attribute"], "name": ["key_segment"]}}, {"source": {"identifier": "ethereum.arrow_glacier.trie.ExtensionNode.subnode", "specifier": 0, "path": "src/ethereum/arrow_glacier/trie.py"}, "content": {"type": ["attribute"], "name": ["subnode"]}}, {"source": {"identifier": "ethereum.arrow_glacier.trie.BranchNode", "specifier": 0, "path": "src/ethereum/arrow_glacier/trie.py"}, "content": {"type": ["class"], "name": ["BranchNode"], "text": ["Branch node in the Merkle Trie"]}}, {"source": {"identifier": "ethereum.arrow_glacier.trie.BranchNode.subnodes", "specifier": 0, "path": "src/ethereum/arrow_glacier/trie.py"}, "content": {"type": ["attribute"], "name": ["subnodes"]}}, {"source": {"identifier": "ethereum.arrow_glacier.trie.BranchNode.value", "specifier": 0, "path": "src/ethereum/arrow_glacier/trie.py"}, "content": {"type": ["attribute"], "name": ["value"]}}, {"source": {"identifier": "ethereum.arrow_glacier.trie.InternalNode", "specifier": 0, "path": "src/ethereum/arrow_glacier/trie.py"}, "content": {"type": ["attribute"], "name": ["InternalNode"]}}, {"source": {"identifier": "ethereum.arrow_glacier.trie.encode_internal_node", "specifier": 0, "path": "src/ethereum/arrow_glacier/trie.py"}, "content": {"type": ["function"], "name": ["encode_internal_node"], "text": ["Encodes a Merkle Trie node into its RLP form. The RLP will then be serialized into a  Bytes  and hashed unless it is less that 32 bytes when serialized. This function also accepts  None , representing the absence of a node, which is encoded to  b\"\" . Parameters node : Optional[InternalNode] The node to encode. Returns encoded :  rlp.RLP The node encoded as RLP."]}}, {"source": {"identifier": "ethereum.arrow_glacier.trie.encode_node", "specifier": 0, "path": "src/ethereum/arrow_glacier/trie.py"}, "content": {"type": ["function"], "name": ["encode_node"], "text": ["Encode a Node for storage in the Merkle Trie. Currently mostly an unimplemented stub."]}}, {"source": {"identifier": "ethereum.arrow_glacier.trie.Trie", "specifier": 0, "path": "src/ethereum/arrow_glacier/trie.py"}, "content": {"type": ["class"], "name": ["Trie"], "text": ["The Merkle Trie."]}}, {"source": {"identifier": "ethereum.arrow_glacier.trie.Trie.secured", "specifier": 0, "path": "src/ethereum/arrow_glacier/trie.py"}, "content": {"type": ["attribute"], "name": ["secured"]}}, {"source": {"identifier": "ethereum.arrow_glacier.trie.Trie.default", "specifier": 0, "path": "src/ethereum/arrow_glacier/trie.py"}, "content": {"type": ["attribute"], "name": ["default"]}}, {"source": {"identifier": "ethereum.arrow_glacier.trie.Trie._data", "specifier": 0, "path": "src/ethereum/arrow_glacier/trie.py"}, "content": {"type": ["attribute"], "name": ["_data"]}}, {"source": {"identifier": "ethereum.arrow_glacier.trie.copy_trie", "specifier": 0, "path": "src/ethereum/arrow_glacier/trie.py"}, "content": {"type": ["function"], "name": ["copy_trie"], "text": ["Create a copy of  trie . Since only frozen objects may be stored in tries, the contents are reused. Parameters trie:  Trie Trie to copy. Returns new_trie :  Trie[K, V] A copy of the trie."]}}, {"source": {"identifier": "ethereum.arrow_glacier.trie.trie_set", "specifier": 0, "path": "src/ethereum/arrow_glacier/trie.py"}, "content": {"type": ["function"], "name": ["trie_set"], "text": ["Stores an item in a Merkle Trie. This method deletes the key if  value == trie.default , because the Merkle Trie represents the default value by omitting it from the trie. Parameters trie:  Trie Trie to store in. key :  Bytes Key to lookup. value :  V Node to insert at  key ."]}}, {"source": {"identifier": "ethereum.arrow_glacier.trie.trie_get", "specifier": 0, "path": "src/ethereum/arrow_glacier/trie.py"}, "content": {"type": ["function"], "name": ["trie_get"], "text": ["Gets an item from the Merkle Trie. This method returns  trie.default  if the key is missing. Parameters trie: Trie to lookup in. key : Key to lookup. Returns node :  V Node at  key  in the trie."]}}, {"source": {"identifier": "ethereum.arrow_glacier.trie.common_prefix_length", "specifier": 0, "path": "src/ethereum/arrow_glacier/trie.py"}, "content": {"type": ["function"], "name": ["common_prefix_length"], "text": ["Find the longest common prefix of two sequences."]}}, {"source": {"identifier": "ethereum.arrow_glacier.trie.nibble_list_to_compact", "specifier": 0, "path": "src/ethereum/arrow_glacier/trie.py"}, "content": {"type": ["function"], "name": ["nibble_list_to_compact"], "text": ["Compresses nibble-list into a standard byte array with a flag. A nibble-list is a list of byte values no greater than  15 . The flag is encoded in high nibble of the highest byte. The flag nibble can be broken down into two two-bit flags. Highest nibble:: +---+---+----------+--------+\n| _ | _ | is_leaf | parity |\n+---+---+----------+--------+\n  3   2      1         0\n The lowest bit of the nibble encodes the parity of the length of the remaining nibbles --  0  when even and  1  when odd. The second lowest bit is used to distinguish leaf and extension nodes. The other two bits are not used. Parameters x : Array of nibbles. is_leaf : True if this is part of a leaf node, or false if it is an extension node. Returns compressed :  bytearray Compact byte array."]}}, {"source": {"identifier": "ethereum.arrow_glacier.trie.bytes_to_nibble_list", "specifier": 0, "path": "src/ethereum/arrow_glacier/trie.py"}, "content": {"type": ["function"], "name": ["bytes_to_nibble_list"], "text": ["Converts a  Bytes  into to a sequence of nibbles (bytes with value < 16). Parameters bytes_: The  Bytes  to convert. Returns nibble_list :  Bytes The  Bytes  in nibble-list format."]}}, {"source": {"identifier": "ethereum.arrow_glacier.trie._prepare_trie", "specifier": 0, "path": "src/ethereum/arrow_glacier/trie.py"}, "content": {"type": ["function"], "name": ["_prepare_trie"], "text": ["Prepares the trie for root calculation. Removes values that are empty, hashes the keys (if  secured == True ) and encodes all the nodes. Parameters trie : The  Trie  to prepare. get_storage_root : Function to get the storage root of an account. Needed to encode Account  objects. Returns out :  Mapping[ethereum.base_types.Bytes, Node] Object with keys mapped to nibble-byte form."]}}, {"source": {"identifier": "ethereum.arrow_glacier.trie.root", "specifier": 0, "path": "src/ethereum/arrow_glacier/trie.py"}, "content": {"type": ["function"], "name": ["root"], "text": ["Computes the root of a modified merkle patricia trie (MPT). Parameters trie : Trie  to get the root of. get_storage_root : Function to get the storage root of an account. Needed to encode Account  objects. Returns root :  .fork_types.Root MPT root of the underlying key-value pairs."]}}, {"source": {"identifier": "ethereum.arrow_glacier.trie.patricialize", "specifier": 0, "path": "src/ethereum/arrow_glacier/trie.py"}, "content": {"type": ["function"], "name": ["patricialize"], "text": ["Structural composition function. Used to recursively patricialize and merkleize a dictionary. Includes memoization of the tree structure and hashes. Parameters obj : Underlying trie key-value pairs, with keys in nibble-list format. level : Current trie level. Returns node :  ethereum.base_types.Bytes Root node of  obj ."]}}, {"source": {"identifier": "ethereum.spurious_dragon.utils", "specifier": 0, "path": "src/ethereum/spurious_dragon/utils/__init__.py"}, "content": {"type": ["module"], "name": ["ethereum.spurious_dragon.utils"], "text": ["Hardfork Utility Functions ^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Utility functions used in this spurious dragon version of specification."]}}, {"source": {"identifier": "ethereum.arrow_glacier.fork", "specifier": 0, "path": "src/ethereum/arrow_glacier/fork.py"}, "content": {"type": ["module"], "name": ["ethereum.arrow_glacier.fork"], "text": ["Ethereum Specification ^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Entry point for the Ethereum specification."]}}, {"source": {"identifier": "ethereum.arrow_glacier.fork.BLOCK_REWARD", "specifier": 0, "path": "src/ethereum/arrow_glacier/fork.py"}, "content": {"type": ["attribute"], "name": ["BLOCK_REWARD"]}}, {"source": {"identifier": "ethereum.arrow_glacier.fork.BASE_FEE_MAX_CHANGE_DENOMINATOR", "specifier": 0, "path": "src/ethereum/arrow_glacier/fork.py"}, "content": {"type": ["attribute"], "name": ["BASE_FEE_MAX_CHANGE_DENOMINATOR"]}}, {"source": {"identifier": "ethereum.arrow_glacier.fork.ELASTICITY_MULTIPLIER", "specifier": 0, "path": "src/ethereum/arrow_glacier/fork.py"}, "content": {"type": ["attribute"], "name": ["ELASTICITY_MULTIPLIER"]}}, {"source": {"identifier": "ethereum.arrow_glacier.fork.GAS_LIMIT_ADJUSTMENT_FACTOR", "specifier": 0, "path": "src/ethereum/arrow_glacier/fork.py"}, "content": {"type": ["attribute"], "name": ["GAS_LIMIT_ADJUSTMENT_FACTOR"]}}, {"source": {"identifier": "ethereum.arrow_glacier.fork.GAS_LIMIT_MINIMUM", "specifier": 0, "path": "src/ethereum/arrow_glacier/fork.py"}, "content": {"type": ["attribute"], "name": ["GAS_LIMIT_MINIMUM"]}}, {"source": {"identifier": "ethereum.arrow_glacier.fork.MINIMUM_DIFFICULTY", "specifier": 0, "path": "src/ethereum/arrow_glacier/fork.py"}, "content": {"type": ["attribute"], "name": ["MINIMUM_DIFFICULTY"]}}, {"source": {"identifier": "ethereum.arrow_glacier.fork.MAX_OMMER_DEPTH", "specifier": 0, "path": "src/ethereum/arrow_glacier/fork.py"}, "content": {"type": ["attribute"], "name": ["MAX_OMMER_DEPTH"]}}, {"source": {"identifier": "ethereum.arrow_glacier.fork.BOMB_DELAY_BLOCKS", "specifier": 0, "path": "src/ethereum/arrow_glacier/fork.py"}, "content": {"type": ["attribute"], "name": ["BOMB_DELAY_BLOCKS"]}}, {"source": {"identifier": "ethereum.arrow_glacier.fork.EMPTY_OMMER_HASH", "specifier": 0, "path": "src/ethereum/arrow_glacier/fork.py"}, "content": {"type": ["attribute"], "name": ["EMPTY_OMMER_HASH"]}}, {"source": {"identifier": "ethereum.arrow_glacier.fork.BlockChain", "specifier": 0, "path": "src/ethereum/arrow_glacier/fork.py"}, "content": {"type": ["class"], "name": ["BlockChain"], "text": ["History and current state of the block chain."]}}, {"source": {"identifier": "ethereum.arrow_glacier.fork.BlockChain.blocks", "specifier": 0, "path": "src/ethereum/arrow_glacier/fork.py"}, "content": {"type": ["attribute"], "name": ["blocks"]}}, {"source": {"identifier": "ethereum.arrow_glacier.fork.BlockChain.state", "specifier": 0, "path": "src/ethereum/arrow_glacier/fork.py"}, "content": {"type": ["attribute"], "name": ["state"]}}, {"source": {"identifier": "ethereum.arrow_glacier.fork.BlockChain.chain_id", "specifier": 0, "path": "src/ethereum/arrow_glacier/fork.py"}, "content": {"type": ["attribute"], "name": ["chain_id"]}}, {"source": {"identifier": "ethereum.arrow_glacier.fork.apply_fork", "specifier": 0, "path": "src/ethereum/arrow_glacier/fork.py"}, "content": {"type": ["function"], "name": ["apply_fork"], "text": ["Transforms the state from the previous hard fork ( old ) into the block chain object for this hard fork and returns it. When forks need to implement an irregular state transition, this function is used to handle the irregularity. See the :ref: DAO Fork <dao-fork>  for an example. Parameters old : Previous block chain object. Returns new :  BlockChain Upgraded block chain object for this hard fork."]}}, {"source": {"identifier": "ethereum.arrow_glacier.fork.get_last_256_block_hashes", "specifier": 0, "path": "src/ethereum/arrow_glacier/fork.py"}, "content": {"type": ["function"], "name": ["get_last_256_block_hashes"], "text": ["Obtain the list of hashes of the previous 256 blocks in order of increasing block number. This function will return less hashes for the first 256 blocks. The  BLOCKHASH  opcode needs to access the latest hashes on the chain, therefore this function retrieves them. Parameters chain : History and current state. Returns recent_block_hashes :  List[Hash32] Hashes of the recent 256 blocks in order of increasing block number."]}}, {"source": {"identifier": "ethereum.arrow_glacier.fork.state_transition", "specifier": 0, "path": "src/ethereum/arrow_glacier/fork.py"}, "content": {"type": ["function"], "name": ["state_transition"], "text": ["Attempts to apply a block to an existing block chain. All parts of the block's contents need to be verified before being added to the chain. Blocks are verified by ensuring that the contents of the block make logical sense with the contents of the parent block. The information in the block's header must also match the corresponding information in the block. To implement Ethereum, in theory clients are only required to store the most recent 255 blocks of the chain since as far as execution is concerned, only those blocks are accessed. Practically, however, clients should store more blocks to handle reorgs. Parameters chain : History and current state. block : Block to apply to  chain ."]}}, {"source": {"identifier": "ethereum.arrow_glacier.fork.calculate_base_fee_per_gas", "specifier": 0, "path": "src/ethereum/arrow_glacier/fork.py"}, "content": {"type": ["function"], "name": ["calculate_base_fee_per_gas"], "text": ["Calculates the base fee per gas for the block. Parameters block_gas_limit : Gas limit of the block for which the base fee is being calculated. parent_gas_limit : Gas limit of the parent block. parent_gas_used : Gas used in the parent block. parent_base_fee_per_gas : Base fee per gas of the parent block. Returns base_fee_per_gas :  Uint Base fee per gas for the block."]}}, {"source": {"identifier": "ethereum.arrow_glacier.fork.validate_header", "specifier": 0, "path": "src/ethereum/arrow_glacier/fork.py"}, "content": {"type": ["function"], "name": ["validate_header"], "text": ["Verifies a block header. In order to consider a block's header valid, the logic for the quantities in the header should match the logic for the block itself. For example the header timestamp should be greater than the block's parent timestamp because the block was created  after  the parent block. Additionally, the block's number should be directly folowing the parent block's number since it is the next block in the sequence. Parameters header : Header to check for correctness. parent_header : Parent Header of the header to check for correctness"]}}, {"source": {"identifier": "ethereum.arrow_glacier.fork.generate_header_hash_for_pow", "specifier": 0, "path": "src/ethereum/arrow_glacier/fork.py"}, "content": {"type": ["function"], "name": ["generate_header_hash_for_pow"], "text": ["Generate rlp hash of the header which is to be used for Proof-of-Work verification. In other words, the PoW artefacts  mix_digest  and  nonce  are ignored while calculating this hash. A particular PoW is valid for a single hash, that hash is computed by this function. The  nonce  and  mix_digest  are omitted from this hash because they are being changed by miners in their search for a sufficient proof-of-work. Parameters header : The header object for which the hash is to be generated. Returns hash :  Hash32 The PoW valid rlp hash of the passed in header."]}}, {"source": {"identifier": "ethereum.arrow_glacier.fork.validate_proof_of_work", "specifier": 0, "path": "src/ethereum/arrow_glacier/fork.py"}, "content": {"type": ["function"], "name": ["validate_proof_of_work"], "text": ["Validates the Proof of Work constraints. In order to verify that a miner's proof-of-work is valid for a block, a mix-digest  and  result  are calculated using the  hashimoto_light hash function. The mix digest is a hash of the header and the nonce that is passed through and it confirms whether or not proof-of-work was done on the correct block. The result is the actual hash value of the block. Parameters header : Header of interest."]}}, {"source": {"identifier": "ethereum.arrow_glacier.fork.check_transaction", "specifier": 0, "path": "src/ethereum/arrow_glacier/fork.py"}, "content": {"type": ["function"], "name": ["check_transaction"], "text": ["Check if the transaction is includable in the block. Parameters tx : The transaction. base_fee_per_gas : The block base fee. gas_available : The gas remaining in the block. chain_id : The ID of the current chain. Returns sender_address : The sender of the transaction. effective_gas_price : The price to charge for gas when the transaction is executed. Raises InvalidBlock : If the transaction is not includable."]}}, {"source": {"identifier": "ethereum.arrow_glacier.fork.make_receipt", "specifier": 0, "path": "src/ethereum/arrow_glacier/fork.py"}, "content": {"type": ["function"], "name": ["make_receipt"], "text": ["Make the receipt for a transaction that was executed. Parameters tx : The executed transaction. has_erred : Whether the top level frame of the transaction exited with an error. cumulative_gas_used : The total gas used so far in the block after the transaction was executed. logs : The logs produced by the transaction. Returns receipt : The receipt for the transaction."]}}, {"source": {"identifier": "ethereum.arrow_glacier.fork.apply_body", "specifier": 0, "path": "src/ethereum/arrow_glacier/fork.py"}, "content": {"type": ["function"], "name": ["apply_body"], "text": ["Executes a block. Many of the contents of a block are stored in data structures called tries. There is a transactions trie which is similar to a ledger of the transactions stored in the current block. There is also a receipts trie which stores the results of executing a transaction, like the post state and gas used. This function creates and executes the block that is to be added to the chain. Parameters state : Current account state. block_hashes : List of hashes of the previous 256 blocks in the order of increasing block number. coinbase : Address of account which receives block reward and transaction fees. block_number : Position of the block within the chain. base_fee_per_gas : Base fee per gas of within the block. block_gas_limit : Initial amount of gas available for execution in this block. block_time : Time the block was produced, measured in seconds since the epoch. block_difficulty : Difficulty of the block. transactions : Transactions included in the block. ommers : Headers of ancestor blocks which are not direct parents (formerly uncles.) chain_id : ID of the executing chain. Returns gas_available :  ethereum.base_types.Uint Remaining gas after all transactions have been executed. transactions_root :  ethereum.fork_types.Root Trie root of all the transactions in the block. receipt_root :  ethereum.fork_types.Root Trie root of all the receipts in the block. block_logs_bloom :  Bloom Logs bloom of all the logs included in all the transactions of the block. state :  ethereum.fork_types.State State after all transactions have been executed."]}}, {"source": {"identifier": "ethereum.arrow_glacier.fork.validate_ommers", "specifier": 0, "path": "src/ethereum/arrow_glacier/fork.py"}, "content": {"type": ["function"], "name": ["validate_ommers"], "text": ["Validates the ommers mentioned in the block. An ommer block is a block that wasn't canonically added to the blockchain because it wasn't validated as fast as the canonical block but was mined at the same time. To be considered valid, the ommers must adhere to the rules defined in the Ethereum protocol. The maximum amount of ommers is 2 per block and there cannot be duplicate ommers in a block. Many of the other ommer contraints are listed in the in-line comments of this function. Parameters ommers : List of ommers mentioned in the current block. block_header: The header of current block. chain : History and current state."]}}, {"source": {"identifier": "ethereum.arrow_glacier.fork.pay_rewards", "specifier": 0, "path": "src/ethereum/arrow_glacier/fork.py"}, "content": {"type": ["function"], "name": ["pay_rewards"], "text": ["Pay rewards to the block miner as well as the ommers miners. The miner of the canonical block is rewarded with the predetermined block reward,  BLOCK_REWARD , plus a variable award based off of the number of ommer blocks that were mined around the same time, and included in the canonical block's header. An ommer block is a block that wasn't added to the canonical blockchain because it wasn't validated as fast as the accepted block but was mined at the same time. Although not all blocks that are mined are added to the canonical chain, miners are still paid a reward for their efforts. This reward is called an ommer reward and is calculated based on the number associated with the ommer block that they mined. Parameters state : Current account state. block_number : Position of the block within the chain. coinbase : Address of account which receives block reward and transaction fees. ommers : List of ommers mentioned in the current block."]}}, {"source": {"identifier": "ethereum.arrow_glacier.fork.process_transaction", "specifier": 0, "path": "src/ethereum/arrow_glacier/fork.py"}, "content": {"type": ["function"], "name": ["process_transaction"], "text": ["Execute a transaction against the provided environment. This function processes the actions needed to execute a transaction. It decrements the sender's account after calculating the gas fee and refunds them the proper amount after execution. Calling contracts, deploying code, and incrementing nonces are all examples of actions that happen within this function or from a call made within this function. Accounts that are marked for deletion are processed and destroyed after execution. Parameters env : Environment for the Ethereum Virtual Machine. tx : Transaction to execute. Returns gas_left :  ethereum.base_types.U256 Remaining gas after execution. logs :  Tuple[ethereum.fork_types.Log, ...] Logs generated during execution."]}}, {"source": {"identifier": "ethereum.arrow_glacier.fork.validate_transaction", "specifier": 0, "path": "src/ethereum/arrow_glacier/fork.py"}, "content": {"type": ["function"], "name": ["validate_transaction"], "text": ["Verifies a transaction. The gas in a transaction gets used to pay for the intrinsic cost of operations, therefore if there is insufficient gas then it would not be possible to execute a transaction and it will be declared invalid. Additionally, the nonce of a transaction must not equal or exceed the limit defined in  EIP-2681 <https://eips.ethereum.org/EIPS/eip-2681> _. In practice, defining the limit as  2**64-1  has no impact because sending  2**64-1  transactions is improbable. It's not strictly impossible though,  2**64-1  transactions is the entire capacity of the Ethereum blockchain at 2022 gas limits for a little over 22 years. Parameters tx : Transaction to validate. Returns verified :  bool True if the transaction can be executed, or False otherwise."]}}, {"source": {"identifier": "ethereum.arrow_glacier.fork.calculate_intrinsic_cost", "specifier": 0, "path": "src/ethereum/arrow_glacier/fork.py"}, "content": {"type": ["function"], "name": ["calculate_intrinsic_cost"], "text": ["Calculates the gas that is charged before execution is started. The intrinsic cost of the transaction is charged before execution has begun. Functions/operations in the EVM cost money to execute so this intrinsic cost is for the operations that need to be paid for as part of the transaction. Data transfer, for example, is part of this intrinsic cost. It costs ether to send data over the wire and that ether is accounted for in the intrinsic cost calculated in this function. This intrinsic cost must be calculated and paid for before execution in order for all operations to be implemented. Parameters tx : Transaction to compute the intrinsic cost of. Returns verified :  ethereum.base_types.Uint The intrinsic cost of the transaction."]}}, {"source": {"identifier": "ethereum.arrow_glacier.fork.recover_sender", "specifier": 0, "path": "src/ethereum/arrow_glacier/fork.py"}, "content": {"type": ["function"], "name": ["recover_sender"], "text": ["Extracts the sender address from a transaction. The v, r, and s values are the three parts that make up the signature of a transaction. In order to recover the sender of a transaction the two components needed are the signature ( v ,  r , and  s ) and the signing hash of the transaction. The sender's public key can be obtained with these two values and therefore the sender address can be retrieved. Parameters tx : Transaction of interest. chain_id : ID of the executing chain. Returns sender :  ethereum.fork_types.Address The address of the account that signed the transaction."]}}, {"source": {"identifier": "ethereum.arrow_glacier.fork.signing_hash_pre155", "specifier": 0, "path": "src/ethereum/arrow_glacier/fork.py"}, "content": {"type": ["function"], "name": ["signing_hash_pre155"], "text": ["Compute the hash of a transaction used in a legacy (pre EIP 155) signature. Parameters tx : Transaction of interest. Returns hash :  ethereum.crypto.hash.Hash32 Hash of the transaction."]}}, {"source": {"identifier": "ethereum.arrow_glacier.fork.signing_hash_155", "specifier": 0, "path": "src/ethereum/arrow_glacier/fork.py"}, "content": {"type": ["function"], "name": ["signing_hash_155"], "text": ["Compute the hash of a transaction used in a EIP 155 signature. Parameters tx : Transaction of interest. Returns hash :  ethereum.crypto.hash.Hash32 Hash of the transaction."]}}, {"source": {"identifier": "ethereum.arrow_glacier.fork.signing_hash_2930", "specifier": 0, "path": "src/ethereum/arrow_glacier/fork.py"}, "content": {"type": ["function"], "name": ["signing_hash_2930"], "text": ["Compute the hash of a transaction used in a EIP 2930 signature. Parameters tx : Transaction of interest. Returns hash :  ethereum.crypto.hash.Hash32 Hash of the transaction."]}}, {"source": {"identifier": "ethereum.arrow_glacier.fork.signing_hash_1559", "specifier": 0, "path": "src/ethereum/arrow_glacier/fork.py"}, "content": {"type": ["function"], "name": ["signing_hash_1559"], "text": ["Compute the hash of a transaction used in a EIP 1559 signature. Parameters tx : Transaction of interest. Returns hash :  ethereum.crypto.hash.Hash32 Hash of the transaction."]}}, {"source": {"identifier": "ethereum.arrow_glacier.fork.compute_header_hash", "specifier": 0, "path": "src/ethereum/arrow_glacier/fork.py"}, "content": {"type": ["function"], "name": ["compute_header_hash"], "text": ["Computes the hash of a block header. The header hash of a block is the canonical hash that is used to refer to a specific block and completely distinguishes a block from another. keccak256  is a function that produces a 256 bit hash of any input. It also takes in any number of bytes as an input and produces a single hash for them. A hash is a completely unique output for a single input. So an input corresponds to one unique hash that can be used to identify the input exactly. Prior to using the  keccak256  hash function, the header must be encoded using the Recursive-Length Prefix. See :ref: rlp . RLP encoding the header converts it into a space-efficient format that allows for easy transfer of data between nodes. The purpose of RLP is to encode arbitrarily nested arrays of binary data, and RLP is the primary encoding method used to serialize objects in Ethereum's execution layer. The only purpose of RLP is to encode structure; encoding specific data types (e.g. strings, floats) is left up to higher-order protocols. Parameters header : Header of interest. Returns hash :  ethereum.crypto.hash.Hash32 Hash of the header."]}}, {"source": {"identifier": "ethereum.arrow_glacier.fork.check_gas_limit", "specifier": 0, "path": "src/ethereum/arrow_glacier/fork.py"}, "content": {"type": ["function"], "name": ["check_gas_limit"], "text": ["Validates the gas limit for a block. The bounds of the gas limit,  max_adjustment_delta , is set as the quotient of the parent block's gas limit and the GAS_LIMIT_ADJUSTMENT_FACTOR . Therefore, if the gas limit that is passed through as a parameter is greater than or equal to the  sum  of the parent's gas and the adjustment delta then the limit for gas is too high and fails this function's check. Similarly, if the limit is less than or equal to the  difference  of the parent's gas and the adjustment delta  or  the predefined  GAS_LIMIT_MINIMUM  then this function's check fails because the gas limit doesn't allow for a sufficient or reasonable amount of gas to be used on a block. Parameters gas_limit : Gas limit to validate. parent_gas_limit : Gas limit of the parent block. Returns check :  bool True if gas limit constraints are satisfied, False otherwise."]}}, {"source": {"identifier": "ethereum.arrow_glacier.fork.calculate_block_difficulty", "specifier": 0, "path": "src/ethereum/arrow_glacier/fork.py"}, "content": {"type": ["function"], "name": ["calculate_block_difficulty"], "text": ["Computes difficulty of a block using its header and parent header. The difficulty is determined by the time the block was created after its parent. The  offset  is calculated using the parent block's difficulty, parent_difficulty , and the timestamp between blocks. This offset is then added to the parent difficulty and is stored as the  difficulty variable. If the time between the block and its parent is too short, the offset will result in a positive number thus making the sum of parent_difficulty  and  offset  to be a greater value in order to avoid mass forking. But, if the time is long enough, then the offset results in a negative value making the block less difficult than its parent. The base standard for a block's difficulty is the predefined value set for the genesis block since it has no parent. So, a block can't be less difficult than the genesis block, therefore each block's difficulty is set to the maximum value between the calculated difficulty and the  GENESIS_DIFFICULTY . Parameters block_number : Block number of the block. block_timestamp : Timestamp of the block. parent_timestamp : Timestamp of the parent block. parent_difficulty : difficulty of the parent block. parent_has_ommers: does the parent have ommers. Returns difficulty :  ethereum.base_types.Uint Computed difficulty for a block."]}}, {"source": {"identifier": "ethereum.frontier.vm.precompiled_contracts.ripemd160", "specifier": 0, "path": "src/ethereum/frontier/vm/precompiled_contracts/ripemd160.py"}, "content": {"type": ["module"], "name": ["ethereum.frontier.vm.precompiled_contracts.ripemd160"], "text": ["Ethereum Virtual Machine (EVM) RIPEMD160 PRECOMPILED CONTRACT ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementation of the  RIPEMD160  precompiled contract."]}}, {"source": {"identifier": "ethereum.frontier.vm.precompiled_contracts.ripemd160.ripemd160", "specifier": 0, "path": "src/ethereum/frontier/vm/precompiled_contracts/ripemd160.py"}, "content": {"type": ["function"], "name": ["ripemd160"], "text": ["Writes the ripemd160 hash to output. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.spurious_dragon.utils.address", "specifier": 0, "path": "src/ethereum/spurious_dragon/utils/address.py"}, "content": {"type": ["module"], "name": ["ethereum.spurious_dragon.utils.address"], "text": ["Hardfork Utility Functions For Addresses ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Address specific functions used in this spurious dragon version of specification."]}}, {"source": {"identifier": "ethereum.spurious_dragon.utils.address.to_address", "specifier": 0, "path": "src/ethereum/spurious_dragon/utils/address.py"}, "content": {"type": ["function"], "name": ["to_address"], "text": ["Convert a Uint or U256 value to a valid address (20 bytes). Parameters data : The string to be converted to bytes. Returns address :  Address The obtained address."]}}, {"source": {"identifier": "ethereum.spurious_dragon.utils.address.compute_contract_address", "specifier": 0, "path": "src/ethereum/spurious_dragon/utils/address.py"}, "content": {"type": ["function"], "name": ["compute_contract_address"], "text": ["Computes address of the new account that needs to be created. Parameters address : The address of the account that wants to create the new account. nonce : The transaction count of the account that wants to create the new account. Returns address:  ethereum.spurious_dragon.fork_types.Address The computed address of the new account."]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.memory", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/memory.py"}, "content": {"type": ["module"], "name": ["ethereum.arrow_glacier.vm.memory"], "text": ["Ethereum Virtual Machine (EVM) Memory ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction EVM memory operations."]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.memory.memory_write", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/memory.py"}, "content": {"type": ["function"], "name": ["memory_write"], "text": ["Writes to memory. Parameters memory : Memory contents of the EVM. start_position : Starting pointer to the memory. value : Data to write to memory."]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.memory.memory_read_bytes", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/memory.py"}, "content": {"type": ["function"], "name": ["memory_read_bytes"], "text": ["Read bytes from memory. Parameters memory : Memory contents of the EVM. start_position : Starting pointer to the memory. size : Size of the data that needs to be read from  start_position . Returns data_bytes : Data read from memory."]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.memory.buffer_read", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/memory.py"}, "content": {"type": ["function"], "name": ["buffer_read"], "text": ["Read bytes from a buffer. Padding with zeros if neccesary. Parameters buffer : Memory contents of the EVM. start_position : Starting pointer to the memory. size : Size of the data that needs to be read from  start_position . Returns data_bytes : Data read from memory."]}}, {"source": {"identifier": "ethereum.frontier.vm.precompiled_contracts.sha256", "specifier": 0, "path": "src/ethereum/frontier/vm/precompiled_contracts/sha256.py"}, "content": {"type": ["module"], "name": ["ethereum.frontier.vm.precompiled_contracts.sha256"], "text": ["Ethereum Virtual Machine (EVM) SHA256 PRECOMPILED CONTRACT ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementation of the  SHA256  precompiled contract."]}}, {"source": {"identifier": "ethereum.frontier.vm.precompiled_contracts.sha256.sha256", "specifier": 0, "path": "src/ethereum/frontier/vm/precompiled_contracts/sha256.py"}, "content": {"type": ["function"], "name": ["sha256"], "text": ["Writes the sha256 hash to output. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.spurious_dragon.utils.message", "specifier": 0, "path": "src/ethereum/spurious_dragon/utils/message.py"}, "content": {"type": ["module"], "name": ["ethereum.spurious_dragon.utils.message"], "text": ["Hardfork Utility Functions For The Message Data-structure ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Message specific functions used in this spurious dragon version of specification."]}}, {"source": {"identifier": "ethereum.spurious_dragon.utils.message.prepare_message", "specifier": 0, "path": "src/ethereum/spurious_dragon/utils/message.py"}, "content": {"type": ["function"], "name": ["prepare_message"], "text": ["Execute a transaction against the provided environment. Parameters caller : Address which initiated the transaction target : Address whose code will be executed value : Value to be transferred. data : Array of bytes provided to the code in  target . gas : Gas provided for the code in  target . env : Environment for the Ethereum Virtual Machine. code_address : This is usually same as the  target  address except when an alternative accounts code needs to be executed. eg.  CALLCODE  calling a precompile. should_transfer_value : if True ETH should be transferred while executing a message call. Returns message:  ethereum.spurious_dragon.vm.Message Items containing contract creation or message call specific data."]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.exceptions", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/exceptions.py"}, "content": {"type": ["module"], "name": ["ethereum.arrow_glacier.vm.exceptions"], "text": ["Ethereum Virtual Machine (EVM) Exceptions ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Exceptions which cause the EVM to halt exceptionally."]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.exceptions.ExceptionalHalt", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/exceptions.py"}, "content": {"type": ["class"], "name": ["ExceptionalHalt"], "text": ["Indicates that the EVM has experienced an exceptional halt. This causes execution to immediately end with all gas being consumed."]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.exceptions.Revert", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/exceptions.py"}, "content": {"type": ["class"], "name": ["Revert"], "text": ["Raised by the  REVERT  opcode. Unlike other EVM exceptions this does not result in the consumption of all gas."]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.exceptions.StackUnderflowError", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/exceptions.py"}, "content": {"type": ["class"], "name": ["StackUnderflowError"], "text": ["Occurs when a pop is executed on an empty stack."]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.exceptions.StackOverflowError", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/exceptions.py"}, "content": {"type": ["class"], "name": ["StackOverflowError"], "text": ["Occurs when a push is executed on a stack at max capacity."]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.exceptions.OutOfGasError", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/exceptions.py"}, "content": {"type": ["class"], "name": ["OutOfGasError"], "text": ["Occurs when an operation costs more than the amount of gas left in the frame."]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.exceptions.InvalidOpcode", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/exceptions.py"}, "content": {"type": ["class"], "name": ["InvalidOpcode"], "text": ["Raised when an invalid opcode is encountered."]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.exceptions.InvalidJumpDestError", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/exceptions.py"}, "content": {"type": ["class"], "name": ["InvalidJumpDestError"], "text": ["Occurs when the destination of a jump operation doesn't meet any of the following criteria: The jump destination is less than the length of the code. The jump destination should have the  JUMPDEST  opcode (0x5B). The jump destination shouldn't be part of the data corresponding to PUSH-N  opcodes."]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.exceptions.StackDepthLimitError", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/exceptions.py"}, "content": {"type": ["class"], "name": ["StackDepthLimitError"], "text": ["Raised when the message depth is greater than  1024"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.exceptions.WriteInStaticContext", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/exceptions.py"}, "content": {"type": ["class"], "name": ["WriteInStaticContext"], "text": ["Raised when an attempt is made to modify the state while operating inside of a STATICCALL context."]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.exceptions.OutOfBoundsRead", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/exceptions.py"}, "content": {"type": ["class"], "name": ["OutOfBoundsRead"], "text": ["Raised when an attempt was made to read data beyond the boundaries of the buffer."]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.exceptions.InvalidParameter", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/exceptions.py"}, "content": {"type": ["class"], "name": ["InvalidParameter"], "text": ["Raised when invalid parameters are passed."]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.exceptions.InvalidContractPrefix", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/exceptions.py"}, "content": {"type": ["class"], "name": ["InvalidContractPrefix"], "text": ["Raised when the new contract code starts with 0xEF."]}}, {"source": {"identifier": "ethereum.frontier.vm.precompiled_contracts.ecrecover", "specifier": 0, "path": "src/ethereum/frontier/vm/precompiled_contracts/ecrecover.py"}, "content": {"type": ["module"], "name": ["ethereum.frontier.vm.precompiled_contracts.ecrecover"], "text": ["Ethereum Virtual Machine (EVM) ECRECOVER PRECOMPILED CONTRACT ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementation of the ECRECOVER precompiled contract."]}}, {"source": {"identifier": "ethereum.frontier.vm.precompiled_contracts.ecrecover.ecrecover", "specifier": 0, "path": "src/ethereum/frontier/vm/precompiled_contracts/ecrecover.py"}, "content": {"type": ["function"], "name": ["ecrecover"], "text": ["Decrypts the address using elliptic curve DSA recovery mechanism and writes the address to output. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.spurious_dragon.utils.hexadecimal", "specifier": 0, "path": "src/ethereum/spurious_dragon/utils/hexadecimal.py"}, "content": {"type": ["module"], "name": ["ethereum.spurious_dragon.utils.hexadecimal"], "text": ["Utility Functions For Hexadecimal Strings ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Hexadecimal utility functions used in this specification, specific to Spurious Dragon types."]}}, {"source": {"identifier": "ethereum.spurious_dragon.utils.hexadecimal.hex_to_root", "specifier": 0, "path": "src/ethereum/spurious_dragon/utils/hexadecimal.py"}, "content": {"type": ["function"], "name": ["hex_to_root"], "text": ["Convert hex string to trie root. Parameters hex_string : The hexadecimal string to be converted to trie root. Returns root :  Root Trie root obtained from the given hexadecimal string."]}}, {"source": {"identifier": "ethereum.spurious_dragon.utils.hexadecimal.hex_to_bloom", "specifier": 0, "path": "src/ethereum/spurious_dragon/utils/hexadecimal.py"}, "content": {"type": ["function"], "name": ["hex_to_bloom"], "text": ["Convert hex string to bloom. Parameters hex_string : The hexadecimal string to be converted to bloom. Returns bloom :  Bloom Bloom obtained from the given hexadecimal string."]}}, {"source": {"identifier": "ethereum.spurious_dragon.utils.hexadecimal.hex_to_address", "specifier": 0, "path": "src/ethereum/spurious_dragon/utils/hexadecimal.py"}, "content": {"type": ["function"], "name": ["hex_to_address"], "text": ["Convert hex string to Address (20 bytes). Parameters hex_string : The hexadecimal string to be converted to Address. Returns address :  Address The address obtained from the given hexadecimal string."]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/__init__.py"}, "content": {"type": ["module"], "name": ["ethereum.arrow_glacier.vm"], "text": ["Ethereum Virtual Machine (EVM) ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction The abstract computer which runs the code stored in an .fork_types.Account ."]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.__all__", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["__all__"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.Environment", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/__init__.py"}, "content": {"type": ["class"], "name": ["Environment"], "text": ["Items external to the virtual machine itself, provided by the environment."]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.Environment.caller", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["caller"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.Environment.block_hashes", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["block_hashes"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.Environment.origin", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["origin"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.Environment.coinbase", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["coinbase"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.Environment.number", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["number"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.Environment.base_fee_per_gas", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["base_fee_per_gas"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.Environment.gas_limit", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["gas_limit"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.Environment.gas_price", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["gas_price"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.Environment.time", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["time"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.Environment.difficulty", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["difficulty"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.Environment.state", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["state"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.Environment.chain_id", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["chain_id"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.Message", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/__init__.py"}, "content": {"type": ["class"], "name": ["Message"], "text": ["Items that are used by contract creation or message call."]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.Message.caller", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["caller"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.Message.target", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["target"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.Message.current_target", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["current_target"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.Message.gas", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["gas"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.Message.value", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["value"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.Message.data", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["data"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.Message.code_address", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["code_address"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.Message.code", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["code"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.Message.depth", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["depth"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.Message.should_transfer_value", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["should_transfer_value"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.Message.is_static", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["is_static"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.Message.accessed_addresses", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["accessed_addresses"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.Message.accessed_storage_keys", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["accessed_storage_keys"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.Evm", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/__init__.py"}, "content": {"type": ["class"], "name": ["Evm"], "text": ["The internal state of the virtual machine."]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.Evm.pc", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["pc"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.Evm.stack", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["stack"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.Evm.memory", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["memory"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.Evm.code", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["code"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.Evm.gas_left", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["gas_left"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.Evm.env", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["env"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.Evm.valid_jump_destinations", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["valid_jump_destinations"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.Evm.logs", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["logs"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.Evm.refund_counter", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["refund_counter"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.Evm.running", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["running"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.Evm.message", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["message"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.Evm.output", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["output"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.Evm.accounts_to_delete", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["accounts_to_delete"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.Evm.touched_accounts", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["touched_accounts"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.Evm.has_erred", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["has_erred"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.Evm.return_data", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["return_data"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.Evm.error", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["error"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.Evm.accessed_addresses", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["accessed_addresses"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.Evm.accessed_storage_keys", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["accessed_storage_keys"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.incorporate_child_on_success", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/__init__.py"}, "content": {"type": ["function"], "name": ["incorporate_child_on_success"], "text": ["Incorporate the state of a successful  child_evm  into the parent  evm . Parameters evm : The parent  EVM . child_evm : The child evm to incorporate."]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.incorporate_child_on_error", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/__init__.py"}, "content": {"type": ["function"], "name": ["incorporate_child_on_error"], "text": ["Incorporate the state of an unsuccessful  child_evm  into the parent  evm . Parameters evm : The parent  EVM . child_evm : The child evm to incorporate."]}}, {"source": {"identifier": "ethereum.frontier.vm.precompiled_contracts.identity", "specifier": 0, "path": "src/ethereum/frontier/vm/precompiled_contracts/identity.py"}, "content": {"type": ["module"], "name": ["ethereum.frontier.vm.precompiled_contracts.identity"], "text": ["Ethereum Virtual Machine (EVM) IDENTITY PRECOMPILED CONTRACT ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementation of the  IDENTITY  precompiled contract."]}}, {"source": {"identifier": "ethereum.frontier.vm.precompiled_contracts.identity.identity", "specifier": 0, "path": "src/ethereum/frontier/vm/precompiled_contracts/identity.py"}, "content": {"type": ["function"], "name": ["identity"], "text": ["Writes the message data to output. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.constantinople.state", "specifier": 0, "path": "src/ethereum/constantinople/state.py"}, "content": {"type": ["module"], "name": ["ethereum.constantinople.state"], "text": ["State ^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction The state contains all information that is preserved between transactions. It consists of a main account trie and storage tries for each contract. There is a distinction between an account that does not exist and EMPTY_ACCOUNT ."]}}, {"source": {"identifier": "ethereum.constantinople.state.State", "specifier": 0, "path": "src/ethereum/constantinople/state.py"}, "content": {"type": ["class"], "name": ["State"], "text": ["Contains all information that is preserved between transactions."]}}, {"source": {"identifier": "ethereum.constantinople.state.State._main_trie", "specifier": 0, "path": "src/ethereum/constantinople/state.py"}, "content": {"type": ["attribute"], "name": ["_main_trie"]}}, {"source": {"identifier": "ethereum.constantinople.state.State._storage_tries", "specifier": 0, "path": "src/ethereum/constantinople/state.py"}, "content": {"type": ["attribute"], "name": ["_storage_tries"]}}, {"source": {"identifier": "ethereum.constantinople.state.State._snapshots", "specifier": 0, "path": "src/ethereum/constantinople/state.py"}, "content": {"type": ["attribute"], "name": ["_snapshots"]}}, {"source": {"identifier": "ethereum.constantinople.state.close_state", "specifier": 0, "path": "src/ethereum/constantinople/state.py"}, "content": {"type": ["function"], "name": ["close_state"], "text": ["Free resources held by the state. Used by optimized implementations to release file descriptors."]}}, {"source": {"identifier": "ethereum.constantinople.state.begin_transaction", "specifier": 0, "path": "src/ethereum/constantinople/state.py"}, "content": {"type": ["function"], "name": ["begin_transaction"], "text": ["Start a state transaction. Transactions are entirely implicit and can be nested. It is not possible to calculate the state root during a transaction. Parameters state : State The state."]}}, {"source": {"identifier": "ethereum.constantinople.state.commit_transaction", "specifier": 0, "path": "src/ethereum/constantinople/state.py"}, "content": {"type": ["function"], "name": ["commit_transaction"], "text": ["Commit a state transaction. Parameters state : State The state."]}}, {"source": {"identifier": "ethereum.constantinople.state.rollback_transaction", "specifier": 0, "path": "src/ethereum/constantinople/state.py"}, "content": {"type": ["function"], "name": ["rollback_transaction"], "text": ["Rollback a state transaction, resetting the state to the point when the corresponding  start_transaction()  call was made. Parameters state : State The state."]}}, {"source": {"identifier": "ethereum.constantinople.state.get_account", "specifier": 0, "path": "src/ethereum/constantinople/state.py"}, "content": {"type": ["function"], "name": ["get_account"], "text": ["Get the  Account  object at an address. Returns  EMPTY_ACCOUNT  if there is no account at the address. Use  get_account_optional()  if you care about the difference between a non-existent account and  EMPTY_ACCOUNT . Parameters state:  State The state address :  Address Address to lookup. Returns account :  Account Account at address."]}}, {"source": {"identifier": "ethereum.constantinople.state.get_account_optional", "specifier": 0, "path": "src/ethereum/constantinople/state.py"}, "content": {"type": ["function"], "name": ["get_account_optional"], "text": ["Get the  Account  object at an address. Returns  None  (rather than EMPTY_ACCOUNT ) if there is no account at the address. Parameters state:  State The state address :  Address Address to lookup. Returns account :  Account Account at address."]}}, {"source": {"identifier": "ethereum.constantinople.state.set_account", "specifier": 0, "path": "src/ethereum/constantinople/state.py"}, "content": {"type": ["function"], "name": ["set_account"], "text": ["Set the  Account  object at an address. Setting to  None  deletes the account (but not its storage, see  destroy_account() ). Parameters state:  State The state address :  Address Address to set. account :  Account Account to set at address."]}}, {"source": {"identifier": "ethereum.constantinople.state.destroy_account", "specifier": 0, "path": "src/ethereum/constantinople/state.py"}, "content": {"type": ["function"], "name": ["destroy_account"], "text": ["Completely remove the account at  address  and all of its storage. This function is made available exclusively for the  SELFDESTRUCT opcode. It is expected that  SELFDESTRUCT  will be disabled in a future hardfork and this function will be removed. Parameters state:  State The state address :  Address Address of account to destroy."]}}, {"source": {"identifier": "ethereum.constantinople.state.destroy_storage", "specifier": 0, "path": "src/ethereum/constantinople/state.py"}, "content": {"type": ["function"], "name": ["destroy_storage"], "text": ["Completely remove the storage at  address . Parameters state:  State The state address :  Address Address of account whose storage is to be deleted."]}}, {"source": {"identifier": "ethereum.constantinople.state.get_storage", "specifier": 0, "path": "src/ethereum/constantinople/state.py"}, "content": {"type": ["function"], "name": ["get_storage"], "text": ["Get a value at a storage key on an account. Returns  U256(0)  if the storage key has not been set previously. Parameters state:  State The state address :  Address Address of the account. key :  Bytes Key to lookup. Returns value :  U256 Value at the key."]}}, {"source": {"identifier": "ethereum.constantinople.state.set_storage", "specifier": 0, "path": "src/ethereum/constantinople/state.py"}, "content": {"type": ["function"], "name": ["set_storage"], "text": ["Set a value at a storage key on an account. Setting to  U256(0)  deletes the key. Parameters state:  State The state address :  Address Address of the account. key :  Bytes Key to set. value :  U256 Value to set at the key."]}}, {"source": {"identifier": "ethereum.constantinople.state.storage_root", "specifier": 0, "path": "src/ethereum/constantinople/state.py"}, "content": {"type": ["function"], "name": ["storage_root"], "text": ["Calculate the storage root of an account. Parameters state: The state address : Address of the account. Returns root :  Root Storage root of the account."]}}, {"source": {"identifier": "ethereum.constantinople.state.state_root", "specifier": 0, "path": "src/ethereum/constantinople/state.py"}, "content": {"type": ["function"], "name": ["state_root"], "text": ["Calculate the state root. Parameters state: The current state. Returns root :  Root The state root."]}}, {"source": {"identifier": "ethereum.constantinople.state.account_exists", "specifier": 0, "path": "src/ethereum/constantinople/state.py"}, "content": {"type": ["function"], "name": ["account_exists"], "text": ["Checks if an account exists in the state trie Parameters state: The state address: Address of the account that needs to be checked. Returns account_exists :  bool True if account exists in the state trie, False otherwise"]}}, {"source": {"identifier": "ethereum.constantinople.state.account_has_code_or_nonce", "specifier": 0, "path": "src/ethereum/constantinople/state.py"}, "content": {"type": ["function"], "name": ["account_has_code_or_nonce"], "text": ["Checks if an account has non zero nonce or non empty code Parameters state: The state address: Address of the account that needs to be checked. Returns has_code_or_nonce :  bool True if if an account has non zero nonce or non empty code, False otherwise."]}}, {"source": {"identifier": "ethereum.constantinople.state.is_account_empty", "specifier": 0, "path": "src/ethereum/constantinople/state.py"}, "content": {"type": ["function"], "name": ["is_account_empty"], "text": ["Checks if an account has zero nonce, empty code and zero balance. Parameters state: The state address: Address of the account that needs to be checked. Returns is_empty :  bool True if if an account has zero nonce, empty code and zero balance, False otherwise."]}}, {"source": {"identifier": "ethereum.constantinople.state.account_exists_and_is_empty", "specifier": 0, "path": "src/ethereum/constantinople/state.py"}, "content": {"type": ["function"], "name": ["account_exists_and_is_empty"], "text": ["Checks if an account exists and has zero nonce, empty code and zero balance. Parameters state: The state address: Address of the account that needs to be checked. Returns exists_and_is_empty :  bool True if an account exists and has zero nonce, empty code and zero balance, False otherwise."]}}, {"source": {"identifier": "ethereum.constantinople.state.is_account_alive", "specifier": 0, "path": "src/ethereum/constantinople/state.py"}, "content": {"type": ["function"], "name": ["is_account_alive"], "text": ["Check whether is an account is both in the state and non empty. Parameters state: The state address: Address of the account that needs to be checked. Returns is_alive :  bool True if the account is alive."]}}, {"source": {"identifier": "ethereum.constantinople.state.modify_state", "specifier": 0, "path": "src/ethereum/constantinople/state.py"}, "content": {"type": ["function"], "name": ["modify_state"], "text": ["Modify an  Account  in the  State ."]}}, {"source": {"identifier": "ethereum.constantinople.state.move_ether", "specifier": 0, "path": "src/ethereum/constantinople/state.py"}, "content": {"type": ["function"], "name": ["move_ether"], "text": ["Move funds between accounts."]}}, {"source": {"identifier": "ethereum.constantinople.state.set_account_balance", "specifier": 0, "path": "src/ethereum/constantinople/state.py"}, "content": {"type": ["function"], "name": ["set_account_balance"], "text": ["Sets the balance of an account. Parameters state: The current state. address: Address of the account whose nonce needs to be incremented. amount: The amount that needs to set in balance."]}}, {"source": {"identifier": "ethereum.constantinople.state.touch_account", "specifier": 0, "path": "src/ethereum/constantinople/state.py"}, "content": {"type": ["function"], "name": ["touch_account"], "text": ["Initializes an account to state. Parameters state: The current state. address: The address of the account that need to initialised."]}}, {"source": {"identifier": "ethereum.constantinople.state.increment_nonce", "specifier": 0, "path": "src/ethereum/constantinople/state.py"}, "content": {"type": ["function"], "name": ["increment_nonce"], "text": ["Increments the nonce of an account. Parameters state: The current state. address: Address of the account whose nonce needs to be incremented."]}}, {"source": {"identifier": "ethereum.constantinople.state.set_code", "specifier": 0, "path": "src/ethereum/constantinople/state.py"}, "content": {"type": ["function"], "name": ["set_code"], "text": ["Sets Account code. Parameters state: The current state. address: Address of the account whose code needs to be update. code: The bytecode that needs to be set."]}}, {"source": {"identifier": "ethereum.constantinople.state.create_ether", "specifier": 0, "path": "src/ethereum/constantinople/state.py"}, "content": {"type": ["function"], "name": ["create_ether"], "text": ["Add newly created ether to an account. Parameters state: The current state. address: Address of the account to which ether is added. amount: The amount of ether to be added to the account of interest."]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.runtime", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/runtime.py"}, "content": {"type": ["module"], "name": ["ethereum.arrow_glacier.vm.runtime"], "text": ["Ethereum Virtual Machine (EVM) Runtime Operations ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Runtime related operations used while executing EVM code."]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.runtime.get_valid_jump_destinations", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/runtime.py"}, "content": {"type": ["function"], "name": ["get_valid_jump_destinations"], "text": ["Analyze the evm code to obtain the set of valid jump destinations. Valid jump destinations are defined as follows: * The jump destination is less than the length of the code. * The jump destination should have the  JUMPDEST  opcode (0x5B). * The jump destination shouldn't be part of the data corresponding to PUSH-N  opcodes. Note - Jump destinations are 0-indexed. Parameters code : The EVM code which is to be executed. Returns valid_jump_destinations:  Set[Uint] The set of valid jump destinations in the code."]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.memory", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/memory.py"}, "content": {"type": ["module"], "name": ["ethereum.frontier.vm.instructions.memory"], "text": ["Ethereum Virtual Machine (EVM) Memory Instructions ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementations of the EVM Memory instructions."]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.memory.mstore", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/memory.py"}, "content": {"type": ["function"], "name": ["mstore"], "text": ["Stores a word to memory. This also expands the memory, if the memory is insufficient to store the word. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.memory.mstore8", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/memory.py"}, "content": {"type": ["function"], "name": ["mstore8"], "text": ["Stores a byte to memory. This also expands the memory, if the memory is insufficient to store the word. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.memory.mload", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/memory.py"}, "content": {"type": ["function"], "name": ["mload"], "text": ["Load word from memory. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.memory.msize", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/memory.py"}, "content": {"type": ["function"], "name": ["msize"], "text": ["Push the size of active memory in bytes onto the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.constantinople", "specifier": 0, "path": "src/ethereum/constantinople/__init__.py"}, "content": {"type": ["module"], "name": ["ethereum.constantinople"], "text": ["Ethereum Constantinople Hardfork ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ The Seventh Ethereum hardfork."]}}, {"source": {"identifier": "ethereum.constantinople.MAINNET_FORK_BLOCK", "specifier": 0, "path": "src/ethereum/constantinople/__init__.py"}, "content": {"type": ["attribute"], "name": ["MAINNET_FORK_BLOCK"]}}, {"source": {"identifier": "ethereum.constantinople.bloom", "specifier": 0, "path": "src/ethereum/constantinople/bloom.py"}, "content": {"type": ["module"], "name": ["ethereum.constantinople.bloom"], "text": ["Ethereum Logs Bloom ^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction This modules defines functions for calculating bloom filters of logs. For the general theory of bloom filters see e.g.  Wikipedia <https://en.wikipedia.org/wiki/Bloom_filter> _. Bloom filters are used to allow for efficient searching of logs by address and/or topic, by rapidly eliminating blocks and reciepts from their search."]}}, {"source": {"identifier": "ethereum.constantinople.bloom.add_to_bloom", "specifier": 0, "path": "src/ethereum/constantinople/bloom.py"}, "content": {"type": ["function"], "name": ["add_to_bloom"], "text": ["Add a bloom entry to the bloom filter ( bloom ). The number of hash functions used is 3. They are calculated by taking the least significant 11 bits from the first 3 16-bit words of the keccak_256()  hash of  bloom_entry . Parameters bloom : The bloom filter. bloom_entry : An entry which is to be added to bloom filter."]}}, {"source": {"identifier": "ethereum.constantinople.bloom.logs_bloom", "specifier": 0, "path": "src/ethereum/constantinople/bloom.py"}, "content": {"type": ["function"], "name": ["logs_bloom"], "text": ["Obtain the logs bloom from a list of log entries. The address and each topic of a log are added to the bloom filter. Parameters logs : List of logs for which the logs bloom is to be obtained. Returns logs_bloom :  Bloom The logs bloom obtained which is 256 bytes with some bits set as per the caller address and the log topics."]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.interpreter", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/interpreter.py"}, "content": {"type": ["module"], "name": ["ethereum.arrow_glacier.vm.interpreter"], "text": ["Ethereum Virtual Machine (EVM) Interpreter ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction A straightforward interpreter that executes EVM code."]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.interpreter.STACK_DEPTH_LIMIT", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/interpreter.py"}, "content": {"type": ["attribute"], "name": ["STACK_DEPTH_LIMIT"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.interpreter.MAX_CODE_SIZE", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/interpreter.py"}, "content": {"type": ["attribute"], "name": ["MAX_CODE_SIZE"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.interpreter.MessageCallOutput", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/interpreter.py"}, "content": {"type": ["class"], "name": ["MessageCallOutput"], "text": ["Output of a particular message call Contains the following:   1. `gas_left`: remaining gas after execution.\n  2. `refund_counter`: gas to refund after execution.\n  3. `logs`: list of `Log` generated during execution.\n  4. `accounts_to_delete`: Contracts which have self-destructed.\n  5. `touched_accounts`: Accounts that have been touched.\n  6. `has_erred`: True if execution has caused an error.\n"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.interpreter.MessageCallOutput.gas_left", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/interpreter.py"}, "content": {"type": ["attribute"], "name": ["gas_left"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.interpreter.MessageCallOutput.refund_counter", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/interpreter.py"}, "content": {"type": ["attribute"], "name": ["refund_counter"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.interpreter.MessageCallOutput.logs", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/interpreter.py"}, "content": {"type": ["attribute"], "name": ["logs"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.interpreter.MessageCallOutput.accounts_to_delete", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/interpreter.py"}, "content": {"type": ["attribute"], "name": ["accounts_to_delete"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.interpreter.MessageCallOutput.touched_accounts", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/interpreter.py"}, "content": {"type": ["attribute"], "name": ["touched_accounts"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.interpreter.MessageCallOutput.has_erred", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/interpreter.py"}, "content": {"type": ["attribute"], "name": ["has_erred"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.interpreter.process_message_call", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/interpreter.py"}, "content": {"type": ["function"], "name": ["process_message_call"], "text": ["If  message.current  is empty then it creates a smart contract else it executes a call from the  message.caller  to the  message.target . Parameters message : Transaction specific items. env : External items required for EVM execution. Returns output :  MessageCallOutput Output of the message call"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.interpreter.process_create_message", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/interpreter.py"}, "content": {"type": ["function"], "name": ["process_create_message"], "text": ["Executes a call to create a smart contract. Parameters message : Transaction specific items. env : External items required for EVM execution. Returns evm: :py:class: ~ethereum.london.vm.Evm Items containing execution specific objects."]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.interpreter.process_message", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/interpreter.py"}, "content": {"type": ["function"], "name": ["process_message"], "text": ["Executes a call to create a smart contract. Parameters message : Transaction specific items. env : External items required for EVM execution. Returns evm: :py:class: ~ethereum.london.vm.Evm Items containing execution specific objects"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.interpreter.execute_code", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/interpreter.py"}, "content": {"type": ["function"], "name": ["execute_code"], "text": ["Executes bytecode present in the  message . Parameters message : Transaction specific items. env : External items required for EVM execution. Returns evm:  ethereum.vm.EVM Items containing execution specific objects"]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.system", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/system.py"}, "content": {"type": ["module"], "name": ["ethereum.frontier.vm.instructions.system"], "text": ["Ethereum Virtual Machine (EVM) System Instructions ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementations of the EVM system related instructions."]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.system.create", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/system.py"}, "content": {"type": ["function"], "name": ["create"], "text": ["Creates a new account with associated code. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.system.return_", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/system.py"}, "content": {"type": ["function"], "name": ["return_"], "text": ["Halts execution returning output data. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.system.generic_call", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/system.py"}, "content": {"type": ["function"], "name": ["generic_call"], "text": ["Perform the core logic of the  CALL*  family of opcodes."]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.system.call", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/system.py"}, "content": {"type": ["function"], "name": ["call"], "text": ["Message-call into an account. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.system.callcode", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/system.py"}, "content": {"type": ["function"], "name": ["callcode"], "text": ["Message-call into this account with alternative account\u2019s code. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.system.selfdestruct", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/system.py"}, "content": {"type": ["function"], "name": ["selfdestruct"], "text": ["Halt execution and register account for later deletion. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.constantinople.fork_types", "specifier": 0, "path": "src/ethereum/constantinople/fork_types.py"}, "content": {"type": ["module"], "name": ["ethereum.constantinople.fork_types"], "text": ["Ethereum Types ^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Types re-used throughout the specification, which are specific to Ethereum."]}}, {"source": {"identifier": "ethereum.constantinople.fork_types.Address", "specifier": 0, "path": "src/ethereum/constantinople/fork_types.py"}, "content": {"type": ["attribute"], "name": ["Address"]}}, {"source": {"identifier": "ethereum.constantinople.fork_types.Root", "specifier": 0, "path": "src/ethereum/constantinople/fork_types.py"}, "content": {"type": ["attribute"], "name": ["Root"]}}, {"source": {"identifier": "ethereum.constantinople.fork_types.Bloom", "specifier": 0, "path": "src/ethereum/constantinople/fork_types.py"}, "content": {"type": ["attribute"], "name": ["Bloom"]}}, {"source": {"identifier": "ethereum.constantinople.fork_types.TX_BASE_COST", "specifier": 0, "path": "src/ethereum/constantinople/fork_types.py"}, "content": {"type": ["attribute"], "name": ["TX_BASE_COST"]}}, {"source": {"identifier": "ethereum.constantinople.fork_types.TX_DATA_COST_PER_NON_ZERO", "specifier": 0, "path": "src/ethereum/constantinople/fork_types.py"}, "content": {"type": ["attribute"], "name": ["TX_DATA_COST_PER_NON_ZERO"]}}, {"source": {"identifier": "ethereum.constantinople.fork_types.TX_DATA_COST_PER_ZERO", "specifier": 0, "path": "src/ethereum/constantinople/fork_types.py"}, "content": {"type": ["attribute"], "name": ["TX_DATA_COST_PER_ZERO"]}}, {"source": {"identifier": "ethereum.constantinople.fork_types.TX_CREATE_COST", "specifier": 0, "path": "src/ethereum/constantinople/fork_types.py"}, "content": {"type": ["attribute"], "name": ["TX_CREATE_COST"]}}, {"source": {"identifier": "ethereum.constantinople.fork_types.Transaction", "specifier": 0, "path": "src/ethereum/constantinople/fork_types.py"}, "content": {"type": ["class"], "name": ["Transaction"], "text": ["Atomic operation performed on the block chain."]}}, {"source": {"identifier": "ethereum.constantinople.fork_types.Transaction.nonce", "specifier": 0, "path": "src/ethereum/constantinople/fork_types.py"}, "content": {"type": ["attribute"], "name": ["nonce"]}}, {"source": {"identifier": "ethereum.constantinople.fork_types.Transaction.gas_price", "specifier": 0, "path": "src/ethereum/constantinople/fork_types.py"}, "content": {"type": ["attribute"], "name": ["gas_price"]}}, {"source": {"identifier": "ethereum.constantinople.fork_types.Transaction.gas", "specifier": 0, "path": "src/ethereum/constantinople/fork_types.py"}, "content": {"type": ["attribute"], "name": ["gas"]}}, {"source": {"identifier": "ethereum.constantinople.fork_types.Transaction.to", "specifier": 0, "path": "src/ethereum/constantinople/fork_types.py"}, "content": {"type": ["attribute"], "name": ["to"]}}, {"source": {"identifier": "ethereum.constantinople.fork_types.Transaction.value", "specifier": 0, "path": "src/ethereum/constantinople/fork_types.py"}, "content": {"type": ["attribute"], "name": ["value"]}}, {"source": {"identifier": "ethereum.constantinople.fork_types.Transaction.data", "specifier": 0, "path": "src/ethereum/constantinople/fork_types.py"}, "content": {"type": ["attribute"], "name": ["data"]}}, {"source": {"identifier": "ethereum.constantinople.fork_types.Transaction.v", "specifier": 0, "path": "src/ethereum/constantinople/fork_types.py"}, "content": {"type": ["attribute"], "name": ["v"]}}, {"source": {"identifier": "ethereum.constantinople.fork_types.Transaction.r", "specifier": 0, "path": "src/ethereum/constantinople/fork_types.py"}, "content": {"type": ["attribute"], "name": ["r"]}}, {"source": {"identifier": "ethereum.constantinople.fork_types.Transaction.s", "specifier": 0, "path": "src/ethereum/constantinople/fork_types.py"}, "content": {"type": ["attribute"], "name": ["s"]}}, {"source": {"identifier": "ethereum.constantinople.fork_types.Account", "specifier": 0, "path": "src/ethereum/constantinople/fork_types.py"}, "content": {"type": ["class"], "name": ["Account"], "text": ["State associated with an address."]}}, {"source": {"identifier": "ethereum.constantinople.fork_types.Account.nonce", "specifier": 0, "path": "src/ethereum/constantinople/fork_types.py"}, "content": {"type": ["attribute"], "name": ["nonce"]}}, {"source": {"identifier": "ethereum.constantinople.fork_types.Account.balance", "specifier": 0, "path": "src/ethereum/constantinople/fork_types.py"}, "content": {"type": ["attribute"], "name": ["balance"]}}, {"source": {"identifier": "ethereum.constantinople.fork_types.Account.code", "specifier": 0, "path": "src/ethereum/constantinople/fork_types.py"}, "content": {"type": ["attribute"], "name": ["code"]}}, {"source": {"identifier": "ethereum.constantinople.fork_types.EMPTY_ACCOUNT", "specifier": 0, "path": "src/ethereum/constantinople/fork_types.py"}, "content": {"type": ["attribute"], "name": ["EMPTY_ACCOUNT"]}}, {"source": {"identifier": "ethereum.constantinople.fork_types.encode_account", "specifier": 0, "path": "src/ethereum/constantinople/fork_types.py"}, "content": {"type": ["function"], "name": ["encode_account"], "text": ["Encode  Account  dataclass. Storage is not stored in the  Account  dataclass, so  Accounts  cannot be encoded with providing a storage root."]}}, {"source": {"identifier": "ethereum.constantinople.fork_types.Header", "specifier": 0, "path": "src/ethereum/constantinople/fork_types.py"}, "content": {"type": ["class"], "name": ["Header"], "text": ["Header portion of a block on the chain."]}}, {"source": {"identifier": "ethereum.constantinople.fork_types.Header.parent_hash", "specifier": 0, "path": "src/ethereum/constantinople/fork_types.py"}, "content": {"type": ["attribute"], "name": ["parent_hash"]}}, {"source": {"identifier": "ethereum.constantinople.fork_types.Header.ommers_hash", "specifier": 0, "path": "src/ethereum/constantinople/fork_types.py"}, "content": {"type": ["attribute"], "name": ["ommers_hash"]}}, {"source": {"identifier": "ethereum.constantinople.fork_types.Header.coinbase", "specifier": 0, "path": "src/ethereum/constantinople/fork_types.py"}, "content": {"type": ["attribute"], "name": ["coinbase"]}}, {"source": {"identifier": "ethereum.constantinople.fork_types.Header.state_root", "specifier": 0, "path": "src/ethereum/constantinople/fork_types.py"}, "content": {"type": ["attribute"], "name": ["state_root"]}}, {"source": {"identifier": "ethereum.constantinople.fork_types.Header.transactions_root", "specifier": 0, "path": "src/ethereum/constantinople/fork_types.py"}, "content": {"type": ["attribute"], "name": ["transactions_root"]}}, {"source": {"identifier": "ethereum.constantinople.fork_types.Header.receipt_root", "specifier": 0, "path": "src/ethereum/constantinople/fork_types.py"}, "content": {"type": ["attribute"], "name": ["receipt_root"]}}, {"source": {"identifier": "ethereum.constantinople.fork_types.Header.bloom", "specifier": 0, "path": "src/ethereum/constantinople/fork_types.py"}, "content": {"type": ["attribute"], "name": ["bloom"]}}, {"source": {"identifier": "ethereum.constantinople.fork_types.Header.difficulty", "specifier": 0, "path": "src/ethereum/constantinople/fork_types.py"}, "content": {"type": ["attribute"], "name": ["difficulty"]}}, {"source": {"identifier": "ethereum.constantinople.fork_types.Header.number", "specifier": 0, "path": "src/ethereum/constantinople/fork_types.py"}, "content": {"type": ["attribute"], "name": ["number"]}}, {"source": {"identifier": "ethereum.constantinople.fork_types.Header.gas_limit", "specifier": 0, "path": "src/ethereum/constantinople/fork_types.py"}, "content": {"type": ["attribute"], "name": ["gas_limit"]}}, {"source": {"identifier": "ethereum.constantinople.fork_types.Header.gas_used", "specifier": 0, "path": "src/ethereum/constantinople/fork_types.py"}, "content": {"type": ["attribute"], "name": ["gas_used"]}}, {"source": {"identifier": "ethereum.constantinople.fork_types.Header.timestamp", "specifier": 0, "path": "src/ethereum/constantinople/fork_types.py"}, "content": {"type": ["attribute"], "name": ["timestamp"]}}, {"source": {"identifier": "ethereum.constantinople.fork_types.Header.extra_data", "specifier": 0, "path": "src/ethereum/constantinople/fork_types.py"}, "content": {"type": ["attribute"], "name": ["extra_data"]}}, {"source": {"identifier": "ethereum.constantinople.fork_types.Header.mix_digest", "specifier": 0, "path": "src/ethereum/constantinople/fork_types.py"}, "content": {"type": ["attribute"], "name": ["mix_digest"]}}, {"source": {"identifier": "ethereum.constantinople.fork_types.Header.nonce", "specifier": 0, "path": "src/ethereum/constantinople/fork_types.py"}, "content": {"type": ["attribute"], "name": ["nonce"]}}, {"source": {"identifier": "ethereum.constantinople.fork_types.Block", "specifier": 0, "path": "src/ethereum/constantinople/fork_types.py"}, "content": {"type": ["class"], "name": ["Block"], "text": ["A complete block."]}}, {"source": {"identifier": "ethereum.constantinople.fork_types.Block.header", "specifier": 0, "path": "src/ethereum/constantinople/fork_types.py"}, "content": {"type": ["attribute"], "name": ["header"]}}, {"source": {"identifier": "ethereum.constantinople.fork_types.Block.transactions", "specifier": 0, "path": "src/ethereum/constantinople/fork_types.py"}, "content": {"type": ["attribute"], "name": ["transactions"]}}, {"source": {"identifier": "ethereum.constantinople.fork_types.Block.ommers", "specifier": 0, "path": "src/ethereum/constantinople/fork_types.py"}, "content": {"type": ["attribute"], "name": ["ommers"]}}, {"source": {"identifier": "ethereum.constantinople.fork_types.Log", "specifier": 0, "path": "src/ethereum/constantinople/fork_types.py"}, "content": {"type": ["class"], "name": ["Log"], "text": ["Data record produced during the execution of a transaction."]}}, {"source": {"identifier": "ethereum.constantinople.fork_types.Log.address", "specifier": 0, "path": "src/ethereum/constantinople/fork_types.py"}, "content": {"type": ["attribute"], "name": ["address"]}}, {"source": {"identifier": "ethereum.constantinople.fork_types.Log.topics", "specifier": 0, "path": "src/ethereum/constantinople/fork_types.py"}, "content": {"type": ["attribute"], "name": ["topics"]}}, {"source": {"identifier": "ethereum.constantinople.fork_types.Log.data", "specifier": 0, "path": "src/ethereum/constantinople/fork_types.py"}, "content": {"type": ["attribute"], "name": ["data"]}}, {"source": {"identifier": "ethereum.constantinople.fork_types.Receipt", "specifier": 0, "path": "src/ethereum/constantinople/fork_types.py"}, "content": {"type": ["class"], "name": ["Receipt"], "text": ["Result of a transaction."]}}, {"source": {"identifier": "ethereum.constantinople.fork_types.Receipt.succeeded", "specifier": 0, "path": "src/ethereum/constantinople/fork_types.py"}, "content": {"type": ["attribute"], "name": ["succeeded"]}}, {"source": {"identifier": "ethereum.constantinople.fork_types.Receipt.cumulative_gas_used", "specifier": 0, "path": "src/ethereum/constantinople/fork_types.py"}, "content": {"type": ["attribute"], "name": ["cumulative_gas_used"]}}, {"source": {"identifier": "ethereum.constantinople.fork_types.Receipt.bloom", "specifier": 0, "path": "src/ethereum/constantinople/fork_types.py"}, "content": {"type": ["attribute"], "name": ["bloom"]}}, {"source": {"identifier": "ethereum.constantinople.fork_types.Receipt.logs", "specifier": 0, "path": "src/ethereum/constantinople/fork_types.py"}, "content": {"type": ["attribute"], "name": ["logs"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.stack", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/stack.py"}, "content": {"type": ["module"], "name": ["ethereum.arrow_glacier.vm.stack"], "text": ["Ethereum Virtual Machine (EVM) Stack ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementation of the stack operators for the EVM."]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.stack.pop", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/stack.py"}, "content": {"type": ["function"], "name": ["pop"], "text": ["Pops the top item off of  stack . Parameters stack : EVM stack. Returns value :  U256 The top element on the stack."]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.stack.push", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/stack.py"}, "content": {"type": ["function"], "name": ["push"], "text": ["Pushes  value  onto  stack . Parameters stack : EVM stack. value : Item to be pushed onto  stack ."]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/__init__.py"}, "content": {"type": ["module"], "name": ["ethereum.frontier.vm.instructions"], "text": ["EVM Instruction Encoding (Opcodes) ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Machine readable representations of EVM instructions, and a mapping to their implementations."]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.Ops", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/__init__.py"}, "content": {"type": ["class"], "name": ["Ops"], "text": ["Enum for EVM Opcodes"]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.Ops.ADD", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["ADD"]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.Ops.MUL", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["MUL"]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.Ops.SUB", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SUB"]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.Ops.DIV", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DIV"]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.Ops.SDIV", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SDIV"]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.Ops.MOD", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["MOD"]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.Ops.SMOD", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SMOD"]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.Ops.ADDMOD", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["ADDMOD"]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.Ops.MULMOD", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["MULMOD"]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.Ops.EXP", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["EXP"]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.Ops.SIGNEXTEND", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SIGNEXTEND"]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.Ops.LT", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["LT"]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.Ops.GT", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["GT"]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.Ops.SLT", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SLT"]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.Ops.SGT", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SGT"]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.Ops.EQ", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["EQ"]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.Ops.ISZERO", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["ISZERO"]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.Ops.AND", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["AND"]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.Ops.OR", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["OR"]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.Ops.XOR", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["XOR"]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.Ops.NOT", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["NOT"]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.Ops.BYTE", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["BYTE"]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.Ops.KECCAK", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["KECCAK"]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.Ops.ADDRESS", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["ADDRESS"]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.Ops.BALANCE", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["BALANCE"]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.Ops.ORIGIN", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["ORIGIN"]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.Ops.CALLER", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["CALLER"]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.Ops.CALLVALUE", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["CALLVALUE"]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.Ops.CALLDATALOAD", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["CALLDATALOAD"]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.Ops.CALLDATASIZE", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["CALLDATASIZE"]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.Ops.CALLDATACOPY", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["CALLDATACOPY"]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.Ops.CODESIZE", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["CODESIZE"]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.Ops.CODECOPY", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["CODECOPY"]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.Ops.GASPRICE", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["GASPRICE"]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.Ops.EXTCODESIZE", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["EXTCODESIZE"]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.Ops.EXTCODECOPY", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["EXTCODECOPY"]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.Ops.BLOCKHASH", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["BLOCKHASH"]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.Ops.COINBASE", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["COINBASE"]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.Ops.TIMESTAMP", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["TIMESTAMP"]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.Ops.NUMBER", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["NUMBER"]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.Ops.DIFFICULTY", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DIFFICULTY"]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.Ops.GASLIMIT", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["GASLIMIT"]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.Ops.STOP", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["STOP"]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.Ops.JUMP", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["JUMP"]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.Ops.JUMPI", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["JUMPI"]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.Ops.PC", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PC"]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.Ops.GAS", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["GAS"]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.Ops.JUMPDEST", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["JUMPDEST"]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.Ops.SLOAD", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SLOAD"]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.Ops.SSTORE", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SSTORE"]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.Ops.POP", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["POP"]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.Ops.PUSH1", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH1"]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.Ops.PUSH2", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH2"]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.Ops.PUSH3", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH3"]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.Ops.PUSH4", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH4"]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.Ops.PUSH5", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH5"]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.Ops.PUSH6", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH6"]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.Ops.PUSH7", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH7"]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.Ops.PUSH8", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH8"]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.Ops.PUSH9", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH9"]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.Ops.PUSH10", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH10"]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.Ops.PUSH11", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH11"]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.Ops.PUSH12", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH12"]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.Ops.PUSH13", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH13"]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.Ops.PUSH14", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH14"]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.Ops.PUSH15", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH15"]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.Ops.PUSH16", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH16"]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.Ops.PUSH17", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH17"]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.Ops.PUSH18", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH18"]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.Ops.PUSH19", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH19"]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.Ops.PUSH20", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH20"]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.Ops.PUSH21", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH21"]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.Ops.PUSH22", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH22"]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.Ops.PUSH23", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH23"]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.Ops.PUSH24", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH24"]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.Ops.PUSH25", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH25"]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.Ops.PUSH26", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH26"]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.Ops.PUSH27", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH27"]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.Ops.PUSH28", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH28"]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.Ops.PUSH29", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH29"]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.Ops.PUSH30", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH30"]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.Ops.PUSH31", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH31"]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.Ops.PUSH32", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH32"]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.Ops.DUP1", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP1"]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.Ops.DUP2", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP2"]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.Ops.DUP3", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP3"]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.Ops.DUP4", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP4"]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.Ops.DUP5", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP5"]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.Ops.DUP6", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP6"]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.Ops.DUP7", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP7"]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.Ops.DUP8", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP8"]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.Ops.DUP9", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP9"]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.Ops.DUP10", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP10"]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.Ops.DUP11", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP11"]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.Ops.DUP12", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP12"]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.Ops.DUP13", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP13"]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.Ops.DUP14", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP14"]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.Ops.DUP15", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP15"]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.Ops.DUP16", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP16"]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.Ops.SWAP1", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP1"]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.Ops.SWAP2", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP2"]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.Ops.SWAP3", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP3"]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.Ops.SWAP4", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP4"]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.Ops.SWAP5", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP5"]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.Ops.SWAP6", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP6"]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.Ops.SWAP7", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP7"]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.Ops.SWAP8", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP8"]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.Ops.SWAP9", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP9"]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.Ops.SWAP10", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP10"]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.Ops.SWAP11", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP11"]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.Ops.SWAP12", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP12"]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.Ops.SWAP13", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP13"]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.Ops.SWAP14", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP14"]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.Ops.SWAP15", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP15"]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.Ops.SWAP16", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP16"]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.Ops.MLOAD", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["MLOAD"]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.Ops.MSTORE", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["MSTORE"]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.Ops.MSTORE8", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["MSTORE8"]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.Ops.MSIZE", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["MSIZE"]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.Ops.LOG0", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["LOG0"]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.Ops.LOG1", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["LOG1"]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.Ops.LOG2", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["LOG2"]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.Ops.LOG3", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["LOG3"]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.Ops.LOG4", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["LOG4"]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.Ops.CREATE", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["CREATE"]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.Ops.RETURN", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["RETURN"]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.Ops.CALL", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["CALL"]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.Ops.CALLCODE", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["CALLCODE"]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.Ops.SELFDESTRUCT", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SELFDESTRUCT"]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.op_implementation", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["op_implementation"]}}, {"source": {"identifier": "ethereum.constantinople.trie", "specifier": 0, "path": "src/ethereum/constantinople/trie.py"}, "content": {"type": ["module"], "name": ["ethereum.constantinople.trie"], "text": ["State Trie ^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction The state trie is the structure responsible for storing .fork_types.Account  objects."]}}, {"source": {"identifier": "ethereum.constantinople.trie.EMPTY_TRIE_ROOT", "specifier": 0, "path": "src/ethereum/constantinople/trie.py"}, "content": {"type": ["attribute"], "name": ["EMPTY_TRIE_ROOT"]}}, {"source": {"identifier": "ethereum.constantinople.trie.Node", "specifier": 0, "path": "src/ethereum/constantinople/trie.py"}, "content": {"type": ["attribute"], "name": ["Node"]}}, {"source": {"identifier": "ethereum.constantinople.trie.K", "specifier": 0, "path": "src/ethereum/constantinople/trie.py"}, "content": {"type": ["attribute"], "name": ["K"]}}, {"source": {"identifier": "ethereum.constantinople.trie.V", "specifier": 0, "path": "src/ethereum/constantinople/trie.py"}, "content": {"type": ["attribute"], "name": ["V"]}}, {"source": {"identifier": "ethereum.constantinople.trie.LeafNode", "specifier": 0, "path": "src/ethereum/constantinople/trie.py"}, "content": {"type": ["class"], "name": ["LeafNode"], "text": ["Leaf node in the Merkle Trie"]}}, {"source": {"identifier": "ethereum.constantinople.trie.LeafNode.rest_of_key", "specifier": 0, "path": "src/ethereum/constantinople/trie.py"}, "content": {"type": ["attribute"], "name": ["rest_of_key"]}}, {"source": {"identifier": "ethereum.constantinople.trie.LeafNode.value", "specifier": 0, "path": "src/ethereum/constantinople/trie.py"}, "content": {"type": ["attribute"], "name": ["value"]}}, {"source": {"identifier": "ethereum.constantinople.trie.ExtensionNode", "specifier": 0, "path": "src/ethereum/constantinople/trie.py"}, "content": {"type": ["class"], "name": ["ExtensionNode"], "text": ["Extension node in the Merkle Trie"]}}, {"source": {"identifier": "ethereum.constantinople.trie.ExtensionNode.key_segment", "specifier": 0, "path": "src/ethereum/constantinople/trie.py"}, "content": {"type": ["attribute"], "name": ["key_segment"]}}, {"source": {"identifier": "ethereum.constantinople.trie.ExtensionNode.subnode", "specifier": 0, "path": "src/ethereum/constantinople/trie.py"}, "content": {"type": ["attribute"], "name": ["subnode"]}}, {"source": {"identifier": "ethereum.constantinople.trie.BranchNode", "specifier": 0, "path": "src/ethereum/constantinople/trie.py"}, "content": {"type": ["class"], "name": ["BranchNode"], "text": ["Branch node in the Merkle Trie"]}}, {"source": {"identifier": "ethereum.constantinople.trie.BranchNode.subnodes", "specifier": 0, "path": "src/ethereum/constantinople/trie.py"}, "content": {"type": ["attribute"], "name": ["subnodes"]}}, {"source": {"identifier": "ethereum.constantinople.trie.BranchNode.value", "specifier": 0, "path": "src/ethereum/constantinople/trie.py"}, "content": {"type": ["attribute"], "name": ["value"]}}, {"source": {"identifier": "ethereum.constantinople.trie.InternalNode", "specifier": 0, "path": "src/ethereum/constantinople/trie.py"}, "content": {"type": ["attribute"], "name": ["InternalNode"]}}, {"source": {"identifier": "ethereum.constantinople.trie.encode_internal_node", "specifier": 0, "path": "src/ethereum/constantinople/trie.py"}, "content": {"type": ["function"], "name": ["encode_internal_node"], "text": ["Encodes a Merkle Trie node into its RLP form. The RLP will then be serialized into a  Bytes  and hashed unless it is less that 32 bytes when serialized. This function also accepts  None , representing the absence of a node, which is encoded to  b\"\" . Parameters node : Optional[InternalNode] The node to encode. Returns encoded :  rlp.RLP The node encoded as RLP."]}}, {"source": {"identifier": "ethereum.constantinople.trie.encode_node", "specifier": 0, "path": "src/ethereum/constantinople/trie.py"}, "content": {"type": ["function"], "name": ["encode_node"], "text": ["Encode a Node for storage in the Merkle Trie. Currently mostly an unimplemented stub."]}}, {"source": {"identifier": "ethereum.constantinople.trie.Trie", "specifier": 0, "path": "src/ethereum/constantinople/trie.py"}, "content": {"type": ["class"], "name": ["Trie"], "text": ["The Merkle Trie."]}}, {"source": {"identifier": "ethereum.constantinople.trie.Trie.secured", "specifier": 0, "path": "src/ethereum/constantinople/trie.py"}, "content": {"type": ["attribute"], "name": ["secured"]}}, {"source": {"identifier": "ethereum.constantinople.trie.Trie.default", "specifier": 0, "path": "src/ethereum/constantinople/trie.py"}, "content": {"type": ["attribute"], "name": ["default"]}}, {"source": {"identifier": "ethereum.constantinople.trie.Trie._data", "specifier": 0, "path": "src/ethereum/constantinople/trie.py"}, "content": {"type": ["attribute"], "name": ["_data"]}}, {"source": {"identifier": "ethereum.constantinople.trie.copy_trie", "specifier": 0, "path": "src/ethereum/constantinople/trie.py"}, "content": {"type": ["function"], "name": ["copy_trie"], "text": ["Create a copy of  trie . Since only frozen objects may be stored in tries, the contents are reused. Parameters trie:  Trie Trie to copy. Returns new_trie :  Trie[K, V] A copy of the trie."]}}, {"source": {"identifier": "ethereum.constantinople.trie.trie_set", "specifier": 0, "path": "src/ethereum/constantinople/trie.py"}, "content": {"type": ["function"], "name": ["trie_set"], "text": ["Stores an item in a Merkle Trie. This method deletes the key if  value == trie.default , because the Merkle Trie represents the default value by omitting it from the trie. Parameters trie:  Trie Trie to store in. key :  Bytes Key to lookup. value :  V Node to insert at  key ."]}}, {"source": {"identifier": "ethereum.constantinople.trie.trie_get", "specifier": 0, "path": "src/ethereum/constantinople/trie.py"}, "content": {"type": ["function"], "name": ["trie_get"], "text": ["Gets an item from the Merkle Trie. This method returns  trie.default  if the key is missing. Parameters trie: Trie to lookup in. key : Key to lookup. Returns node :  V Node at  key  in the trie."]}}, {"source": {"identifier": "ethereum.constantinople.trie.common_prefix_length", "specifier": 0, "path": "src/ethereum/constantinople/trie.py"}, "content": {"type": ["function"], "name": ["common_prefix_length"], "text": ["Find the longest common prefix of two sequences."]}}, {"source": {"identifier": "ethereum.constantinople.trie.nibble_list_to_compact", "specifier": 0, "path": "src/ethereum/constantinople/trie.py"}, "content": {"type": ["function"], "name": ["nibble_list_to_compact"], "text": ["Compresses nibble-list into a standard byte array with a flag. A nibble-list is a list of byte values no greater than  15 . The flag is encoded in high nibble of the highest byte. The flag nibble can be broken down into two two-bit flags. Highest nibble:: +---+---+----------+--------+\n| _ | _ | is_leaf | parity |\n+---+---+----------+--------+\n  3   2      1         0\n The lowest bit of the nibble encodes the parity of the length of the remaining nibbles --  0  when even and  1  when odd. The second lowest bit is used to distinguish leaf and extension nodes. The other two bits are not used. Parameters x : Array of nibbles. is_leaf : True if this is part of a leaf node, or false if it is an extension node. Returns compressed :  bytearray Compact byte array."]}}, {"source": {"identifier": "ethereum.constantinople.trie.bytes_to_nibble_list", "specifier": 0, "path": "src/ethereum/constantinople/trie.py"}, "content": {"type": ["function"], "name": ["bytes_to_nibble_list"], "text": ["Converts a  Bytes  into to a sequence of nibbles (bytes with value < 16). Parameters bytes_: The  Bytes  to convert. Returns nibble_list :  Bytes The  Bytes  in nibble-list format."]}}, {"source": {"identifier": "ethereum.constantinople.trie._prepare_trie", "specifier": 0, "path": "src/ethereum/constantinople/trie.py"}, "content": {"type": ["function"], "name": ["_prepare_trie"], "text": ["Prepares the trie for root calculation. Removes values that are empty, hashes the keys (if  secured == True ) and encodes all the nodes. Parameters trie : The  Trie  to prepare. get_storage_root : Function to get the storage root of an account. Needed to encode Account  objects. Returns out :  Mapping[ethereum.base_types.Bytes, Node] Object with keys mapped to nibble-byte form."]}}, {"source": {"identifier": "ethereum.constantinople.trie.root", "specifier": 0, "path": "src/ethereum/constantinople/trie.py"}, "content": {"type": ["function"], "name": ["root"], "text": ["Computes the root of a modified merkle patricia trie (MPT). Parameters trie : Trie  to get the root of. get_storage_root : Function to get the storage root of an account. Needed to encode Account  objects. Returns root :  .fork_types.Root MPT root of the underlying key-value pairs."]}}, {"source": {"identifier": "ethereum.constantinople.trie.patricialize", "specifier": 0, "path": "src/ethereum/constantinople/trie.py"}, "content": {"type": ["function"], "name": ["patricialize"], "text": ["Structural composition function. Used to recursively patricialize and merkleize a dictionary. Includes memoization of the tree structure and hashes. Parameters obj : Underlying trie key-value pairs, with keys in nibble-list format. level : Current trie level. Returns node :  ethereum.base_types.Bytes Root node of  obj ."]}}, {"source": {"identifier": "ethereum.constantinople.fork", "specifier": 0, "path": "src/ethereum/constantinople/fork.py"}, "content": {"type": ["module"], "name": ["ethereum.constantinople.fork"], "text": ["Ethereum Specification ^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Entry point for the Ethereum specification."]}}, {"source": {"identifier": "ethereum.constantinople.fork.BLOCK_REWARD", "specifier": 0, "path": "src/ethereum/constantinople/fork.py"}, "content": {"type": ["attribute"], "name": ["BLOCK_REWARD"]}}, {"source": {"identifier": "ethereum.constantinople.fork.GAS_LIMIT_ADJUSTMENT_FACTOR", "specifier": 0, "path": "src/ethereum/constantinople/fork.py"}, "content": {"type": ["attribute"], "name": ["GAS_LIMIT_ADJUSTMENT_FACTOR"]}}, {"source": {"identifier": "ethereum.constantinople.fork.GAS_LIMIT_MINIMUM", "specifier": 0, "path": "src/ethereum/constantinople/fork.py"}, "content": {"type": ["attribute"], "name": ["GAS_LIMIT_MINIMUM"]}}, {"source": {"identifier": "ethereum.constantinople.fork.MINIMUM_DIFFICULTY", "specifier": 0, "path": "src/ethereum/constantinople/fork.py"}, "content": {"type": ["attribute"], "name": ["MINIMUM_DIFFICULTY"]}}, {"source": {"identifier": "ethereum.constantinople.fork.MAX_OMMER_DEPTH", "specifier": 0, "path": "src/ethereum/constantinople/fork.py"}, "content": {"type": ["attribute"], "name": ["MAX_OMMER_DEPTH"]}}, {"source": {"identifier": "ethereum.constantinople.fork.BOMB_DELAY_BLOCKS", "specifier": 0, "path": "src/ethereum/constantinople/fork.py"}, "content": {"type": ["attribute"], "name": ["BOMB_DELAY_BLOCKS"]}}, {"source": {"identifier": "ethereum.constantinople.fork.EMPTY_OMMER_HASH", "specifier": 0, "path": "src/ethereum/constantinople/fork.py"}, "content": {"type": ["attribute"], "name": ["EMPTY_OMMER_HASH"]}}, {"source": {"identifier": "ethereum.constantinople.fork.BlockChain", "specifier": 0, "path": "src/ethereum/constantinople/fork.py"}, "content": {"type": ["class"], "name": ["BlockChain"], "text": ["History and current state of the block chain."]}}, {"source": {"identifier": "ethereum.constantinople.fork.BlockChain.blocks", "specifier": 0, "path": "src/ethereum/constantinople/fork.py"}, "content": {"type": ["attribute"], "name": ["blocks"]}}, {"source": {"identifier": "ethereum.constantinople.fork.BlockChain.state", "specifier": 0, "path": "src/ethereum/constantinople/fork.py"}, "content": {"type": ["attribute"], "name": ["state"]}}, {"source": {"identifier": "ethereum.constantinople.fork.BlockChain.chain_id", "specifier": 0, "path": "src/ethereum/constantinople/fork.py"}, "content": {"type": ["attribute"], "name": ["chain_id"]}}, {"source": {"identifier": "ethereum.constantinople.fork.apply_fork", "specifier": 0, "path": "src/ethereum/constantinople/fork.py"}, "content": {"type": ["function"], "name": ["apply_fork"], "text": ["Transforms the state from the previous hard fork ( old ) into the block chain object for this hard fork and returns it. When forks need to implement an irregular state transition, this function is used to handle the irregularity. See the :ref: DAO Fork <dao-fork>  for an example. Parameters old : Previous block chain object. Returns new :  BlockChain Upgraded block chain object for this hard fork."]}}, {"source": {"identifier": "ethereum.constantinople.fork.get_last_256_block_hashes", "specifier": 0, "path": "src/ethereum/constantinople/fork.py"}, "content": {"type": ["function"], "name": ["get_last_256_block_hashes"], "text": ["Obtain the list of hashes of the previous 256 blocks in order of increasing block number. This function will return less hashes for the first 256 blocks. The  BLOCKHASH  opcode needs to access the latest hashes on the chain, therefore this function retrieves them. Parameters chain : History and current state. Returns recent_block_hashes :  List[Hash32] Hashes of the recent 256 blocks in order of increasing block number."]}}, {"source": {"identifier": "ethereum.constantinople.fork.state_transition", "specifier": 0, "path": "src/ethereum/constantinople/fork.py"}, "content": {"type": ["function"], "name": ["state_transition"], "text": ["Attempts to apply a block to an existing block chain. All parts of the block's contents need to be verified before being added to the chain. Blocks are verified by ensuring that the contents of the block make logical sense with the contents of the parent block. The information in the block's header must also match the corresponding information in the block. To implement Ethereum, in theory clients are only required to store the most recent 255 blocks of the chain since as far as execution is concerned, only those blocks are accessed. Practically, however, clients should store more blocks to handle reorgs. Parameters chain : History and current state. block : Block to apply to  chain ."]}}, {"source": {"identifier": "ethereum.constantinople.fork.validate_header", "specifier": 0, "path": "src/ethereum/constantinople/fork.py"}, "content": {"type": ["function"], "name": ["validate_header"], "text": ["Verifies a block header. In order to consider a block's header valid, the logic for the quantities in the header should match the logic for the block itself. For example the header timestamp should be greater than the block's parent timestamp because the block was created  after  the parent block. Additionally, the block's number should be directly folowing the parent block's number since it is the next block in the sequence. Parameters header : Header to check for correctness. parent_header : Parent Header of the header to check for correctness"]}}, {"source": {"identifier": "ethereum.constantinople.fork.generate_header_hash_for_pow", "specifier": 0, "path": "src/ethereum/constantinople/fork.py"}, "content": {"type": ["function"], "name": ["generate_header_hash_for_pow"], "text": ["Generate rlp hash of the header which is to be used for Proof-of-Work verification. In other words, the PoW artefacts  mix_digest  and  nonce  are ignored while calculating this hash. A particular PoW is valid for a single hash, that hash is computed by this function. The  nonce  and  mix_digest  are omitted from this hash because they are being changed by miners in their search for a sufficient proof-of-work. Parameters header : The header object for which the hash is to be generated. Returns hash :  Hash32 The PoW valid rlp hash of the passed in header."]}}, {"source": {"identifier": "ethereum.constantinople.fork.validate_proof_of_work", "specifier": 0, "path": "src/ethereum/constantinople/fork.py"}, "content": {"type": ["function"], "name": ["validate_proof_of_work"], "text": ["Validates the Proof of Work constraints. In order to verify that a miner's proof-of-work is valid for a block, a mix-digest  and  result  are calculated using the  hashimoto_light hash function. The mix digest is a hash of the header and the nonce that is passed through and it confirms whether or not proof-of-work was done on the correct block. The result is the actual hash value of the block. Parameters header : Header of interest."]}}, {"source": {"identifier": "ethereum.constantinople.fork.check_transaction", "specifier": 0, "path": "src/ethereum/constantinople/fork.py"}, "content": {"type": ["function"], "name": ["check_transaction"], "text": ["Check if the transaction is includable in the block. Parameters tx : The transaction. gas_available : The gas remaining in the block. chain_id : The ID of the current chain. Returns sender_address : The sender of the transaction. Raises InvalidBlock : If the transaction is not includable."]}}, {"source": {"identifier": "ethereum.constantinople.fork.make_receipt", "specifier": 0, "path": "src/ethereum/constantinople/fork.py"}, "content": {"type": ["function"], "name": ["make_receipt"], "text": ["Make the receipt for a transaction that was executed. Parameters tx : The executed transaction. has_erred : Whether the top level frame of the transaction exited with an error. cumulative_gas_used : The total gas used so far in the block after the transaction was executed. logs : The logs produced by the transaction. Returns receipt : The receipt for the transaction."]}}, {"source": {"identifier": "ethereum.constantinople.fork.apply_body", "specifier": 0, "path": "src/ethereum/constantinople/fork.py"}, "content": {"type": ["function"], "name": ["apply_body"], "text": ["Executes a block. Many of the contents of a block are stored in data structures called tries. There is a transactions trie which is similar to a ledger of the transactions stored in the current block. There is also a receipts trie which stores the results of executing a transaction, like the post state and gas used. This function creates and executes the block that is to be added to the chain. Parameters state : Current account state. block_hashes : List of hashes of the previous 256 blocks in the order of increasing block number. coinbase : Address of account which receives block reward and transaction fees. block_number : Position of the block within the chain. block_gas_limit : Initial amount of gas available for execution in this block. block_time : Time the block was produced, measured in seconds since the epoch. block_difficulty : Difficulty of the block. transactions : Transactions included in the block. ommers : Headers of ancestor blocks which are not direct parents (formerly uncles.) chain_id : ID of the executing chain. Returns gas_available :  ethereum.base_types.Uint Remaining gas after all transactions have been executed. transactions_root :  ethereum.fork_types.Root Trie root of all the transactions in the block. receipt_root :  ethereum.fork_types.Root Trie root of all the receipts in the block. block_logs_bloom :  Bloom Logs bloom of all the logs included in all the transactions of the block. state :  ethereum.fork_types.State State after all transactions have been executed."]}}, {"source": {"identifier": "ethereum.constantinople.fork.validate_ommers", "specifier": 0, "path": "src/ethereum/constantinople/fork.py"}, "content": {"type": ["function"], "name": ["validate_ommers"], "text": ["Validates the ommers mentioned in the block. An ommer block is a block that wasn't canonically added to the blockchain because it wasn't validated as fast as the canonical block but was mined at the same time. To be considered valid, the ommers must adhere to the rules defined in the Ethereum protocol. The maximum amount of ommers is 2 per block and there cannot be duplicate ommers in a block. Many of the other ommer contraints are listed in the in-line comments of this function. Parameters ommers : List of ommers mentioned in the current block. block_header: The header of current block. chain : History and current state."]}}, {"source": {"identifier": "ethereum.constantinople.fork.pay_rewards", "specifier": 0, "path": "src/ethereum/constantinople/fork.py"}, "content": {"type": ["function"], "name": ["pay_rewards"], "text": ["Pay rewards to the block miner as well as the ommers miners. The miner of the canonical block is rewarded with the predetermined block reward,  BLOCK_REWARD , plus a variable award based off of the number of ommer blocks that were mined around the same time, and included in the canonical block's header. An ommer block is a block that wasn't added to the canonical blockchain because it wasn't validated as fast as the accepted block but was mined at the same time. Although not all blocks that are mined are added to the canonical chain, miners are still paid a reward for their efforts. This reward is called an ommer reward and is calculated based on the number associated with the ommer block that they mined. Parameters state : Current account state. block_number : Position of the block within the chain. coinbase : Address of account which receives block reward and transaction fees. ommers : List of ommers mentioned in the current block."]}}, {"source": {"identifier": "ethereum.constantinople.fork.process_transaction", "specifier": 0, "path": "src/ethereum/constantinople/fork.py"}, "content": {"type": ["function"], "name": ["process_transaction"], "text": ["Execute a transaction against the provided environment. This function processes the actions needed to execute a transaction. It decrements the sender's account after calculating the gas fee and refunds them the proper amount after execution. Calling contracts, deploying code, and incrementing nonces are all examples of actions that happen within this function or from a call made within this function. Accounts that are marked for deletion are processed and destroyed after execution. Parameters env : Environment for the Ethereum Virtual Machine. tx : Transaction to execute. Returns gas_left :  ethereum.base_types.U256 Remaining gas after execution. logs :  Tuple[ethereum.fork_types.Log, ...] Logs generated during execution."]}}, {"source": {"identifier": "ethereum.constantinople.fork.validate_transaction", "specifier": 0, "path": "src/ethereum/constantinople/fork.py"}, "content": {"type": ["function"], "name": ["validate_transaction"], "text": ["Verifies a transaction. The gas in a transaction gets used to pay for the intrinsic cost of operations, therefore if there is insufficient gas then it would not be possible to execute a transaction and it will be declared invalid. Additionally, the nonce of a transaction must not equal or exceed the limit defined in  EIP-2681 <https://eips.ethereum.org/EIPS/eip-2681> _. In practice, defining the limit as  2**64-1  has no impact because sending  2**64-1  transactions is improbable. It's not strictly impossible though,  2**64-1  transactions is the entire capacity of the Ethereum blockchain at 2022 gas limits for a little over 22 years. Parameters tx : Transaction to validate. Returns verified :  bool True if the transaction can be executed, or False otherwise."]}}, {"source": {"identifier": "ethereum.constantinople.fork.calculate_intrinsic_cost", "specifier": 0, "path": "src/ethereum/constantinople/fork.py"}, "content": {"type": ["function"], "name": ["calculate_intrinsic_cost"], "text": ["Calculates the gas that is charged before execution is started. The intrinsic cost of the transaction is charged before execution has begun. Functions/operations in the EVM cost money to execute so this intrinsic cost is for the operations that need to be paid for as part of the transaction. Data transfer, for example, is part of this intrinsic cost. It costs ether to send data over the wire and that ether is accounted for in the intrinsic cost calculated in this function. This intrinsic cost must be calculated and paid for before execution in order for all operations to be implemented. Parameters tx : Transaction to compute the intrinsic cost of. Returns verified :  ethereum.base_types.Uint The intrinsic cost of the transaction."]}}, {"source": {"identifier": "ethereum.constantinople.fork.recover_sender", "specifier": 0, "path": "src/ethereum/constantinople/fork.py"}, "content": {"type": ["function"], "name": ["recover_sender"], "text": ["Extracts the sender address from a transaction. The v, r, and s values are the three parts that make up the signature of a transaction. In order to recover the sender of a transaction the two components needed are the signature ( v ,  r , and  s ) and the signing hash of the transaction. The sender's public key can be obtained with these two values and therefore the sender address can be retrieved. Parameters tx : Transaction of interest. chain_id : ID of the executing chain. Returns sender :  ethereum.fork_types.Address The address of the account that signed the transaction."]}}, {"source": {"identifier": "ethereum.constantinople.fork.signing_hash_pre155", "specifier": 0, "path": "src/ethereum/constantinople/fork.py"}, "content": {"type": ["function"], "name": ["signing_hash_pre155"], "text": ["Compute the hash of a transaction used in a legacy (pre EIP 155) signature. Parameters tx : Transaction of interest. Returns hash :  ethereum.crypto.hash.Hash32 Hash of the transaction."]}}, {"source": {"identifier": "ethereum.constantinople.fork.signing_hash_155", "specifier": 0, "path": "src/ethereum/constantinople/fork.py"}, "content": {"type": ["function"], "name": ["signing_hash_155"], "text": ["Compute the hash of a transaction used in a EIP 155 signature. Parameters tx : Transaction of interest. Returns hash :  ethereum.crypto.hash.Hash32 Hash of the transaction."]}}, {"source": {"identifier": "ethereum.constantinople.fork.compute_header_hash", "specifier": 0, "path": "src/ethereum/constantinople/fork.py"}, "content": {"type": ["function"], "name": ["compute_header_hash"], "text": ["Computes the hash of a block header. The header hash of a block is the canonical hash that is used to refer to a specific block and completely distinguishes a block from another. keccak256  is a function that produces a 256 bit hash of any input. It also takes in any number of bytes as an input and produces a single hash for them. A hash is a completely unique output for a single input. So an input corresponds to one unique hash that can be used to identify the input exactly. Prior to using the  keccak256  hash function, the header must be encoded using the Recursive-Length Prefix. See :ref: rlp . RLP encoding the header converts it into a space-efficient format that allows for easy transfer of data between nodes. The purpose of RLP is to encode arbitrarily nested arrays of binary data, and RLP is the primary encoding method used to serialize objects in Ethereum's execution layer. The only purpose of RLP is to encode structure; encoding specific data types (e.g. strings, floats) is left up to higher-order protocols. Parameters header : Header of interest. Returns hash :  ethereum.crypto.hash.Hash32 Hash of the header."]}}, {"source": {"identifier": "ethereum.constantinople.fork.check_gas_limit", "specifier": 0, "path": "src/ethereum/constantinople/fork.py"}, "content": {"type": ["function"], "name": ["check_gas_limit"], "text": ["Validates the gas limit for a block. The bounds of the gas limit,  max_adjustment_delta , is set as the quotient of the parent block's gas limit and the GAS_LIMIT_ADJUSTMENT_FACTOR . Therefore, if the gas limit that is passed through as a parameter is greater than or equal to the  sum  of the parent's gas and the adjustment delta then the limit for gas is too high and fails this function's check. Similarly, if the limit is less than or equal to the  difference  of the parent's gas and the adjustment delta  or  the predefined  GAS_LIMIT_MINIMUM  then this function's check fails because the gas limit doesn't allow for a sufficient or reasonable amount of gas to be used on a block. Parameters gas_limit : Gas limit to validate. parent_gas_limit : Gas limit of the parent block. Returns check :  bool True if gas limit constraints are satisfied, False otherwise."]}}, {"source": {"identifier": "ethereum.constantinople.fork.calculate_block_difficulty", "specifier": 0, "path": "src/ethereum/constantinople/fork.py"}, "content": {"type": ["function"], "name": ["calculate_block_difficulty"], "text": ["Computes difficulty of a block using its header and parent header. The difficulty is determined by the time the block was created after its parent. The  offset  is calculated using the parent block's difficulty, parent_difficulty , and the timestamp between blocks. This offset is then added to the parent difficulty and is stored as the  difficulty variable. If the time between the block and its parent is too short, the offset will result in a positive number thus making the sum of parent_difficulty  and  offset  to be a greater value in order to avoid mass forking. But, if the time is long enough, then the offset results in a negative value making the block less difficult than its parent. The base standard for a block's difficulty is the predefined value set for the genesis block since it has no parent. So, a block can't be less difficult than the genesis block, therefore each block's difficulty is set to the maximum value between the calculated difficulty and the  GENESIS_DIFFICULTY . Parameters block_number : Block number of the block. block_timestamp : Timestamp of the block. parent_timestamp : Timestamp of the parent block. parent_difficulty : difficulty of the parent block. parent_has_ommers: does the parent have ommers. Returns difficulty :  ethereum.base_types.Uint Computed difficulty for a block."]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.gas", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/gas.py"}, "content": {"type": ["module"], "name": ["ethereum.arrow_glacier.vm.gas"], "text": ["Ethereum Virtual Machine (EVM) Gas ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction EVM gas constants and calculators."]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.gas.GAS_JUMPDEST", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_JUMPDEST"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.gas.GAS_BASE", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_BASE"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.gas.GAS_VERY_LOW", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_VERY_LOW"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.gas.GAS_STORAGE_SET", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_STORAGE_SET"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.gas.GAS_STORAGE_UPDATE", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_STORAGE_UPDATE"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.gas.GAS_STORAGE_CLEAR_REFUND", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_STORAGE_CLEAR_REFUND"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.gas.GAS_LOW", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_LOW"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.gas.GAS_MID", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_MID"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.gas.GAS_HIGH", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_HIGH"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.gas.GAS_EXPONENTIATION", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_EXPONENTIATION"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.gas.GAS_EXPONENTIATION_PER_BYTE", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_EXPONENTIATION_PER_BYTE"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.gas.GAS_MEMORY", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_MEMORY"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.gas.GAS_KECCAK256", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_KECCAK256"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.gas.GAS_KECCAK256_WORD", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_KECCAK256_WORD"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.gas.GAS_COPY", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_COPY"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.gas.GAS_BLOCK_HASH", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_BLOCK_HASH"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.gas.GAS_LOG", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_LOG"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.gas.GAS_LOG_DATA", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_LOG_DATA"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.gas.GAS_LOG_TOPIC", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_LOG_TOPIC"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.gas.GAS_CREATE", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_CREATE"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.gas.GAS_CODE_DEPOSIT", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_CODE_DEPOSIT"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.gas.GAS_ZERO", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_ZERO"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.gas.GAS_NEW_ACCOUNT", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_NEW_ACCOUNT"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.gas.GAS_CALL_VALUE", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_CALL_VALUE"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.gas.GAS_CALL_STIPEND", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_CALL_STIPEND"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.gas.GAS_SELF_DESTRUCT", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_SELF_DESTRUCT"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.gas.GAS_SELF_DESTRUCT_NEW_ACCOUNT", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_SELF_DESTRUCT_NEW_ACCOUNT"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.gas.GAS_ECRECOVER", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_ECRECOVER"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.gas.GAS_SHA256", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_SHA256"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.gas.GAS_SHA256_WORD", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_SHA256_WORD"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.gas.GAS_RIPEMD160", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_RIPEMD160"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.gas.GAS_RIPEMD160_WORD", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_RIPEMD160_WORD"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.gas.GAS_IDENTITY", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_IDENTITY"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.gas.GAS_IDENTITY_WORD", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_IDENTITY_WORD"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.gas.GAS_RETURN_DATA_COPY", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_RETURN_DATA_COPY"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.gas.GAS_FAST_STEP", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_FAST_STEP"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.gas.GAS_BLAKE2_PER_ROUND", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_BLAKE2_PER_ROUND"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.gas.GAS_COLD_SLOAD", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_COLD_SLOAD"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.gas.GAS_COLD_ACCOUNT_ACCESS", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_COLD_ACCOUNT_ACCESS"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.gas.GAS_WARM_ACCESS", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_WARM_ACCESS"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.gas.ExtendMemory", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/gas.py"}, "content": {"type": ["class"], "name": ["ExtendMemory"], "text": ["Define the parameters for memory extension in opcodes cost :  ethereum.base_types.Uint The gas required to perform the extension expand_by :  ethereum.base_types.Uint The size by which the memory will be extended"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.gas.ExtendMemory.cost", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["cost"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.gas.ExtendMemory.expand_by", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["expand_by"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.gas.MessageCallGas", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/gas.py"}, "content": {"type": ["class"], "name": ["MessageCallGas"], "text": ["Define the gas cost and stipend for executing the call opcodes. cost :  ethereum.base_types.Uint The non-refundable portion of gas reserved for executing the call opcode. stipend :  ethereum.base_types.Uint The portion of gas available to sub-calls that is refundable if not consumed"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.gas.MessageCallGas.cost", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["cost"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.gas.MessageCallGas.stipend", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["stipend"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.gas.charge_gas", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/gas.py"}, "content": {"type": ["function"], "name": ["charge_gas"], "text": ["Subtracts  amount  from  evm.gas_left . Parameters evm : The current EVM. amount : The amount of gas the current operation requires."]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.gas.calculate_memory_gas_cost", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/gas.py"}, "content": {"type": ["function"], "name": ["calculate_memory_gas_cost"], "text": ["Calculates the gas cost for allocating memory to the smallest multiple of 32 bytes, such that the allocated size is at least as big as the given size. Parameters size_in_bytes : The size of the data in bytes. Returns total_gas_cost :  ethereum.base_types.Uint The gas cost for storing data in memory."]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.gas.calculate_gas_extend_memory", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/gas.py"}, "content": {"type": ["function"], "name": ["calculate_gas_extend_memory"], "text": ["Calculates the gas amount to extend memory Parameters memory : Memory contents of the EVM. extensions: List of extensions to be made to the memory. Consists of a tuple of start position and size. Returns extend_memory:  ExtendMemory"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.gas.calculate_message_call_gas", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/gas.py"}, "content": {"type": ["function"], "name": ["calculate_message_call_gas"], "text": ["Calculates the MessageCallGas (cost and stipend) for executing call Opcodes. Parameters value: The amount of  ETH  that needs to be transferred. gas : The amount of gas provided to the message-call. gas_left : The amount of gas left in the current frame. memory_cost : The amount needed to extend the memory in the current frame. extra_gas : The amount of gas needed for transferring value + creating a new account inside a message call. call_stipend : The amount of stipend provided to a message call to execute code while transferring value(ETH). Returns message_call_gas:  MessageCallGas"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.gas.max_message_call_gas", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/gas.py"}, "content": {"type": ["function"], "name": ["max_message_call_gas"], "text": ["Calculates the maximum gas that is allowed for making a message call Parameters gas : The amount of gas provided to the message-call. Returns max_allowed_message_call_gas:  ethereum.base_types.Uint The maximum gas allowed for making the message-call."]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.control_flow", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/control_flow.py"}, "content": {"type": ["module"], "name": ["ethereum.frontier.vm.instructions.control_flow"], "text": ["Ethereum Virtual Machine (EVM) Control Flow Instructions ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementations of the EVM control flow instructions."]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.control_flow.stop", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/control_flow.py"}, "content": {"type": ["function"], "name": ["stop"], "text": ["Stop further execution of EVM code. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.control_flow.jump", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/control_flow.py"}, "content": {"type": ["function"], "name": ["jump"], "text": ["Alter the program counter to the location specified by the top of the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.control_flow.jumpi", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/control_flow.py"}, "content": {"type": ["function"], "name": ["jumpi"], "text": ["Alter the program counter to the specified location if and only if a condition is true. If the condition is not true, then the program counter would increase only by 1. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.control_flow.pc", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/control_flow.py"}, "content": {"type": ["function"], "name": ["pc"], "text": ["Push onto the stack the value of the program counter after reaching the current instruction and without increasing it for the next instruction. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.control_flow.gas_left", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/control_flow.py"}, "content": {"type": ["function"], "name": ["gas_left"], "text": ["Push the amount of available gas (including the corresponding reduction for the cost of this instruction) onto the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.control_flow.jumpdest", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/control_flow.py"}, "content": {"type": ["function"], "name": ["jumpdest"], "text": ["Mark a valid destination for jumps. This is a noop, present only to be used by  JUMP  and  JUMPI  opcodes to verify that their jump is valid. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.constantinople.vm.memory", "specifier": 0, "path": "src/ethereum/constantinople/vm/memory.py"}, "content": {"type": ["module"], "name": ["ethereum.constantinople.vm.memory"], "text": ["Ethereum Virtual Machine (EVM) Memory ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction EVM memory operations."]}}, {"source": {"identifier": "ethereum.constantinople.vm.memory.memory_write", "specifier": 0, "path": "src/ethereum/constantinople/vm/memory.py"}, "content": {"type": ["function"], "name": ["memory_write"], "text": ["Writes to memory. Parameters memory : Memory contents of the EVM. start_position : Starting pointer to the memory. value : Data to write to memory."]}}, {"source": {"identifier": "ethereum.constantinople.vm.memory.memory_read_bytes", "specifier": 0, "path": "src/ethereum/constantinople/vm/memory.py"}, "content": {"type": ["function"], "name": ["memory_read_bytes"], "text": ["Read bytes from memory. Parameters memory : Memory contents of the EVM. start_position : Starting pointer to the memory. size : Size of the data that needs to be read from  start_position . Returns data_bytes : Data read from memory."]}}, {"source": {"identifier": "ethereum.constantinople.vm.memory.buffer_read", "specifier": 0, "path": "src/ethereum/constantinople/vm/memory.py"}, "content": {"type": ["function"], "name": ["buffer_read"], "text": ["Read bytes from a buffer. Padding with zeros if neccesary. Parameters buffer : Memory contents of the EVM. start_position : Starting pointer to the memory. size : Size of the data that needs to be read from  start_position . Returns data_bytes : Data read from memory."]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.precompiled_contracts.blake2f", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/precompiled_contracts/blake2f.py"}, "content": {"type": ["module"], "name": ["ethereum.arrow_glacier.vm.precompiled_contracts.blake2f"], "text": ["Ethereum Virtual Machine (EVM) Blake2 PRECOMPILED CONTRACT ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementation of the  Blake2  precompiled contract."]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.precompiled_contracts.blake2f.blake2f", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/precompiled_contracts/blake2f.py"}, "content": {"type": ["function"], "name": ["blake2f"], "text": ["Writes the Blake2 hash to output. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.comparison", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/comparison.py"}, "content": {"type": ["module"], "name": ["ethereum.frontier.vm.instructions.comparison"], "text": ["Ethereum Virtual Machine (EVM) Comparison Instructions ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementations of the EVM Comparison instructions."]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.comparison.less_than", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/comparison.py"}, "content": {"type": ["function"], "name": ["less_than"], "text": ["Checks if the top element is less than the next top element. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.comparison.signed_less_than", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/comparison.py"}, "content": {"type": ["function"], "name": ["signed_less_than"], "text": ["Signed less-than comparison. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.comparison.greater_than", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/comparison.py"}, "content": {"type": ["function"], "name": ["greater_than"], "text": ["Checks if the top element is greater than the next top element. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.comparison.signed_greater_than", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/comparison.py"}, "content": {"type": ["function"], "name": ["signed_greater_than"], "text": ["Signed greater-than comparison. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.comparison.equal", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/comparison.py"}, "content": {"type": ["function"], "name": ["equal"], "text": ["Checks if the top element is equal to the next top element. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.comparison.is_zero", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/comparison.py"}, "content": {"type": ["function"], "name": ["is_zero"], "text": ["Checks if the top element is equal to 0. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.constantinople.vm.exceptions", "specifier": 0, "path": "src/ethereum/constantinople/vm/exceptions.py"}, "content": {"type": ["module"], "name": ["ethereum.constantinople.vm.exceptions"], "text": ["Ethereum Virtual Machine (EVM) Exceptions ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Exceptions which cause the EVM to halt exceptionally."]}}, {"source": {"identifier": "ethereum.constantinople.vm.exceptions.ExceptionalHalt", "specifier": 0, "path": "src/ethereum/constantinople/vm/exceptions.py"}, "content": {"type": ["class"], "name": ["ExceptionalHalt"], "text": ["Indicates that the EVM has experienced an exceptional halt. This causes execution to immediately end with all gas being consumed."]}}, {"source": {"identifier": "ethereum.constantinople.vm.exceptions.Revert", "specifier": 0, "path": "src/ethereum/constantinople/vm/exceptions.py"}, "content": {"type": ["class"], "name": ["Revert"], "text": ["Raised by the  REVERT  opcode. Unlike other EVM exceptions this does not result in the consumption of all gas."]}}, {"source": {"identifier": "ethereum.constantinople.vm.exceptions.StackUnderflowError", "specifier": 0, "path": "src/ethereum/constantinople/vm/exceptions.py"}, "content": {"type": ["class"], "name": ["StackUnderflowError"], "text": ["Occurs when a pop is executed on an empty stack."]}}, {"source": {"identifier": "ethereum.constantinople.vm.exceptions.StackOverflowError", "specifier": 0, "path": "src/ethereum/constantinople/vm/exceptions.py"}, "content": {"type": ["class"], "name": ["StackOverflowError"], "text": ["Occurs when a push is executed on a stack at max capacity."]}}, {"source": {"identifier": "ethereum.constantinople.vm.exceptions.OutOfGasError", "specifier": 0, "path": "src/ethereum/constantinople/vm/exceptions.py"}, "content": {"type": ["class"], "name": ["OutOfGasError"], "text": ["Occurs when an operation costs more than the amount of gas left in the frame."]}}, {"source": {"identifier": "ethereum.constantinople.vm.exceptions.InvalidOpcode", "specifier": 0, "path": "src/ethereum/constantinople/vm/exceptions.py"}, "content": {"type": ["class"], "name": ["InvalidOpcode"], "text": ["Raised when an invalid opcode is encountered."]}}, {"source": {"identifier": "ethereum.constantinople.vm.exceptions.InvalidJumpDestError", "specifier": 0, "path": "src/ethereum/constantinople/vm/exceptions.py"}, "content": {"type": ["class"], "name": ["InvalidJumpDestError"], "text": ["Occurs when the destination of a jump operation doesn't meet any of the following criteria: The jump destination is less than the length of the code. The jump destination should have the  JUMPDEST  opcode (0x5B). The jump destination shouldn't be part of the data corresponding to PUSH-N  opcodes."]}}, {"source": {"identifier": "ethereum.constantinople.vm.exceptions.StackDepthLimitError", "specifier": 0, "path": "src/ethereum/constantinople/vm/exceptions.py"}, "content": {"type": ["class"], "name": ["StackDepthLimitError"], "text": ["Raised when the message depth is greater than  1024"]}}, {"source": {"identifier": "ethereum.constantinople.vm.exceptions.WriteInStaticContext", "specifier": 0, "path": "src/ethereum/constantinople/vm/exceptions.py"}, "content": {"type": ["class"], "name": ["WriteInStaticContext"], "text": ["Raised when an attempt is made to modify the state while operating inside of a STATICCALL context."]}}, {"source": {"identifier": "ethereum.constantinople.vm.exceptions.OutOfBoundsRead", "specifier": 0, "path": "src/ethereum/constantinople/vm/exceptions.py"}, "content": {"type": ["class"], "name": ["OutOfBoundsRead"], "text": ["Raised when an attempt was made to read data beyond the boundaries of the buffer."]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.precompiled_contracts.mapping", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/precompiled_contracts/mapping.py"}, "content": {"type": ["module"], "name": ["ethereum.arrow_glacier.vm.precompiled_contracts.mapping"], "text": ["Precompiled Contract Addresses ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Mapping of precompiled contracts their implementations."]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.precompiled_contracts.mapping.PRE_COMPILED_CONTRACTS", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/precompiled_contracts/mapping.py"}, "content": {"type": ["attribute"], "name": ["PRE_COMPILED_CONTRACTS"]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.log", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/log.py"}, "content": {"type": ["module"], "name": ["ethereum.frontier.vm.instructions.log"], "text": ["Ethereum Virtual Machine (EVM) Logging Instructions ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementations of the EVM logging instructions."]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.log.log_n", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/log.py"}, "content": {"type": ["function"], "name": ["log_n"], "text": ["Appends a log entry, having  num_topics  topics, to the evm logs. This will also expand the memory if the data (required by the log entry) corresponding to the memory is not accessible. Parameters evm : The current EVM frame. num_topics : The number of topics to be included in the log entry."]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.log.log0", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/log.py"}, "content": {"type": ["attribute"], "name": ["log0"]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.log.log1", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/log.py"}, "content": {"type": ["attribute"], "name": ["log1"]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.log.log2", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/log.py"}, "content": {"type": ["attribute"], "name": ["log2"]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.log.log3", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/log.py"}, "content": {"type": ["attribute"], "name": ["log3"]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.log.log4", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/log.py"}, "content": {"type": ["attribute"], "name": ["log4"]}}, {"source": {"identifier": "ethereum.constantinople.vm", "specifier": 0, "path": "src/ethereum/constantinople/vm/__init__.py"}, "content": {"type": ["module"], "name": ["ethereum.constantinople.vm"], "text": ["Ethereum Virtual Machine (EVM) ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction The abstract computer which runs the code stored in an .fork_types.Account ."]}}, {"source": {"identifier": "ethereum.constantinople.vm.__all__", "specifier": 0, "path": "src/ethereum/constantinople/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["__all__"]}}, {"source": {"identifier": "ethereum.constantinople.vm.Environment", "specifier": 0, "path": "src/ethereum/constantinople/vm/__init__.py"}, "content": {"type": ["class"], "name": ["Environment"], "text": ["Items external to the virtual machine itself, provided by the environment."]}}, {"source": {"identifier": "ethereum.constantinople.vm.Environment.caller", "specifier": 0, "path": "src/ethereum/constantinople/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["caller"]}}, {"source": {"identifier": "ethereum.constantinople.vm.Environment.block_hashes", "specifier": 0, "path": "src/ethereum/constantinople/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["block_hashes"]}}, {"source": {"identifier": "ethereum.constantinople.vm.Environment.origin", "specifier": 0, "path": "src/ethereum/constantinople/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["origin"]}}, {"source": {"identifier": "ethereum.constantinople.vm.Environment.coinbase", "specifier": 0, "path": "src/ethereum/constantinople/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["coinbase"]}}, {"source": {"identifier": "ethereum.constantinople.vm.Environment.number", "specifier": 0, "path": "src/ethereum/constantinople/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["number"]}}, {"source": {"identifier": "ethereum.constantinople.vm.Environment.gas_limit", "specifier": 0, "path": "src/ethereum/constantinople/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["gas_limit"]}}, {"source": {"identifier": "ethereum.constantinople.vm.Environment.gas_price", "specifier": 0, "path": "src/ethereum/constantinople/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["gas_price"]}}, {"source": {"identifier": "ethereum.constantinople.vm.Environment.time", "specifier": 0, "path": "src/ethereum/constantinople/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["time"]}}, {"source": {"identifier": "ethereum.constantinople.vm.Environment.difficulty", "specifier": 0, "path": "src/ethereum/constantinople/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["difficulty"]}}, {"source": {"identifier": "ethereum.constantinople.vm.Environment.state", "specifier": 0, "path": "src/ethereum/constantinople/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["state"]}}, {"source": {"identifier": "ethereum.constantinople.vm.Message", "specifier": 0, "path": "src/ethereum/constantinople/vm/__init__.py"}, "content": {"type": ["class"], "name": ["Message"], "text": ["Items that are used by contract creation or message call."]}}, {"source": {"identifier": "ethereum.constantinople.vm.Message.caller", "specifier": 0, "path": "src/ethereum/constantinople/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["caller"]}}, {"source": {"identifier": "ethereum.constantinople.vm.Message.target", "specifier": 0, "path": "src/ethereum/constantinople/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["target"]}}, {"source": {"identifier": "ethereum.constantinople.vm.Message.current_target", "specifier": 0, "path": "src/ethereum/constantinople/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["current_target"]}}, {"source": {"identifier": "ethereum.constantinople.vm.Message.gas", "specifier": 0, "path": "src/ethereum/constantinople/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["gas"]}}, {"source": {"identifier": "ethereum.constantinople.vm.Message.value", "specifier": 0, "path": "src/ethereum/constantinople/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["value"]}}, {"source": {"identifier": "ethereum.constantinople.vm.Message.data", "specifier": 0, "path": "src/ethereum/constantinople/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["data"]}}, {"source": {"identifier": "ethereum.constantinople.vm.Message.code_address", "specifier": 0, "path": "src/ethereum/constantinople/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["code_address"]}}, {"source": {"identifier": "ethereum.constantinople.vm.Message.code", "specifier": 0, "path": "src/ethereum/constantinople/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["code"]}}, {"source": {"identifier": "ethereum.constantinople.vm.Message.depth", "specifier": 0, "path": "src/ethereum/constantinople/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["depth"]}}, {"source": {"identifier": "ethereum.constantinople.vm.Message.should_transfer_value", "specifier": 0, "path": "src/ethereum/constantinople/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["should_transfer_value"]}}, {"source": {"identifier": "ethereum.constantinople.vm.Message.is_static", "specifier": 0, "path": "src/ethereum/constantinople/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["is_static"]}}, {"source": {"identifier": "ethereum.constantinople.vm.Evm", "specifier": 0, "path": "src/ethereum/constantinople/vm/__init__.py"}, "content": {"type": ["class"], "name": ["Evm"], "text": ["The internal state of the virtual machine."]}}, {"source": {"identifier": "ethereum.constantinople.vm.Evm.pc", "specifier": 0, "path": "src/ethereum/constantinople/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["pc"]}}, {"source": {"identifier": "ethereum.constantinople.vm.Evm.stack", "specifier": 0, "path": "src/ethereum/constantinople/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["stack"]}}, {"source": {"identifier": "ethereum.constantinople.vm.Evm.memory", "specifier": 0, "path": "src/ethereum/constantinople/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["memory"]}}, {"source": {"identifier": "ethereum.constantinople.vm.Evm.code", "specifier": 0, "path": "src/ethereum/constantinople/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["code"]}}, {"source": {"identifier": "ethereum.constantinople.vm.Evm.gas_left", "specifier": 0, "path": "src/ethereum/constantinople/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["gas_left"]}}, {"source": {"identifier": "ethereum.constantinople.vm.Evm.env", "specifier": 0, "path": "src/ethereum/constantinople/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["env"]}}, {"source": {"identifier": "ethereum.constantinople.vm.Evm.valid_jump_destinations", "specifier": 0, "path": "src/ethereum/constantinople/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["valid_jump_destinations"]}}, {"source": {"identifier": "ethereum.constantinople.vm.Evm.logs", "specifier": 0, "path": "src/ethereum/constantinople/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["logs"]}}, {"source": {"identifier": "ethereum.constantinople.vm.Evm.refund_counter", "specifier": 0, "path": "src/ethereum/constantinople/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["refund_counter"]}}, {"source": {"identifier": "ethereum.constantinople.vm.Evm.running", "specifier": 0, "path": "src/ethereum/constantinople/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["running"]}}, {"source": {"identifier": "ethereum.constantinople.vm.Evm.message", "specifier": 0, "path": "src/ethereum/constantinople/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["message"]}}, {"source": {"identifier": "ethereum.constantinople.vm.Evm.output", "specifier": 0, "path": "src/ethereum/constantinople/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["output"]}}, {"source": {"identifier": "ethereum.constantinople.vm.Evm.accounts_to_delete", "specifier": 0, "path": "src/ethereum/constantinople/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["accounts_to_delete"]}}, {"source": {"identifier": "ethereum.constantinople.vm.Evm.touched_accounts", "specifier": 0, "path": "src/ethereum/constantinople/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["touched_accounts"]}}, {"source": {"identifier": "ethereum.constantinople.vm.Evm.has_erred", "specifier": 0, "path": "src/ethereum/constantinople/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["has_erred"]}}, {"source": {"identifier": "ethereum.constantinople.vm.Evm.return_data", "specifier": 0, "path": "src/ethereum/constantinople/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["return_data"]}}, {"source": {"identifier": "ethereum.constantinople.vm.Evm.error", "specifier": 0, "path": "src/ethereum/constantinople/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["error"]}}, {"source": {"identifier": "ethereum.constantinople.vm.incorporate_child_on_success", "specifier": 0, "path": "src/ethereum/constantinople/vm/__init__.py"}, "content": {"type": ["function"], "name": ["incorporate_child_on_success"], "text": ["Incorporate the state of a successful  child_evm  into the parent  evm . Parameters evm : The parent  EVM . child_evm : The child evm to incorporate."]}}, {"source": {"identifier": "ethereum.constantinople.vm.incorporate_child_on_error", "specifier": 0, "path": "src/ethereum/constantinople/vm/__init__.py"}, "content": {"type": ["function"], "name": ["incorporate_child_on_error"], "text": ["Incorporate the state of an unsuccessful  child_evm  into the parent  evm . Parameters evm : The parent  EVM . child_evm : The child evm to incorporate."]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.precompiled_contracts", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/precompiled_contracts/__init__.py"}, "content": {"type": ["module"], "name": ["ethereum.arrow_glacier.vm.precompiled_contracts"], "text": ["Precompiled Contract Addresses ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Addresses of precompiled contracts and mappings to their implementations."]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.precompiled_contracts.__all__", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/precompiled_contracts/__init__.py"}, "content": {"type": ["attribute"], "name": ["__all__"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.precompiled_contracts.ECRECOVER_ADDRESS", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/precompiled_contracts/__init__.py"}, "content": {"type": ["attribute"], "name": ["ECRECOVER_ADDRESS"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.precompiled_contracts.SHA256_ADDRESS", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/precompiled_contracts/__init__.py"}, "content": {"type": ["attribute"], "name": ["SHA256_ADDRESS"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.precompiled_contracts.RIPEMD160_ADDRESS", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/precompiled_contracts/__init__.py"}, "content": {"type": ["attribute"], "name": ["RIPEMD160_ADDRESS"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.precompiled_contracts.IDENTITY_ADDRESS", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/precompiled_contracts/__init__.py"}, "content": {"type": ["attribute"], "name": ["IDENTITY_ADDRESS"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.precompiled_contracts.MODEXP_ADDRESS", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/precompiled_contracts/__init__.py"}, "content": {"type": ["attribute"], "name": ["MODEXP_ADDRESS"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.precompiled_contracts.ALT_BN128_ADD_ADDRESS", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/precompiled_contracts/__init__.py"}, "content": {"type": ["attribute"], "name": ["ALT_BN128_ADD_ADDRESS"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.precompiled_contracts.ALT_BN128_MUL_ADDRESS", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/precompiled_contracts/__init__.py"}, "content": {"type": ["attribute"], "name": ["ALT_BN128_MUL_ADDRESS"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.precompiled_contracts.ALT_BN128_PAIRING_CHECK_ADDRESS", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/precompiled_contracts/__init__.py"}, "content": {"type": ["attribute"], "name": ["ALT_BN128_PAIRING_CHECK_ADDRESS"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.precompiled_contracts.BLAKE2F_ADDRESS", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/precompiled_contracts/__init__.py"}, "content": {"type": ["attribute"], "name": ["BLAKE2F_ADDRESS"]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.storage", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/storage.py"}, "content": {"type": ["module"], "name": ["ethereum.frontier.vm.instructions.storage"], "text": ["Ethereum Virtual Machine (EVM) Storage Instructions ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementations of the EVM storage related instructions."]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.storage.sload", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/storage.py"}, "content": {"type": ["function"], "name": ["sload"], "text": ["Loads to the stack, the value corresponding to a certain key from the storage of the current account. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.storage.sstore", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/storage.py"}, "content": {"type": ["function"], "name": ["sstore"], "text": ["Stores a value at a certain key in the current context's storage. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.constantinople.vm.runtime", "specifier": 0, "path": "src/ethereum/constantinople/vm/runtime.py"}, "content": {"type": ["module"], "name": ["ethereum.constantinople.vm.runtime"], "text": ["Ethereum Virtual Machine (EVM) Runtime Operations ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Runtime related operations used while executing EVM code."]}}, {"source": {"identifier": "ethereum.constantinople.vm.runtime.get_valid_jump_destinations", "specifier": 0, "path": "src/ethereum/constantinople/vm/runtime.py"}, "content": {"type": ["function"], "name": ["get_valid_jump_destinations"], "text": ["Analyze the evm code to obtain the set of valid jump destinations. Valid jump destinations are defined as follows: * The jump destination is less than the length of the code. * The jump destination should have the  JUMPDEST  opcode (0x5B). * The jump destination shouldn't be part of the data corresponding to PUSH-N  opcodes. Note - Jump destinations are 0-indexed. Parameters code : The EVM code which is to be executed. Returns valid_jump_destinations:  Set[Uint] The set of valid jump destinations in the code."]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.precompiled_contracts.alt_bn128", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/precompiled_contracts/alt_bn128.py"}, "content": {"type": ["module"], "name": ["ethereum.arrow_glacier.vm.precompiled_contracts.alt_bn128"], "text": ["Ethereum Virtual Machine (EVM) ALT_BN128 CONTRACTS ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementation of the ALT_BN128 precompiled contracts."]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.precompiled_contracts.alt_bn128.alt_bn128_add", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/precompiled_contracts/alt_bn128.py"}, "content": {"type": ["function"], "name": ["alt_bn128_add"], "text": ["The ALT_BN128 addition precompiled contract. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.precompiled_contracts.alt_bn128.alt_bn128_mul", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/precompiled_contracts/alt_bn128.py"}, "content": {"type": ["function"], "name": ["alt_bn128_mul"], "text": ["The ALT_BN128 multiplication precompiled contract. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.precompiled_contracts.alt_bn128.alt_bn128_pairing_check", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/precompiled_contracts/alt_bn128.py"}, "content": {"type": ["function"], "name": ["alt_bn128_pairing_check"], "text": ["The ALT_BN128 pairing check precompiled contract. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.block", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/block.py"}, "content": {"type": ["module"], "name": ["ethereum.frontier.vm.instructions.block"], "text": ["Ethereum Virtual Machine (EVM) Block Instructions ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementations of the EVM block instructions."]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.block.block_hash", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/block.py"}, "content": {"type": ["function"], "name": ["block_hash"], "text": ["Push the hash of one of the 256 most recent complete blocks onto the stack. The block number to hash is present at the top of the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.block.coinbase", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/block.py"}, "content": {"type": ["function"], "name": ["coinbase"], "text": ["Push the current block's beneficiary address (address of the block miner) onto the stack. Here the current block refers to the block in which the currently executing transaction/call resides. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.block.timestamp", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/block.py"}, "content": {"type": ["function"], "name": ["timestamp"], "text": ["Push the current block's timestamp onto the stack. Here the timestamp being referred is actually the unix timestamp in seconds. Here the current block refers to the block in which the currently executing transaction/call resides. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.block.number", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/block.py"}, "content": {"type": ["function"], "name": ["number"], "text": ["Push the current block's number onto the stack. Here the current block refers to the block in which the currently executing transaction/call resides. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.block.difficulty", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/block.py"}, "content": {"type": ["function"], "name": ["difficulty"], "text": ["Push the current block's difficulty onto the stack. Here the current block refers to the block in which the currently executing transaction/call resides. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.block.gas_limit", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/block.py"}, "content": {"type": ["function"], "name": ["gas_limit"], "text": ["Push the current block's gas limit onto the stack. Here the current block refers to the block in which the currently executing transaction/call resides. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.constantinople.vm.interpreter", "specifier": 0, "path": "src/ethereum/constantinople/vm/interpreter.py"}, "content": {"type": ["module"], "name": ["ethereum.constantinople.vm.interpreter"], "text": ["Ethereum Virtual Machine (EVM) Interpreter ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction A straightforward interpreter that executes EVM code."]}}, {"source": {"identifier": "ethereum.constantinople.vm.interpreter.STACK_DEPTH_LIMIT", "specifier": 0, "path": "src/ethereum/constantinople/vm/interpreter.py"}, "content": {"type": ["attribute"], "name": ["STACK_DEPTH_LIMIT"]}}, {"source": {"identifier": "ethereum.constantinople.vm.interpreter.MAX_CODE_SIZE", "specifier": 0, "path": "src/ethereum/constantinople/vm/interpreter.py"}, "content": {"type": ["attribute"], "name": ["MAX_CODE_SIZE"]}}, {"source": {"identifier": "ethereum.constantinople.vm.interpreter.MessageCallOutput", "specifier": 0, "path": "src/ethereum/constantinople/vm/interpreter.py"}, "content": {"type": ["class"], "name": ["MessageCallOutput"], "text": ["Output of a particular message call Contains the following:   1. `gas_left`: remaining gas after execution.\n  2. `refund_counter`: gas to refund after execution.\n  3. `logs`: list of `Log` generated during execution.\n  4. `accounts_to_delete`: Contracts which have self-destructed.\n  5. `touched_accounts`: Accounts that have been touched.\n  6. `has_erred`: True if execution has caused an error.\n"]}}, {"source": {"identifier": "ethereum.constantinople.vm.interpreter.MessageCallOutput.gas_left", "specifier": 0, "path": "src/ethereum/constantinople/vm/interpreter.py"}, "content": {"type": ["attribute"], "name": ["gas_left"]}}, {"source": {"identifier": "ethereum.constantinople.vm.interpreter.MessageCallOutput.refund_counter", "specifier": 0, "path": "src/ethereum/constantinople/vm/interpreter.py"}, "content": {"type": ["attribute"], "name": ["refund_counter"]}}, {"source": {"identifier": "ethereum.constantinople.vm.interpreter.MessageCallOutput.logs", "specifier": 0, "path": "src/ethereum/constantinople/vm/interpreter.py"}, "content": {"type": ["attribute"], "name": ["logs"]}}, {"source": {"identifier": "ethereum.constantinople.vm.interpreter.MessageCallOutput.accounts_to_delete", "specifier": 0, "path": "src/ethereum/constantinople/vm/interpreter.py"}, "content": {"type": ["attribute"], "name": ["accounts_to_delete"]}}, {"source": {"identifier": "ethereum.constantinople.vm.interpreter.MessageCallOutput.touched_accounts", "specifier": 0, "path": "src/ethereum/constantinople/vm/interpreter.py"}, "content": {"type": ["attribute"], "name": ["touched_accounts"]}}, {"source": {"identifier": "ethereum.constantinople.vm.interpreter.MessageCallOutput.has_erred", "specifier": 0, "path": "src/ethereum/constantinople/vm/interpreter.py"}, "content": {"type": ["attribute"], "name": ["has_erred"]}}, {"source": {"identifier": "ethereum.constantinople.vm.interpreter.process_message_call", "specifier": 0, "path": "src/ethereum/constantinople/vm/interpreter.py"}, "content": {"type": ["function"], "name": ["process_message_call"], "text": ["If  message.current  is empty then it creates a smart contract else it executes a call from the  message.caller  to the  message.target . Parameters message : Transaction specific items. env : External items required for EVM execution. Returns output :  MessageCallOutput Output of the message call"]}}, {"source": {"identifier": "ethereum.constantinople.vm.interpreter.process_create_message", "specifier": 0, "path": "src/ethereum/constantinople/vm/interpreter.py"}, "content": {"type": ["function"], "name": ["process_create_message"], "text": ["Executes a call to create a smart contract. Parameters message : Transaction specific items. env : External items required for EVM execution. Returns evm: :py:class: ~ethereum.constantinople.vm.Evm Items containing execution specific objects."]}}, {"source": {"identifier": "ethereum.constantinople.vm.interpreter.process_message", "specifier": 0, "path": "src/ethereum/constantinople/vm/interpreter.py"}, "content": {"type": ["function"], "name": ["process_message"], "text": ["Executes a call to create a smart contract. Parameters message : Transaction specific items. env : External items required for EVM execution. Returns evm: :py:class: ~ethereum.constantinople.vm.Evm Items containing execution specific objects"]}}, {"source": {"identifier": "ethereum.constantinople.vm.interpreter.execute_code", "specifier": 0, "path": "src/ethereum/constantinople/vm/interpreter.py"}, "content": {"type": ["function"], "name": ["execute_code"], "text": ["Executes bytecode present in the  message . Parameters message : Transaction specific items. env : External items required for EVM execution. Returns evm:  ethereum.vm.EVM Items containing execution specific objects"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.precompiled_contracts.ripemd160", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/precompiled_contracts/ripemd160.py"}, "content": {"type": ["module"], "name": ["ethereum.arrow_glacier.vm.precompiled_contracts.ripemd160"], "text": ["Ethereum Virtual Machine (EVM) RIPEMD160 PRECOMPILED CONTRACT ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementation of the  RIPEMD160  precompiled contract."]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.precompiled_contracts.ripemd160.ripemd160", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/precompiled_contracts/ripemd160.py"}, "content": {"type": ["function"], "name": ["ripemd160"], "text": ["Writes the ripemd160 hash to output. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.arithmetic", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/arithmetic.py"}, "content": {"type": ["module"], "name": ["ethereum.frontier.vm.instructions.arithmetic"], "text": ["Ethereum Virtual Machine (EVM) Arithmetic Instructions ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementations of the EVM Arithmetic instructions."]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.arithmetic.add", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/arithmetic.py"}, "content": {"type": ["function"], "name": ["add"], "text": ["Adds the top two elements of the stack together, and pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.arithmetic.sub", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/arithmetic.py"}, "content": {"type": ["function"], "name": ["sub"], "text": ["Subtracts the top two elements of the stack, and pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.arithmetic.mul", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/arithmetic.py"}, "content": {"type": ["function"], "name": ["mul"], "text": ["Multiply the top two elements of the stack, and pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.arithmetic.div", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/arithmetic.py"}, "content": {"type": ["function"], "name": ["div"], "text": ["Integer division of the top two elements of the stack. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.arithmetic.sdiv", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/arithmetic.py"}, "content": {"type": ["function"], "name": ["sdiv"], "text": ["Signed integer division of the top two elements of the stack. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.arithmetic.mod", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/arithmetic.py"}, "content": {"type": ["function"], "name": ["mod"], "text": ["Modulo remainder of the top two elements of the stack. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.arithmetic.smod", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/arithmetic.py"}, "content": {"type": ["function"], "name": ["smod"], "text": ["Signed modulo remainder of the top two elements of the stack. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.arithmetic.addmod", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/arithmetic.py"}, "content": {"type": ["function"], "name": ["addmod"], "text": ["Modulo addition of the top 2 elements with the 3rd element. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.arithmetic.mulmod", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/arithmetic.py"}, "content": {"type": ["function"], "name": ["mulmod"], "text": ["Modulo multiplication of the top 2 elements with the 3rd element. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.arithmetic.exp", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/arithmetic.py"}, "content": {"type": ["function"], "name": ["exp"], "text": ["Exponential operation of the top 2 elements. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.arithmetic.signextend", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/arithmetic.py"}, "content": {"type": ["function"], "name": ["signextend"], "text": ["Sign extend operation. In other words, extend a signed number which fits in N bytes to 32 bytes. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.constantinople.vm.stack", "specifier": 0, "path": "src/ethereum/constantinople/vm/stack.py"}, "content": {"type": ["module"], "name": ["ethereum.constantinople.vm.stack"], "text": ["Ethereum Virtual Machine (EVM) Stack ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementation of the stack operators for the EVM."]}}, {"source": {"identifier": "ethereum.constantinople.vm.stack.pop", "specifier": 0, "path": "src/ethereum/constantinople/vm/stack.py"}, "content": {"type": ["function"], "name": ["pop"], "text": ["Pops the top item off of  stack . Parameters stack : EVM stack. Returns value :  U256 The top element on the stack."]}}, {"source": {"identifier": "ethereum.constantinople.vm.stack.push", "specifier": 0, "path": "src/ethereum/constantinople/vm/stack.py"}, "content": {"type": ["function"], "name": ["push"], "text": ["Pushes  value  onto  stack . Parameters stack : EVM stack. value : Item to be pushed onto  stack ."]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.precompiled_contracts.sha256", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/precompiled_contracts/sha256.py"}, "content": {"type": ["module"], "name": ["ethereum.arrow_glacier.vm.precompiled_contracts.sha256"], "text": ["Ethereum Virtual Machine (EVM) SHA256 PRECOMPILED CONTRACT ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementation of the  SHA256  precompiled contract."]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.precompiled_contracts.sha256.sha256", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/precompiled_contracts/sha256.py"}, "content": {"type": ["function"], "name": ["sha256"], "text": ["Writes the sha256 hash to output. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.keccak", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/keccak.py"}, "content": {"type": ["module"], "name": ["ethereum.frontier.vm.instructions.keccak"], "text": ["Ethereum Virtual Machine (EVM) Keccak Instructions ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementations of the EVM keccak instructions."]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.keccak.keccak", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/keccak.py"}, "content": {"type": ["function"], "name": ["keccak"], "text": ["Pushes to the stack the Keccak-256 hash of a region of memory. This also expands the memory, in case the memory is insufficient to access the data's memory location. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.constantinople.vm.gas", "specifier": 0, "path": "src/ethereum/constantinople/vm/gas.py"}, "content": {"type": ["module"], "name": ["ethereum.constantinople.vm.gas"], "text": ["Ethereum Virtual Machine (EVM) Gas ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction EVM gas constants and calculators."]}}, {"source": {"identifier": "ethereum.constantinople.vm.gas.GAS_JUMPDEST", "specifier": 0, "path": "src/ethereum/constantinople/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_JUMPDEST"]}}, {"source": {"identifier": "ethereum.constantinople.vm.gas.GAS_BASE", "specifier": 0, "path": "src/ethereum/constantinople/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_BASE"]}}, {"source": {"identifier": "ethereum.constantinople.vm.gas.GAS_VERY_LOW", "specifier": 0, "path": "src/ethereum/constantinople/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_VERY_LOW"]}}, {"source": {"identifier": "ethereum.constantinople.vm.gas.GAS_SLOAD", "specifier": 0, "path": "src/ethereum/constantinople/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_SLOAD"]}}, {"source": {"identifier": "ethereum.constantinople.vm.gas.GAS_STORAGE_SET", "specifier": 0, "path": "src/ethereum/constantinople/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_STORAGE_SET"]}}, {"source": {"identifier": "ethereum.constantinople.vm.gas.GAS_STORAGE_UPDATE", "specifier": 0, "path": "src/ethereum/constantinople/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_STORAGE_UPDATE"]}}, {"source": {"identifier": "ethereum.constantinople.vm.gas.GAS_STORAGE_CLEAR_REFUND", "specifier": 0, "path": "src/ethereum/constantinople/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_STORAGE_CLEAR_REFUND"]}}, {"source": {"identifier": "ethereum.constantinople.vm.gas.GAS_LOW", "specifier": 0, "path": "src/ethereum/constantinople/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_LOW"]}}, {"source": {"identifier": "ethereum.constantinople.vm.gas.GAS_MID", "specifier": 0, "path": "src/ethereum/constantinople/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_MID"]}}, {"source": {"identifier": "ethereum.constantinople.vm.gas.GAS_HIGH", "specifier": 0, "path": "src/ethereum/constantinople/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_HIGH"]}}, {"source": {"identifier": "ethereum.constantinople.vm.gas.GAS_EXPONENTIATION", "specifier": 0, "path": "src/ethereum/constantinople/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_EXPONENTIATION"]}}, {"source": {"identifier": "ethereum.constantinople.vm.gas.GAS_EXPONENTIATION_PER_BYTE", "specifier": 0, "path": "src/ethereum/constantinople/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_EXPONENTIATION_PER_BYTE"]}}, {"source": {"identifier": "ethereum.constantinople.vm.gas.GAS_MEMORY", "specifier": 0, "path": "src/ethereum/constantinople/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_MEMORY"]}}, {"source": {"identifier": "ethereum.constantinople.vm.gas.GAS_KECCAK256", "specifier": 0, "path": "src/ethereum/constantinople/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_KECCAK256"]}}, {"source": {"identifier": "ethereum.constantinople.vm.gas.GAS_KECCAK256_WORD", "specifier": 0, "path": "src/ethereum/constantinople/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_KECCAK256_WORD"]}}, {"source": {"identifier": "ethereum.constantinople.vm.gas.GAS_COPY", "specifier": 0, "path": "src/ethereum/constantinople/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_COPY"]}}, {"source": {"identifier": "ethereum.constantinople.vm.gas.GAS_BLOCK_HASH", "specifier": 0, "path": "src/ethereum/constantinople/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_BLOCK_HASH"]}}, {"source": {"identifier": "ethereum.constantinople.vm.gas.GAS_EXTERNAL", "specifier": 0, "path": "src/ethereum/constantinople/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_EXTERNAL"]}}, {"source": {"identifier": "ethereum.constantinople.vm.gas.GAS_BALANCE", "specifier": 0, "path": "src/ethereum/constantinople/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_BALANCE"]}}, {"source": {"identifier": "ethereum.constantinople.vm.gas.GAS_LOG", "specifier": 0, "path": "src/ethereum/constantinople/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_LOG"]}}, {"source": {"identifier": "ethereum.constantinople.vm.gas.GAS_LOG_DATA", "specifier": 0, "path": "src/ethereum/constantinople/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_LOG_DATA"]}}, {"source": {"identifier": "ethereum.constantinople.vm.gas.GAS_LOG_TOPIC", "specifier": 0, "path": "src/ethereum/constantinople/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_LOG_TOPIC"]}}, {"source": {"identifier": "ethereum.constantinople.vm.gas.GAS_CREATE", "specifier": 0, "path": "src/ethereum/constantinople/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_CREATE"]}}, {"source": {"identifier": "ethereum.constantinople.vm.gas.GAS_CODE_DEPOSIT", "specifier": 0, "path": "src/ethereum/constantinople/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_CODE_DEPOSIT"]}}, {"source": {"identifier": "ethereum.constantinople.vm.gas.GAS_ZERO", "specifier": 0, "path": "src/ethereum/constantinople/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_ZERO"]}}, {"source": {"identifier": "ethereum.constantinople.vm.gas.GAS_CALL", "specifier": 0, "path": "src/ethereum/constantinople/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_CALL"]}}, {"source": {"identifier": "ethereum.constantinople.vm.gas.GAS_NEW_ACCOUNT", "specifier": 0, "path": "src/ethereum/constantinople/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_NEW_ACCOUNT"]}}, {"source": {"identifier": "ethereum.constantinople.vm.gas.GAS_CALL_VALUE", "specifier": 0, "path": "src/ethereum/constantinople/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_CALL_VALUE"]}}, {"source": {"identifier": "ethereum.constantinople.vm.gas.GAS_CALL_STIPEND", "specifier": 0, "path": "src/ethereum/constantinople/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_CALL_STIPEND"]}}, {"source": {"identifier": "ethereum.constantinople.vm.gas.GAS_SELF_DESTRUCT", "specifier": 0, "path": "src/ethereum/constantinople/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_SELF_DESTRUCT"]}}, {"source": {"identifier": "ethereum.constantinople.vm.gas.GAS_SELF_DESTRUCT_NEW_ACCOUNT", "specifier": 0, "path": "src/ethereum/constantinople/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_SELF_DESTRUCT_NEW_ACCOUNT"]}}, {"source": {"identifier": "ethereum.constantinople.vm.gas.REFUND_SELF_DESTRUCT", "specifier": 0, "path": "src/ethereum/constantinople/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["REFUND_SELF_DESTRUCT"]}}, {"source": {"identifier": "ethereum.constantinople.vm.gas.GAS_ECRECOVER", "specifier": 0, "path": "src/ethereum/constantinople/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_ECRECOVER"]}}, {"source": {"identifier": "ethereum.constantinople.vm.gas.GAS_SHA256", "specifier": 0, "path": "src/ethereum/constantinople/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_SHA256"]}}, {"source": {"identifier": "ethereum.constantinople.vm.gas.GAS_SHA256_WORD", "specifier": 0, "path": "src/ethereum/constantinople/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_SHA256_WORD"]}}, {"source": {"identifier": "ethereum.constantinople.vm.gas.GAS_RIPEMD160", "specifier": 0, "path": "src/ethereum/constantinople/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_RIPEMD160"]}}, {"source": {"identifier": "ethereum.constantinople.vm.gas.GAS_RIPEMD160_WORD", "specifier": 0, "path": "src/ethereum/constantinople/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_RIPEMD160_WORD"]}}, {"source": {"identifier": "ethereum.constantinople.vm.gas.GAS_IDENTITY", "specifier": 0, "path": "src/ethereum/constantinople/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_IDENTITY"]}}, {"source": {"identifier": "ethereum.constantinople.vm.gas.GAS_IDENTITY_WORD", "specifier": 0, "path": "src/ethereum/constantinople/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_IDENTITY_WORD"]}}, {"source": {"identifier": "ethereum.constantinople.vm.gas.GAS_RETURN_DATA_COPY", "specifier": 0, "path": "src/ethereum/constantinople/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_RETURN_DATA_COPY"]}}, {"source": {"identifier": "ethereum.constantinople.vm.gas.GAS_CODE_HASH", "specifier": 0, "path": "src/ethereum/constantinople/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_CODE_HASH"]}}, {"source": {"identifier": "ethereum.constantinople.vm.gas.ExtendMemory", "specifier": 0, "path": "src/ethereum/constantinople/vm/gas.py"}, "content": {"type": ["class"], "name": ["ExtendMemory"], "text": ["Define the parameters for memory extension in opcodes cost :  ethereum.base_types.Uint The gas required to perform the extension expand_by :  ethereum.base_types.Uint The size by which the memory will be extended"]}}, {"source": {"identifier": "ethereum.constantinople.vm.gas.ExtendMemory.cost", "specifier": 0, "path": "src/ethereum/constantinople/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["cost"]}}, {"source": {"identifier": "ethereum.constantinople.vm.gas.ExtendMemory.expand_by", "specifier": 0, "path": "src/ethereum/constantinople/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["expand_by"]}}, {"source": {"identifier": "ethereum.constantinople.vm.gas.MessageCallGas", "specifier": 0, "path": "src/ethereum/constantinople/vm/gas.py"}, "content": {"type": ["class"], "name": ["MessageCallGas"], "text": ["Define the gas cost and stipend for executing the call opcodes. cost :  ethereum.base_types.Uint The non-refundable portion of gas reserved for executing the call opcode. stipend :  ethereum.base_types.Uint The portion of gas available to sub-calls that is refundable if not consumed"]}}, {"source": {"identifier": "ethereum.constantinople.vm.gas.MessageCallGas.cost", "specifier": 0, "path": "src/ethereum/constantinople/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["cost"]}}, {"source": {"identifier": "ethereum.constantinople.vm.gas.MessageCallGas.stipend", "specifier": 0, "path": "src/ethereum/constantinople/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["stipend"]}}, {"source": {"identifier": "ethereum.constantinople.vm.gas.charge_gas", "specifier": 0, "path": "src/ethereum/constantinople/vm/gas.py"}, "content": {"type": ["function"], "name": ["charge_gas"], "text": ["Subtracts  amount  from  evm.gas_left . Parameters evm : The current EVM. amount : The amount of gas the current operation requires."]}}, {"source": {"identifier": "ethereum.constantinople.vm.gas.calculate_memory_gas_cost", "specifier": 0, "path": "src/ethereum/constantinople/vm/gas.py"}, "content": {"type": ["function"], "name": ["calculate_memory_gas_cost"], "text": ["Calculates the gas cost for allocating memory to the smallest multiple of 32 bytes, such that the allocated size is at least as big as the given size. Parameters size_in_bytes : The size of the data in bytes. Returns total_gas_cost :  ethereum.base_types.Uint The gas cost for storing data in memory."]}}, {"source": {"identifier": "ethereum.constantinople.vm.gas.calculate_gas_extend_memory", "specifier": 0, "path": "src/ethereum/constantinople/vm/gas.py"}, "content": {"type": ["function"], "name": ["calculate_gas_extend_memory"], "text": ["Calculates the gas amount to extend memory Parameters memory : Memory contents of the EVM. extensions: List of extensions to be made to the memory. Consists of a tuple of start position and size. Returns extend_memory:  ExtendMemory"]}}, {"source": {"identifier": "ethereum.constantinople.vm.gas.calculate_message_call_gas", "specifier": 0, "path": "src/ethereum/constantinople/vm/gas.py"}, "content": {"type": ["function"], "name": ["calculate_message_call_gas"], "text": ["Calculates the MessageCallGas (cost and stipend) for executing call Opcodes. Parameters value: The amount of  ETH  that needs to be transferred. gas : The amount of gas provided to the message-call. gas_left : The amount of gas left in the current frame. memory_cost : The amount needed to extend the memory in the current frame. extra_gas : The amount of gas needed for transferring value + creating a new account inside a message call. call_stipend : The amount of stipend provided to a message call to execute code while transferring value(ETH). Returns message_call_gas:  MessageCallGas"]}}, {"source": {"identifier": "ethereum.constantinople.vm.gas.max_message_call_gas", "specifier": 0, "path": "src/ethereum/constantinople/vm/gas.py"}, "content": {"type": ["function"], "name": ["max_message_call_gas"], "text": ["Calculates the maximum gas that is allowed for making a message call Parameters gas : The amount of gas provided to the message-call. Returns max_allowed_message_call_gas:  ethereum.base_types.Uint The maximum gas allowed for making the message-call."]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.precompiled_contracts.modexp", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/precompiled_contracts/modexp.py"}, "content": {"type": ["module"], "name": ["ethereum.arrow_glacier.vm.precompiled_contracts.modexp"], "text": ["Ethereum Virtual Machine (EVM) MODEXP PRECOMPILED CONTRACT ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementation of the  MODEXP  precompiled contract."]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.precompiled_contracts.modexp.GQUADDIVISOR", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/precompiled_contracts/modexp.py"}, "content": {"type": ["attribute"], "name": ["GQUADDIVISOR"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.precompiled_contracts.modexp.modexp", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/precompiled_contracts/modexp.py"}, "content": {"type": ["function"], "name": ["modexp"], "text": ["Calculates  (base**exp) % modulus  for arbitary sized  base ,  exp  and. modulus . The return value is the same length as the modulus."]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.precompiled_contracts.modexp.complexity", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/precompiled_contracts/modexp.py"}, "content": {"type": ["function"], "name": ["complexity"], "text": ["Estimate the complexity of performing a modular exponentiation. Parameters base_length : Length of the array representing the base integer. modulus_length : Length of the array representing the modulus integer. Returns complexity :  Uint Complexity of performing the operation."]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.precompiled_contracts.modexp.iterations", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/precompiled_contracts/modexp.py"}, "content": {"type": ["function"], "name": ["iterations"], "text": ["Calculate the number of iterations required to perform a modular exponentiation. Parameters exponent_length : Length of the array representing the exponent integer. exponent_head : First 32 bytes of the exponent (with leading zero padding if it is shorter than 32 bytes), as an unsigned integer. Returns iterations :  Uint Number of iterations."]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.precompiled_contracts.modexp.gas_cost", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/precompiled_contracts/modexp.py"}, "content": {"type": ["function"], "name": ["gas_cost"], "text": ["Calculate the gas cost of performing a modular exponentiation. Parameters base_length : Length of the array representing the base integer. modulus_length : Length of the array representing the modulus integer. exponent_length : Length of the array representing the exponent integer. exponent_head : First 32 bytes of the exponent (with leading zero padding if it is shorter than 32 bytes), as an unsigned integer. Returns gas_cost :  Uint Gas required for performing the operation."]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.bitwise", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/bitwise.py"}, "content": {"type": ["module"], "name": ["ethereum.frontier.vm.instructions.bitwise"], "text": ["Ethereum Virtual Machine (EVM) Bitwise Instructions ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementations of the EVM bitwise instructions."]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.bitwise.bitwise_and", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/bitwise.py"}, "content": {"type": ["function"], "name": ["bitwise_and"], "text": ["Bitwise AND operation of the top 2 elements of the stack. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.bitwise.bitwise_or", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/bitwise.py"}, "content": {"type": ["function"], "name": ["bitwise_or"], "text": ["Bitwise OR operation of the top 2 elements of the stack. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.bitwise.bitwise_xor", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/bitwise.py"}, "content": {"type": ["function"], "name": ["bitwise_xor"], "text": ["Bitwise XOR operation of the top 2 elements of the stack. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.bitwise.bitwise_not", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/bitwise.py"}, "content": {"type": ["function"], "name": ["bitwise_not"], "text": ["Bitwise NOT operation of the top element of the stack. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.bitwise.get_byte", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/bitwise.py"}, "content": {"type": ["function"], "name": ["get_byte"], "text": ["For a word (defined by next top element of the stack), retrieve the Nth byte (0-indexed and defined by top element of stack) from the left (most significant) to right (least significant). Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.constantinople.vm.precompiled_contracts.mapping", "specifier": 0, "path": "src/ethereum/constantinople/vm/precompiled_contracts/mapping.py"}, "content": {"type": ["module"], "name": ["ethereum.constantinople.vm.precompiled_contracts.mapping"], "text": ["Precompiled Contract Addresses ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Mapping of precompiled contracts their implementations."]}}, {"source": {"identifier": "ethereum.constantinople.vm.precompiled_contracts.mapping.PRE_COMPILED_CONTRACTS", "specifier": 0, "path": "src/ethereum/constantinople/vm/precompiled_contracts/mapping.py"}, "content": {"type": ["attribute"], "name": ["PRE_COMPILED_CONTRACTS"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.precompiled_contracts.ecrecover", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/precompiled_contracts/ecrecover.py"}, "content": {"type": ["module"], "name": ["ethereum.arrow_glacier.vm.precompiled_contracts.ecrecover"], "text": ["Ethereum Virtual Machine (EVM) ECRECOVER PRECOMPILED CONTRACT ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementation of the ECRECOVER precompiled contract."]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.precompiled_contracts.ecrecover.ecrecover", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/precompiled_contracts/ecrecover.py"}, "content": {"type": ["function"], "name": ["ecrecover"], "text": ["Decrypts the address using elliptic curve DSA recovery mechanism and writes the address to output. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.environment", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/environment.py"}, "content": {"type": ["module"], "name": ["ethereum.frontier.vm.instructions.environment"], "text": ["Ethereum Virtual Machine (EVM) Environmental Instructions ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementations of the EVM environment related instructions."]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.environment.address", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["address"], "text": ["Pushes the address of the current executing account to the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.environment.balance", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["balance"], "text": ["Pushes the balance of the given account onto the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.environment.origin", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["origin"], "text": ["Pushes the address of the original transaction sender to the stack. The origin address can only be an EOA. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.environment.caller", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["caller"], "text": ["Pushes the address of the caller onto the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.environment.callvalue", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["callvalue"], "text": ["Push the value (in wei) sent with the call onto the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.environment.calldataload", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["calldataload"], "text": ["Push a word (32 bytes) of the input data belonging to the current environment onto the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.environment.calldatasize", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["calldatasize"], "text": ["Push the size of input data in current environment onto the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.environment.calldatacopy", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["calldatacopy"], "text": ["Copy a portion of the input data in current environment to memory. This will also expand the memory, in case that the memory is insufficient to store the data. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.environment.codesize", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["codesize"], "text": ["Push the size of code running in current environment onto the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.environment.codecopy", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["codecopy"], "text": ["Copy a portion of the code in current environment to memory. This will also expand the memory, in case that the memory is insufficient to store the data. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.environment.gasprice", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["gasprice"], "text": ["Push the gas price used in current environment onto the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.environment.extcodesize", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["extcodesize"], "text": ["Push the code size of a given account onto the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.environment.extcodecopy", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["extcodecopy"], "text": ["Copy a portion of an account's code to memory. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.constantinople.vm.precompiled_contracts", "specifier": 0, "path": "src/ethereum/constantinople/vm/precompiled_contracts/__init__.py"}, "content": {"type": ["module"], "name": ["ethereum.constantinople.vm.precompiled_contracts"], "text": ["Precompiled Contract Addresses ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Addresses of precompiled contracts and mappings to their implementations."]}}, {"source": {"identifier": "ethereum.constantinople.vm.precompiled_contracts.__all__", "specifier": 0, "path": "src/ethereum/constantinople/vm/precompiled_contracts/__init__.py"}, "content": {"type": ["attribute"], "name": ["__all__"]}}, {"source": {"identifier": "ethereum.constantinople.vm.precompiled_contracts.ECRECOVER_ADDRESS", "specifier": 0, "path": "src/ethereum/constantinople/vm/precompiled_contracts/__init__.py"}, "content": {"type": ["attribute"], "name": ["ECRECOVER_ADDRESS"]}}, {"source": {"identifier": "ethereum.constantinople.vm.precompiled_contracts.SHA256_ADDRESS", "specifier": 0, "path": "src/ethereum/constantinople/vm/precompiled_contracts/__init__.py"}, "content": {"type": ["attribute"], "name": ["SHA256_ADDRESS"]}}, {"source": {"identifier": "ethereum.constantinople.vm.precompiled_contracts.RIPEMD160_ADDRESS", "specifier": 0, "path": "src/ethereum/constantinople/vm/precompiled_contracts/__init__.py"}, "content": {"type": ["attribute"], "name": ["RIPEMD160_ADDRESS"]}}, {"source": {"identifier": "ethereum.constantinople.vm.precompiled_contracts.IDENTITY_ADDRESS", "specifier": 0, "path": "src/ethereum/constantinople/vm/precompiled_contracts/__init__.py"}, "content": {"type": ["attribute"], "name": ["IDENTITY_ADDRESS"]}}, {"source": {"identifier": "ethereum.constantinople.vm.precompiled_contracts.MODEXP_ADDRESS", "specifier": 0, "path": "src/ethereum/constantinople/vm/precompiled_contracts/__init__.py"}, "content": {"type": ["attribute"], "name": ["MODEXP_ADDRESS"]}}, {"source": {"identifier": "ethereum.constantinople.vm.precompiled_contracts.ALT_BN128_ADD_ADDRESS", "specifier": 0, "path": "src/ethereum/constantinople/vm/precompiled_contracts/__init__.py"}, "content": {"type": ["attribute"], "name": ["ALT_BN128_ADD_ADDRESS"]}}, {"source": {"identifier": "ethereum.constantinople.vm.precompiled_contracts.ALT_BN128_MUL_ADDRESS", "specifier": 0, "path": "src/ethereum/constantinople/vm/precompiled_contracts/__init__.py"}, "content": {"type": ["attribute"], "name": ["ALT_BN128_MUL_ADDRESS"]}}, {"source": {"identifier": "ethereum.constantinople.vm.precompiled_contracts.ALT_BN128_PAIRING_CHECK_ADDRESS", "specifier": 0, "path": "src/ethereum/constantinople/vm/precompiled_contracts/__init__.py"}, "content": {"type": ["attribute"], "name": ["ALT_BN128_PAIRING_CHECK_ADDRESS"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.precompiled_contracts.identity", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/precompiled_contracts/identity.py"}, "content": {"type": ["module"], "name": ["ethereum.arrow_glacier.vm.precompiled_contracts.identity"], "text": ["Ethereum Virtual Machine (EVM) IDENTITY PRECOMPILED CONTRACT ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementation of the  IDENTITY  precompiled contract."]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.precompiled_contracts.identity.identity", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/precompiled_contracts/identity.py"}, "content": {"type": ["function"], "name": ["identity"], "text": ["Writes the message data to output. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.stack", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/stack.py"}, "content": {"type": ["module"], "name": ["ethereum.frontier.vm.instructions.stack"], "text": ["Ethereum Virtual Machine (EVM) Stack Instructions ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementations of the EVM stack related instructions."]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.stack.pop", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/stack.py"}, "content": {"type": ["function"], "name": ["pop"], "text": ["Remove item from stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.stack.push_n", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/stack.py"}, "content": {"type": ["function"], "name": ["push_n"], "text": ["Pushes a N-byte immediate onto the stack. Parameters evm : The current EVM frame. num_bytes : The number of immediate bytes to be read from the code and pushed to the stack."]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.stack.dup_n", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/stack.py"}, "content": {"type": ["function"], "name": ["dup_n"], "text": ["Duplicate the Nth stack item (from top of the stack) to the top of stack. Parameters evm : The current EVM frame. item_number : The stack item number (0-indexed from top of stack) to be duplicated to the top of stack."]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.stack.swap_n", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/stack.py"}, "content": {"type": ["function"], "name": ["swap_n"], "text": ["Swap the top and the  item_number  element of the stack, where the top of the stack is position zero. If  item_number  is zero, this function does nothing (which should not be possible, since there is no  SWAP0  instruction). Parameters evm : The current EVM frame. item_number : The stack item number (0-indexed from top of stack) to be swapped with the top of stack element."]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.stack.push1", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push1"]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.stack.push2", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push2"]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.stack.push3", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push3"]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.stack.push4", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push4"]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.stack.push5", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push5"]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.stack.push6", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push6"]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.stack.push7", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push7"]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.stack.push8", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push8"]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.stack.push9", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push9"]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.stack.push10", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push10"]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.stack.push11", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push11"]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.stack.push12", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push12"]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.stack.push13", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push13"]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.stack.push14", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push14"]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.stack.push15", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push15"]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.stack.push16", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push16"]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.stack.push17", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push17"]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.stack.push18", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push18"]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.stack.push19", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push19"]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.stack.push20", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push20"]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.stack.push21", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push21"]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.stack.push22", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push22"]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.stack.push23", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push23"]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.stack.push24", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push24"]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.stack.push25", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push25"]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.stack.push26", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push26"]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.stack.push27", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push27"]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.stack.push28", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push28"]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.stack.push29", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push29"]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.stack.push30", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push30"]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.stack.push31", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push31"]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.stack.push32", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push32"]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.stack.dup1", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup1"]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.stack.dup2", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup2"]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.stack.dup3", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup3"]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.stack.dup4", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup4"]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.stack.dup5", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup5"]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.stack.dup6", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup6"]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.stack.dup7", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup7"]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.stack.dup8", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup8"]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.stack.dup9", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup9"]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.stack.dup10", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup10"]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.stack.dup11", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup11"]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.stack.dup12", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup12"]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.stack.dup13", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup13"]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.stack.dup14", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup14"]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.stack.dup15", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup15"]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.stack.dup16", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup16"]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.stack.swap1", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap1"]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.stack.swap2", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap2"]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.stack.swap3", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap3"]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.stack.swap4", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap4"]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.stack.swap5", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap5"]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.stack.swap6", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap6"]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.stack.swap7", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap7"]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.stack.swap8", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap8"]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.stack.swap9", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap9"]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.stack.swap10", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap10"]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.stack.swap11", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap11"]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.stack.swap12", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap12"]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.stack.swap13", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap13"]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.stack.swap14", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap14"]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.stack.swap15", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap15"]}}, {"source": {"identifier": "ethereum.frontier.vm.instructions.stack.swap16", "specifier": 0, "path": "src/ethereum/frontier/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap16"]}}, {"source": {"identifier": "ethereum.constantinople.vm.precompiled_contracts.alt_bn128", "specifier": 0, "path": "src/ethereum/constantinople/vm/precompiled_contracts/alt_bn128.py"}, "content": {"type": ["module"], "name": ["ethereum.constantinople.vm.precompiled_contracts.alt_bn128"], "text": ["Ethereum Virtual Machine (EVM) ALT_BN128 CONTRACTS ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementation of the ALT_BN128 precompiled contracts."]}}, {"source": {"identifier": "ethereum.constantinople.vm.precompiled_contracts.alt_bn128.alt_bn128_add", "specifier": 0, "path": "src/ethereum/constantinople/vm/precompiled_contracts/alt_bn128.py"}, "content": {"type": ["function"], "name": ["alt_bn128_add"], "text": ["The ALT_BN128 addition precompiled contract. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.constantinople.vm.precompiled_contracts.alt_bn128.alt_bn128_mul", "specifier": 0, "path": "src/ethereum/constantinople/vm/precompiled_contracts/alt_bn128.py"}, "content": {"type": ["function"], "name": ["alt_bn128_mul"], "text": ["The ALT_BN128 multiplication precompiled contract. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.constantinople.vm.precompiled_contracts.alt_bn128.alt_bn128_pairing_check", "specifier": 0, "path": "src/ethereum/constantinople/vm/precompiled_contracts/alt_bn128.py"}, "content": {"type": ["function"], "name": ["alt_bn128_pairing_check"], "text": ["The ALT_BN128 pairing check precompiled contract. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.memory", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/memory.py"}, "content": {"type": ["module"], "name": ["ethereum.arrow_glacier.vm.instructions.memory"], "text": ["Ethereum Virtual Machine (EVM) Memory Instructions ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementations of the EVM Memory instructions."]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.memory.mstore", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/memory.py"}, "content": {"type": ["function"], "name": ["mstore"], "text": ["Stores a word to memory. This also expands the memory, if the memory is insufficient to store the word. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.memory.mstore8", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/memory.py"}, "content": {"type": ["function"], "name": ["mstore8"], "text": ["Stores a byte to memory. This also expands the memory, if the memory is insufficient to store the word. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.memory.mload", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/memory.py"}, "content": {"type": ["function"], "name": ["mload"], "text": ["Load word from memory. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.memory.msize", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/memory.py"}, "content": {"type": ["function"], "name": ["msize"], "text": ["Push the size of active memory in bytes onto the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.frontier.utils", "specifier": 0, "path": "src/ethereum/frontier/utils/__init__.py"}, "content": {"type": ["module"], "name": ["ethereum.frontier.utils"], "text": ["Hardfork Utility Functions ^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Utility functions used in this frontier version of specification."]}}, {"source": {"identifier": "ethereum.constantinople.vm.precompiled_contracts.ripemd160", "specifier": 0, "path": "src/ethereum/constantinople/vm/precompiled_contracts/ripemd160.py"}, "content": {"type": ["module"], "name": ["ethereum.constantinople.vm.precompiled_contracts.ripemd160"], "text": ["Ethereum Virtual Machine (EVM) RIPEMD160 PRECOMPILED CONTRACT ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementation of the  RIPEMD160  precompiled contract."]}}, {"source": {"identifier": "ethereum.constantinople.vm.precompiled_contracts.ripemd160.ripemd160", "specifier": 0, "path": "src/ethereum/constantinople/vm/precompiled_contracts/ripemd160.py"}, "content": {"type": ["function"], "name": ["ripemd160"], "text": ["Writes the ripemd160 hash to output. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.system", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/system.py"}, "content": {"type": ["module"], "name": ["ethereum.arrow_glacier.vm.instructions.system"], "text": ["Ethereum Virtual Machine (EVM) System Instructions ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementations of the EVM system related instructions."]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.system.generic_create", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/system.py"}, "content": {"type": ["function"], "name": ["generic_create"], "text": ["Core logic used by the  CREATE*  family of opcodes."]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.system.create", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/system.py"}, "content": {"type": ["function"], "name": ["create"], "text": ["Creates a new account with associated code. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.system.create2", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/system.py"}, "content": {"type": ["function"], "name": ["create2"], "text": ["Creates a new account with associated code. It's similar to CREATE opcode except that the address of new account depends on the init_code instead of the nonce of sender. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.system.return_", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/system.py"}, "content": {"type": ["function"], "name": ["return_"], "text": ["Halts execution returning output data. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.system.generic_call", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/system.py"}, "content": {"type": ["function"], "name": ["generic_call"], "text": ["Perform the core logic of the  CALL*  family of opcodes."]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.system.call", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/system.py"}, "content": {"type": ["function"], "name": ["call"], "text": ["Message-call into an account. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.system.callcode", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/system.py"}, "content": {"type": ["function"], "name": ["callcode"], "text": ["Message-call into this account with alternative account\u2019s code. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.system.selfdestruct", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/system.py"}, "content": {"type": ["function"], "name": ["selfdestruct"], "text": ["Halt execution and register account for later deletion. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.system.delegatecall", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/system.py"}, "content": {"type": ["function"], "name": ["delegatecall"], "text": ["Message-call into an account. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.system.staticcall", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/system.py"}, "content": {"type": ["function"], "name": ["staticcall"], "text": ["Message-call into an account. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.system.revert", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/system.py"}, "content": {"type": ["function"], "name": ["revert"], "text": ["Stop execution and revert state changes, without consuming all provided gas and also has the ability to return a reason Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.frontier.utils.address", "specifier": 0, "path": "src/ethereum/frontier/utils/address.py"}, "content": {"type": ["module"], "name": ["ethereum.frontier.utils.address"], "text": ["Hardfork Utility Functions For Addresses ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Address specific functions used in this frontier version of specification."]}}, {"source": {"identifier": "ethereum.frontier.utils.address.to_address", "specifier": 0, "path": "src/ethereum/frontier/utils/address.py"}, "content": {"type": ["function"], "name": ["to_address"], "text": ["Convert a Uint or U256 value to a valid address (20 bytes). Parameters data : The string to be converted to bytes. Returns address :  Address The obtained address."]}}, {"source": {"identifier": "ethereum.frontier.utils.address.compute_contract_address", "specifier": 0, "path": "src/ethereum/frontier/utils/address.py"}, "content": {"type": ["function"], "name": ["compute_contract_address"], "text": ["Computes address of the new account that needs to be created. Parameters address : The address of the account that wants to create the new account. nonce : The transaction count of the account that wants to create the new account. Returns address:  ethereum.frontier.fork_types.Address The computed address of the new account."]}}, {"source": {"identifier": "ethereum.constantinople.vm.precompiled_contracts.sha256", "specifier": 0, "path": "src/ethereum/constantinople/vm/precompiled_contracts/sha256.py"}, "content": {"type": ["module"], "name": ["ethereum.constantinople.vm.precompiled_contracts.sha256"], "text": ["Ethereum Virtual Machine (EVM) SHA256 PRECOMPILED CONTRACT ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementation of the  SHA256  precompiled contract."]}}, {"source": {"identifier": "ethereum.constantinople.vm.precompiled_contracts.sha256.sha256", "specifier": 0, "path": "src/ethereum/constantinople/vm/precompiled_contracts/sha256.py"}, "content": {"type": ["function"], "name": ["sha256"], "text": ["Writes the sha256 hash to output. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/__init__.py"}, "content": {"type": ["module"], "name": ["ethereum.arrow_glacier.vm.instructions"], "text": ["EVM Instruction Encoding (Opcodes) ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Machine readable representations of EVM instructions, and a mapping to their implementations."]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.Ops", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/__init__.py"}, "content": {"type": ["class"], "name": ["Ops"], "text": ["Enum for EVM Opcodes"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.Ops.ADD", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["ADD"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.Ops.MUL", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["MUL"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.Ops.SUB", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SUB"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.Ops.DIV", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DIV"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.Ops.SDIV", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SDIV"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.Ops.MOD", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["MOD"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.Ops.SMOD", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SMOD"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.Ops.ADDMOD", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["ADDMOD"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.Ops.MULMOD", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["MULMOD"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.Ops.EXP", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["EXP"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.Ops.SIGNEXTEND", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SIGNEXTEND"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.Ops.LT", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["LT"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.Ops.GT", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["GT"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.Ops.SLT", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SLT"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.Ops.SGT", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SGT"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.Ops.EQ", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["EQ"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.Ops.ISZERO", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["ISZERO"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.Ops.AND", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["AND"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.Ops.OR", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["OR"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.Ops.XOR", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["XOR"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.Ops.NOT", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["NOT"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.Ops.BYTE", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["BYTE"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.Ops.SHL", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SHL"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.Ops.SHR", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SHR"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.Ops.SAR", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SAR"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.Ops.KECCAK", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["KECCAK"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.Ops.ADDRESS", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["ADDRESS"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.Ops.BALANCE", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["BALANCE"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.Ops.ORIGIN", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["ORIGIN"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.Ops.CALLER", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["CALLER"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.Ops.CALLVALUE", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["CALLVALUE"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.Ops.CALLDATALOAD", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["CALLDATALOAD"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.Ops.CALLDATASIZE", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["CALLDATASIZE"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.Ops.CALLDATACOPY", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["CALLDATACOPY"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.Ops.CODESIZE", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["CODESIZE"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.Ops.CODECOPY", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["CODECOPY"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.Ops.GASPRICE", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["GASPRICE"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.Ops.EXTCODESIZE", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["EXTCODESIZE"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.Ops.EXTCODECOPY", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["EXTCODECOPY"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.Ops.RETURNDATASIZE", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["RETURNDATASIZE"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.Ops.RETURNDATACOPY", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["RETURNDATACOPY"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.Ops.EXTCODEHASH", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["EXTCODEHASH"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.Ops.BLOCKHASH", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["BLOCKHASH"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.Ops.COINBASE", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["COINBASE"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.Ops.TIMESTAMP", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["TIMESTAMP"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.Ops.NUMBER", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["NUMBER"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.Ops.DIFFICULTY", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DIFFICULTY"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.Ops.GASLIMIT", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["GASLIMIT"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.Ops.CHAINID", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["CHAINID"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.Ops.SELFBALANCE", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SELFBALANCE"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.Ops.BASEFEE", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["BASEFEE"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.Ops.STOP", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["STOP"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.Ops.JUMP", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["JUMP"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.Ops.JUMPI", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["JUMPI"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.Ops.PC", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PC"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.Ops.GAS", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["GAS"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.Ops.JUMPDEST", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["JUMPDEST"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.Ops.SLOAD", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SLOAD"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.Ops.SSTORE", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SSTORE"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.Ops.POP", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["POP"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.Ops.PUSH1", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH1"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.Ops.PUSH2", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH2"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.Ops.PUSH3", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH3"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.Ops.PUSH4", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH4"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.Ops.PUSH5", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH5"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.Ops.PUSH6", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH6"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.Ops.PUSH7", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH7"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.Ops.PUSH8", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH8"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.Ops.PUSH9", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH9"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.Ops.PUSH10", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH10"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.Ops.PUSH11", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH11"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.Ops.PUSH12", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH12"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.Ops.PUSH13", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH13"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.Ops.PUSH14", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH14"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.Ops.PUSH15", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH15"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.Ops.PUSH16", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH16"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.Ops.PUSH17", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH17"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.Ops.PUSH18", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH18"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.Ops.PUSH19", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH19"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.Ops.PUSH20", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH20"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.Ops.PUSH21", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH21"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.Ops.PUSH22", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH22"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.Ops.PUSH23", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH23"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.Ops.PUSH24", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH24"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.Ops.PUSH25", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH25"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.Ops.PUSH26", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH26"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.Ops.PUSH27", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH27"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.Ops.PUSH28", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH28"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.Ops.PUSH29", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH29"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.Ops.PUSH30", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH30"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.Ops.PUSH31", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH31"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.Ops.PUSH32", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH32"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.Ops.DUP1", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP1"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.Ops.DUP2", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP2"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.Ops.DUP3", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP3"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.Ops.DUP4", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP4"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.Ops.DUP5", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP5"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.Ops.DUP6", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP6"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.Ops.DUP7", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP7"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.Ops.DUP8", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP8"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.Ops.DUP9", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP9"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.Ops.DUP10", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP10"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.Ops.DUP11", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP11"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.Ops.DUP12", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP12"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.Ops.DUP13", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP13"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.Ops.DUP14", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP14"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.Ops.DUP15", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP15"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.Ops.DUP16", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP16"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.Ops.SWAP1", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP1"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.Ops.SWAP2", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP2"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.Ops.SWAP3", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP3"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.Ops.SWAP4", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP4"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.Ops.SWAP5", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP5"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.Ops.SWAP6", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP6"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.Ops.SWAP7", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP7"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.Ops.SWAP8", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP8"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.Ops.SWAP9", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP9"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.Ops.SWAP10", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP10"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.Ops.SWAP11", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP11"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.Ops.SWAP12", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP12"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.Ops.SWAP13", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP13"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.Ops.SWAP14", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP14"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.Ops.SWAP15", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP15"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.Ops.SWAP16", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP16"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.Ops.MLOAD", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["MLOAD"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.Ops.MSTORE", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["MSTORE"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.Ops.MSTORE8", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["MSTORE8"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.Ops.MSIZE", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["MSIZE"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.Ops.LOG0", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["LOG0"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.Ops.LOG1", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["LOG1"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.Ops.LOG2", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["LOG2"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.Ops.LOG3", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["LOG3"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.Ops.LOG4", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["LOG4"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.Ops.CREATE", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["CREATE"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.Ops.RETURN", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["RETURN"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.Ops.CALL", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["CALL"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.Ops.CALLCODE", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["CALLCODE"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.Ops.DELEGATECALL", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DELEGATECALL"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.Ops.STATICCALL", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["STATICCALL"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.Ops.REVERT", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["REVERT"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.Ops.SELFDESTRUCT", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SELFDESTRUCT"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.Ops.CREATE2", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["CREATE2"]}}, {"source": {"identifier": "ethereum.arrow_glacier.vm.instructions.op_implementation", "specifier": 0, "path": "src/ethereum/arrow_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["op_implementation"]}}, {"source": {"identifier": "ethereum.frontier.utils.message", "specifier": 0, "path": "src/ethereum/frontier/utils/message.py"}, "content": {"type": ["module"], "name": ["ethereum.frontier.utils.message"], "text": ["Hardfork Utility Functions For The Message Data-structure ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Message specific functions used in this frontier version of specification."]}}, {"source": {"identifier": "ethereum.frontier.utils.message.prepare_message", "specifier": 0, "path": "src/ethereum/frontier/utils/message.py"}, "content": {"type": ["function"], "name": ["prepare_message"], "text": ["Execute a transaction against the provided environment. Parameters caller : Address which initiated the transaction target : Address whose code will be executed value : Value to be transferred. data : Array of bytes provided to the code in  target . gas : Gas provided for the code in  target . env : Environment for the Ethereum Virtual Machine. code_address : This is usually same as the  target  address except when an alternative accounts code needs to be executed. eg.  CALLCODE  calling a precompile. Returns message:  ethereum.frontier.vm.Message Items containing contract creation or message call specific data."]}}, {"source": {"identifier": "ethereum_optimized.paris.state_db", "specifier": 0, "path": "src/ethereum_optimized/paris/state_db.py"}, "content": {"type": ["module"], "name": ["ethereum_optimized.paris.state_db"], "text": ["Optimized State ^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction This module contains functions can be monkey patched into ethereum.paris.state  to use an optimized database backed state."]}}, {"source": {"identifier": "ethereum_optimized.paris.state_db.UnmodifiedType", "specifier": 0, "path": "src/ethereum_optimized/paris/state_db.py"}, "content": {"type": ["class"], "name": ["UnmodifiedType"], "text": ["Sentinal type to represent a value that hasn't been modified."]}}, {"source": {"identifier": "ethereum_optimized.paris.state_db.Unmodified", "specifier": 0, "path": "src/ethereum_optimized/paris/state_db.py"}, "content": {"type": ["attribute"], "name": ["Unmodified"]}}, {"source": {"identifier": "ethereum_optimized.paris.state_db.State", "specifier": 0, "path": "src/ethereum_optimized/paris/state_db.py"}, "content": {"type": ["class"], "name": ["State"], "text": ["The State, backed by a LMDB database. When created with  State()  store the db in a temporary directory. When created with  State(path)  open or create the db located at  path ."]}}, {"source": {"identifier": "ethereum_optimized.paris.state_db.State.default_path", "specifier": 0, "path": "src/ethereum_optimized/paris/state_db.py"}, "content": {"type": ["attribute"], "name": ["default_path"]}}, {"source": {"identifier": "ethereum_optimized.paris.state_db.State.db", "specifier": 0, "path": "src/ethereum_optimized/paris/state_db.py"}, "content": {"type": ["attribute"], "name": ["db"]}}, {"source": {"identifier": "ethereum_optimized.paris.state_db.State.dirty_accounts", "specifier": 0, "path": "src/ethereum_optimized/paris/state_db.py"}, "content": {"type": ["attribute"], "name": ["dirty_accounts"]}}, {"source": {"identifier": "ethereum_optimized.paris.state_db.State.dirty_storage", "specifier": 0, "path": "src/ethereum_optimized/paris/state_db.py"}, "content": {"type": ["attribute"], "name": ["dirty_storage"]}}, {"source": {"identifier": "ethereum_optimized.paris.state_db.State.destroyed_accounts", "specifier": 0, "path": "src/ethereum_optimized/paris/state_db.py"}, "content": {"type": ["attribute"], "name": ["destroyed_accounts"]}}, {"source": {"identifier": "ethereum_optimized.paris.state_db.State.tx_restore_points", "specifier": 0, "path": "src/ethereum_optimized/paris/state_db.py"}, "content": {"type": ["attribute"], "name": ["tx_restore_points"]}}, {"source": {"identifier": "ethereum_optimized.paris.state_db.State.journal", "specifier": 0, "path": "src/ethereum_optimized/paris/state_db.py"}, "content": {"type": ["attribute"], "name": ["journal"]}}, {"source": {"identifier": "ethereum_optimized.paris.state_db.State.__init__", "specifier": 0, "path": "src/ethereum_optimized/paris/state_db.py"}, "content": {"type": ["function"], "name": ["__init__"]}}, {"source": {"identifier": "ethereum_optimized.paris.state_db.State.__eq__", "specifier": 0, "path": "src/ethereum_optimized/paris/state_db.py"}, "content": {"type": ["function"], "name": ["__eq__"], "text": ["Test for equality by comparing state roots."]}}, {"source": {"identifier": "ethereum_optimized.paris.state_db.State.__enter__", "specifier": 0, "path": "src/ethereum_optimized/paris/state_db.py"}, "content": {"type": ["function"], "name": ["__enter__"], "text": ["Support with statements"]}}, {"source": {"identifier": "ethereum_optimized.paris.state_db.State.__exit__", "specifier": 0, "path": "src/ethereum_optimized/paris/state_db.py"}, "content": {"type": ["function"], "name": ["__exit__"], "text": ["Support with statements"]}}, {"source": {"identifier": "ethereum_optimized.paris.state_db.close_state", "specifier": 0, "path": "src/ethereum_optimized/paris/state_db.py"}, "content": {"type": ["function"], "name": ["close_state"], "text": ["Close a state, releasing all resources it holds"]}}, {"source": {"identifier": "ethereum_optimized.paris.state_db.get_metadata", "specifier": 0, "path": "src/ethereum_optimized/paris/state_db.py"}, "content": {"type": ["function"], "name": ["get_metadata"], "text": ["Get a piece of metadata"]}}, {"source": {"identifier": "ethereum_optimized.paris.state_db.set_metadata", "specifier": 0, "path": "src/ethereum_optimized/paris/state_db.py"}, "content": {"type": ["function"], "name": ["set_metadata"], "text": ["Set a piece of metadata"]}}, {"source": {"identifier": "ethereum_optimized.paris.state_db.begin_db_transaction", "specifier": 0, "path": "src/ethereum_optimized/paris/state_db.py"}, "content": {"type": ["function"], "name": ["begin_db_transaction"], "text": ["Start a database transaction. A transaction is automatically started when a State  is created. Nesting of DB transactions is not supported (unlike non-db transactions). No operations are supported when not in a transaction."]}}, {"source": {"identifier": "ethereum_optimized.paris.state_db.commit_db_transaction", "specifier": 0, "path": "src/ethereum_optimized/paris/state_db.py"}, "content": {"type": ["function"], "name": ["commit_db_transaction"], "text": ["Commit the current database transaction."]}}, {"source": {"identifier": "ethereum_optimized.paris.state_db.state_root", "specifier": 0, "path": "src/ethereum_optimized/paris/state_db.py"}, "content": {"type": ["function"], "name": ["state_root"], "text": ["See  ethereum.paris.state ."]}}, {"source": {"identifier": "ethereum_optimized.paris.state_db.storage_root", "specifier": 0, "path": "src/ethereum_optimized/paris/state_db.py"}, "content": {"type": ["function"], "name": ["storage_root"], "text": ["See  ethereum.paris.state ."]}}, {"source": {"identifier": "ethereum_optimized.paris.state_db.flush", "specifier": 0, "path": "src/ethereum_optimized/paris/state_db.py"}, "content": {"type": ["function"], "name": ["flush"], "text": ["Send everything in the internal caches to the Rust layer."]}}, {"source": {"identifier": "ethereum_optimized.paris.state_db.rollback_db_transaction", "specifier": 0, "path": "src/ethereum_optimized/paris/state_db.py"}, "content": {"type": ["function"], "name": ["rollback_db_transaction"], "text": ["Rollback the current database transaction."]}}, {"source": {"identifier": "ethereum_optimized.paris.state_db.begin_transaction", "specifier": 0, "path": "src/ethereum_optimized/paris/state_db.py"}, "content": {"type": ["function"], "name": ["begin_transaction"], "text": ["See  ethereum.paris.state ."]}}, {"source": {"identifier": "ethereum_optimized.paris.state_db.commit_transaction", "specifier": 0, "path": "src/ethereum_optimized/paris/state_db.py"}, "content": {"type": ["function"], "name": ["commit_transaction"], "text": ["See  ethereum.paris.state ."]}}, {"source": {"identifier": "ethereum_optimized.paris.state_db.rollback_transaction", "specifier": 0, "path": "src/ethereum_optimized/paris/state_db.py"}, "content": {"type": ["function"], "name": ["rollback_transaction"], "text": ["See  ethereum.paris.state ."]}}, {"source": {"identifier": "ethereum_optimized.paris.state_db.get_storage", "specifier": 0, "path": "src/ethereum_optimized/paris/state_db.py"}, "content": {"type": ["function"], "name": ["get_storage"], "text": ["See  ethereum.paris.state ."]}}, {"source": {"identifier": "ethereum_optimized.paris.state_db.get_storage_original", "specifier": 0, "path": "src/ethereum_optimized/paris/state_db.py"}, "content": {"type": ["function"], "name": ["get_storage_original"], "text": ["See  ethereum.istanbul.state ."]}}, {"source": {"identifier": "ethereum_optimized.paris.state_db.set_storage", "specifier": 0, "path": "src/ethereum_optimized/paris/state_db.py"}, "content": {"type": ["function"], "name": ["set_storage"], "text": ["See  ethereum.paris.state ."]}}, {"source": {"identifier": "ethereum_optimized.paris.state_db.get_account_optional", "specifier": 0, "path": "src/ethereum_optimized/paris/state_db.py"}, "content": {"type": ["function"], "name": ["get_account_optional"], "text": ["See  ethereum.paris.state ."]}}, {"source": {"identifier": "ethereum_optimized.paris.state_db.set_account", "specifier": 0, "path": "src/ethereum_optimized/paris/state_db.py"}, "content": {"type": ["function"], "name": ["set_account"], "text": ["See  ethereum.paris.state ."]}}, {"source": {"identifier": "ethereum_optimized.paris.state_db.destroy_storage", "specifier": 0, "path": "src/ethereum_optimized/paris/state_db.py"}, "content": {"type": ["function"], "name": ["destroy_storage"], "text": ["See  ethereum.paris.state ."]}}, {"source": {"identifier": "ethereum.muir_glacier.fork", "specifier": 0, "path": "src/ethereum/muir_glacier/fork.py"}, "content": {"type": ["module"], "name": ["ethereum.muir_glacier.fork"], "text": ["Ethereum Specification ^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Entry point for the Ethereum specification."]}}, {"source": {"identifier": "ethereum.muir_glacier.fork.BLOCK_REWARD", "specifier": 0, "path": "src/ethereum/muir_glacier/fork.py"}, "content": {"type": ["attribute"], "name": ["BLOCK_REWARD"]}}, {"source": {"identifier": "ethereum.muir_glacier.fork.GAS_LIMIT_ADJUSTMENT_FACTOR", "specifier": 0, "path": "src/ethereum/muir_glacier/fork.py"}, "content": {"type": ["attribute"], "name": ["GAS_LIMIT_ADJUSTMENT_FACTOR"]}}, {"source": {"identifier": "ethereum.muir_glacier.fork.GAS_LIMIT_MINIMUM", "specifier": 0, "path": "src/ethereum/muir_glacier/fork.py"}, "content": {"type": ["attribute"], "name": ["GAS_LIMIT_MINIMUM"]}}, {"source": {"identifier": "ethereum.muir_glacier.fork.MINIMUM_DIFFICULTY", "specifier": 0, "path": "src/ethereum/muir_glacier/fork.py"}, "content": {"type": ["attribute"], "name": ["MINIMUM_DIFFICULTY"]}}, {"source": {"identifier": "ethereum.muir_glacier.fork.MAX_OMMER_DEPTH", "specifier": 0, "path": "src/ethereum/muir_glacier/fork.py"}, "content": {"type": ["attribute"], "name": ["MAX_OMMER_DEPTH"]}}, {"source": {"identifier": "ethereum.muir_glacier.fork.BOMB_DELAY_BLOCKS", "specifier": 0, "path": "src/ethereum/muir_glacier/fork.py"}, "content": {"type": ["attribute"], "name": ["BOMB_DELAY_BLOCKS"]}}, {"source": {"identifier": "ethereum.muir_glacier.fork.EMPTY_OMMER_HASH", "specifier": 0, "path": "src/ethereum/muir_glacier/fork.py"}, "content": {"type": ["attribute"], "name": ["EMPTY_OMMER_HASH"]}}, {"source": {"identifier": "ethereum.muir_glacier.fork.BlockChain", "specifier": 0, "path": "src/ethereum/muir_glacier/fork.py"}, "content": {"type": ["class"], "name": ["BlockChain"], "text": ["History and current state of the block chain."]}}, {"source": {"identifier": "ethereum.muir_glacier.fork.BlockChain.blocks", "specifier": 0, "path": "src/ethereum/muir_glacier/fork.py"}, "content": {"type": ["attribute"], "name": ["blocks"]}}, {"source": {"identifier": "ethereum.muir_glacier.fork.BlockChain.state", "specifier": 0, "path": "src/ethereum/muir_glacier/fork.py"}, "content": {"type": ["attribute"], "name": ["state"]}}, {"source": {"identifier": "ethereum.muir_glacier.fork.BlockChain.chain_id", "specifier": 0, "path": "src/ethereum/muir_glacier/fork.py"}, "content": {"type": ["attribute"], "name": ["chain_id"]}}, {"source": {"identifier": "ethereum.muir_glacier.fork.apply_fork", "specifier": 0, "path": "src/ethereum/muir_glacier/fork.py"}, "content": {"type": ["function"], "name": ["apply_fork"], "text": ["Transforms the state from the previous hard fork ( old ) into the block chain object for this hard fork and returns it. When forks need to implement an irregular state transition, this function is used to handle the irregularity. See the :ref: DAO Fork <dao-fork>  for an example. Parameters old : Previous block chain object. Returns new :  BlockChain Upgraded block chain object for this hard fork."]}}, {"source": {"identifier": "ethereum.muir_glacier.fork.get_last_256_block_hashes", "specifier": 0, "path": "src/ethereum/muir_glacier/fork.py"}, "content": {"type": ["function"], "name": ["get_last_256_block_hashes"], "text": ["Obtain the list of hashes of the previous 256 blocks in order of increasing block number. This function will return less hashes for the first 256 blocks. The  BLOCKHASH  opcode needs to access the latest hashes on the chain, therefore this function retrieves them. Parameters chain : History and current state. Returns recent_block_hashes :  List[Hash32] Hashes of the recent 256 blocks in order of increasing block number."]}}, {"source": {"identifier": "ethereum.muir_glacier.fork.state_transition", "specifier": 0, "path": "src/ethereum/muir_glacier/fork.py"}, "content": {"type": ["function"], "name": ["state_transition"], "text": ["Attempts to apply a block to an existing block chain. All parts of the block's contents need to be verified before being added to the chain. Blocks are verified by ensuring that the contents of the block make logical sense with the contents of the parent block. The information in the block's header must also match the corresponding information in the block. To implement Ethereum, in theory clients are only required to store the most recent 255 blocks of the chain since as far as execution is concerned, only those blocks are accessed. Practically, however, clients should store more blocks to handle reorgs. Parameters chain : History and current state. block : Block to apply to  chain ."]}}, {"source": {"identifier": "ethereum.muir_glacier.fork.validate_header", "specifier": 0, "path": "src/ethereum/muir_glacier/fork.py"}, "content": {"type": ["function"], "name": ["validate_header"], "text": ["Verifies a block header. In order to consider a block's header valid, the logic for the quantities in the header should match the logic for the block itself. For example the header timestamp should be greater than the block's parent timestamp because the block was created  after  the parent block. Additionally, the block's number should be directly folowing the parent block's number since it is the next block in the sequence. Parameters header : Header to check for correctness. parent_header : Parent Header of the header to check for correctness"]}}, {"source": {"identifier": "ethereum.muir_glacier.fork.generate_header_hash_for_pow", "specifier": 0, "path": "src/ethereum/muir_glacier/fork.py"}, "content": {"type": ["function"], "name": ["generate_header_hash_for_pow"], "text": ["Generate rlp hash of the header which is to be used for Proof-of-Work verification. In other words, the PoW artefacts  mix_digest  and  nonce  are ignored while calculating this hash. A particular PoW is valid for a single hash, that hash is computed by this function. The  nonce  and  mix_digest  are omitted from this hash because they are being changed by miners in their search for a sufficient proof-of-work. Parameters header : The header object for which the hash is to be generated. Returns hash :  Hash32 The PoW valid rlp hash of the passed in header."]}}, {"source": {"identifier": "ethereum.muir_glacier.fork.validate_proof_of_work", "specifier": 0, "path": "src/ethereum/muir_glacier/fork.py"}, "content": {"type": ["function"], "name": ["validate_proof_of_work"], "text": ["Validates the Proof of Work constraints. In order to verify that a miner's proof-of-work is valid for a block, a mix-digest  and  result  are calculated using the  hashimoto_light hash function. The mix digest is a hash of the header and the nonce that is passed through and it confirms whether or not proof-of-work was done on the correct block. The result is the actual hash value of the block. Parameters header : Header of interest."]}}, {"source": {"identifier": "ethereum.muir_glacier.fork.check_transaction", "specifier": 0, "path": "src/ethereum/muir_glacier/fork.py"}, "content": {"type": ["function"], "name": ["check_transaction"], "text": ["Check if the transaction is includable in the block. Parameters tx : The transaction. gas_available : The gas remaining in the block. chain_id : The ID of the current chain. Returns sender_address : The sender of the transaction. Raises InvalidBlock : If the transaction is not includable."]}}, {"source": {"identifier": "ethereum.muir_glacier.fork.make_receipt", "specifier": 0, "path": "src/ethereum/muir_glacier/fork.py"}, "content": {"type": ["function"], "name": ["make_receipt"], "text": ["Make the receipt for a transaction that was executed. Parameters tx : The executed transaction. has_erred : Whether the top level frame of the transaction exited with an error. cumulative_gas_used : The total gas used so far in the block after the transaction was executed. logs : The logs produced by the transaction. Returns receipt : The receipt for the transaction."]}}, {"source": {"identifier": "ethereum.muir_glacier.fork.apply_body", "specifier": 0, "path": "src/ethereum/muir_glacier/fork.py"}, "content": {"type": ["function"], "name": ["apply_body"], "text": ["Executes a block. Many of the contents of a block are stored in data structures called tries. There is a transactions trie which is similar to a ledger of the transactions stored in the current block. There is also a receipts trie which stores the results of executing a transaction, like the post state and gas used. This function creates and executes the block that is to be added to the chain. Parameters state : Current account state. block_hashes : List of hashes of the previous 256 blocks in the order of increasing block number. coinbase : Address of account which receives block reward and transaction fees. block_number : Position of the block within the chain. block_gas_limit : Initial amount of gas available for execution in this block. block_time : Time the block was produced, measured in seconds since the epoch. block_difficulty : Difficulty of the block. transactions : Transactions included in the block. ommers : Headers of ancestor blocks which are not direct parents (formerly uncles.) chain_id : ID of the executing chain. Returns gas_available :  ethereum.base_types.Uint Remaining gas after all transactions have been executed. transactions_root :  ethereum.fork_types.Root Trie root of all the transactions in the block. receipt_root :  ethereum.fork_types.Root Trie root of all the receipts in the block. block_logs_bloom :  Bloom Logs bloom of all the logs included in all the transactions of the block. state :  ethereum.fork_types.State State after all transactions have been executed."]}}, {"source": {"identifier": "ethereum.muir_glacier.fork.validate_ommers", "specifier": 0, "path": "src/ethereum/muir_glacier/fork.py"}, "content": {"type": ["function"], "name": ["validate_ommers"], "text": ["Validates the ommers mentioned in the block. An ommer block is a block that wasn't canonically added to the blockchain because it wasn't validated as fast as the canonical block but was mined at the same time. To be considered valid, the ommers must adhere to the rules defined in the Ethereum protocol. The maximum amount of ommers is 2 per block and there cannot be duplicate ommers in a block. Many of the other ommer contraints are listed in the in-line comments of this function. Parameters ommers : List of ommers mentioned in the current block. block_header: The header of current block. chain : History and current state."]}}, {"source": {"identifier": "ethereum.muir_glacier.fork.pay_rewards", "specifier": 0, "path": "src/ethereum/muir_glacier/fork.py"}, "content": {"type": ["function"], "name": ["pay_rewards"], "text": ["Pay rewards to the block miner as well as the ommers miners. The miner of the canonical block is rewarded with the predetermined block reward,  BLOCK_REWARD , plus a variable award based off of the number of ommer blocks that were mined around the same time, and included in the canonical block's header. An ommer block is a block that wasn't added to the canonical blockchain because it wasn't validated as fast as the accepted block but was mined at the same time. Although not all blocks that are mined are added to the canonical chain, miners are still paid a reward for their efforts. This reward is called an ommer reward and is calculated based on the number associated with the ommer block that they mined. Parameters state : Current account state. block_number : Position of the block within the chain. coinbase : Address of account which receives block reward and transaction fees. ommers : List of ommers mentioned in the current block."]}}, {"source": {"identifier": "ethereum.muir_glacier.fork.process_transaction", "specifier": 0, "path": "src/ethereum/muir_glacier/fork.py"}, "content": {"type": ["function"], "name": ["process_transaction"], "text": ["Execute a transaction against the provided environment. This function processes the actions needed to execute a transaction. It decrements the sender's account after calculating the gas fee and refunds them the proper amount after execution. Calling contracts, deploying code, and incrementing nonces are all examples of actions that happen within this function or from a call made within this function. Accounts that are marked for deletion are processed and destroyed after execution. Parameters env : Environment for the Ethereum Virtual Machine. tx : Transaction to execute. Returns gas_left :  ethereum.base_types.U256 Remaining gas after execution. logs :  Tuple[ethereum.fork_types.Log, ...] Logs generated during execution."]}}, {"source": {"identifier": "ethereum.muir_glacier.fork.validate_transaction", "specifier": 0, "path": "src/ethereum/muir_glacier/fork.py"}, "content": {"type": ["function"], "name": ["validate_transaction"], "text": ["Verifies a transaction. The gas in a transaction gets used to pay for the intrinsic cost of operations, therefore if there is insufficient gas then it would not be possible to execute a transaction and it will be declared invalid. Additionally, the nonce of a transaction must not equal or exceed the limit defined in  EIP-2681 <https://eips.ethereum.org/EIPS/eip-2681> _. In practice, defining the limit as  2**64-1  has no impact because sending  2**64-1  transactions is improbable. It's not strictly impossible though,  2**64-1  transactions is the entire capacity of the Ethereum blockchain at 2022 gas limits for a little over 22 years. Parameters tx : Transaction to validate. Returns verified :  bool True if the transaction can be executed, or False otherwise."]}}, {"source": {"identifier": "ethereum.muir_glacier.fork.calculate_intrinsic_cost", "specifier": 0, "path": "src/ethereum/muir_glacier/fork.py"}, "content": {"type": ["function"], "name": ["calculate_intrinsic_cost"], "text": ["Calculates the gas that is charged before execution is started. The intrinsic cost of the transaction is charged before execution has begun. Functions/operations in the EVM cost money to execute so this intrinsic cost is for the operations that need to be paid for as part of the transaction. Data transfer, for example, is part of this intrinsic cost. It costs ether to send data over the wire and that ether is accounted for in the intrinsic cost calculated in this function. This intrinsic cost must be calculated and paid for before execution in order for all operations to be implemented. Parameters tx : Transaction to compute the intrinsic cost of. Returns verified :  ethereum.base_types.Uint The intrinsic cost of the transaction."]}}, {"source": {"identifier": "ethereum.muir_glacier.fork.recover_sender", "specifier": 0, "path": "src/ethereum/muir_glacier/fork.py"}, "content": {"type": ["function"], "name": ["recover_sender"], "text": ["Extracts the sender address from a transaction. The v, r, and s values are the three parts that make up the signature of a transaction. In order to recover the sender of a transaction the two components needed are the signature ( v ,  r , and  s ) and the signing hash of the transaction. The sender's public key can be obtained with these two values and therefore the sender address can be retrieved. Parameters tx : Transaction of interest. chain_id : ID of the executing chain. Returns sender :  ethereum.fork_types.Address The address of the account that signed the transaction."]}}, {"source": {"identifier": "ethereum.muir_glacier.fork.signing_hash_pre155", "specifier": 0, "path": "src/ethereum/muir_glacier/fork.py"}, "content": {"type": ["function"], "name": ["signing_hash_pre155"], "text": ["Compute the hash of a transaction used in a legacy (pre EIP 155) signature. Parameters tx : Transaction of interest. Returns hash :  ethereum.crypto.hash.Hash32 Hash of the transaction."]}}, {"source": {"identifier": "ethereum.muir_glacier.fork.signing_hash_155", "specifier": 0, "path": "src/ethereum/muir_glacier/fork.py"}, "content": {"type": ["function"], "name": ["signing_hash_155"], "text": ["Compute the hash of a transaction used in a EIP 155 signature. Parameters tx : Transaction of interest. Returns hash :  ethereum.crypto.hash.Hash32 Hash of the transaction."]}}, {"source": {"identifier": "ethereum.muir_glacier.fork.compute_header_hash", "specifier": 0, "path": "src/ethereum/muir_glacier/fork.py"}, "content": {"type": ["function"], "name": ["compute_header_hash"], "text": ["Computes the hash of a block header. The header hash of a block is the canonical hash that is used to refer to a specific block and completely distinguishes a block from another. keccak256  is a function that produces a 256 bit hash of any input. It also takes in any number of bytes as an input and produces a single hash for them. A hash is a completely unique output for a single input. So an input corresponds to one unique hash that can be used to identify the input exactly. Prior to using the  keccak256  hash function, the header must be encoded using the Recursive-Length Prefix. See :ref: rlp . RLP encoding the header converts it into a space-efficient format that allows for easy transfer of data between nodes. The purpose of RLP is to encode arbitrarily nested arrays of binary data, and RLP is the primary encoding method used to serialize objects in Ethereum's execution layer. The only purpose of RLP is to encode structure; encoding specific data types (e.g. strings, floats) is left up to higher-order protocols. Parameters header : Header of interest. Returns hash :  ethereum.crypto.hash.Hash32 Hash of the header."]}}, {"source": {"identifier": "ethereum.muir_glacier.fork.check_gas_limit", "specifier": 0, "path": "src/ethereum/muir_glacier/fork.py"}, "content": {"type": ["function"], "name": ["check_gas_limit"], "text": ["Validates the gas limit for a block. The bounds of the gas limit,  max_adjustment_delta , is set as the quotient of the parent block's gas limit and the GAS_LIMIT_ADJUSTMENT_FACTOR . Therefore, if the gas limit that is passed through as a parameter is greater than or equal to the  sum  of the parent's gas and the adjustment delta then the limit for gas is too high and fails this function's check. Similarly, if the limit is less than or equal to the  difference  of the parent's gas and the adjustment delta  or  the predefined  GAS_LIMIT_MINIMUM  then this function's check fails because the gas limit doesn't allow for a sufficient or reasonable amount of gas to be used on a block. Parameters gas_limit : Gas limit to validate. parent_gas_limit : Gas limit of the parent block. Returns check :  bool True if gas limit constraints are satisfied, False otherwise."]}}, {"source": {"identifier": "ethereum.muir_glacier.fork.calculate_block_difficulty", "specifier": 0, "path": "src/ethereum/muir_glacier/fork.py"}, "content": {"type": ["function"], "name": ["calculate_block_difficulty"], "text": ["Computes difficulty of a block using its header and parent header. The difficulty is determined by the time the block was created after its parent. The  offset  is calculated using the parent block's difficulty, parent_difficulty , and the timestamp between blocks. This offset is then added to the parent difficulty and is stored as the  difficulty variable. If the time between the block and its parent is too short, the offset will result in a positive number thus making the sum of parent_difficulty  and  offset  to be a greater value in order to avoid mass forking. But, if the time is long enough, then the offset results in a negative value making the block less difficult than its parent. The base standard for a block's difficulty is the predefined value set for the genesis block since it has no parent. So, a block can't be less difficult than the genesis block, therefore each block's difficulty is set to the maximum value between the calculated difficulty and the  GENESIS_DIFFICULTY . Parameters block_number : Block number of the block. block_timestamp : Timestamp of the block. parent_timestamp : Timestamp of the parent block. parent_difficulty : difficulty of the parent block. parent_has_ommers: does the parent have ommers. Returns difficulty :  ethereum.base_types.Uint Computed difficulty for a block."]}}, {"source": {"identifier": "ethereum_optimized.berlin.fork", "specifier": 0, "path": "src/ethereum_optimized/berlin/fork.py"}, "content": {"type": ["module"], "name": ["ethereum_optimized.berlin.fork"], "text": ["Optimized Spec ^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction This module contains functions can be monkey patched into ethereum.berlin.fork  to use alternate optimized implementations."]}}, {"source": {"identifier": "ethereum_optimized.berlin.fork.validate_proof_of_work", "specifier": 0, "path": "src/ethereum_optimized/berlin/fork.py"}, "content": {"type": ["function"], "name": ["validate_proof_of_work"], "text": ["See  ethereum.berlin.fork.validate_proof_of_work ."]}}, {"source": {"identifier": "ethereum_optimized.byzantium.state_db", "specifier": 0, "path": "src/ethereum_optimized/byzantium/state_db.py"}, "content": {"type": ["module"], "name": ["ethereum_optimized.byzantium.state_db"], "text": ["Optimized State ^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction This module contains functions can be monkey patched into ethereum.byzantium.state  to use an optimized database backed state."]}}, {"source": {"identifier": "ethereum_optimized.byzantium.state_db.UnmodifiedType", "specifier": 0, "path": "src/ethereum_optimized/byzantium/state_db.py"}, "content": {"type": ["class"], "name": ["UnmodifiedType"], "text": ["Sentinal type to represent a value that hasn't been modified."]}}, {"source": {"identifier": "ethereum_optimized.byzantium.state_db.Unmodified", "specifier": 0, "path": "src/ethereum_optimized/byzantium/state_db.py"}, "content": {"type": ["attribute"], "name": ["Unmodified"]}}, {"source": {"identifier": "ethereum_optimized.byzantium.state_db.State", "specifier": 0, "path": "src/ethereum_optimized/byzantium/state_db.py"}, "content": {"type": ["class"], "name": ["State"], "text": ["The State, backed by a LMDB database. When created with  State()  store the db in a temporary directory. When created with  State(path)  open or create the db located at  path ."]}}, {"source": {"identifier": "ethereum_optimized.byzantium.state_db.State.default_path", "specifier": 0, "path": "src/ethereum_optimized/byzantium/state_db.py"}, "content": {"type": ["attribute"], "name": ["default_path"]}}, {"source": {"identifier": "ethereum_optimized.byzantium.state_db.State.db", "specifier": 0, "path": "src/ethereum_optimized/byzantium/state_db.py"}, "content": {"type": ["attribute"], "name": ["db"]}}, {"source": {"identifier": "ethereum_optimized.byzantium.state_db.State.dirty_accounts", "specifier": 0, "path": "src/ethereum_optimized/byzantium/state_db.py"}, "content": {"type": ["attribute"], "name": ["dirty_accounts"]}}, {"source": {"identifier": "ethereum_optimized.byzantium.state_db.State.dirty_storage", "specifier": 0, "path": "src/ethereum_optimized/byzantium/state_db.py"}, "content": {"type": ["attribute"], "name": ["dirty_storage"]}}, {"source": {"identifier": "ethereum_optimized.byzantium.state_db.State.destroyed_accounts", "specifier": 0, "path": "src/ethereum_optimized/byzantium/state_db.py"}, "content": {"type": ["attribute"], "name": ["destroyed_accounts"]}}, {"source": {"identifier": "ethereum_optimized.byzantium.state_db.State.tx_restore_points", "specifier": 0, "path": "src/ethereum_optimized/byzantium/state_db.py"}, "content": {"type": ["attribute"], "name": ["tx_restore_points"]}}, {"source": {"identifier": "ethereum_optimized.byzantium.state_db.State.journal", "specifier": 0, "path": "src/ethereum_optimized/byzantium/state_db.py"}, "content": {"type": ["attribute"], "name": ["journal"]}}, {"source": {"identifier": "ethereum_optimized.byzantium.state_db.State.__init__", "specifier": 0, "path": "src/ethereum_optimized/byzantium/state_db.py"}, "content": {"type": ["function"], "name": ["__init__"]}}, {"source": {"identifier": "ethereum_optimized.byzantium.state_db.State.__eq__", "specifier": 0, "path": "src/ethereum_optimized/byzantium/state_db.py"}, "content": {"type": ["function"], "name": ["__eq__"], "text": ["Test for equality by comparing state roots."]}}, {"source": {"identifier": "ethereum_optimized.byzantium.state_db.State.__enter__", "specifier": 0, "path": "src/ethereum_optimized/byzantium/state_db.py"}, "content": {"type": ["function"], "name": ["__enter__"], "text": ["Support with statements"]}}, {"source": {"identifier": "ethereum_optimized.byzantium.state_db.State.__exit__", "specifier": 0, "path": "src/ethereum_optimized/byzantium/state_db.py"}, "content": {"type": ["function"], "name": ["__exit__"], "text": ["Support with statements"]}}, {"source": {"identifier": "ethereum_optimized.byzantium.state_db.close_state", "specifier": 0, "path": "src/ethereum_optimized/byzantium/state_db.py"}, "content": {"type": ["function"], "name": ["close_state"], "text": ["Close a state, releasing all resources it holds"]}}, {"source": {"identifier": "ethereum_optimized.byzantium.state_db.get_metadata", "specifier": 0, "path": "src/ethereum_optimized/byzantium/state_db.py"}, "content": {"type": ["function"], "name": ["get_metadata"], "text": ["Get a piece of metadata"]}}, {"source": {"identifier": "ethereum_optimized.byzantium.state_db.set_metadata", "specifier": 0, "path": "src/ethereum_optimized/byzantium/state_db.py"}, "content": {"type": ["function"], "name": ["set_metadata"], "text": ["Set a piece of metadata"]}}, {"source": {"identifier": "ethereum_optimized.byzantium.state_db.begin_db_transaction", "specifier": 0, "path": "src/ethereum_optimized/byzantium/state_db.py"}, "content": {"type": ["function"], "name": ["begin_db_transaction"], "text": ["Start a database transaction. A transaction is automatically started when a State  is created. Nesting of DB transactions is not supported (unlike non-db transactions). No operations are supported when not in a transaction."]}}, {"source": {"identifier": "ethereum_optimized.byzantium.state_db.commit_db_transaction", "specifier": 0, "path": "src/ethereum_optimized/byzantium/state_db.py"}, "content": {"type": ["function"], "name": ["commit_db_transaction"], "text": ["Commit the current database transaction."]}}, {"source": {"identifier": "ethereum_optimized.byzantium.state_db.state_root", "specifier": 0, "path": "src/ethereum_optimized/byzantium/state_db.py"}, "content": {"type": ["function"], "name": ["state_root"], "text": ["See  ethereum.byzantium.state ."]}}, {"source": {"identifier": "ethereum_optimized.byzantium.state_db.storage_root", "specifier": 0, "path": "src/ethereum_optimized/byzantium/state_db.py"}, "content": {"type": ["function"], "name": ["storage_root"], "text": ["See  ethereum.byzantium.state ."]}}, {"source": {"identifier": "ethereum_optimized.byzantium.state_db.flush", "specifier": 0, "path": "src/ethereum_optimized/byzantium/state_db.py"}, "content": {"type": ["function"], "name": ["flush"], "text": ["Send everything in the internal caches to the Rust layer."]}}, {"source": {"identifier": "ethereum_optimized.byzantium.state_db.rollback_db_transaction", "specifier": 0, "path": "src/ethereum_optimized/byzantium/state_db.py"}, "content": {"type": ["function"], "name": ["rollback_db_transaction"], "text": ["Rollback the current database transaction."]}}, {"source": {"identifier": "ethereum_optimized.byzantium.state_db.begin_transaction", "specifier": 0, "path": "src/ethereum_optimized/byzantium/state_db.py"}, "content": {"type": ["function"], "name": ["begin_transaction"], "text": ["See  ethereum.byzantium.state ."]}}, {"source": {"identifier": "ethereum_optimized.byzantium.state_db.commit_transaction", "specifier": 0, "path": "src/ethereum_optimized/byzantium/state_db.py"}, "content": {"type": ["function"], "name": ["commit_transaction"], "text": ["See  ethereum.byzantium.state ."]}}, {"source": {"identifier": "ethereum_optimized.byzantium.state_db.rollback_transaction", "specifier": 0, "path": "src/ethereum_optimized/byzantium/state_db.py"}, "content": {"type": ["function"], "name": ["rollback_transaction"], "text": ["See  ethereum.byzantium.state ."]}}, {"source": {"identifier": "ethereum_optimized.byzantium.state_db.get_storage", "specifier": 0, "path": "src/ethereum_optimized/byzantium/state_db.py"}, "content": {"type": ["function"], "name": ["get_storage"], "text": ["See  ethereum.byzantium.state ."]}}, {"source": {"identifier": "ethereum_optimized.byzantium.state_db.get_storage_original", "specifier": 0, "path": "src/ethereum_optimized/byzantium/state_db.py"}, "content": {"type": ["function"], "name": ["get_storage_original"], "text": ["See  ethereum.istanbul.state ."]}}, {"source": {"identifier": "ethereum_optimized.byzantium.state_db.set_storage", "specifier": 0, "path": "src/ethereum_optimized/byzantium/state_db.py"}, "content": {"type": ["function"], "name": ["set_storage"], "text": ["See  ethereum.byzantium.state ."]}}, {"source": {"identifier": "ethereum_optimized.byzantium.state_db.get_account_optional", "specifier": 0, "path": "src/ethereum_optimized/byzantium/state_db.py"}, "content": {"type": ["function"], "name": ["get_account_optional"], "text": ["See  ethereum.byzantium.state ."]}}, {"source": {"identifier": "ethereum_optimized.byzantium.state_db.set_account", "specifier": 0, "path": "src/ethereum_optimized/byzantium/state_db.py"}, "content": {"type": ["function"], "name": ["set_account"], "text": ["See  ethereum.byzantium.state ."]}}, {"source": {"identifier": "ethereum_optimized.byzantium.state_db.destroy_storage", "specifier": 0, "path": "src/ethereum_optimized/byzantium/state_db.py"}, "content": {"type": ["function"], "name": ["destroy_storage"], "text": ["See  ethereum.byzantium.state ."]}}, {"source": {"identifier": "ethereum.shanghai.vm.interpreter", "specifier": 0, "path": "src/ethereum/shanghai/vm/interpreter.py"}, "content": {"type": ["module"], "name": ["ethereum.shanghai.vm.interpreter"], "text": ["Ethereum Virtual Machine (EVM) Interpreter ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction A straightforward interpreter that executes EVM code."]}}, {"source": {"identifier": "ethereum.shanghai.vm.interpreter.STACK_DEPTH_LIMIT", "specifier": 0, "path": "src/ethereum/shanghai/vm/interpreter.py"}, "content": {"type": ["attribute"], "name": ["STACK_DEPTH_LIMIT"]}}, {"source": {"identifier": "ethereum.shanghai.vm.interpreter.MAX_CODE_SIZE", "specifier": 0, "path": "src/ethereum/shanghai/vm/interpreter.py"}, "content": {"type": ["attribute"], "name": ["MAX_CODE_SIZE"]}}, {"source": {"identifier": "ethereum.shanghai.vm.interpreter.MessageCallOutput", "specifier": 0, "path": "src/ethereum/shanghai/vm/interpreter.py"}, "content": {"type": ["class"], "name": ["MessageCallOutput"], "text": ["Output of a particular message call Contains the following:   1. `gas_left`: remaining gas after execution.\n  2. `refund_counter`: gas to refund after execution.\n  3. `logs`: list of `Log` generated during execution.\n  4. `accounts_to_delete`: Contracts which have self-destructed.\n  5. `touched_accounts`: Accounts that have been touched.\n  6. `has_erred`: True if execution has caused an error.\n"]}}, {"source": {"identifier": "ethereum.shanghai.vm.interpreter.MessageCallOutput.gas_left", "specifier": 0, "path": "src/ethereum/shanghai/vm/interpreter.py"}, "content": {"type": ["attribute"], "name": ["gas_left"]}}, {"source": {"identifier": "ethereum.shanghai.vm.interpreter.MessageCallOutput.refund_counter", "specifier": 0, "path": "src/ethereum/shanghai/vm/interpreter.py"}, "content": {"type": ["attribute"], "name": ["refund_counter"]}}, {"source": {"identifier": "ethereum.shanghai.vm.interpreter.MessageCallOutput.logs", "specifier": 0, "path": "src/ethereum/shanghai/vm/interpreter.py"}, "content": {"type": ["attribute"], "name": ["logs"]}}, {"source": {"identifier": "ethereum.shanghai.vm.interpreter.MessageCallOutput.accounts_to_delete", "specifier": 0, "path": "src/ethereum/shanghai/vm/interpreter.py"}, "content": {"type": ["attribute"], "name": ["accounts_to_delete"]}}, {"source": {"identifier": "ethereum.shanghai.vm.interpreter.MessageCallOutput.touched_accounts", "specifier": 0, "path": "src/ethereum/shanghai/vm/interpreter.py"}, "content": {"type": ["attribute"], "name": ["touched_accounts"]}}, {"source": {"identifier": "ethereum.shanghai.vm.interpreter.MessageCallOutput.has_erred", "specifier": 0, "path": "src/ethereum/shanghai/vm/interpreter.py"}, "content": {"type": ["attribute"], "name": ["has_erred"]}}, {"source": {"identifier": "ethereum.shanghai.vm.interpreter.process_message_call", "specifier": 0, "path": "src/ethereum/shanghai/vm/interpreter.py"}, "content": {"type": ["function"], "name": ["process_message_call"], "text": ["If  message.current  is empty then it creates a smart contract else it executes a call from the  message.caller  to the  message.target . Parameters message : Transaction specific items. env : External items required for EVM execution. Returns output :  MessageCallOutput Output of the message call"]}}, {"source": {"identifier": "ethereum.shanghai.vm.interpreter.process_create_message", "specifier": 0, "path": "src/ethereum/shanghai/vm/interpreter.py"}, "content": {"type": ["function"], "name": ["process_create_message"], "text": ["Executes a call to create a smart contract. Parameters message : Transaction specific items. env : External items required for EVM execution. Returns evm: :py:class: ~ethereum.shanghai.vm.Evm Items containing execution specific objects."]}}, {"source": {"identifier": "ethereum.shanghai.vm.interpreter.process_message", "specifier": 0, "path": "src/ethereum/shanghai/vm/interpreter.py"}, "content": {"type": ["function"], "name": ["process_message"], "text": ["Executes a call to create a smart contract. Parameters message : Transaction specific items. env : External items required for EVM execution. Returns evm: :py:class: ~ethereum.shanghai.vm.Evm Items containing execution specific objects"]}}, {"source": {"identifier": "ethereum.shanghai.vm.interpreter.execute_code", "specifier": 0, "path": "src/ethereum/shanghai/vm/interpreter.py"}, "content": {"type": ["function"], "name": ["execute_code"], "text": ["Executes bytecode present in the  message . Parameters message : Transaction specific items. env : External items required for EVM execution. Returns evm:  ethereum.vm.EVM Items containing execution specific objects"]}}, {"source": {"identifier": "ethereum_optimized.muir_glacier", "specifier": 0, "path": "src/ethereum_optimized/muir_glacier/__init__.py"}, "content": {"type": ["module"], "name": ["ethereum_optimized.muir_glacier"], "text": ["Optimized Implementations (Muir Glacier) ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local:"]}}, {"source": {"identifier": "ethereum_optimized.muir_glacier.monkey_patch_optimized_state_db", "specifier": 0, "path": "src/ethereum_optimized/muir_glacier/__init__.py"}, "content": {"type": ["function"], "name": ["monkey_patch_optimized_state_db"], "text": ["Replace the state interface with one that supports high performance updates and storing state in a database. This function must be called before the state interface is imported anywhere."]}}, {"source": {"identifier": "ethereum_optimized.muir_glacier.monkey_patch_optimized_spec", "specifier": 0, "path": "src/ethereum_optimized/muir_glacier/__init__.py"}, "content": {"type": ["function"], "name": ["monkey_patch_optimized_spec"], "text": ["Replace the ethash implementation with one that supports higher performance. This function must be called before the spec interface is imported anywhere."]}}, {"source": {"identifier": "ethereum_optimized.muir_glacier.monkey_patch", "specifier": 0, "path": "src/ethereum_optimized/muir_glacier/__init__.py"}, "content": {"type": ["function"], "name": ["monkey_patch"], "text": ["Apply all monkey patches to swap in high performance implementations. This function must be called before any of the ethereum modules are imported anywhere."]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.bitwise", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/bitwise.py"}, "content": {"type": ["module"], "name": ["ethereum.dao_fork.vm.instructions.bitwise"], "text": ["Ethereum Virtual Machine (EVM) Bitwise Instructions ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementations of the EVM bitwise instructions."]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.bitwise.bitwise_and", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/bitwise.py"}, "content": {"type": ["function"], "name": ["bitwise_and"], "text": ["Bitwise AND operation of the top 2 elements of the stack. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.bitwise.bitwise_or", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/bitwise.py"}, "content": {"type": ["function"], "name": ["bitwise_or"], "text": ["Bitwise OR operation of the top 2 elements of the stack. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.bitwise.bitwise_xor", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/bitwise.py"}, "content": {"type": ["function"], "name": ["bitwise_xor"], "text": ["Bitwise XOR operation of the top 2 elements of the stack. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.bitwise.bitwise_not", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/bitwise.py"}, "content": {"type": ["function"], "name": ["bitwise_not"], "text": ["Bitwise NOT operation of the top element of the stack. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.bitwise.get_byte", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/bitwise.py"}, "content": {"type": ["function"], "name": ["get_byte"], "text": ["For a word (defined by next top element of the stack), retrieve the Nth byte (0-indexed and defined by top element of stack) from the left (most significant) to right (least significant). Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum_optimized.byzantium.fork", "specifier": 0, "path": "src/ethereum_optimized/byzantium/fork.py"}, "content": {"type": ["module"], "name": ["ethereum_optimized.byzantium.fork"], "text": ["Optimized Spec ^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction This module contains functions can be monkey patched into ethereum.byzantium.fork  to use alternate optimized implementations."]}}, {"source": {"identifier": "ethereum_optimized.byzantium.fork.validate_proof_of_work", "specifier": 0, "path": "src/ethereum_optimized/byzantium/fork.py"}, "content": {"type": ["function"], "name": ["validate_proof_of_work"], "text": ["See  ethereum.byzantium.fork.validate_proof_of_work ."]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.memory", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/memory.py"}, "content": {"type": ["module"], "name": ["ethereum.muir_glacier.vm.memory"], "text": ["Ethereum Virtual Machine (EVM) Memory ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction EVM memory operations."]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.memory.memory_write", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/memory.py"}, "content": {"type": ["function"], "name": ["memory_write"], "text": ["Writes to memory. Parameters memory : Memory contents of the EVM. start_position : Starting pointer to the memory. value : Data to write to memory."]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.memory.memory_read_bytes", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/memory.py"}, "content": {"type": ["function"], "name": ["memory_read_bytes"], "text": ["Read bytes from memory. Parameters memory : Memory contents of the EVM. start_position : Starting pointer to the memory. size : Size of the data that needs to be read from  start_position . Returns data_bytes : Data read from memory."]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.memory.buffer_read", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/memory.py"}, "content": {"type": ["function"], "name": ["buffer_read"], "text": ["Read bytes from a buffer. Padding with zeros if neccesary. Parameters buffer : Memory contents of the EVM. start_position : Starting pointer to the memory. size : Size of the data that needs to be read from  start_position . Returns data_bytes : Data read from memory."]}}, {"source": {"identifier": "ethereum.shanghai.vm.stack", "specifier": 0, "path": "src/ethereum/shanghai/vm/stack.py"}, "content": {"type": ["module"], "name": ["ethereum.shanghai.vm.stack"], "text": ["Ethereum Virtual Machine (EVM) Stack ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementation of the stack operators for the EVM."]}}, {"source": {"identifier": "ethereum.shanghai.vm.stack.pop", "specifier": 0, "path": "src/ethereum/shanghai/vm/stack.py"}, "content": {"type": ["function"], "name": ["pop"], "text": ["Pops the top item off of  stack . Parameters stack : EVM stack. Returns value :  U256 The top element on the stack."]}}, {"source": {"identifier": "ethereum.shanghai.vm.stack.push", "specifier": 0, "path": "src/ethereum/shanghai/vm/stack.py"}, "content": {"type": ["function"], "name": ["push"], "text": ["Pushes  value  onto  stack . Parameters stack : EVM stack. value : Item to be pushed onto  stack ."]}}, {"source": {"identifier": "ethereum.exceptions", "specifier": 0, "path": "src/ethereum/exceptions.py"}, "content": {"type": ["module"], "name": ["ethereum.exceptions"], "text": ["Exceptions ^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction The Ethereum specification exception classes."]}}, {"source": {"identifier": "ethereum.exceptions.EthereumException", "specifier": 0, "path": "src/ethereum/exceptions.py"}, "content": {"type": ["class"], "name": ["EthereumException"], "text": ["The base class from which all exceptions thrown by the specification during normal operation derive."]}}, {"source": {"identifier": "ethereum.exceptions.InvalidBlock", "specifier": 0, "path": "src/ethereum/exceptions.py"}, "content": {"type": ["class"], "name": ["InvalidBlock"], "text": ["Thrown when a block being processed is found to be invalid."]}}, {"source": {"identifier": "ethereum.exceptions.RLPDecodingError", "specifier": 0, "path": "src/ethereum/exceptions.py"}, "content": {"type": ["class"], "name": ["RLPDecodingError"], "text": ["Indicates that RLP decoding failed."]}}, {"source": {"identifier": "ethereum.exceptions.RLPEncodingError", "specifier": 0, "path": "src/ethereum/exceptions.py"}, "content": {"type": ["class"], "name": ["RLPEncodingError"], "text": ["Indicates that RLP encoding failed."]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.environment", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/environment.py"}, "content": {"type": ["module"], "name": ["ethereum.dao_fork.vm.instructions.environment"], "text": ["Ethereum Virtual Machine (EVM) Environmental Instructions ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementations of the EVM environment related instructions."]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.environment.address", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["address"], "text": ["Pushes the address of the current executing account to the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.environment.balance", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["balance"], "text": ["Pushes the balance of the given account onto the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.environment.origin", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["origin"], "text": ["Pushes the address of the original transaction sender to the stack. The origin address can only be an EOA. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.environment.caller", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["caller"], "text": ["Pushes the address of the caller onto the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.environment.callvalue", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["callvalue"], "text": ["Push the value (in wei) sent with the call onto the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.environment.calldataload", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["calldataload"], "text": ["Push a word (32 bytes) of the input data belonging to the current environment onto the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.environment.calldatasize", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["calldatasize"], "text": ["Push the size of input data in current environment onto the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.environment.calldatacopy", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["calldatacopy"], "text": ["Copy a portion of the input data in current environment to memory. This will also expand the memory, in case that the memory is insufficient to store the data. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.environment.codesize", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["codesize"], "text": ["Push the size of code running in current environment onto the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.environment.codecopy", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["codecopy"], "text": ["Copy a portion of the code in current environment to memory. This will also expand the memory, in case that the memory is insufficient to store the data. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.environment.gasprice", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["gasprice"], "text": ["Push the gas price used in current environment onto the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.environment.extcodesize", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["extcodesize"], "text": ["Push the code size of a given account onto the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.environment.extcodecopy", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["extcodecopy"], "text": ["Copy a portion of an account's code to memory. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum_optimized.muir_glacier.state_db", "specifier": 0, "path": "src/ethereum_optimized/muir_glacier/state_db.py"}, "content": {"type": ["module"], "name": ["ethereum_optimized.muir_glacier.state_db"], "text": ["Optimized State ^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction This module contains functions can be monkey patched into ethereum.muir_glacier.state  to use an optimized database backed state."]}}, {"source": {"identifier": "ethereum_optimized.muir_glacier.state_db.UnmodifiedType", "specifier": 0, "path": "src/ethereum_optimized/muir_glacier/state_db.py"}, "content": {"type": ["class"], "name": ["UnmodifiedType"], "text": ["Sentinal type to represent a value that hasn't been modified."]}}, {"source": {"identifier": "ethereum_optimized.muir_glacier.state_db.Unmodified", "specifier": 0, "path": "src/ethereum_optimized/muir_glacier/state_db.py"}, "content": {"type": ["attribute"], "name": ["Unmodified"]}}, {"source": {"identifier": "ethereum_optimized.muir_glacier.state_db.State", "specifier": 0, "path": "src/ethereum_optimized/muir_glacier/state_db.py"}, "content": {"type": ["class"], "name": ["State"], "text": ["The State, backed by a LMDB database. When created with  State()  store the db in a temporary directory. When created with  State(path)  open or create the db located at  path ."]}}, {"source": {"identifier": "ethereum_optimized.muir_glacier.state_db.State.default_path", "specifier": 0, "path": "src/ethereum_optimized/muir_glacier/state_db.py"}, "content": {"type": ["attribute"], "name": ["default_path"]}}, {"source": {"identifier": "ethereum_optimized.muir_glacier.state_db.State.db", "specifier": 0, "path": "src/ethereum_optimized/muir_glacier/state_db.py"}, "content": {"type": ["attribute"], "name": ["db"]}}, {"source": {"identifier": "ethereum_optimized.muir_glacier.state_db.State.dirty_accounts", "specifier": 0, "path": "src/ethereum_optimized/muir_glacier/state_db.py"}, "content": {"type": ["attribute"], "name": ["dirty_accounts"]}}, {"source": {"identifier": "ethereum_optimized.muir_glacier.state_db.State.dirty_storage", "specifier": 0, "path": "src/ethereum_optimized/muir_glacier/state_db.py"}, "content": {"type": ["attribute"], "name": ["dirty_storage"]}}, {"source": {"identifier": "ethereum_optimized.muir_glacier.state_db.State.destroyed_accounts", "specifier": 0, "path": "src/ethereum_optimized/muir_glacier/state_db.py"}, "content": {"type": ["attribute"], "name": ["destroyed_accounts"]}}, {"source": {"identifier": "ethereum_optimized.muir_glacier.state_db.State.tx_restore_points", "specifier": 0, "path": "src/ethereum_optimized/muir_glacier/state_db.py"}, "content": {"type": ["attribute"], "name": ["tx_restore_points"]}}, {"source": {"identifier": "ethereum_optimized.muir_glacier.state_db.State.journal", "specifier": 0, "path": "src/ethereum_optimized/muir_glacier/state_db.py"}, "content": {"type": ["attribute"], "name": ["journal"]}}, {"source": {"identifier": "ethereum_optimized.muir_glacier.state_db.State.__init__", "specifier": 0, "path": "src/ethereum_optimized/muir_glacier/state_db.py"}, "content": {"type": ["function"], "name": ["__init__"]}}, {"source": {"identifier": "ethereum_optimized.muir_glacier.state_db.State.__eq__", "specifier": 0, "path": "src/ethereum_optimized/muir_glacier/state_db.py"}, "content": {"type": ["function"], "name": ["__eq__"], "text": ["Test for equality by comparing state roots."]}}, {"source": {"identifier": "ethereum_optimized.muir_glacier.state_db.State.__enter__", "specifier": 0, "path": "src/ethereum_optimized/muir_glacier/state_db.py"}, "content": {"type": ["function"], "name": ["__enter__"], "text": ["Support with statements"]}}, {"source": {"identifier": "ethereum_optimized.muir_glacier.state_db.State.__exit__", "specifier": 0, "path": "src/ethereum_optimized/muir_glacier/state_db.py"}, "content": {"type": ["function"], "name": ["__exit__"], "text": ["Support with statements"]}}, {"source": {"identifier": "ethereum_optimized.muir_glacier.state_db.close_state", "specifier": 0, "path": "src/ethereum_optimized/muir_glacier/state_db.py"}, "content": {"type": ["function"], "name": ["close_state"], "text": ["Close a state, releasing all resources it holds"]}}, {"source": {"identifier": "ethereum_optimized.muir_glacier.state_db.get_metadata", "specifier": 0, "path": "src/ethereum_optimized/muir_glacier/state_db.py"}, "content": {"type": ["function"], "name": ["get_metadata"], "text": ["Get a piece of metadata"]}}, {"source": {"identifier": "ethereum_optimized.muir_glacier.state_db.set_metadata", "specifier": 0, "path": "src/ethereum_optimized/muir_glacier/state_db.py"}, "content": {"type": ["function"], "name": ["set_metadata"], "text": ["Set a piece of metadata"]}}, {"source": {"identifier": "ethereum_optimized.muir_glacier.state_db.begin_db_transaction", "specifier": 0, "path": "src/ethereum_optimized/muir_glacier/state_db.py"}, "content": {"type": ["function"], "name": ["begin_db_transaction"], "text": ["Start a database transaction. A transaction is automatically started when a State  is created. Nesting of DB transactions is not supported (unlike non-db transactions). No operations are supported when not in a transaction."]}}, {"source": {"identifier": "ethereum_optimized.muir_glacier.state_db.commit_db_transaction", "specifier": 0, "path": "src/ethereum_optimized/muir_glacier/state_db.py"}, "content": {"type": ["function"], "name": ["commit_db_transaction"], "text": ["Commit the current database transaction."]}}, {"source": {"identifier": "ethereum_optimized.muir_glacier.state_db.state_root", "specifier": 0, "path": "src/ethereum_optimized/muir_glacier/state_db.py"}, "content": {"type": ["function"], "name": ["state_root"], "text": ["See  ethereum.muir_glacier.state ."]}}, {"source": {"identifier": "ethereum_optimized.muir_glacier.state_db.storage_root", "specifier": 0, "path": "src/ethereum_optimized/muir_glacier/state_db.py"}, "content": {"type": ["function"], "name": ["storage_root"], "text": ["See  ethereum.muir_glacier.state ."]}}, {"source": {"identifier": "ethereum_optimized.muir_glacier.state_db.flush", "specifier": 0, "path": "src/ethereum_optimized/muir_glacier/state_db.py"}, "content": {"type": ["function"], "name": ["flush"], "text": ["Send everything in the internal caches to the Rust layer."]}}, {"source": {"identifier": "ethereum_optimized.muir_glacier.state_db.rollback_db_transaction", "specifier": 0, "path": "src/ethereum_optimized/muir_glacier/state_db.py"}, "content": {"type": ["function"], "name": ["rollback_db_transaction"], "text": ["Rollback the current database transaction."]}}, {"source": {"identifier": "ethereum_optimized.muir_glacier.state_db.begin_transaction", "specifier": 0, "path": "src/ethereum_optimized/muir_glacier/state_db.py"}, "content": {"type": ["function"], "name": ["begin_transaction"], "text": ["See  ethereum.muir_glacier.state ."]}}, {"source": {"identifier": "ethereum_optimized.muir_glacier.state_db.commit_transaction", "specifier": 0, "path": "src/ethereum_optimized/muir_glacier/state_db.py"}, "content": {"type": ["function"], "name": ["commit_transaction"], "text": ["See  ethereum.muir_glacier.state ."]}}, {"source": {"identifier": "ethereum_optimized.muir_glacier.state_db.rollback_transaction", "specifier": 0, "path": "src/ethereum_optimized/muir_glacier/state_db.py"}, "content": {"type": ["function"], "name": ["rollback_transaction"], "text": ["See  ethereum.muir_glacier.state ."]}}, {"source": {"identifier": "ethereum_optimized.muir_glacier.state_db.get_storage", "specifier": 0, "path": "src/ethereum_optimized/muir_glacier/state_db.py"}, "content": {"type": ["function"], "name": ["get_storage"], "text": ["See  ethereum.muir_glacier.state ."]}}, {"source": {"identifier": "ethereum_optimized.muir_glacier.state_db.get_storage_original", "specifier": 0, "path": "src/ethereum_optimized/muir_glacier/state_db.py"}, "content": {"type": ["function"], "name": ["get_storage_original"], "text": ["See  ethereum.istanbul.state ."]}}, {"source": {"identifier": "ethereum_optimized.muir_glacier.state_db.set_storage", "specifier": 0, "path": "src/ethereum_optimized/muir_glacier/state_db.py"}, "content": {"type": ["function"], "name": ["set_storage"], "text": ["See  ethereum.muir_glacier.state ."]}}, {"source": {"identifier": "ethereum_optimized.muir_glacier.state_db.get_account_optional", "specifier": 0, "path": "src/ethereum_optimized/muir_glacier/state_db.py"}, "content": {"type": ["function"], "name": ["get_account_optional"], "text": ["See  ethereum.muir_glacier.state ."]}}, {"source": {"identifier": "ethereum_optimized.muir_glacier.state_db.set_account", "specifier": 0, "path": "src/ethereum_optimized/muir_glacier/state_db.py"}, "content": {"type": ["function"], "name": ["set_account"], "text": ["See  ethereum.muir_glacier.state ."]}}, {"source": {"identifier": "ethereum_optimized.muir_glacier.state_db.destroy_storage", "specifier": 0, "path": "src/ethereum_optimized/muir_glacier/state_db.py"}, "content": {"type": ["function"], "name": ["destroy_storage"], "text": ["See  ethereum.muir_glacier.state ."]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.exceptions", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/exceptions.py"}, "content": {"type": ["module"], "name": ["ethereum.muir_glacier.vm.exceptions"], "text": ["Ethereum Virtual Machine (EVM) Exceptions ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Exceptions which cause the EVM to halt exceptionally."]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.exceptions.ExceptionalHalt", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/exceptions.py"}, "content": {"type": ["class"], "name": ["ExceptionalHalt"], "text": ["Indicates that the EVM has experienced an exceptional halt. This causes execution to immediately end with all gas being consumed."]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.exceptions.Revert", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/exceptions.py"}, "content": {"type": ["class"], "name": ["Revert"], "text": ["Raised by the  REVERT  opcode. Unlike other EVM exceptions this does not result in the consumption of all gas."]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.exceptions.StackUnderflowError", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/exceptions.py"}, "content": {"type": ["class"], "name": ["StackUnderflowError"], "text": ["Occurs when a pop is executed on an empty stack."]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.exceptions.StackOverflowError", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/exceptions.py"}, "content": {"type": ["class"], "name": ["StackOverflowError"], "text": ["Occurs when a push is executed on a stack at max capacity."]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.exceptions.OutOfGasError", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/exceptions.py"}, "content": {"type": ["class"], "name": ["OutOfGasError"], "text": ["Occurs when an operation costs more than the amount of gas left in the frame."]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.exceptions.InvalidOpcode", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/exceptions.py"}, "content": {"type": ["class"], "name": ["InvalidOpcode"], "text": ["Raised when an invalid opcode is encountered."]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.exceptions.InvalidJumpDestError", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/exceptions.py"}, "content": {"type": ["class"], "name": ["InvalidJumpDestError"], "text": ["Occurs when the destination of a jump operation doesn't meet any of the following criteria: The jump destination is less than the length of the code. The jump destination should have the  JUMPDEST  opcode (0x5B). The jump destination shouldn't be part of the data corresponding to PUSH-N  opcodes."]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.exceptions.StackDepthLimitError", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/exceptions.py"}, "content": {"type": ["class"], "name": ["StackDepthLimitError"], "text": ["Raised when the message depth is greater than  1024"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.exceptions.WriteInStaticContext", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/exceptions.py"}, "content": {"type": ["class"], "name": ["WriteInStaticContext"], "text": ["Raised when an attempt is made to modify the state while operating inside of a STATICCALL context."]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.exceptions.OutOfBoundsRead", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/exceptions.py"}, "content": {"type": ["class"], "name": ["OutOfBoundsRead"], "text": ["Raised when an attempt was made to read data beyond the boundaries of the buffer."]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.exceptions.InvalidParameter", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/exceptions.py"}, "content": {"type": ["class"], "name": ["InvalidParameter"], "text": ["Raised when invalid parameters are passed."]}}, {"source": {"identifier": "ethereum.genesis", "specifier": 0, "path": "src/ethereum/genesis.py"}, "content": {"type": ["module"], "name": ["ethereum.genesis"], "text": ["Genesis Configuration ^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Functionalities and entities to obtain the genesis configurations for different chains."]}}, {"source": {"identifier": "ethereum.genesis.Address", "specifier": 0, "path": "src/ethereum/genesis.py"}, "content": {"type": ["attribute"], "name": ["Address"]}}, {"source": {"identifier": "ethereum.genesis.GenesisConfiguration", "specifier": 0, "path": "src/ethereum/genesis.py"}, "content": {"type": ["class"], "name": ["GenesisConfiguration"], "text": ["Configuration for the first block of an Ethereum chain. Specifies the allocation of ether set out in the pre-sale, and some of the fields of the genesis block."]}}, {"source": {"identifier": "ethereum.genesis.GenesisConfiguration.chain_id", "specifier": 0, "path": "src/ethereum/genesis.py"}, "content": {"type": ["attribute"], "name": ["chain_id"]}}, {"source": {"identifier": "ethereum.genesis.GenesisConfiguration.difficulty", "specifier": 0, "path": "src/ethereum/genesis.py"}, "content": {"type": ["attribute"], "name": ["difficulty"]}}, {"source": {"identifier": "ethereum.genesis.GenesisConfiguration.extra_data", "specifier": 0, "path": "src/ethereum/genesis.py"}, "content": {"type": ["attribute"], "name": ["extra_data"]}}, {"source": {"identifier": "ethereum.genesis.GenesisConfiguration.gas_limit", "specifier": 0, "path": "src/ethereum/genesis.py"}, "content": {"type": ["attribute"], "name": ["gas_limit"]}}, {"source": {"identifier": "ethereum.genesis.GenesisConfiguration.nonce", "specifier": 0, "path": "src/ethereum/genesis.py"}, "content": {"type": ["attribute"], "name": ["nonce"]}}, {"source": {"identifier": "ethereum.genesis.GenesisConfiguration.timestamp", "specifier": 0, "path": "src/ethereum/genesis.py"}, "content": {"type": ["attribute"], "name": ["timestamp"]}}, {"source": {"identifier": "ethereum.genesis.GenesisConfiguration.initial_balances", "specifier": 0, "path": "src/ethereum/genesis.py"}, "content": {"type": ["attribute"], "name": ["initial_balances"]}}, {"source": {"identifier": "ethereum.genesis.get_genesis_configuration", "specifier": 0, "path": "src/ethereum/genesis.py"}, "content": {"type": ["function"], "name": ["get_genesis_configuration"], "text": ["Obtain the genesis configuration from the given genesis json file. The genesis file should be present in the  assets  directory. Parameters genesis_file : The json file which contains the parameters for the genesis block and the pre-sale allocation data. Returns configuration :  GenesisConfiguration The genesis configuration obtained from the json genesis file."]}}, {"source": {"identifier": "ethereum.genesis.add_genesis_block", "specifier": 0, "path": "src/ethereum/genesis.py"}, "content": {"type": ["function"], "name": ["add_genesis_block"], "text": ["Adds the genesis block to an empty blockchain. The genesis block is an entirely sui generis block (unique) that is not governed by the general rules applying to all other Ethereum blocks. Instead, the only consensus requirement is that it must be identical to the block added by this function. The mainnet genesis configuration was originally created using the mk_genesis_block.py  script. It is long since defunct, but is still available at https://github.com/ethereum/genesis_block_generator. The initial state is populated with balances based on the Ethereum presale that happened on the Bitcoin blockchain. Additional Ether worth 1.98% of the presale was given to the foundation. The  state_root  is set to the root of the initial state. The  gas_limit and  difficulty  are set to suitable starting values. In particular the low gas limit made sending transactions impossible in the early stages of Frontier. The  nonce  field is  0x42  referencing Douglas Adams' \"HitchHiker's Guide to the Galaxy\". The  extra_data  field contains the hash of block  1028201  on the pre-launch Olympus testnet. The creation of block  1028201  on Olympus marked the \"starting gun\" for Ethereum block creation. Including its hash in the genesis block ensured a fair launch of the Ethereum mining process. The remaining fields are set to appropriate default values. On testnets the genesis configuration usually allocates 1 wei to addresses 0x00  to  0xFF  to avoid edgecases around precompiles being created or cleared (by EIP 161). Parameters hardfork: The module containing the initial hardfork chain : An empty  Blockchain  object. genesis : The genesis configuration to use."]}}, {"source": {"identifier": "ethereum.shanghai.vm.gas", "specifier": 0, "path": "src/ethereum/shanghai/vm/gas.py"}, "content": {"type": ["module"], "name": ["ethereum.shanghai.vm.gas"], "text": ["Ethereum Virtual Machine (EVM) Gas ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction EVM gas constants and calculators."]}}, {"source": {"identifier": "ethereum.shanghai.vm.gas.GAS_JUMPDEST", "specifier": 0, "path": "src/ethereum/shanghai/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_JUMPDEST"]}}, {"source": {"identifier": "ethereum.shanghai.vm.gas.GAS_BASE", "specifier": 0, "path": "src/ethereum/shanghai/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_BASE"]}}, {"source": {"identifier": "ethereum.shanghai.vm.gas.GAS_VERY_LOW", "specifier": 0, "path": "src/ethereum/shanghai/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_VERY_LOW"]}}, {"source": {"identifier": "ethereum.shanghai.vm.gas.GAS_STORAGE_SET", "specifier": 0, "path": "src/ethereum/shanghai/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_STORAGE_SET"]}}, {"source": {"identifier": "ethereum.shanghai.vm.gas.GAS_STORAGE_UPDATE", "specifier": 0, "path": "src/ethereum/shanghai/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_STORAGE_UPDATE"]}}, {"source": {"identifier": "ethereum.shanghai.vm.gas.GAS_STORAGE_CLEAR_REFUND", "specifier": 0, "path": "src/ethereum/shanghai/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_STORAGE_CLEAR_REFUND"]}}, {"source": {"identifier": "ethereum.shanghai.vm.gas.GAS_LOW", "specifier": 0, "path": "src/ethereum/shanghai/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_LOW"]}}, {"source": {"identifier": "ethereum.shanghai.vm.gas.GAS_MID", "specifier": 0, "path": "src/ethereum/shanghai/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_MID"]}}, {"source": {"identifier": "ethereum.shanghai.vm.gas.GAS_HIGH", "specifier": 0, "path": "src/ethereum/shanghai/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_HIGH"]}}, {"source": {"identifier": "ethereum.shanghai.vm.gas.GAS_EXPONENTIATION", "specifier": 0, "path": "src/ethereum/shanghai/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_EXPONENTIATION"]}}, {"source": {"identifier": "ethereum.shanghai.vm.gas.GAS_EXPONENTIATION_PER_BYTE", "specifier": 0, "path": "src/ethereum/shanghai/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_EXPONENTIATION_PER_BYTE"]}}, {"source": {"identifier": "ethereum.shanghai.vm.gas.GAS_MEMORY", "specifier": 0, "path": "src/ethereum/shanghai/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_MEMORY"]}}, {"source": {"identifier": "ethereum.shanghai.vm.gas.GAS_KECCAK256", "specifier": 0, "path": "src/ethereum/shanghai/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_KECCAK256"]}}, {"source": {"identifier": "ethereum.shanghai.vm.gas.GAS_KECCAK256_WORD", "specifier": 0, "path": "src/ethereum/shanghai/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_KECCAK256_WORD"]}}, {"source": {"identifier": "ethereum.shanghai.vm.gas.GAS_COPY", "specifier": 0, "path": "src/ethereum/shanghai/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_COPY"]}}, {"source": {"identifier": "ethereum.shanghai.vm.gas.GAS_BLOCK_HASH", "specifier": 0, "path": "src/ethereum/shanghai/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_BLOCK_HASH"]}}, {"source": {"identifier": "ethereum.shanghai.vm.gas.GAS_LOG", "specifier": 0, "path": "src/ethereum/shanghai/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_LOG"]}}, {"source": {"identifier": "ethereum.shanghai.vm.gas.GAS_LOG_DATA", "specifier": 0, "path": "src/ethereum/shanghai/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_LOG_DATA"]}}, {"source": {"identifier": "ethereum.shanghai.vm.gas.GAS_LOG_TOPIC", "specifier": 0, "path": "src/ethereum/shanghai/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_LOG_TOPIC"]}}, {"source": {"identifier": "ethereum.shanghai.vm.gas.GAS_CREATE", "specifier": 0, "path": "src/ethereum/shanghai/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_CREATE"]}}, {"source": {"identifier": "ethereum.shanghai.vm.gas.GAS_CODE_DEPOSIT", "specifier": 0, "path": "src/ethereum/shanghai/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_CODE_DEPOSIT"]}}, {"source": {"identifier": "ethereum.shanghai.vm.gas.GAS_ZERO", "specifier": 0, "path": "src/ethereum/shanghai/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_ZERO"]}}, {"source": {"identifier": "ethereum.shanghai.vm.gas.GAS_NEW_ACCOUNT", "specifier": 0, "path": "src/ethereum/shanghai/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_NEW_ACCOUNT"]}}, {"source": {"identifier": "ethereum.shanghai.vm.gas.GAS_CALL_VALUE", "specifier": 0, "path": "src/ethereum/shanghai/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_CALL_VALUE"]}}, {"source": {"identifier": "ethereum.shanghai.vm.gas.GAS_CALL_STIPEND", "specifier": 0, "path": "src/ethereum/shanghai/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_CALL_STIPEND"]}}, {"source": {"identifier": "ethereum.shanghai.vm.gas.GAS_SELF_DESTRUCT", "specifier": 0, "path": "src/ethereum/shanghai/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_SELF_DESTRUCT"]}}, {"source": {"identifier": "ethereum.shanghai.vm.gas.GAS_SELF_DESTRUCT_NEW_ACCOUNT", "specifier": 0, "path": "src/ethereum/shanghai/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_SELF_DESTRUCT_NEW_ACCOUNT"]}}, {"source": {"identifier": "ethereum.shanghai.vm.gas.GAS_ECRECOVER", "specifier": 0, "path": "src/ethereum/shanghai/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_ECRECOVER"]}}, {"source": {"identifier": "ethereum.shanghai.vm.gas.GAS_SHA256", "specifier": 0, "path": "src/ethereum/shanghai/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_SHA256"]}}, {"source": {"identifier": "ethereum.shanghai.vm.gas.GAS_SHA256_WORD", "specifier": 0, "path": "src/ethereum/shanghai/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_SHA256_WORD"]}}, {"source": {"identifier": "ethereum.shanghai.vm.gas.GAS_RIPEMD160", "specifier": 0, "path": "src/ethereum/shanghai/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_RIPEMD160"]}}, {"source": {"identifier": "ethereum.shanghai.vm.gas.GAS_RIPEMD160_WORD", "specifier": 0, "path": "src/ethereum/shanghai/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_RIPEMD160_WORD"]}}, {"source": {"identifier": "ethereum.shanghai.vm.gas.GAS_IDENTITY", "specifier": 0, "path": "src/ethereum/shanghai/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_IDENTITY"]}}, {"source": {"identifier": "ethereum.shanghai.vm.gas.GAS_IDENTITY_WORD", "specifier": 0, "path": "src/ethereum/shanghai/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_IDENTITY_WORD"]}}, {"source": {"identifier": "ethereum.shanghai.vm.gas.GAS_RETURN_DATA_COPY", "specifier": 0, "path": "src/ethereum/shanghai/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_RETURN_DATA_COPY"]}}, {"source": {"identifier": "ethereum.shanghai.vm.gas.GAS_FAST_STEP", "specifier": 0, "path": "src/ethereum/shanghai/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_FAST_STEP"]}}, {"source": {"identifier": "ethereum.shanghai.vm.gas.GAS_BLAKE2_PER_ROUND", "specifier": 0, "path": "src/ethereum/shanghai/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_BLAKE2_PER_ROUND"]}}, {"source": {"identifier": "ethereum.shanghai.vm.gas.GAS_COLD_SLOAD", "specifier": 0, "path": "src/ethereum/shanghai/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_COLD_SLOAD"]}}, {"source": {"identifier": "ethereum.shanghai.vm.gas.GAS_COLD_ACCOUNT_ACCESS", "specifier": 0, "path": "src/ethereum/shanghai/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_COLD_ACCOUNT_ACCESS"]}}, {"source": {"identifier": "ethereum.shanghai.vm.gas.GAS_WARM_ACCESS", "specifier": 0, "path": "src/ethereum/shanghai/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_WARM_ACCESS"]}}, {"source": {"identifier": "ethereum.shanghai.vm.gas.GAS_INIT_CODE_WORD_COST", "specifier": 0, "path": "src/ethereum/shanghai/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_INIT_CODE_WORD_COST"]}}, {"source": {"identifier": "ethereum.shanghai.vm.gas.ExtendMemory", "specifier": 0, "path": "src/ethereum/shanghai/vm/gas.py"}, "content": {"type": ["class"], "name": ["ExtendMemory"], "text": ["Define the parameters for memory extension in opcodes cost :  ethereum.base_types.Uint The gas required to perform the extension expand_by :  ethereum.base_types.Uint The size by which the memory will be extended"]}}, {"source": {"identifier": "ethereum.shanghai.vm.gas.ExtendMemory.cost", "specifier": 0, "path": "src/ethereum/shanghai/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["cost"]}}, {"source": {"identifier": "ethereum.shanghai.vm.gas.ExtendMemory.expand_by", "specifier": 0, "path": "src/ethereum/shanghai/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["expand_by"]}}, {"source": {"identifier": "ethereum.shanghai.vm.gas.MessageCallGas", "specifier": 0, "path": "src/ethereum/shanghai/vm/gas.py"}, "content": {"type": ["class"], "name": ["MessageCallGas"], "text": ["Define the gas cost and stipend for executing the call opcodes. cost :  ethereum.base_types.Uint The non-refundable portion of gas reserved for executing the call opcode. stipend :  ethereum.base_types.Uint The portion of gas available to sub-calls that is refundable if not consumed"]}}, {"source": {"identifier": "ethereum.shanghai.vm.gas.MessageCallGas.cost", "specifier": 0, "path": "src/ethereum/shanghai/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["cost"]}}, {"source": {"identifier": "ethereum.shanghai.vm.gas.MessageCallGas.stipend", "specifier": 0, "path": "src/ethereum/shanghai/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["stipend"]}}, {"source": {"identifier": "ethereum.shanghai.vm.gas.charge_gas", "specifier": 0, "path": "src/ethereum/shanghai/vm/gas.py"}, "content": {"type": ["function"], "name": ["charge_gas"], "text": ["Subtracts  amount  from  evm.gas_left . Parameters evm : The current EVM. amount : The amount of gas the current operation requires."]}}, {"source": {"identifier": "ethereum.shanghai.vm.gas.calculate_memory_gas_cost", "specifier": 0, "path": "src/ethereum/shanghai/vm/gas.py"}, "content": {"type": ["function"], "name": ["calculate_memory_gas_cost"], "text": ["Calculates the gas cost for allocating memory to the smallest multiple of 32 bytes, such that the allocated size is at least as big as the given size. Parameters size_in_bytes : The size of the data in bytes. Returns total_gas_cost :  ethereum.base_types.Uint The gas cost for storing data in memory."]}}, {"source": {"identifier": "ethereum.shanghai.vm.gas.calculate_gas_extend_memory", "specifier": 0, "path": "src/ethereum/shanghai/vm/gas.py"}, "content": {"type": ["function"], "name": ["calculate_gas_extend_memory"], "text": ["Calculates the gas amount to extend memory Parameters memory : Memory contents of the EVM. extensions: List of extensions to be made to the memory. Consists of a tuple of start position and size. Returns extend_memory:  ExtendMemory"]}}, {"source": {"identifier": "ethereum.shanghai.vm.gas.calculate_message_call_gas", "specifier": 0, "path": "src/ethereum/shanghai/vm/gas.py"}, "content": {"type": ["function"], "name": ["calculate_message_call_gas"], "text": ["Calculates the MessageCallGas (cost and stipend) for executing call Opcodes. Parameters value: The amount of  ETH  that needs to be transferred. gas : The amount of gas provided to the message-call. gas_left : The amount of gas left in the current frame. memory_cost : The amount needed to extend the memory in the current frame. extra_gas : The amount of gas needed for transferring value + creating a new account inside a message call. call_stipend : The amount of stipend provided to a message call to execute code while transferring value(ETH). Returns message_call_gas:  MessageCallGas"]}}, {"source": {"identifier": "ethereum.shanghai.vm.gas.max_message_call_gas", "specifier": 0, "path": "src/ethereum/shanghai/vm/gas.py"}, "content": {"type": ["function"], "name": ["max_message_call_gas"], "text": ["Calculates the maximum gas that is allowed for making a message call Parameters gas : The amount of gas provided to the message-call. Returns max_allowed_message_call_gas:  ethereum.base_types.Uint The maximum gas allowed for making the message-call."]}}, {"source": {"identifier": "ethereum.shanghai.vm.gas.init_code_cost", "specifier": 0, "path": "src/ethereum/shanghai/vm/gas.py"}, "content": {"type": ["function"], "name": ["init_code_cost"], "text": ["Calculates the gas to be charged for the init code in CREAT* opcodes as well as create transactions. Parameters init_code_length : The length of the init code provided to the opcode or a create transaction Returns init_code_gas:  ethereum.base_types.Uint The gas to be charged for the init code."]}}, {"source": {"identifier": "ethereum_optimized.spurious_dragon.fork", "specifier": 0, "path": "src/ethereum_optimized/spurious_dragon/fork.py"}, "content": {"type": ["module"], "name": ["ethereum_optimized.spurious_dragon.fork"], "text": ["Optimized Spec ^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction This module contains functions can be monkey patched into ethereum.spurious_dragon.fork  to use alternate optimized implementations."]}}, {"source": {"identifier": "ethereum_optimized.spurious_dragon.fork.validate_proof_of_work", "specifier": 0, "path": "src/ethereum_optimized/spurious_dragon/fork.py"}, "content": {"type": ["function"], "name": ["validate_proof_of_work"], "text": ["See  ethereum.spurious_dragon.fork.validate_proof_of_work ."]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.stack", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/stack.py"}, "content": {"type": ["module"], "name": ["ethereum.dao_fork.vm.instructions.stack"], "text": ["Ethereum Virtual Machine (EVM) Stack Instructions ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementations of the EVM stack related instructions."]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.stack.pop", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/stack.py"}, "content": {"type": ["function"], "name": ["pop"], "text": ["Remove item from stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.stack.push_n", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/stack.py"}, "content": {"type": ["function"], "name": ["push_n"], "text": ["Pushes a N-byte immediate onto the stack. Parameters evm : The current EVM frame. num_bytes : The number of immediate bytes to be read from the code and pushed to the stack."]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.stack.dup_n", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/stack.py"}, "content": {"type": ["function"], "name": ["dup_n"], "text": ["Duplicate the Nth stack item (from top of the stack) to the top of stack. Parameters evm : The current EVM frame. item_number : The stack item number (0-indexed from top of stack) to be duplicated to the top of stack."]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.stack.swap_n", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/stack.py"}, "content": {"type": ["function"], "name": ["swap_n"], "text": ["Swap the top and the  item_number  element of the stack, where the top of the stack is position zero. If  item_number  is zero, this function does nothing (which should not be possible, since there is no  SWAP0  instruction). Parameters evm : The current EVM frame. item_number : The stack item number (0-indexed from top of stack) to be swapped with the top of stack element."]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.stack.push1", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push1"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.stack.push2", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push2"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.stack.push3", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push3"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.stack.push4", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push4"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.stack.push5", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push5"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.stack.push6", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push6"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.stack.push7", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push7"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.stack.push8", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push8"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.stack.push9", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push9"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.stack.push10", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push10"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.stack.push11", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push11"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.stack.push12", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push12"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.stack.push13", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push13"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.stack.push14", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push14"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.stack.push15", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push15"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.stack.push16", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push16"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.stack.push17", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push17"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.stack.push18", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push18"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.stack.push19", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push19"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.stack.push20", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push20"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.stack.push21", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push21"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.stack.push22", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push22"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.stack.push23", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push23"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.stack.push24", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push24"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.stack.push25", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push25"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.stack.push26", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push26"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.stack.push27", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push27"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.stack.push28", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push28"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.stack.push29", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push29"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.stack.push30", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push30"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.stack.push31", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push31"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.stack.push32", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push32"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.stack.dup1", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup1"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.stack.dup2", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup2"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.stack.dup3", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup3"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.stack.dup4", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup4"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.stack.dup5", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup5"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.stack.dup6", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup6"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.stack.dup7", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup7"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.stack.dup8", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup8"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.stack.dup9", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup9"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.stack.dup10", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup10"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.stack.dup11", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup11"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.stack.dup12", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup12"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.stack.dup13", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup13"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.stack.dup14", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup14"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.stack.dup15", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup15"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.stack.dup16", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup16"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.stack.swap1", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap1"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.stack.swap2", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap2"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.stack.swap3", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap3"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.stack.swap4", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap4"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.stack.swap5", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap5"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.stack.swap6", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap6"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.stack.swap7", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap7"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.stack.swap8", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap8"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.stack.swap9", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap9"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.stack.swap10", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap10"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.stack.swap11", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap11"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.stack.swap12", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap12"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.stack.swap13", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap13"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.stack.swap14", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap14"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.stack.swap15", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap15"]}}, {"source": {"identifier": "ethereum.dao_fork.vm.instructions.stack.swap16", "specifier": 0, "path": "src/ethereum/dao_fork/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap16"]}}, {"source": {"identifier": "ethereum", "specifier": 0, "path": "src/ethereum/__init__.py"}, "content": {"type": ["module"], "name": ["ethereum"], "text": ["Ethereum Specification ^^^^^^^^^^^^^^^^^^^^^^ Seeing as internet connections have been vastly expanding across the world, spreading information has become as cheap as ever. Bitcoin, for example, has demonstrated the possibility of creating a decentralized, trade system that is accessible around the world. Namecoin is another system that built off of Bitcoin's currency structure to create other simple technological applications. Ethereum's goal is to create a cryptographically secure system in which any and all types of transaction-based concepts can be built. It provides an exceptionally accessible and decentralized system to build software and execute transactions. This package contains a reference implementation, written as simply as possible, to aid in defining the behavior of Ethereum clients."]}}, {"source": {"identifier": "ethereum.__version__", "specifier": 0, "path": "src/ethereum/__init__.py"}, "content": {"type": ["attribute"], "name": ["__version__"]}}, {"source": {"identifier": "ethereum.EVM_RECURSION_LIMIT", "specifier": 0, "path": "src/ethereum/__init__.py"}, "content": {"type": ["attribute"], "name": ["EVM_RECURSION_LIMIT"]}}, {"source": {"identifier": "ethereum.evm_trace", "specifier": 0, "path": "src/ethereum/__init__.py"}, "content": {"type": ["function"], "name": ["evm_trace"], "text": ["autoapi_noshow Placeholder for an evm trace function. The spec does not trace evm by default. EVM tracing will be injected if the user requests it."]}}, {"source": {"identifier": "ethereum.muir_glacier.vm", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/__init__.py"}, "content": {"type": ["module"], "name": ["ethereum.muir_glacier.vm"], "text": ["Ethereum Virtual Machine (EVM) ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction The abstract computer which runs the code stored in an .fork_types.Account ."]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.__all__", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["__all__"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.Environment", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/__init__.py"}, "content": {"type": ["class"], "name": ["Environment"], "text": ["Items external to the virtual machine itself, provided by the environment."]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.Environment.caller", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["caller"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.Environment.block_hashes", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["block_hashes"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.Environment.origin", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["origin"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.Environment.coinbase", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["coinbase"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.Environment.number", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["number"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.Environment.gas_limit", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["gas_limit"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.Environment.gas_price", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["gas_price"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.Environment.time", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["time"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.Environment.difficulty", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["difficulty"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.Environment.state", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["state"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.Environment.chain_id", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["chain_id"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.Message", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/__init__.py"}, "content": {"type": ["class"], "name": ["Message"], "text": ["Items that are used by contract creation or message call."]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.Message.caller", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["caller"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.Message.target", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["target"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.Message.current_target", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["current_target"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.Message.gas", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["gas"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.Message.value", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["value"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.Message.data", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["data"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.Message.code_address", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["code_address"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.Message.code", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["code"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.Message.depth", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["depth"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.Message.should_transfer_value", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["should_transfer_value"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.Message.is_static", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["is_static"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.Evm", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/__init__.py"}, "content": {"type": ["class"], "name": ["Evm"], "text": ["The internal state of the virtual machine."]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.Evm.pc", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["pc"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.Evm.stack", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["stack"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.Evm.memory", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["memory"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.Evm.code", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["code"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.Evm.gas_left", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["gas_left"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.Evm.env", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["env"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.Evm.valid_jump_destinations", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["valid_jump_destinations"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.Evm.logs", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["logs"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.Evm.refund_counter", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["refund_counter"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.Evm.running", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["running"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.Evm.message", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["message"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.Evm.output", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["output"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.Evm.accounts_to_delete", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["accounts_to_delete"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.Evm.touched_accounts", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["touched_accounts"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.Evm.has_erred", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["has_erred"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.Evm.return_data", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["return_data"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.Evm.error", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["error"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.incorporate_child_on_success", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/__init__.py"}, "content": {"type": ["function"], "name": ["incorporate_child_on_success"], "text": ["Incorporate the state of a successful  child_evm  into the parent  evm . Parameters evm : The parent  EVM . child_evm : The child evm to incorporate."]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.incorporate_child_on_error", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/__init__.py"}, "content": {"type": ["function"], "name": ["incorporate_child_on_error"], "text": ["Incorporate the state of an unsuccessful  child_evm  into the parent  evm . Parameters evm : The parent  EVM . child_evm : The child evm to incorporate."]}}, {"source": {"identifier": "ethereum.shanghai.vm.precompiled_contracts.blake2f", "specifier": 0, "path": "src/ethereum/shanghai/vm/precompiled_contracts/blake2f.py"}, "content": {"type": ["module"], "name": ["ethereum.shanghai.vm.precompiled_contracts.blake2f"], "text": ["Ethereum Virtual Machine (EVM) Blake2 PRECOMPILED CONTRACT ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementation of the  Blake2  precompiled contract."]}}, {"source": {"identifier": "ethereum.shanghai.vm.precompiled_contracts.blake2f.blake2f", "specifier": 0, "path": "src/ethereum/shanghai/vm/precompiled_contracts/blake2f.py"}, "content": {"type": ["function"], "name": ["blake2f"], "text": ["Writes the Blake2 hash to output. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum_optimized.muir_glacier.fork", "specifier": 0, "path": "src/ethereum_optimized/muir_glacier/fork.py"}, "content": {"type": ["module"], "name": ["ethereum_optimized.muir_glacier.fork"], "text": ["Optimized Spec ^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction This module contains functions can be monkey patched into ethereum.muir_glacier.fork  to use alternate optimized implementations."]}}, {"source": {"identifier": "ethereum_optimized.muir_glacier.fork.validate_proof_of_work", "specifier": 0, "path": "src/ethereum_optimized/muir_glacier/fork.py"}, "content": {"type": ["function"], "name": ["validate_proof_of_work"], "text": ["See  ethereum.muir_glacier.fork.validate_proof_of_work ."]}}, {"source": {"identifier": "ethereum.ethash", "specifier": 0, "path": "src/ethereum/ethash.py"}, "content": {"type": ["module"], "name": ["ethereum.ethash"], "text": ["Ethash Functions ^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Ethash algorithm related functionalities."]}}, {"source": {"identifier": "ethereum.ethash.EPOCH_SIZE", "specifier": 0, "path": "src/ethereum/ethash.py"}, "content": {"type": ["attribute"], "name": ["EPOCH_SIZE"]}}, {"source": {"identifier": "ethereum.ethash.INITIAL_CACHE_SIZE", "specifier": 0, "path": "src/ethereum/ethash.py"}, "content": {"type": ["attribute"], "name": ["INITIAL_CACHE_SIZE"]}}, {"source": {"identifier": "ethereum.ethash.CACHE_EPOCH_GROWTH_SIZE", "specifier": 0, "path": "src/ethereum/ethash.py"}, "content": {"type": ["attribute"], "name": ["CACHE_EPOCH_GROWTH_SIZE"]}}, {"source": {"identifier": "ethereum.ethash.INITIAL_DATASET_SIZE", "specifier": 0, "path": "src/ethereum/ethash.py"}, "content": {"type": ["attribute"], "name": ["INITIAL_DATASET_SIZE"]}}, {"source": {"identifier": "ethereum.ethash.DATASET_EPOCH_GROWTH_SIZE", "specifier": 0, "path": "src/ethereum/ethash.py"}, "content": {"type": ["attribute"], "name": ["DATASET_EPOCH_GROWTH_SIZE"]}}, {"source": {"identifier": "ethereum.ethash.HASH_BYTES", "specifier": 0, "path": "src/ethereum/ethash.py"}, "content": {"type": ["attribute"], "name": ["HASH_BYTES"]}}, {"source": {"identifier": "ethereum.ethash.MIX_BYTES", "specifier": 0, "path": "src/ethereum/ethash.py"}, "content": {"type": ["attribute"], "name": ["MIX_BYTES"]}}, {"source": {"identifier": "ethereum.ethash.CACHE_ROUNDS", "specifier": 0, "path": "src/ethereum/ethash.py"}, "content": {"type": ["attribute"], "name": ["CACHE_ROUNDS"]}}, {"source": {"identifier": "ethereum.ethash.DATASET_PARENTS", "specifier": 0, "path": "src/ethereum/ethash.py"}, "content": {"type": ["attribute"], "name": ["DATASET_PARENTS"]}}, {"source": {"identifier": "ethereum.ethash.HASHIMOTO_ACCESSES", "specifier": 0, "path": "src/ethereum/ethash.py"}, "content": {"type": ["attribute"], "name": ["HASHIMOTO_ACCESSES"]}}, {"source": {"identifier": "ethereum.ethash.epoch", "specifier": 0, "path": "src/ethereum/ethash.py"}, "content": {"type": ["function"], "name": ["epoch"], "text": ["Obtain the epoch number to which the block identified by  block_number belongs. Parameters block_number : The number of the block of interest. Returns epoch_number :  Uint The epoch number to which the passed in block belongs."]}}, {"source": {"identifier": "ethereum.ethash.cache_size", "specifier": 0, "path": "src/ethereum/ethash.py"}, "content": {"type": ["function"], "name": ["cache_size"], "text": ["Obtain the cache size (in bytes) of the epoch to which  block_number belongs. Parameters block_number : The number of the block of interest. Returns cache_size_bytes :  Uint The cache size in bytes for the passed in block."]}}, {"source": {"identifier": "ethereum.ethash.dataset_size", "specifier": 0, "path": "src/ethereum/ethash.py"}, "content": {"type": ["function"], "name": ["dataset_size"], "text": ["Obtain the dataset size (in bytes) of the epoch to which  block_number belongs. Parameters block_number : The number of the block of interest. Returns dataset_size_bytes :  Uint The dataset size in bytes for the passed in block."]}}, {"source": {"identifier": "ethereum.ethash.generate_seed", "specifier": 0, "path": "src/ethereum/ethash.py"}, "content": {"type": ["function"], "name": ["generate_seed"], "text": ["Obtain the cache generation seed for the block identified by block_number . Parameters block_number : The number of the block of interest. Returns seed :  Hash32 The cache generation seed for the passed in block."]}}, {"source": {"identifier": "ethereum.ethash.generate_cache", "specifier": 0, "path": "src/ethereum/ethash.py"}, "content": {"type": ["function"], "name": ["generate_cache"], "text": ["Generate the cache for the block identified by  block_number . This cache would later be used to generate the full dataset. Parameters block_number : The number of the block of interest. Returns cache :  Tuple[Tuple[U32, ...], ...] The cache generated for the passed in block."]}}, {"source": {"identifier": "ethereum.ethash.fnv", "specifier": 0, "path": "src/ethereum/ethash.py"}, "content": {"type": ["function"], "name": ["fnv"], "text": ["FNV algorithm is inspired by the FNV hash, which in some cases is used as a non-associative substitute for XOR. Note that here we multiply the prime with the full 32-bit input, in contrast with the FNV-1 spec which multiplies the prime with one byte (octet) in turn. Parameters a: The first data point. b : The second data point. Returns modified_mix_integers :  U32 The result of performing fnv on the passed in data points."]}}, {"source": {"identifier": "ethereum.ethash.fnv_hash", "specifier": 0, "path": "src/ethereum/ethash.py"}, "content": {"type": ["function"], "name": ["fnv_hash"], "text": ["FNV Hash mixes in data into mix using the ethash fnv method. Parameters mix_integers: Mix data in the form of a sequence of U32. data : The data (sequence of U32) to be hashed into the mix. Returns modified_mix_integers :  Tuple[U32, ...] The result of performing the fnv hash on the mix and the passed in data."]}}, {"source": {"identifier": "ethereum.ethash.generate_dataset_item", "specifier": 0, "path": "src/ethereum/ethash.py"}, "content": {"type": ["function"], "name": ["generate_dataset_item"], "text": ["Generate a particular dataset item 0-indexed by  index  using  cache . Each dataset item is a byte stream of 64 bytes or a stream of 16 uint32 numbers. Parameters cache: The cache from which a subset of items will be used to generate the dataset item. index : The index of the dataset item to generate. Returns dataset_item :  Hash64 The generated dataset item for passed index."]}}, {"source": {"identifier": "ethereum.ethash.generate_dataset", "specifier": 0, "path": "src/ethereum/ethash.py"}, "content": {"type": ["function"], "name": ["generate_dataset"], "text": ["Generate the full dataset for the block identified by  block_number . This function is present only for demonstration purposes, as it will take a long time to execute. Parameters block_number : The number of the block of interest. Returns dataset :  Tuple[Hash64, ...] The dataset generated for the passed in block."]}}, {"source": {"identifier": "ethereum.ethash.hashimoto", "specifier": 0, "path": "src/ethereum/ethash.py"}, "content": {"type": ["function"], "name": ["hashimoto"], "text": ["Obtain the mix digest and the final value for a header, by aggregating data from the full dataset. Parameters header_hash : The PoW valid rlp hash of a header. nonce : The propogated nonce for the given block. dataset_size : Dataset size for the epoch to which the current block belongs to. fetch_dataset_item : The function which will be used to obtain a specific dataset item from an index. Returns mix_digest :  bytes The mix digest generated from the header hash and propogated nonce. result :  Hash32 The final result obtained which will be checked for leading zeros (in byte representation) in correspondance with the block difficulty."]}}, {"source": {"identifier": "ethereum.ethash.hashimoto_light", "specifier": 0, "path": "src/ethereum/ethash.py"}, "content": {"type": ["function"], "name": ["hashimoto_light"], "text": ["Run the hashimoto algorithm by generating dataset item using the cache instead of loading the full dataset into main memory. Parameters header_hash : The PoW valid rlp hash of a header. nonce : The propogated nonce for the given block. cache: The generated cache for the epoch to which the current block belongs to. dataset_size : Dataset size for the epoch to which the current block belongs to. Returns mix_digest :  bytes The mix digest generated from the header hash and propogated nonce. result :  Hash32 The final result obtained which will be checked for leading zeros (in byte representation) in correspondance with the block difficulty."]}}, {"source": {"identifier": "ethereum.dao_fork.utils", "specifier": 0, "path": "src/ethereum/dao_fork/utils/__init__.py"}, "content": {"type": ["module"], "name": ["ethereum.dao_fork.utils"], "text": ["Hardfork Utility Functions ^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Utility functions used in this Dao Fork version of specification."]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.runtime", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/runtime.py"}, "content": {"type": ["module"], "name": ["ethereum.muir_glacier.vm.runtime"], "text": ["Ethereum Virtual Machine (EVM) Runtime Operations ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Runtime related operations used while executing EVM code."]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.runtime.get_valid_jump_destinations", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/runtime.py"}, "content": {"type": ["function"], "name": ["get_valid_jump_destinations"], "text": ["Analyze the evm code to obtain the set of valid jump destinations. Valid jump destinations are defined as follows: * The jump destination is less than the length of the code. * The jump destination should have the  JUMPDEST  opcode (0x5B). * The jump destination shouldn't be part of the data corresponding to PUSH-N  opcodes. Note - Jump destinations are 0-indexed. Parameters code : The EVM code which is to be executed. Returns valid_jump_destinations:  Set[Uint] The set of valid jump destinations in the code."]}}, {"source": {"identifier": "ethereum_optimized.dao_fork.fork", "specifier": 0, "path": "src/ethereum_optimized/dao_fork/fork.py"}, "content": {"type": ["module"], "name": ["ethereum_optimized.dao_fork.fork"], "text": ["Optimized Spec ^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction This module contains functions can be monkey patched into ethereum.dao_fork.fork  to use alternate optimized implementations."]}}, {"source": {"identifier": "ethereum_optimized.dao_fork.fork.validate_proof_of_work", "specifier": 0, "path": "src/ethereum_optimized/dao_fork/fork.py"}, "content": {"type": ["function"], "name": ["validate_proof_of_work"], "text": ["See  ethereum.dao_fork.fork.validate_proof_of_work ."]}}, {"source": {"identifier": "ethereum.base_types", "specifier": 0, "path": "src/ethereum/base_types.py"}, "content": {"type": ["module"], "name": ["ethereum.base_types"], "text": ["Numeric & Array Types ^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Integer and array types which are used by\u2014but not unique to\u2014Ethereum."]}}, {"source": {"identifier": "ethereum.base_types.U8_MAX_VALUE", "specifier": 0, "path": "src/ethereum/base_types.py"}, "content": {"type": ["attribute"], "name": ["U8_MAX_VALUE"]}}, {"source": {"identifier": "ethereum.base_types.U32_MAX_VALUE", "specifier": 0, "path": "src/ethereum/base_types.py"}, "content": {"type": ["attribute"], "name": ["U32_MAX_VALUE"]}}, {"source": {"identifier": "ethereum.base_types.U32_CEIL_VALUE", "specifier": 0, "path": "src/ethereum/base_types.py"}, "content": {"type": ["attribute"], "name": ["U32_CEIL_VALUE"]}}, {"source": {"identifier": "ethereum.base_types.U64_MAX_VALUE", "specifier": 0, "path": "src/ethereum/base_types.py"}, "content": {"type": ["attribute"], "name": ["U64_MAX_VALUE"]}}, {"source": {"identifier": "ethereum.base_types.U255_MAX_VALUE", "specifier": 0, "path": "src/ethereum/base_types.py"}, "content": {"type": ["attribute"], "name": ["U255_MAX_VALUE"]}}, {"source": {"identifier": "ethereum.base_types.U255_CEIL_VALUE", "specifier": 0, "path": "src/ethereum/base_types.py"}, "content": {"type": ["attribute"], "name": ["U255_CEIL_VALUE"]}}, {"source": {"identifier": "ethereum.base_types.U256_MAX_VALUE", "specifier": 0, "path": "src/ethereum/base_types.py"}, "content": {"type": ["attribute"], "name": ["U256_MAX_VALUE"]}}, {"source": {"identifier": "ethereum.base_types.U256_CEIL_VALUE", "specifier": 0, "path": "src/ethereum/base_types.py"}, "content": {"type": ["attribute"], "name": ["U256_CEIL_VALUE"]}}, {"source": {"identifier": "ethereum.base_types.Uint", "specifier": 0, "path": "src/ethereum/base_types.py"}, "content": {"type": ["class"], "name": ["Uint"], "text": ["Unsigned positive integer."]}}, {"source": {"identifier": "ethereum.base_types.Uint.__slots__", "specifier": 0, "path": "src/ethereum/base_types.py"}, "content": {"type": ["attribute"], "name": ["__slots__"]}}, {"source": {"identifier": "ethereum.base_types.Uint.from_be_bytes", "specifier": 0, "path": "src/ethereum/base_types.py"}, "content": {"type": ["function"], "name": ["from_be_bytes"], "text": ["Converts a sequence of bytes into an arbitrarily sized unsigned integer from its big endian representation. Parameters buffer : Bytes to decode. Returns self :  Uint Unsigned integer decoded from  buffer ."]}}, {"source": {"identifier": "ethereum.base_types.Uint.from_le_bytes", "specifier": 0, "path": "src/ethereum/base_types.py"}, "content": {"type": ["function"], "name": ["from_le_bytes"], "text": ["Convert a series of little endian bytes to an unsigned integer."]}}, {"source": {"identifier": "ethereum.base_types.Uint.__init__", "specifier": 0, "path": "src/ethereum/base_types.py"}, "content": {"type": ["function"], "name": ["__init__"]}}, {"source": {"identifier": "ethereum.base_types.Uint.__radd__", "specifier": 0, "path": "src/ethereum/base_types.py"}, "content": {"type": ["function"], "name": ["__radd__"]}}, {"source": {"identifier": "ethereum.base_types.Uint.__add__", "specifier": 0, "path": "src/ethereum/base_types.py"}, "content": {"type": ["function"], "name": ["__add__"]}}, {"source": {"identifier": "ethereum.base_types.Uint.__iadd__", "specifier": 0, "path": "src/ethereum/base_types.py"}, "content": {"type": ["function"], "name": ["__iadd__"]}}, {"source": {"identifier": "ethereum.base_types.Uint.__sub__", "specifier": 0, "path": "src/ethereum/base_types.py"}, "content": {"type": ["function"], "name": ["__sub__"]}}, {"source": {"identifier": "ethereum.base_types.Uint.__rsub__", "specifier": 0, "path": "src/ethereum/base_types.py"}, "content": {"type": ["function"], "name": ["__rsub__"]}}, {"source": {"identifier": "ethereum.base_types.Uint.__isub__", "specifier": 0, "path": "src/ethereum/base_types.py"}, "content": {"type": ["function"], "name": ["__isub__"]}}, {"source": {"identifier": "ethereum.base_types.Uint.__mul__", "specifier": 0, "path": "src/ethereum/base_types.py"}, "content": {"type": ["function"], "name": ["__mul__"]}}, {"source": {"identifier": "ethereum.base_types.Uint.__rmul__", "specifier": 0, "path": "src/ethereum/base_types.py"}, "content": {"type": ["function"], "name": ["__rmul__"]}}, {"source": {"identifier": "ethereum.base_types.Uint.__imul__", "specifier": 0, "path": "src/ethereum/base_types.py"}, "content": {"type": ["function"], "name": ["__imul__"]}}, {"source": {"identifier": "ethereum.base_types.Uint.__floordiv__", "specifier": 0, "path": "src/ethereum/base_types.py"}, "content": {"type": ["function"], "name": ["__floordiv__"]}}, {"source": {"identifier": "ethereum.base_types.Uint.__rfloordiv__", "specifier": 0, "path": "src/ethereum/base_types.py"}, "content": {"type": ["function"], "name": ["__rfloordiv__"]}}, {"source": {"identifier": "ethereum.base_types.Uint.__ifloordiv__", "specifier": 0, "path": "src/ethereum/base_types.py"}, "content": {"type": ["function"], "name": ["__ifloordiv__"]}}, {"source": {"identifier": "ethereum.base_types.Uint.__mod__", "specifier": 0, "path": "src/ethereum/base_types.py"}, "content": {"type": ["function"], "name": ["__mod__"]}}, {"source": {"identifier": "ethereum.base_types.Uint.__rmod__", "specifier": 0, "path": "src/ethereum/base_types.py"}, "content": {"type": ["function"], "name": ["__rmod__"]}}, {"source": {"identifier": "ethereum.base_types.Uint.__imod__", "specifier": 0, "path": "src/ethereum/base_types.py"}, "content": {"type": ["function"], "name": ["__imod__"]}}, {"source": {"identifier": "ethereum.base_types.Uint.__divmod__", "specifier": 0, "path": "src/ethereum/base_types.py"}, "content": {"type": ["function"], "name": ["__divmod__"]}}, {"source": {"identifier": "ethereum.base_types.Uint.__rdivmod__", "specifier": 0, "path": "src/ethereum/base_types.py"}, "content": {"type": ["function"], "name": ["__rdivmod__"]}}, {"source": {"identifier": "ethereum.base_types.Uint.__pow__", "specifier": 0, "path": "src/ethereum/base_types.py"}, "content": {"type": ["function"], "name": ["__pow__"]}}, {"source": {"identifier": "ethereum.base_types.Uint.__rpow__", "specifier": 0, "path": "src/ethereum/base_types.py"}, "content": {"type": ["function"], "name": ["__rpow__"]}}, {"source": {"identifier": "ethereum.base_types.Uint.__ipow__", "specifier": 0, "path": "src/ethereum/base_types.py"}, "content": {"type": ["function"], "name": ["__ipow__"]}}, {"source": {"identifier": "ethereum.base_types.Uint.__xor__", "specifier": 0, "path": "src/ethereum/base_types.py"}, "content": {"type": ["function"], "name": ["__xor__"]}}, {"source": {"identifier": "ethereum.base_types.Uint.__rxor__", "specifier": 0, "path": "src/ethereum/base_types.py"}, "content": {"type": ["function"], "name": ["__rxor__"]}}, {"source": {"identifier": "ethereum.base_types.Uint.__ixor__", "specifier": 0, "path": "src/ethereum/base_types.py"}, "content": {"type": ["function"], "name": ["__ixor__"]}}, {"source": {"identifier": "ethereum.base_types.Uint.to_be_bytes32", "specifier": 0, "path": "src/ethereum/base_types.py"}, "content": {"type": ["function"], "name": ["to_be_bytes32"], "text": ["Converts this arbitrarily sized unsigned integer into its big endian representation with exactly 32 bytes. Returns big_endian :  Bytes32 Big endian (most significant bits first) representation."]}}, {"source": {"identifier": "ethereum.base_types.Uint.to_be_bytes", "specifier": 0, "path": "src/ethereum/base_types.py"}, "content": {"type": ["function"], "name": ["to_be_bytes"], "text": ["Converts this arbitrarily sized unsigned integer into its big endian representation. Returns big_endian :  Bytes Big endian (most significant bits first) representation."]}}, {"source": {"identifier": "ethereum.base_types.Uint.to_le_bytes", "specifier": 0, "path": "src/ethereum/base_types.py"}, "content": {"type": ["function"], "name": ["to_le_bytes"], "text": ["Converts this arbitrarily sized unsigned integer into its little endian representation. Parameters number_bytes : Exact number of bytes to return (defaults to the fewest that can represent this number.) Returns little_endian :  Bytes Little endian (most significant bits last) representation."]}}, {"source": {"identifier": "ethereum.base_types.T", "specifier": 0, "path": "src/ethereum/base_types.py"}, "content": {"type": ["attribute"], "name": ["T"]}}, {"source": {"identifier": "ethereum.base_types.FixedUInt", "specifier": 0, "path": "src/ethereum/base_types.py"}, "content": {"type": ["class"], "name": ["FixedUInt"], "text": ["Superclass for fixed size unsigned integers. Not intended to be used directly, but rather to be subclassed."]}}, {"source": {"identifier": "ethereum.base_types.FixedUInt.MAX_VALUE", "specifier": 0, "path": "src/ethereum/base_types.py"}, "content": {"type": ["attribute"], "name": ["MAX_VALUE"]}}, {"source": {"identifier": "ethereum.base_types.FixedUInt.__slots__", "specifier": 0, "path": "src/ethereum/base_types.py"}, "content": {"type": ["attribute"], "name": ["__slots__"]}}, {"source": {"identifier": "ethereum.base_types.FixedUInt.__init__", "specifier": 0, "path": "src/ethereum/base_types.py"}, "content": {"type": ["function"], "name": ["__init__"]}}, {"source": {"identifier": "ethereum.base_types.FixedUInt.__radd__", "specifier": 0, "path": "src/ethereum/base_types.py"}, "content": {"type": ["function"], "name": ["__radd__"]}}, {"source": {"identifier": "ethereum.base_types.FixedUInt.__add__", "specifier": 0, "path": "src/ethereum/base_types.py"}, "content": {"type": ["function"], "name": ["__add__"]}}, {"source": {"identifier": "ethereum.base_types.FixedUInt.wrapping_add", "specifier": 0, "path": "src/ethereum/base_types.py"}, "content": {"type": ["function"], "name": ["wrapping_add"], "text": ["Return a new instance containing  self + right (mod N) . Parameters right : Other operand for addition. Returns sum : T The result of adding  self  and  right , wrapped."]}}, {"source": {"identifier": "ethereum.base_types.FixedUInt.__iadd__", "specifier": 0, "path": "src/ethereum/base_types.py"}, "content": {"type": ["function"], "name": ["__iadd__"]}}, {"source": {"identifier": "ethereum.base_types.FixedUInt.__sub__", "specifier": 0, "path": "src/ethereum/base_types.py"}, "content": {"type": ["function"], "name": ["__sub__"]}}, {"source": {"identifier": "ethereum.base_types.FixedUInt.wrapping_sub", "specifier": 0, "path": "src/ethereum/base_types.py"}, "content": {"type": ["function"], "name": ["wrapping_sub"], "text": ["Return a new instance containing  self - right (mod N) . Parameters right : Subtrahend operand for subtraction. Returns difference : T The result of subtracting  right  from  self , wrapped."]}}, {"source": {"identifier": "ethereum.base_types.FixedUInt.__rsub__", "specifier": 0, "path": "src/ethereum/base_types.py"}, "content": {"type": ["function"], "name": ["__rsub__"]}}, {"source": {"identifier": "ethereum.base_types.FixedUInt.__isub__", "specifier": 0, "path": "src/ethereum/base_types.py"}, "content": {"type": ["function"], "name": ["__isub__"]}}, {"source": {"identifier": "ethereum.base_types.FixedUInt.__mul__", "specifier": 0, "path": "src/ethereum/base_types.py"}, "content": {"type": ["function"], "name": ["__mul__"]}}, {"source": {"identifier": "ethereum.base_types.FixedUInt.wrapping_mul", "specifier": 0, "path": "src/ethereum/base_types.py"}, "content": {"type": ["function"], "name": ["wrapping_mul"], "text": ["Return a new instance containing  self * right (mod N) . Parameters right : Other operand for multiplication. Returns product : T The result of multiplying  self  by  right , wrapped."]}}, {"source": {"identifier": "ethereum.base_types.FixedUInt.__rmul__", "specifier": 0, "path": "src/ethereum/base_types.py"}, "content": {"type": ["function"], "name": ["__rmul__"]}}, {"source": {"identifier": "ethereum.base_types.FixedUInt.__imul__", "specifier": 0, "path": "src/ethereum/base_types.py"}, "content": {"type": ["function"], "name": ["__imul__"]}}, {"source": {"identifier": "ethereum.base_types.FixedUInt.__floordiv__", "specifier": 0, "path": "src/ethereum/base_types.py"}, "content": {"type": ["function"], "name": ["__floordiv__"]}}, {"source": {"identifier": "ethereum.base_types.FixedUInt.__rfloordiv__", "specifier": 0, "path": "src/ethereum/base_types.py"}, "content": {"type": ["function"], "name": ["__rfloordiv__"]}}, {"source": {"identifier": "ethereum.base_types.FixedUInt.__ifloordiv__", "specifier": 0, "path": "src/ethereum/base_types.py"}, "content": {"type": ["function"], "name": ["__ifloordiv__"]}}, {"source": {"identifier": "ethereum.base_types.FixedUInt.__mod__", "specifier": 0, "path": "src/ethereum/base_types.py"}, "content": {"type": ["function"], "name": ["__mod__"]}}, {"source": {"identifier": "ethereum.base_types.FixedUInt.__rmod__", "specifier": 0, "path": "src/ethereum/base_types.py"}, "content": {"type": ["function"], "name": ["__rmod__"]}}, {"source": {"identifier": "ethereum.base_types.FixedUInt.__imod__", "specifier": 0, "path": "src/ethereum/base_types.py"}, "content": {"type": ["function"], "name": ["__imod__"]}}, {"source": {"identifier": "ethereum.base_types.FixedUInt.__divmod__", "specifier": 0, "path": "src/ethereum/base_types.py"}, "content": {"type": ["function"], "name": ["__divmod__"]}}, {"source": {"identifier": "ethereum.base_types.FixedUInt.__rdivmod__", "specifier": 0, "path": "src/ethereum/base_types.py"}, "content": {"type": ["function"], "name": ["__rdivmod__"]}}, {"source": {"identifier": "ethereum.base_types.FixedUInt.__pow__", "specifier": 0, "path": "src/ethereum/base_types.py"}, "content": {"type": ["function"], "name": ["__pow__"]}}, {"source": {"identifier": "ethereum.base_types.FixedUInt.wrapping_pow", "specifier": 0, "path": "src/ethereum/base_types.py"}, "content": {"type": ["function"], "name": ["wrapping_pow"], "text": ["Return a new instance containing  self ** right (mod modulo) . Parameters right : Exponent operand. modulo : Optional modulus (defaults to  MAX_VALUE + 1 .) Returns power : T The result of raising  self  to the power of  right , wrapped."]}}, {"source": {"identifier": "ethereum.base_types.FixedUInt.__rpow__", "specifier": 0, "path": "src/ethereum/base_types.py"}, "content": {"type": ["function"], "name": ["__rpow__"]}}, {"source": {"identifier": "ethereum.base_types.FixedUInt.__ipow__", "specifier": 0, "path": "src/ethereum/base_types.py"}, "content": {"type": ["function"], "name": ["__ipow__"]}}, {"source": {"identifier": "ethereum.base_types.FixedUInt.__and__", "specifier": 0, "path": "src/ethereum/base_types.py"}, "content": {"type": ["function"], "name": ["__and__"]}}, {"source": {"identifier": "ethereum.base_types.FixedUInt.__or__", "specifier": 0, "path": "src/ethereum/base_types.py"}, "content": {"type": ["function"], "name": ["__or__"]}}, {"source": {"identifier": "ethereum.base_types.FixedUInt.__xor__", "specifier": 0, "path": "src/ethereum/base_types.py"}, "content": {"type": ["function"], "name": ["__xor__"]}}, {"source": {"identifier": "ethereum.base_types.FixedUInt.__rxor__", "specifier": 0, "path": "src/ethereum/base_types.py"}, "content": {"type": ["function"], "name": ["__rxor__"]}}, {"source": {"identifier": "ethereum.base_types.FixedUInt.__ixor__", "specifier": 0, "path": "src/ethereum/base_types.py"}, "content": {"type": ["function"], "name": ["__ixor__"]}}, {"source": {"identifier": "ethereum.base_types.FixedUInt.__invert__", "specifier": 0, "path": "src/ethereum/base_types.py"}, "content": {"type": ["function"], "name": ["__invert__"]}}, {"source": {"identifier": "ethereum.base_types.FixedUInt.__rshift__", "specifier": 0, "path": "src/ethereum/base_types.py"}, "content": {"type": ["function"], "name": ["__rshift__"]}}, {"source": {"identifier": "ethereum.base_types.FixedUInt.to_be_bytes", "specifier": 0, "path": "src/ethereum/base_types.py"}, "content": {"type": ["function"], "name": ["to_be_bytes"], "text": ["Converts this unsigned integer into its big endian representation, omitting leading zero bytes. Returns big_endian :  Bytes Big endian (most significant bits first) representation."]}}, {"source": {"identifier": "ethereum.base_types.U256", "specifier": 0, "path": "src/ethereum/base_types.py"}, "content": {"type": ["class"], "name": ["U256"], "text": ["Unsigned positive integer, which can represent  0  to  2 ** 256 - 1 , inclusive."]}}, {"source": {"identifier": "ethereum.base_types.U256.MAX_VALUE", "specifier": 0, "path": "src/ethereum/base_types.py"}, "content": {"type": ["attribute"], "name": ["MAX_VALUE"]}}, {"source": {"identifier": "ethereum.base_types.U256.__slots__", "specifier": 0, "path": "src/ethereum/base_types.py"}, "content": {"type": ["attribute"], "name": ["__slots__"]}}, {"source": {"identifier": "ethereum.base_types.U256.from_be_bytes", "specifier": 0, "path": "src/ethereum/base_types.py"}, "content": {"type": ["function"], "name": ["from_be_bytes"], "text": ["Converts a sequence of bytes into an arbitrarily sized unsigned integer from its big endian representation. Parameters buffer : Bytes to decode. Returns self :  U256 Unsigned integer decoded from  buffer ."]}}, {"source": {"identifier": "ethereum.base_types.U256.from_signed", "specifier": 0, "path": "src/ethereum/base_types.py"}, "content": {"type": ["function"], "name": ["from_signed"], "text": ["Converts a signed number into a 256-bit unsigned integer. Parameters value : Signed number Returns self :  U256 Unsigned integer obtained from  value ."]}}, {"source": {"identifier": "ethereum.base_types.U256.to_be_bytes32", "specifier": 0, "path": "src/ethereum/base_types.py"}, "content": {"type": ["function"], "name": ["to_be_bytes32"], "text": ["Converts this 256-bit unsigned integer into its big endian representation with exactly 32 bytes. Returns big_endian :  Bytes32 Big endian (most significant bits first) representation."]}}, {"source": {"identifier": "ethereum.base_types.U256.to_signed", "specifier": 0, "path": "src/ethereum/base_types.py"}, "content": {"type": ["function"], "name": ["to_signed"], "text": ["Converts this 256-bit unsigned integer into a signed integer. Returns signed_int :  int Signed integer obtained from 256-bit unsigned integer."]}}, {"source": {"identifier": "ethereum.base_types.U256.MAX_VALUE", "specifier": 1, "path": "src/ethereum/base_types.py"}, "content": {"type": ["attribute"], "name": ["U256", "MAX_VALUE"], "text": ["autoapi_noindex"]}}, {"source": {"identifier": "ethereum.base_types.U32", "specifier": 0, "path": "src/ethereum/base_types.py"}, "content": {"type": ["class"], "name": ["U32"], "text": ["Unsigned positive integer, which can represent  0  to  2 ** 32 - 1 , inclusive."]}}, {"source": {"identifier": "ethereum.base_types.U32.MAX_VALUE", "specifier": 0, "path": "src/ethereum/base_types.py"}, "content": {"type": ["attribute"], "name": ["MAX_VALUE"]}}, {"source": {"identifier": "ethereum.base_types.U32.__slots__", "specifier": 0, "path": "src/ethereum/base_types.py"}, "content": {"type": ["attribute"], "name": ["__slots__"]}}, {"source": {"identifier": "ethereum.base_types.U32.from_le_bytes", "specifier": 0, "path": "src/ethereum/base_types.py"}, "content": {"type": ["function"], "name": ["from_le_bytes"], "text": ["Converts a sequence of bytes into an arbitrarily sized unsigned integer from its little endian representation."]}}, {"source": {"identifier": "ethereum.base_types.U32.to_le_bytes4", "specifier": 0, "path": "src/ethereum/base_types.py"}, "content": {"type": ["function"], "name": ["to_le_bytes4"], "text": ["Converts this fixed sized unsigned integer into its little endian representation, with exactly 4 bytes. Returns little_endian :  Bytes4 Little endian (most significant bits last) representation."]}}, {"source": {"identifier": "ethereum.base_types.U32.to_le_bytes", "specifier": 0, "path": "src/ethereum/base_types.py"}, "content": {"type": ["function"], "name": ["to_le_bytes"], "text": ["Converts this fixed sized unsigned integer into its little endian representation, in the fewest bytes possible. Returns little_endian :  Bytes Little endian (most significant bits last) representation."]}}, {"source": {"identifier": "ethereum.base_types.U32.MAX_VALUE", "specifier": 1, "path": "src/ethereum/base_types.py"}, "content": {"type": ["attribute"], "name": ["U32", "MAX_VALUE"], "text": ["autoapi_noindex"]}}, {"source": {"identifier": "ethereum.base_types.U64", "specifier": 0, "path": "src/ethereum/base_types.py"}, "content": {"type": ["class"], "name": ["U64"], "text": ["Unsigned positive integer, which can represent  0  to  2 ** 64 - 1 , inclusive."]}}, {"source": {"identifier": "ethereum.base_types.U64.MAX_VALUE", "specifier": 0, "path": "src/ethereum/base_types.py"}, "content": {"type": ["attribute"], "name": ["MAX_VALUE"]}}, {"source": {"identifier": "ethereum.base_types.U64.__slots__", "specifier": 0, "path": "src/ethereum/base_types.py"}, "content": {"type": ["attribute"], "name": ["__slots__"]}}, {"source": {"identifier": "ethereum.base_types.U64.from_le_bytes", "specifier": 0, "path": "src/ethereum/base_types.py"}, "content": {"type": ["function"], "name": ["from_le_bytes"], "text": ["Converts a sequence of bytes into an arbitrarily sized unsigned integer from its little endian representation."]}}, {"source": {"identifier": "ethereum.base_types.U64.to_le_bytes8", "specifier": 0, "path": "src/ethereum/base_types.py"}, "content": {"type": ["function"], "name": ["to_le_bytes8"], "text": ["Converts this fixed sized unsigned integer into its little endian representation, with exactly 8 bytes. Returns little_endian :  Bytes8 Little endian (most significant bits last) representation."]}}, {"source": {"identifier": "ethereum.base_types.U64.to_le_bytes", "specifier": 0, "path": "src/ethereum/base_types.py"}, "content": {"type": ["function"], "name": ["to_le_bytes"], "text": ["Converts this fixed sized unsigned integer into its little endian representation, in the fewest bytes possible. Returns little_endian :  Bytes Little endian (most significant bits last) representation."]}}, {"source": {"identifier": "ethereum.base_types.U64.from_be_bytes", "specifier": 0, "path": "src/ethereum/base_types.py"}, "content": {"type": ["function"], "name": ["from_be_bytes"], "text": ["Converts a sequence of bytes into an unsigned 64 bit integer from its big endian representation. Parameters buffer : Bytes to decode. Returns self :  U64 Unsigned integer decoded from  buffer ."]}}, {"source": {"identifier": "ethereum.base_types.U64.MAX_VALUE", "specifier": 1, "path": "src/ethereum/base_types.py"}, "content": {"type": ["attribute"], "name": ["U64", "MAX_VALUE"], "text": ["autoapi_noindex"]}}, {"source": {"identifier": "ethereum.base_types.B", "specifier": 0, "path": "src/ethereum/base_types.py"}, "content": {"type": ["attribute"], "name": ["B"]}}, {"source": {"identifier": "ethereum.base_types.FixedBytes", "specifier": 0, "path": "src/ethereum/base_types.py"}, "content": {"type": ["class"], "name": ["FixedBytes"], "text": ["Superclass for fixed sized byte arrays. Not intended to be used directly, but should be subclassed."]}}, {"source": {"identifier": "ethereum.base_types.FixedBytes.LENGTH", "specifier": 0, "path": "src/ethereum/base_types.py"}, "content": {"type": ["attribute"], "name": ["LENGTH"]}}, {"source": {"identifier": "ethereum.base_types.FixedBytes.__slots__", "specifier": 0, "path": "src/ethereum/base_types.py"}, "content": {"type": ["attribute"], "name": ["__slots__"]}}, {"source": {"identifier": "ethereum.base_types.FixedBytes.__new__", "specifier": 0, "path": "src/ethereum/base_types.py"}, "content": {"type": ["function"], "name": ["__new__"], "text": ["Create a new instance, ensuring the result has the correct length."]}}, {"source": {"identifier": "ethereum.base_types.Bytes0", "specifier": 0, "path": "src/ethereum/base_types.py"}, "content": {"type": ["class"], "name": ["Bytes0"], "text": ["Byte array of exactly zero elements."]}}, {"source": {"identifier": "ethereum.base_types.Bytes0.LENGTH", "specifier": 0, "path": "src/ethereum/base_types.py"}, "content": {"type": ["attribute"], "name": ["LENGTH"]}}, {"source": {"identifier": "ethereum.base_types.Bytes4", "specifier": 0, "path": "src/ethereum/base_types.py"}, "content": {"type": ["class"], "name": ["Bytes4"], "text": ["Byte array of exactly four elements."]}}, {"source": {"identifier": "ethereum.base_types.Bytes4.LENGTH", "specifier": 0, "path": "src/ethereum/base_types.py"}, "content": {"type": ["attribute"], "name": ["LENGTH"]}}, {"source": {"identifier": "ethereum.base_types.Bytes8", "specifier": 0, "path": "src/ethereum/base_types.py"}, "content": {"type": ["class"], "name": ["Bytes8"], "text": ["Byte array of exactly eight elements."]}}, {"source": {"identifier": "ethereum.base_types.Bytes8.LENGTH", "specifier": 0, "path": "src/ethereum/base_types.py"}, "content": {"type": ["attribute"], "name": ["LENGTH"]}}, {"source": {"identifier": "ethereum.base_types.Bytes20", "specifier": 0, "path": "src/ethereum/base_types.py"}, "content": {"type": ["class"], "name": ["Bytes20"], "text": ["Byte array of exactly 20 elements."]}}, {"source": {"identifier": "ethereum.base_types.Bytes20.LENGTH", "specifier": 0, "path": "src/ethereum/base_types.py"}, "content": {"type": ["attribute"], "name": ["LENGTH"]}}, {"source": {"identifier": "ethereum.base_types.Bytes32", "specifier": 0, "path": "src/ethereum/base_types.py"}, "content": {"type": ["class"], "name": ["Bytes32"], "text": ["Byte array of exactly 32 elements."]}}, {"source": {"identifier": "ethereum.base_types.Bytes32.LENGTH", "specifier": 0, "path": "src/ethereum/base_types.py"}, "content": {"type": ["attribute"], "name": ["LENGTH"]}}, {"source": {"identifier": "ethereum.base_types.Bytes64", "specifier": 0, "path": "src/ethereum/base_types.py"}, "content": {"type": ["class"], "name": ["Bytes64"], "text": ["Byte array of exactly 64 elements."]}}, {"source": {"identifier": "ethereum.base_types.Bytes64.LENGTH", "specifier": 0, "path": "src/ethereum/base_types.py"}, "content": {"type": ["attribute"], "name": ["LENGTH"]}}, {"source": {"identifier": "ethereum.base_types.Bytes256", "specifier": 0, "path": "src/ethereum/base_types.py"}, "content": {"type": ["class"], "name": ["Bytes256"], "text": ["Byte array of exactly 256 elements."]}}, {"source": {"identifier": "ethereum.base_types.Bytes256.LENGTH", "specifier": 0, "path": "src/ethereum/base_types.py"}, "content": {"type": ["attribute"], "name": ["LENGTH"]}}, {"source": {"identifier": "ethereum.base_types.Bytes", "specifier": 0, "path": "src/ethereum/base_types.py"}, "content": {"type": ["attribute"], "name": ["Bytes"]}}, {"source": {"identifier": "ethereum.base_types._setattr_function", "specifier": 0, "path": "src/ethereum/base_types.py"}, "content": {"type": ["function"], "name": ["_setattr_function"]}}, {"source": {"identifier": "ethereum.base_types._delattr_function", "specifier": 0, "path": "src/ethereum/base_types.py"}, "content": {"type": ["function"], "name": ["_delattr_function"]}}, {"source": {"identifier": "ethereum.base_types._make_init_function", "specifier": 0, "path": "src/ethereum/base_types.py"}, "content": {"type": ["function"], "name": ["_make_init_function"]}}, {"source": {"identifier": "ethereum.base_types.slotted_freezable", "specifier": 0, "path": "src/ethereum/base_types.py"}, "content": {"type": ["function"], "name": ["slotted_freezable"], "text": ["Monkey patches a dataclass so it can be frozen by setting  _frozen  to True  and uses  __slots__  for efficiency. Instances will be created frozen by default unless you pass  _frozen=False to  __init__ ."]}}, {"source": {"identifier": "ethereum.base_types.S", "specifier": 0, "path": "src/ethereum/base_types.py"}, "content": {"type": ["attribute"], "name": ["S"]}}, {"source": {"identifier": "ethereum.base_types.modify", "specifier": 0, "path": "src/ethereum/base_types.py"}, "content": {"type": ["function"], "name": ["modify"], "text": ["Create a mutable copy of  obj  (which must be  @slotted_freezable ) and apply  f  to the copy before freezing it. Parameters obj :  S Object to copy. f :  Callable[[S], None] Function to apply to  obj . Returns new_obj :  S Compact byte array."]}}, {"source": {"identifier": "ethereum.shanghai.vm.precompiled_contracts.mapping", "specifier": 0, "path": "src/ethereum/shanghai/vm/precompiled_contracts/mapping.py"}, "content": {"type": ["module"], "name": ["ethereum.shanghai.vm.precompiled_contracts.mapping"], "text": ["Precompiled Contract Addresses ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Mapping of precompiled contracts their implementations."]}}, {"source": {"identifier": "ethereum.shanghai.vm.precompiled_contracts.mapping.PRE_COMPILED_CONTRACTS", "specifier": 0, "path": "src/ethereum/shanghai/vm/precompiled_contracts/mapping.py"}, "content": {"type": ["attribute"], "name": ["PRE_COMPILED_CONTRACTS"]}}, {"source": {"identifier": "ethereum.dao_fork.utils.address", "specifier": 0, "path": "src/ethereum/dao_fork/utils/address.py"}, "content": {"type": ["module"], "name": ["ethereum.dao_fork.utils.address"], "text": ["Hardfork Utility Functions For Addresses ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Address specific functions used in this Dao Fork version of specification."]}}, {"source": {"identifier": "ethereum.dao_fork.utils.address.to_address", "specifier": 0, "path": "src/ethereum/dao_fork/utils/address.py"}, "content": {"type": ["function"], "name": ["to_address"], "text": ["Convert a Uint or U256 value to a valid address (20 bytes). Parameters data : The string to be converted to bytes. Returns address :  Address The obtained address."]}}, {"source": {"identifier": "ethereum.dao_fork.utils.address.compute_contract_address", "specifier": 0, "path": "src/ethereum/dao_fork/utils/address.py"}, "content": {"type": ["function"], "name": ["compute_contract_address"], "text": ["Computes address of the new account that needs to be created. Parameters address : The address of the account that wants to create the new account. nonce : The transaction count of the account that wants to create the new account. Returns address:  ethereum.dao_fork.fork_types.Address The computed address of the new account."]}}, {"source": {"identifier": "ethereum.rlp", "specifier": 0, "path": "src/ethereum/rlp.py"}, "content": {"type": ["module"], "name": ["ethereum.rlp"], "text": [".. _rlp: Recursive Length Prefix (RLP) Encoding ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Defines the serialization and deserialization format used throughout Ethereum."]}}, {"source": {"identifier": "ethereum.rlp.RLP", "specifier": 0, "path": "src/ethereum/rlp.py"}, "content": {"type": ["attribute"], "name": ["RLP"]}}, {"source": {"identifier": "ethereum.rlp.encode", "specifier": 0, "path": "src/ethereum/rlp.py"}, "content": {"type": ["function"], "name": ["encode"], "text": ["Encodes  raw_data  into a sequence of bytes using RLP. Parameters raw_data : A  Bytes ,  Uint ,  Uint256  or sequence of  RLP  encodable objects. Returns encoded :  ethereum.base_types.Bytes The RLP encoded bytes representing  raw_data ."]}}, {"source": {"identifier": "ethereum.rlp.encode_bytes", "specifier": 0, "path": "src/ethereum/rlp.py"}, "content": {"type": ["function"], "name": ["encode_bytes"], "text": ["Encodes  raw_bytes , a sequence of bytes, using RLP. Parameters raw_bytes : Bytes to encode with RLP. Returns encoded :  ethereum.base_types.Bytes The RLP encoded bytes representing  raw_bytes ."]}}, {"source": {"identifier": "ethereum.rlp.encode_sequence", "specifier": 0, "path": "src/ethereum/rlp.py"}, "content": {"type": ["function"], "name": ["encode_sequence"], "text": ["Encodes a list of RLP encodable objects ( raw_sequence ) using RLP. Parameters raw_sequence : Sequence of RLP encodable objects. Returns encoded :  ethereum.base_types.Bytes The RLP encoded bytes representing  raw_sequence ."]}}, {"source": {"identifier": "ethereum.rlp.get_joined_encodings", "specifier": 0, "path": "src/ethereum/rlp.py"}, "content": {"type": ["function"], "name": ["get_joined_encodings"], "text": ["Obtain concatenation of rlp encoding for each item in the sequence raw_sequence. Parameters raw_sequence : Sequence to encode with RLP. Returns joined_encodings :  ethereum.base_types.Bytes The concatenated RLP encoded bytes for each item in sequence raw_sequence."]}}, {"source": {"identifier": "ethereum.rlp.decode", "specifier": 0, "path": "src/ethereum/rlp.py"}, "content": {"type": ["function"], "name": ["decode"], "text": ["Decodes an integer, byte sequence, or list of RLP encodable objects from the byte sequence  encoded_data , using RLP. Parameters encoded_data : A sequence of bytes, in RLP form. Returns decoded_data :  RLP Object decoded from  encoded_data ."]}}, {"source": {"identifier": "ethereum.rlp.T", "specifier": 0, "path": "src/ethereum/rlp.py"}, "content": {"type": ["attribute"], "name": ["T"]}}, {"source": {"identifier": "ethereum.rlp.decode_to", "specifier": 0, "path": "src/ethereum/rlp.py"}, "content": {"type": ["function"], "name": ["decode_to"], "text": ["Decode the bytes in  encoded_data  to an object of type  cls .  cls  can be a  Bytes  subclass, a dataclass,  Uint ,  U256  or  Tuple[cls] . Parameters cls:  Type[T] The type to decode to. encoded_data : A sequence of bytes, in RLP form. Returns decoded_data :  T Object decoded from  encoded_data ."]}}, {"source": {"identifier": "ethereum.rlp._decode_to", "specifier": 0, "path": "src/ethereum/rlp.py"}, "content": {"type": ["function"], "name": ["_decode_to"], "text": ["Decode the rlp structure in  encoded_data  to an object of type  cls . cls  can be a  Bytes  subclass, a dataclass,  Uint ,  U256 , Tuple[cls, ...] ,  Tuple[cls1, cls2]  or  Union[Bytes, cls] . Parameters cls:  Type[T] The type to decode to. raw_rlp : A decoded rlp structure. Returns decoded_data :  T Object decoded from  encoded_data ."]}}, {"source": {"identifier": "ethereum.rlp.decode_to_bytes", "specifier": 0, "path": "src/ethereum/rlp.py"}, "content": {"type": ["function"], "name": ["decode_to_bytes"], "text": ["Decodes a rlp encoded byte stream assuming that the decoded data should be of type  bytes . Parameters encoded_bytes : RLP encoded byte stream. Returns decoded :  ethereum.base_types.Bytes RLP decoded Bytes data"]}}, {"source": {"identifier": "ethereum.rlp.decode_to_sequence", "specifier": 0, "path": "src/ethereum/rlp.py"}, "content": {"type": ["function"], "name": ["decode_to_sequence"], "text": ["Decodes a rlp encoded byte stream assuming that the decoded data should be of type  Sequence  of objects. Parameters encoded_sequence : An RLP encoded Sequence. Returns decoded :  Sequence[RLP] Sequence of objects decoded from  encoded_sequence ."]}}, {"source": {"identifier": "ethereum.rlp.decode_joined_encodings", "specifier": 0, "path": "src/ethereum/rlp.py"}, "content": {"type": ["function"], "name": ["decode_joined_encodings"], "text": ["Decodes  joined_encodings , which is a concatenation of RLP encoded objects. Parameters joined_encodings : concatenation of RLP encoded objects Returns decoded :  List[RLP] A list of objects decoded from  joined_encodings ."]}}, {"source": {"identifier": "ethereum.rlp.decode_item_length", "specifier": 0, "path": "src/ethereum/rlp.py"}, "content": {"type": ["function"], "name": ["decode_item_length"], "text": ["Find the length of the rlp encoding for the first object in the encoded sequence. Here  encoded_data  refers to concatenation of rlp encoding for each item in a sequence. NOTE - This is a helper function not described in the spec. It was introduced as the spec doesn't discuss about decoding the RLP encoded data. Parameters encoded_data : RLP encoded data for a sequence of objects. Returns rlp_length :  int"]}}, {"source": {"identifier": "ethereum.rlp.rlp_hash", "specifier": 0, "path": "src/ethereum/rlp.py"}, "content": {"type": ["function"], "name": ["rlp_hash"], "text": ["Obtain the keccak-256 hash of the rlp encoding of the passed in data. Parameters data : The data for which we need the rlp hash. Returns hash :  Hash32 The rlp hash of the passed in data."]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.interpreter", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/interpreter.py"}, "content": {"type": ["module"], "name": ["ethereum.muir_glacier.vm.interpreter"], "text": ["Ethereum Virtual Machine (EVM) Interpreter ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction A straightforward interpreter that executes EVM code."]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.interpreter.STACK_DEPTH_LIMIT", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/interpreter.py"}, "content": {"type": ["attribute"], "name": ["STACK_DEPTH_LIMIT"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.interpreter.MAX_CODE_SIZE", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/interpreter.py"}, "content": {"type": ["attribute"], "name": ["MAX_CODE_SIZE"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.interpreter.MessageCallOutput", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/interpreter.py"}, "content": {"type": ["class"], "name": ["MessageCallOutput"], "text": ["Output of a particular message call Contains the following:   1. `gas_left`: remaining gas after execution.\n  2. `refund_counter`: gas to refund after execution.\n  3. `logs`: list of `Log` generated during execution.\n  4. `accounts_to_delete`: Contracts which have self-destructed.\n  5. `touched_accounts`: Accounts that have been touched.\n  6. `has_erred`: True if execution has caused an error.\n"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.interpreter.MessageCallOutput.gas_left", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/interpreter.py"}, "content": {"type": ["attribute"], "name": ["gas_left"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.interpreter.MessageCallOutput.refund_counter", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/interpreter.py"}, "content": {"type": ["attribute"], "name": ["refund_counter"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.interpreter.MessageCallOutput.logs", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/interpreter.py"}, "content": {"type": ["attribute"], "name": ["logs"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.interpreter.MessageCallOutput.accounts_to_delete", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/interpreter.py"}, "content": {"type": ["attribute"], "name": ["accounts_to_delete"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.interpreter.MessageCallOutput.touched_accounts", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/interpreter.py"}, "content": {"type": ["attribute"], "name": ["touched_accounts"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.interpreter.MessageCallOutput.has_erred", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/interpreter.py"}, "content": {"type": ["attribute"], "name": ["has_erred"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.interpreter.process_message_call", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/interpreter.py"}, "content": {"type": ["function"], "name": ["process_message_call"], "text": ["If  message.current  is empty then it creates a smart contract else it executes a call from the  message.caller  to the  message.target . Parameters message : Transaction specific items. env : External items required for EVM execution. Returns output :  MessageCallOutput Output of the message call"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.interpreter.process_create_message", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/interpreter.py"}, "content": {"type": ["function"], "name": ["process_create_message"], "text": ["Executes a call to create a smart contract. Parameters message : Transaction specific items. env : External items required for EVM execution. Returns evm: :py:class: ~ethereum.muir_glacier.vm.Evm Items containing execution specific objects."]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.interpreter.process_message", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/interpreter.py"}, "content": {"type": ["function"], "name": ["process_message"], "text": ["Executes a call to create a smart contract. Parameters message : Transaction specific items. env : External items required for EVM execution. Returns evm: :py:class: ~ethereum.muir_glacier.vm.Evm Items containing execution specific objects"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.interpreter.execute_code", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/interpreter.py"}, "content": {"type": ["function"], "name": ["execute_code"], "text": ["Executes bytecode present in the  message . Parameters message : Transaction specific items. env : External items required for EVM execution. Returns evm:  ethereum.vm.EVM Items containing execution specific objects"]}}, {"source": {"identifier": "ethereum.shanghai.vm.precompiled_contracts", "specifier": 0, "path": "src/ethereum/shanghai/vm/precompiled_contracts/__init__.py"}, "content": {"type": ["module"], "name": ["ethereum.shanghai.vm.precompiled_contracts"], "text": ["Precompiled Contract Addresses ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Addresses of precompiled contracts and mappings to their implementations."]}}, {"source": {"identifier": "ethereum.shanghai.vm.precompiled_contracts.__all__", "specifier": 0, "path": "src/ethereum/shanghai/vm/precompiled_contracts/__init__.py"}, "content": {"type": ["attribute"], "name": ["__all__"]}}, {"source": {"identifier": "ethereum.shanghai.vm.precompiled_contracts.ECRECOVER_ADDRESS", "specifier": 0, "path": "src/ethereum/shanghai/vm/precompiled_contracts/__init__.py"}, "content": {"type": ["attribute"], "name": ["ECRECOVER_ADDRESS"]}}, {"source": {"identifier": "ethereum.shanghai.vm.precompiled_contracts.SHA256_ADDRESS", "specifier": 0, "path": "src/ethereum/shanghai/vm/precompiled_contracts/__init__.py"}, "content": {"type": ["attribute"], "name": ["SHA256_ADDRESS"]}}, {"source": {"identifier": "ethereum.shanghai.vm.precompiled_contracts.RIPEMD160_ADDRESS", "specifier": 0, "path": "src/ethereum/shanghai/vm/precompiled_contracts/__init__.py"}, "content": {"type": ["attribute"], "name": ["RIPEMD160_ADDRESS"]}}, {"source": {"identifier": "ethereum.shanghai.vm.precompiled_contracts.IDENTITY_ADDRESS", "specifier": 0, "path": "src/ethereum/shanghai/vm/precompiled_contracts/__init__.py"}, "content": {"type": ["attribute"], "name": ["IDENTITY_ADDRESS"]}}, {"source": {"identifier": "ethereum.shanghai.vm.precompiled_contracts.MODEXP_ADDRESS", "specifier": 0, "path": "src/ethereum/shanghai/vm/precompiled_contracts/__init__.py"}, "content": {"type": ["attribute"], "name": ["MODEXP_ADDRESS"]}}, {"source": {"identifier": "ethereum.shanghai.vm.precompiled_contracts.ALT_BN128_ADD_ADDRESS", "specifier": 0, "path": "src/ethereum/shanghai/vm/precompiled_contracts/__init__.py"}, "content": {"type": ["attribute"], "name": ["ALT_BN128_ADD_ADDRESS"]}}, {"source": {"identifier": "ethereum.shanghai.vm.precompiled_contracts.ALT_BN128_MUL_ADDRESS", "specifier": 0, "path": "src/ethereum/shanghai/vm/precompiled_contracts/__init__.py"}, "content": {"type": ["attribute"], "name": ["ALT_BN128_MUL_ADDRESS"]}}, {"source": {"identifier": "ethereum.shanghai.vm.precompiled_contracts.ALT_BN128_PAIRING_CHECK_ADDRESS", "specifier": 0, "path": "src/ethereum/shanghai/vm/precompiled_contracts/__init__.py"}, "content": {"type": ["attribute"], "name": ["ALT_BN128_PAIRING_CHECK_ADDRESS"]}}, {"source": {"identifier": "ethereum.shanghai.vm.precompiled_contracts.BLAKE2F_ADDRESS", "specifier": 0, "path": "src/ethereum/shanghai/vm/precompiled_contracts/__init__.py"}, "content": {"type": ["attribute"], "name": ["BLAKE2F_ADDRESS"]}}, {"source": {"identifier": "ethereum_optimized.paris", "specifier": 0, "path": "src/ethereum_optimized/paris/__init__.py"}, "content": {"type": ["module"], "name": ["ethereum_optimized.paris"], "text": ["Optimized Implementations (London) ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local:"]}}, {"source": {"identifier": "ethereum_optimized.paris.monkey_patch_optimized_state_db", "specifier": 0, "path": "src/ethereum_optimized/paris/__init__.py"}, "content": {"type": ["function"], "name": ["monkey_patch_optimized_state_db"], "text": ["Replace the state interface with one that supports high performance updates and storing state in a database. This function must be called before the state interface is imported anywhere."]}}, {"source": {"identifier": "ethereum_optimized.paris.monkey_patch", "specifier": 0, "path": "src/ethereum_optimized/paris/__init__.py"}, "content": {"type": ["function"], "name": ["monkey_patch"], "text": ["Apply all monkey patches to swap in high performance implementations. This function must be called before any of the ethereum modules are imported anywhere."]}}, {"source": {"identifier": "ethereum.spurious_dragon.state", "specifier": 0, "path": "src/ethereum/spurious_dragon/state.py"}, "content": {"type": ["module"], "name": ["ethereum.spurious_dragon.state"], "text": ["State ^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction The state contains all information that is preserved between transactions. It consists of a main account trie and storage tries for each contract. There is a distinction between an account that does not exist and EMPTY_ACCOUNT ."]}}, {"source": {"identifier": "ethereum.spurious_dragon.state.State", "specifier": 0, "path": "src/ethereum/spurious_dragon/state.py"}, "content": {"type": ["class"], "name": ["State"], "text": ["Contains all information that is preserved between transactions."]}}, {"source": {"identifier": "ethereum.spurious_dragon.state.State._main_trie", "specifier": 0, "path": "src/ethereum/spurious_dragon/state.py"}, "content": {"type": ["attribute"], "name": ["_main_trie"]}}, {"source": {"identifier": "ethereum.spurious_dragon.state.State._storage_tries", "specifier": 0, "path": "src/ethereum/spurious_dragon/state.py"}, "content": {"type": ["attribute"], "name": ["_storage_tries"]}}, {"source": {"identifier": "ethereum.spurious_dragon.state.State._snapshots", "specifier": 0, "path": "src/ethereum/spurious_dragon/state.py"}, "content": {"type": ["attribute"], "name": ["_snapshots"]}}, {"source": {"identifier": "ethereum.spurious_dragon.state.close_state", "specifier": 0, "path": "src/ethereum/spurious_dragon/state.py"}, "content": {"type": ["function"], "name": ["close_state"], "text": ["Free resources held by the state. Used by optimized implementations to release file descriptors."]}}, {"source": {"identifier": "ethereum.spurious_dragon.state.begin_transaction", "specifier": 0, "path": "src/ethereum/spurious_dragon/state.py"}, "content": {"type": ["function"], "name": ["begin_transaction"], "text": ["Start a state transaction. Transactions are entirely implicit and can be nested. It is not possible to calculate the state root during a transaction. Parameters state : State The state."]}}, {"source": {"identifier": "ethereum.spurious_dragon.state.commit_transaction", "specifier": 0, "path": "src/ethereum/spurious_dragon/state.py"}, "content": {"type": ["function"], "name": ["commit_transaction"], "text": ["Commit a state transaction. Parameters state : State The state."]}}, {"source": {"identifier": "ethereum.spurious_dragon.state.rollback_transaction", "specifier": 0, "path": "src/ethereum/spurious_dragon/state.py"}, "content": {"type": ["function"], "name": ["rollback_transaction"], "text": ["Rollback a state transaction, resetting the state to the point when the corresponding  start_transaction()  call was made. Parameters state : State The state."]}}, {"source": {"identifier": "ethereum.spurious_dragon.state.get_account", "specifier": 0, "path": "src/ethereum/spurious_dragon/state.py"}, "content": {"type": ["function"], "name": ["get_account"], "text": ["Get the  Account  object at an address. Returns  EMPTY_ACCOUNT  if there is no account at the address. Use  get_account_optional()  if you care about the difference between a non-existent account and  EMPTY_ACCOUNT . Parameters state:  State The state address :  Address Address to lookup. Returns account :  Account Account at address."]}}, {"source": {"identifier": "ethereum.spurious_dragon.state.get_account_optional", "specifier": 0, "path": "src/ethereum/spurious_dragon/state.py"}, "content": {"type": ["function"], "name": ["get_account_optional"], "text": ["Get the  Account  object at an address. Returns  None  (rather than EMPTY_ACCOUNT ) if there is no account at the address. Parameters state:  State The state address :  Address Address to lookup. Returns account :  Account Account at address."]}}, {"source": {"identifier": "ethereum.spurious_dragon.state.set_account", "specifier": 0, "path": "src/ethereum/spurious_dragon/state.py"}, "content": {"type": ["function"], "name": ["set_account"], "text": ["Set the  Account  object at an address. Setting to  None  deletes the account (but not its storage, see  destroy_account() ). Parameters state:  State The state address :  Address Address to set. account :  Account Account to set at address."]}}, {"source": {"identifier": "ethereum.spurious_dragon.state.destroy_account", "specifier": 0, "path": "src/ethereum/spurious_dragon/state.py"}, "content": {"type": ["function"], "name": ["destroy_account"], "text": ["Completely remove the account at  address  and all of its storage. This function is made available exclusively for the  SELFDESTRUCT opcode. It is expected that  SELFDESTRUCT  will be disabled in a future hardfork and this function will be removed. Parameters state:  State The state address :  Address Address of account to destroy."]}}, {"source": {"identifier": "ethereum.spurious_dragon.state.destroy_storage", "specifier": 0, "path": "src/ethereum/spurious_dragon/state.py"}, "content": {"type": ["function"], "name": ["destroy_storage"], "text": ["Completely remove the storage at  address . Parameters state:  State The state address :  Address Address of account whose storage is to be deleted."]}}, {"source": {"identifier": "ethereum.spurious_dragon.state.get_storage", "specifier": 0, "path": "src/ethereum/spurious_dragon/state.py"}, "content": {"type": ["function"], "name": ["get_storage"], "text": ["Get a value at a storage key on an account. Returns  U256(0)  if the storage key has not been set previously. Parameters state:  State The state address :  Address Address of the account. key :  Bytes Key to lookup. Returns value :  U256 Value at the key."]}}, {"source": {"identifier": "ethereum.spurious_dragon.state.set_storage", "specifier": 0, "path": "src/ethereum/spurious_dragon/state.py"}, "content": {"type": ["function"], "name": ["set_storage"], "text": ["Set a value at a storage key on an account. Setting to  U256(0)  deletes the key. Parameters state:  State The state address :  Address Address of the account. key :  Bytes Key to set. value :  U256 Value to set at the key."]}}, {"source": {"identifier": "ethereum.spurious_dragon.state.storage_root", "specifier": 0, "path": "src/ethereum/spurious_dragon/state.py"}, "content": {"type": ["function"], "name": ["storage_root"], "text": ["Calculate the storage root of an account. Parameters state: The state address : Address of the account. Returns root :  Root Storage root of the account."]}}, {"source": {"identifier": "ethereum.spurious_dragon.state.state_root", "specifier": 0, "path": "src/ethereum/spurious_dragon/state.py"}, "content": {"type": ["function"], "name": ["state_root"], "text": ["Calculate the state root. Parameters state: The current state. Returns root :  Root The state root."]}}, {"source": {"identifier": "ethereum.spurious_dragon.state.account_exists", "specifier": 0, "path": "src/ethereum/spurious_dragon/state.py"}, "content": {"type": ["function"], "name": ["account_exists"], "text": ["Checks if an account exists in the state trie Parameters state: The state address: Address of the account that needs to be checked. Returns account_exists :  bool True if account exists in the state trie, False otherwise"]}}, {"source": {"identifier": "ethereum.spurious_dragon.state.account_has_code_or_nonce", "specifier": 0, "path": "src/ethereum/spurious_dragon/state.py"}, "content": {"type": ["function"], "name": ["account_has_code_or_nonce"], "text": ["Checks if an account has non zero nonce or non empty code Parameters state: The state address: Address of the account that needs to be checked. Returns has_code_or_nonce :  bool True if if an account has non zero nonce or non empty code, False otherwise."]}}, {"source": {"identifier": "ethereum.spurious_dragon.state.is_account_empty", "specifier": 0, "path": "src/ethereum/spurious_dragon/state.py"}, "content": {"type": ["function"], "name": ["is_account_empty"], "text": ["Checks if an account has zero nonce, empty code and zero balance. Parameters state: The state address: Address of the account that needs to be checked. Returns is_empty :  bool True if if an account has zero nonce, empty code and zero balance, False otherwise."]}}, {"source": {"identifier": "ethereum.spurious_dragon.state.account_exists_and_is_empty", "specifier": 0, "path": "src/ethereum/spurious_dragon/state.py"}, "content": {"type": ["function"], "name": ["account_exists_and_is_empty"], "text": ["Checks if an account exists and has zero nonce, empty code and zero balance. Parameters state: The state address: Address of the account that needs to be checked. Returns exists_and_is_empty :  bool True if an account exists and has zero nonce, empty code and zero balance, False otherwise."]}}, {"source": {"identifier": "ethereum.spurious_dragon.state.is_account_alive", "specifier": 0, "path": "src/ethereum/spurious_dragon/state.py"}, "content": {"type": ["function"], "name": ["is_account_alive"], "text": ["Check whether is an account is both in the state and non empty. Parameters state: The state address: Address of the account that needs to be checked. Returns is_alive :  bool True if the account is alive."]}}, {"source": {"identifier": "ethereum.spurious_dragon.state.modify_state", "specifier": 0, "path": "src/ethereum/spurious_dragon/state.py"}, "content": {"type": ["function"], "name": ["modify_state"], "text": ["Modify an  Account  in the  State ."]}}, {"source": {"identifier": "ethereum.spurious_dragon.state.move_ether", "specifier": 0, "path": "src/ethereum/spurious_dragon/state.py"}, "content": {"type": ["function"], "name": ["move_ether"], "text": ["Move funds between accounts."]}}, {"source": {"identifier": "ethereum.spurious_dragon.state.set_account_balance", "specifier": 0, "path": "src/ethereum/spurious_dragon/state.py"}, "content": {"type": ["function"], "name": ["set_account_balance"], "text": ["Sets the balance of an account. Parameters state: The current state. address: Address of the account whose nonce needs to be incremented. amount: The amount that needs to set in balance."]}}, {"source": {"identifier": "ethereum.spurious_dragon.state.touch_account", "specifier": 0, "path": "src/ethereum/spurious_dragon/state.py"}, "content": {"type": ["function"], "name": ["touch_account"], "text": ["Initializes an account to state. Parameters state: The current state. address: The address of the account that need to initialised."]}}, {"source": {"identifier": "ethereum.spurious_dragon.state.increment_nonce", "specifier": 0, "path": "src/ethereum/spurious_dragon/state.py"}, "content": {"type": ["function"], "name": ["increment_nonce"], "text": ["Increments the nonce of an account. Parameters state: The current state. address: Address of the account whose nonce needs to be incremented."]}}, {"source": {"identifier": "ethereum.spurious_dragon.state.set_code", "specifier": 0, "path": "src/ethereum/spurious_dragon/state.py"}, "content": {"type": ["function"], "name": ["set_code"], "text": ["Sets Account code. Parameters state: The current state. address: Address of the account whose code needs to be update. code: The bytecode that needs to be set."]}}, {"source": {"identifier": "ethereum.spurious_dragon.state.create_ether", "specifier": 0, "path": "src/ethereum/spurious_dragon/state.py"}, "content": {"type": ["function"], "name": ["create_ether"], "text": ["Add newly created ether to an account. Parameters state: The current state. address: Address of the account to which ether is added. amount: The amount of ether to be added to the account of interest."]}}, {"source": {"identifier": "ethereum.dao_fork.utils.message", "specifier": 0, "path": "src/ethereum/dao_fork/utils/message.py"}, "content": {"type": ["module"], "name": ["ethereum.dao_fork.utils.message"], "text": ["Hardfork Utility Functions For The Message Data-structure ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Message specific functions used in this Dao Fork version of specification."]}}, {"source": {"identifier": "ethereum.dao_fork.utils.message.prepare_message", "specifier": 0, "path": "src/ethereum/dao_fork/utils/message.py"}, "content": {"type": ["function"], "name": ["prepare_message"], "text": ["Execute a transaction against the provided environment. Parameters caller : Address which initiated the transaction target : Address whose code will be executed value : Value to be transferred. data : Array of bytes provided to the code in  target . gas : Gas provided for the code in  target . env : Environment for the Ethereum Virtual Machine. code_address : This is usually same as the  target  address except when an alternative accounts code needs to be executed. eg.  CALLCODE  calling a precompile. should_transfer_value : if True ETH should be transferred while executing a message call. Returns message:  ethereum.dao_fork.vm.Message Items containing contract creation or message call specific data."]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.stack", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/stack.py"}, "content": {"type": ["module"], "name": ["ethereum.muir_glacier.vm.stack"], "text": ["Ethereum Virtual Machine (EVM) Stack ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementation of the stack operators for the EVM."]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.stack.pop", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/stack.py"}, "content": {"type": ["function"], "name": ["pop"], "text": ["Pops the top item off of  stack . Parameters stack : EVM stack. Returns value :  U256 The top element on the stack."]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.stack.push", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/stack.py"}, "content": {"type": ["function"], "name": ["push"], "text": ["Pushes  value  onto  stack . Parameters stack : EVM stack. value : Item to be pushed onto  stack ."]}}, {"source": {"identifier": "ethereum.spurious_dragon", "specifier": 0, "path": "src/ethereum/spurious_dragon/__init__.py"}, "content": {"type": ["module"], "name": ["ethereum.spurious_dragon"], "text": ["Ethereum Spurious Dragon Hardfork ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ The fifth Ethereum hardfork."]}}, {"source": {"identifier": "ethereum.spurious_dragon.MAINNET_FORK_BLOCK", "specifier": 0, "path": "src/ethereum/spurious_dragon/__init__.py"}, "content": {"type": ["attribute"], "name": ["MAINNET_FORK_BLOCK"]}}, {"source": {"identifier": "ethereum.shanghai.vm.precompiled_contracts.alt_bn128", "specifier": 0, "path": "src/ethereum/shanghai/vm/precompiled_contracts/alt_bn128.py"}, "content": {"type": ["module"], "name": ["ethereum.shanghai.vm.precompiled_contracts.alt_bn128"], "text": ["Ethereum Virtual Machine (EVM) ALT_BN128 CONTRACTS ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementation of the ALT_BN128 precompiled contracts."]}}, {"source": {"identifier": "ethereum.shanghai.vm.precompiled_contracts.alt_bn128.alt_bn128_add", "specifier": 0, "path": "src/ethereum/shanghai/vm/precompiled_contracts/alt_bn128.py"}, "content": {"type": ["function"], "name": ["alt_bn128_add"], "text": ["The ALT_BN128 addition precompiled contract. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.shanghai.vm.precompiled_contracts.alt_bn128.alt_bn128_mul", "specifier": 0, "path": "src/ethereum/shanghai/vm/precompiled_contracts/alt_bn128.py"}, "content": {"type": ["function"], "name": ["alt_bn128_mul"], "text": ["The ALT_BN128 multiplication precompiled contract. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.shanghai.vm.precompiled_contracts.alt_bn128.alt_bn128_pairing_check", "specifier": 0, "path": "src/ethereum/shanghai/vm/precompiled_contracts/alt_bn128.py"}, "content": {"type": ["function"], "name": ["alt_bn128_pairing_check"], "text": ["The ALT_BN128 pairing check precompiled contract. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum_optimized.byzantium", "specifier": 0, "path": "src/ethereum_optimized/byzantium/__init__.py"}, "content": {"type": ["module"], "name": ["ethereum_optimized.byzantium"], "text": ["Optimized Implementations (Byzantium) ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local:"]}}, {"source": {"identifier": "ethereum_optimized.byzantium.monkey_patch_optimized_state_db", "specifier": 0, "path": "src/ethereum_optimized/byzantium/__init__.py"}, "content": {"type": ["function"], "name": ["monkey_patch_optimized_state_db"], "text": ["Replace the state interface with one that supports high performance updates and storing state in a database. This function must be called before the state interface is imported anywhere."]}}, {"source": {"identifier": "ethereum_optimized.byzantium.monkey_patch_optimized_spec", "specifier": 0, "path": "src/ethereum_optimized/byzantium/__init__.py"}, "content": {"type": ["function"], "name": ["monkey_patch_optimized_spec"], "text": ["Replace the ethash implementation with one that supports higher performance. This function must be called before the spec interface is imported anywhere."]}}, {"source": {"identifier": "ethereum_optimized.byzantium.monkey_patch", "specifier": 0, "path": "src/ethereum_optimized/byzantium/__init__.py"}, "content": {"type": ["function"], "name": ["monkey_patch"], "text": ["Apply all monkey patches to swap in high performance implementations. This function must be called before any of the ethereum modules are imported anywhere."]}}, {"source": {"identifier": "ethereum.dao_fork.utils.hexadecimal", "specifier": 0, "path": "src/ethereum/dao_fork/utils/hexadecimal.py"}, "content": {"type": ["module"], "name": ["ethereum.dao_fork.utils.hexadecimal"], "text": ["Utility Functions For Hexadecimal Strings ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Hexadecimal utility functions used in this specification, specific to Dao Fork types."]}}, {"source": {"identifier": "ethereum.dao_fork.utils.hexadecimal.hex_to_root", "specifier": 0, "path": "src/ethereum/dao_fork/utils/hexadecimal.py"}, "content": {"type": ["function"], "name": ["hex_to_root"], "text": ["Convert hex string to trie root. Parameters hex_string : The hexadecimal string to be converted to trie root. Returns root :  Root Trie root obtained from the given hexadecimal string."]}}, {"source": {"identifier": "ethereum.dao_fork.utils.hexadecimal.hex_to_bloom", "specifier": 0, "path": "src/ethereum/dao_fork/utils/hexadecimal.py"}, "content": {"type": ["function"], "name": ["hex_to_bloom"], "text": ["Convert hex string to bloom. Parameters hex_string : The hexadecimal string to be converted to bloom. Returns bloom :  Bloom Bloom obtained from the given hexadecimal string."]}}, {"source": {"identifier": "ethereum.dao_fork.utils.hexadecimal.hex_to_address", "specifier": 0, "path": "src/ethereum/dao_fork/utils/hexadecimal.py"}, "content": {"type": ["function"], "name": ["hex_to_address"], "text": ["Convert hex string to Address (20 bytes). Parameters hex_string : The hexadecimal string to be converted to Address. Returns address :  Address The address obtained from the given hexadecimal string."]}}, {"source": {"identifier": "ethereum.spurious_dragon.bloom", "specifier": 0, "path": "src/ethereum/spurious_dragon/bloom.py"}, "content": {"type": ["module"], "name": ["ethereum.spurious_dragon.bloom"], "text": ["Ethereum Logs Bloom ^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction This modules defines functions for calculating bloom filters of logs. For the general theory of bloom filters see e.g.  Wikipedia <https://en.wikipedia.org/wiki/Bloom_filter> _. Bloom filters are used to allow for efficient searching of logs by address and/or topic, by rapidly eliminating blocks and reciepts from their search."]}}, {"source": {"identifier": "ethereum.spurious_dragon.bloom.add_to_bloom", "specifier": 0, "path": "src/ethereum/spurious_dragon/bloom.py"}, "content": {"type": ["function"], "name": ["add_to_bloom"], "text": ["Add a bloom entry to the bloom filter ( bloom ). The number of hash functions used is 3. They are calculated by taking the least significant 11 bits from the first 3 16-bit words of the keccak_256()  hash of  bloom_entry . Parameters bloom : The bloom filter. bloom_entry : An entry which is to be added to bloom filter."]}}, {"source": {"identifier": "ethereum.spurious_dragon.bloom.logs_bloom", "specifier": 0, "path": "src/ethereum/spurious_dragon/bloom.py"}, "content": {"type": ["function"], "name": ["logs_bloom"], "text": ["Obtain the logs bloom from a list of log entries. The address and each topic of a log are added to the bloom filter. Parameters logs : List of logs for which the logs bloom is to be obtained. Returns logs_bloom :  Bloom The logs bloom obtained which is 256 bytes with some bits set as per the caller address and the log topics."]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.gas", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/gas.py"}, "content": {"type": ["module"], "name": ["ethereum.muir_glacier.vm.gas"], "text": ["Ethereum Virtual Machine (EVM) Gas ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction EVM gas constants and calculators."]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.gas.GAS_JUMPDEST", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_JUMPDEST"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.gas.GAS_BASE", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_BASE"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.gas.GAS_VERY_LOW", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_VERY_LOW"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.gas.GAS_SLOAD", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_SLOAD"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.gas.GAS_STORAGE_SET", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_STORAGE_SET"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.gas.GAS_STORAGE_UPDATE", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_STORAGE_UPDATE"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.gas.GAS_STORAGE_CLEAR_REFUND", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_STORAGE_CLEAR_REFUND"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.gas.GAS_LOW", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_LOW"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.gas.GAS_MID", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_MID"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.gas.GAS_HIGH", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_HIGH"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.gas.GAS_EXPONENTIATION", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_EXPONENTIATION"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.gas.GAS_EXPONENTIATION_PER_BYTE", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_EXPONENTIATION_PER_BYTE"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.gas.GAS_MEMORY", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_MEMORY"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.gas.GAS_KECCAK256", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_KECCAK256"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.gas.GAS_KECCAK256_WORD", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_KECCAK256_WORD"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.gas.GAS_COPY", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_COPY"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.gas.GAS_BLOCK_HASH", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_BLOCK_HASH"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.gas.GAS_EXTERNAL", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_EXTERNAL"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.gas.GAS_BALANCE", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_BALANCE"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.gas.GAS_LOG", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_LOG"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.gas.GAS_LOG_DATA", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_LOG_DATA"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.gas.GAS_LOG_TOPIC", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_LOG_TOPIC"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.gas.GAS_CREATE", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_CREATE"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.gas.GAS_CODE_DEPOSIT", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_CODE_DEPOSIT"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.gas.GAS_ZERO", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_ZERO"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.gas.GAS_CALL", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_CALL"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.gas.GAS_NEW_ACCOUNT", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_NEW_ACCOUNT"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.gas.GAS_CALL_VALUE", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_CALL_VALUE"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.gas.GAS_CALL_STIPEND", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_CALL_STIPEND"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.gas.GAS_SELF_DESTRUCT", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_SELF_DESTRUCT"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.gas.GAS_SELF_DESTRUCT_NEW_ACCOUNT", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_SELF_DESTRUCT_NEW_ACCOUNT"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.gas.REFUND_SELF_DESTRUCT", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["REFUND_SELF_DESTRUCT"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.gas.GAS_ECRECOVER", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_ECRECOVER"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.gas.GAS_SHA256", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_SHA256"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.gas.GAS_SHA256_WORD", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_SHA256_WORD"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.gas.GAS_RIPEMD160", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_RIPEMD160"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.gas.GAS_RIPEMD160_WORD", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_RIPEMD160_WORD"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.gas.GAS_IDENTITY", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_IDENTITY"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.gas.GAS_IDENTITY_WORD", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_IDENTITY_WORD"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.gas.GAS_RETURN_DATA_COPY", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_RETURN_DATA_COPY"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.gas.GAS_CODE_HASH", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_CODE_HASH"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.gas.GAS_FAST_STEP", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_FAST_STEP"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.gas.GAS_BLAKE2_PER_ROUND", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_BLAKE2_PER_ROUND"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.gas.ExtendMemory", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/gas.py"}, "content": {"type": ["class"], "name": ["ExtendMemory"], "text": ["Define the parameters for memory extension in opcodes cost :  ethereum.base_types.Uint The gas required to perform the extension expand_by :  ethereum.base_types.Uint The size by which the memory will be extended"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.gas.ExtendMemory.cost", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["cost"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.gas.ExtendMemory.expand_by", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["expand_by"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.gas.MessageCallGas", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/gas.py"}, "content": {"type": ["class"], "name": ["MessageCallGas"], "text": ["Define the gas cost and stipend for executing the call opcodes. cost :  ethereum.base_types.Uint The non-refundable portion of gas reserved for executing the call opcode. stipend :  ethereum.base_types.Uint The portion of gas available to sub-calls that is refundable if not consumed"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.gas.MessageCallGas.cost", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["cost"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.gas.MessageCallGas.stipend", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["stipend"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.gas.charge_gas", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/gas.py"}, "content": {"type": ["function"], "name": ["charge_gas"], "text": ["Subtracts  amount  from  evm.gas_left . Parameters evm : The current EVM. amount : The amount of gas the current operation requires."]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.gas.calculate_memory_gas_cost", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/gas.py"}, "content": {"type": ["function"], "name": ["calculate_memory_gas_cost"], "text": ["Calculates the gas cost for allocating memory to the smallest multiple of 32 bytes, such that the allocated size is at least as big as the given size. Parameters size_in_bytes : The size of the data in bytes. Returns total_gas_cost :  ethereum.base_types.Uint The gas cost for storing data in memory."]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.gas.calculate_gas_extend_memory", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/gas.py"}, "content": {"type": ["function"], "name": ["calculate_gas_extend_memory"], "text": ["Calculates the gas amount to extend memory Parameters memory : Memory contents of the EVM. extensions: List of extensions to be made to the memory. Consists of a tuple of start position and size. Returns extend_memory:  ExtendMemory"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.gas.calculate_message_call_gas", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/gas.py"}, "content": {"type": ["function"], "name": ["calculate_message_call_gas"], "text": ["Calculates the MessageCallGas (cost and stipend) for executing call Opcodes. Parameters value: The amount of  ETH  that needs to be transferred. gas : The amount of gas provided to the message-call. gas_left : The amount of gas left in the current frame. memory_cost : The amount needed to extend the memory in the current frame. extra_gas : The amount of gas needed for transferring value + creating a new account inside a message call. call_stipend : The amount of stipend provided to a message call to execute code while transferring value(ETH). Returns message_call_gas:  MessageCallGas"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.gas.max_message_call_gas", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/gas.py"}, "content": {"type": ["function"], "name": ["max_message_call_gas"], "text": ["Calculates the maximum gas that is allowed for making a message call Parameters gas : The amount of gas provided to the message-call. Returns max_allowed_message_call_gas:  ethereum.base_types.Uint The maximum gas allowed for making the message-call."]}}, {"source": {"identifier": "ethereum_optimized.london", "specifier": 0, "path": "src/ethereum_optimized/london/__init__.py"}, "content": {"type": ["module"], "name": ["ethereum_optimized.london"], "text": ["Optimized Implementations (London) ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local:"]}}, {"source": {"identifier": "ethereum_optimized.london.monkey_patch_optimized_state_db", "specifier": 0, "path": "src/ethereum_optimized/london/__init__.py"}, "content": {"type": ["function"], "name": ["monkey_patch_optimized_state_db"], "text": ["Replace the state interface with one that supports high performance updates and storing state in a database. This function must be called before the state interface is imported anywhere."]}}, {"source": {"identifier": "ethereum_optimized.london.monkey_patch_optimized_spec", "specifier": 0, "path": "src/ethereum_optimized/london/__init__.py"}, "content": {"type": ["function"], "name": ["monkey_patch_optimized_spec"], "text": ["Replace the ethash implementation with one that supports higher performance. This function must be called before the spec interface is imported anywhere."]}}, {"source": {"identifier": "ethereum_optimized.london.monkey_patch", "specifier": 0, "path": "src/ethereum_optimized/london/__init__.py"}, "content": {"type": ["function"], "name": ["monkey_patch"], "text": ["Apply all monkey patches to swap in high performance implementations. This function must be called before any of the ethereum modules are imported anywhere."]}}, {"source": {"identifier": "ethereum.shanghai.vm.precompiled_contracts.ripemd160", "specifier": 0, "path": "src/ethereum/shanghai/vm/precompiled_contracts/ripemd160.py"}, "content": {"type": ["module"], "name": ["ethereum.shanghai.vm.precompiled_contracts.ripemd160"], "text": ["Ethereum Virtual Machine (EVM) RIPEMD160 PRECOMPILED CONTRACT ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementation of the  RIPEMD160  precompiled contract."]}}, {"source": {"identifier": "ethereum.shanghai.vm.precompiled_contracts.ripemd160.ripemd160", "specifier": 0, "path": "src/ethereum/shanghai/vm/precompiled_contracts/ripemd160.py"}, "content": {"type": ["function"], "name": ["ripemd160"], "text": ["Writes the ripemd160 hash to output. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.byzantium.state", "specifier": 0, "path": "src/ethereum/byzantium/state.py"}, "content": {"type": ["module"], "name": ["ethereum.byzantium.state"], "text": ["State ^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction The state contains all information that is preserved between transactions. It consists of a main account trie and storage tries for each contract. There is a distinction between an account that does not exist and EMPTY_ACCOUNT ."]}}, {"source": {"identifier": "ethereum.byzantium.state.State", "specifier": 0, "path": "src/ethereum/byzantium/state.py"}, "content": {"type": ["class"], "name": ["State"], "text": ["Contains all information that is preserved between transactions."]}}, {"source": {"identifier": "ethereum.byzantium.state.State._main_trie", "specifier": 0, "path": "src/ethereum/byzantium/state.py"}, "content": {"type": ["attribute"], "name": ["_main_trie"]}}, {"source": {"identifier": "ethereum.byzantium.state.State._storage_tries", "specifier": 0, "path": "src/ethereum/byzantium/state.py"}, "content": {"type": ["attribute"], "name": ["_storage_tries"]}}, {"source": {"identifier": "ethereum.byzantium.state.State._snapshots", "specifier": 0, "path": "src/ethereum/byzantium/state.py"}, "content": {"type": ["attribute"], "name": ["_snapshots"]}}, {"source": {"identifier": "ethereum.byzantium.state.close_state", "specifier": 0, "path": "src/ethereum/byzantium/state.py"}, "content": {"type": ["function"], "name": ["close_state"], "text": ["Free resources held by the state. Used by optimized implementations to release file descriptors."]}}, {"source": {"identifier": "ethereum.byzantium.state.begin_transaction", "specifier": 0, "path": "src/ethereum/byzantium/state.py"}, "content": {"type": ["function"], "name": ["begin_transaction"], "text": ["Start a state transaction. Transactions are entirely implicit and can be nested. It is not possible to calculate the state root during a transaction. Parameters state : State The state."]}}, {"source": {"identifier": "ethereum.byzantium.state.commit_transaction", "specifier": 0, "path": "src/ethereum/byzantium/state.py"}, "content": {"type": ["function"], "name": ["commit_transaction"], "text": ["Commit a state transaction. Parameters state : State The state."]}}, {"source": {"identifier": "ethereum.byzantium.state.rollback_transaction", "specifier": 0, "path": "src/ethereum/byzantium/state.py"}, "content": {"type": ["function"], "name": ["rollback_transaction"], "text": ["Rollback a state transaction, resetting the state to the point when the corresponding  start_transaction()  call was made. Parameters state : State The state."]}}, {"source": {"identifier": "ethereum.byzantium.state.get_account", "specifier": 0, "path": "src/ethereum/byzantium/state.py"}, "content": {"type": ["function"], "name": ["get_account"], "text": ["Get the  Account  object at an address. Returns  EMPTY_ACCOUNT  if there is no account at the address. Use  get_account_optional()  if you care about the difference between a non-existent account and  EMPTY_ACCOUNT . Parameters state:  State The state address :  Address Address to lookup. Returns account :  Account Account at address."]}}, {"source": {"identifier": "ethereum.byzantium.state.get_account_optional", "specifier": 0, "path": "src/ethereum/byzantium/state.py"}, "content": {"type": ["function"], "name": ["get_account_optional"], "text": ["Get the  Account  object at an address. Returns  None  (rather than EMPTY_ACCOUNT ) if there is no account at the address. Parameters state:  State The state address :  Address Address to lookup. Returns account :  Account Account at address."]}}, {"source": {"identifier": "ethereum.byzantium.state.set_account", "specifier": 0, "path": "src/ethereum/byzantium/state.py"}, "content": {"type": ["function"], "name": ["set_account"], "text": ["Set the  Account  object at an address. Setting to  None  deletes the account (but not its storage, see  destroy_account() ). Parameters state:  State The state address :  Address Address to set. account :  Account Account to set at address."]}}, {"source": {"identifier": "ethereum.byzantium.state.destroy_account", "specifier": 0, "path": "src/ethereum/byzantium/state.py"}, "content": {"type": ["function"], "name": ["destroy_account"], "text": ["Completely remove the account at  address  and all of its storage. This function is made available exclusively for the  SELFDESTRUCT opcode. It is expected that  SELFDESTRUCT  will be disabled in a future hardfork and this function will be removed. Parameters state:  State The state address :  Address Address of account to destroy."]}}, {"source": {"identifier": "ethereum.byzantium.state.destroy_storage", "specifier": 0, "path": "src/ethereum/byzantium/state.py"}, "content": {"type": ["function"], "name": ["destroy_storage"], "text": ["Completely remove the storage at  address . Parameters state:  State The state address :  Address Address of account whose storage is to be deleted."]}}, {"source": {"identifier": "ethereum.byzantium.state.get_storage", "specifier": 0, "path": "src/ethereum/byzantium/state.py"}, "content": {"type": ["function"], "name": ["get_storage"], "text": ["Get a value at a storage key on an account. Returns  U256(0)  if the storage key has not been set previously. Parameters state:  State The state address :  Address Address of the account. key :  Bytes Key to lookup. Returns value :  U256 Value at the key."]}}, {"source": {"identifier": "ethereum.byzantium.state.set_storage", "specifier": 0, "path": "src/ethereum/byzantium/state.py"}, "content": {"type": ["function"], "name": ["set_storage"], "text": ["Set a value at a storage key on an account. Setting to  U256(0)  deletes the key. Parameters state:  State The state address :  Address Address of the account. key :  Bytes Key to set. value :  U256 Value to set at the key."]}}, {"source": {"identifier": "ethereum.byzantium.state.storage_root", "specifier": 0, "path": "src/ethereum/byzantium/state.py"}, "content": {"type": ["function"], "name": ["storage_root"], "text": ["Calculate the storage root of an account. Parameters state: The state address : Address of the account. Returns root :  Root Storage root of the account."]}}, {"source": {"identifier": "ethereum.byzantium.state.state_root", "specifier": 0, "path": "src/ethereum/byzantium/state.py"}, "content": {"type": ["function"], "name": ["state_root"], "text": ["Calculate the state root. Parameters state: The current state. Returns root :  Root The state root."]}}, {"source": {"identifier": "ethereum.byzantium.state.account_exists", "specifier": 0, "path": "src/ethereum/byzantium/state.py"}, "content": {"type": ["function"], "name": ["account_exists"], "text": ["Checks if an account exists in the state trie Parameters state: The state address: Address of the account that needs to be checked. Returns account_exists :  bool True if account exists in the state trie, False otherwise"]}}, {"source": {"identifier": "ethereum.byzantium.state.account_has_code_or_nonce", "specifier": 0, "path": "src/ethereum/byzantium/state.py"}, "content": {"type": ["function"], "name": ["account_has_code_or_nonce"], "text": ["Checks if an account has non zero nonce or non empty code Parameters state: The state address: Address of the account that needs to be checked. Returns has_code_or_nonce :  bool True if if an account has non zero nonce or non empty code, False otherwise."]}}, {"source": {"identifier": "ethereum.byzantium.state.is_account_empty", "specifier": 0, "path": "src/ethereum/byzantium/state.py"}, "content": {"type": ["function"], "name": ["is_account_empty"], "text": ["Checks if an account has zero nonce, empty code and zero balance. Parameters state: The state address: Address of the account that needs to be checked. Returns is_empty :  bool True if if an account has zero nonce, empty code and zero balance, False otherwise."]}}, {"source": {"identifier": "ethereum.byzantium.state.account_exists_and_is_empty", "specifier": 0, "path": "src/ethereum/byzantium/state.py"}, "content": {"type": ["function"], "name": ["account_exists_and_is_empty"], "text": ["Checks if an account exists and has zero nonce, empty code and zero balance. Parameters state: The state address: Address of the account that needs to be checked. Returns exists_and_is_empty :  bool True if an account exists and has zero nonce, empty code and zero balance, False otherwise."]}}, {"source": {"identifier": "ethereum.byzantium.state.is_account_alive", "specifier": 0, "path": "src/ethereum/byzantium/state.py"}, "content": {"type": ["function"], "name": ["is_account_alive"], "text": ["Check whether is an account is both in the state and non empty. Parameters state: The state address: Address of the account that needs to be checked. Returns is_alive :  bool True if the account is alive."]}}, {"source": {"identifier": "ethereum.byzantium.state.modify_state", "specifier": 0, "path": "src/ethereum/byzantium/state.py"}, "content": {"type": ["function"], "name": ["modify_state"], "text": ["Modify an  Account  in the  State ."]}}, {"source": {"identifier": "ethereum.byzantium.state.move_ether", "specifier": 0, "path": "src/ethereum/byzantium/state.py"}, "content": {"type": ["function"], "name": ["move_ether"], "text": ["Move funds between accounts."]}}, {"source": {"identifier": "ethereum.byzantium.state.set_account_balance", "specifier": 0, "path": "src/ethereum/byzantium/state.py"}, "content": {"type": ["function"], "name": ["set_account_balance"], "text": ["Sets the balance of an account. Parameters state: The current state. address: Address of the account whose nonce needs to be incremented. amount: The amount that needs to set in balance."]}}, {"source": {"identifier": "ethereum.byzantium.state.touch_account", "specifier": 0, "path": "src/ethereum/byzantium/state.py"}, "content": {"type": ["function"], "name": ["touch_account"], "text": ["Initializes an account to state. Parameters state: The current state. address: The address of the account that need to initialised."]}}, {"source": {"identifier": "ethereum.byzantium.state.increment_nonce", "specifier": 0, "path": "src/ethereum/byzantium/state.py"}, "content": {"type": ["function"], "name": ["increment_nonce"], "text": ["Increments the nonce of an account. Parameters state: The current state. address: Address of the account whose nonce needs to be incremented."]}}, {"source": {"identifier": "ethereum.byzantium.state.set_code", "specifier": 0, "path": "src/ethereum/byzantium/state.py"}, "content": {"type": ["function"], "name": ["set_code"], "text": ["Sets Account code. Parameters state: The current state. address: Address of the account whose code needs to be update. code: The bytecode that needs to be set."]}}, {"source": {"identifier": "ethereum.byzantium.state.create_ether", "specifier": 0, "path": "src/ethereum/byzantium/state.py"}, "content": {"type": ["function"], "name": ["create_ether"], "text": ["Add newly created ether to an account. Parameters state: The current state. address: Address of the account to which ether is added. amount: The amount of ether to be added to the account of interest."]}}, {"source": {"identifier": "ethereum.spurious_dragon.fork_types", "specifier": 0, "path": "src/ethereum/spurious_dragon/fork_types.py"}, "content": {"type": ["module"], "name": ["ethereum.spurious_dragon.fork_types"], "text": ["Ethereum Types ^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Types re-used throughout the specification, which are specific to Ethereum."]}}, {"source": {"identifier": "ethereum.spurious_dragon.fork_types.Address", "specifier": 0, "path": "src/ethereum/spurious_dragon/fork_types.py"}, "content": {"type": ["attribute"], "name": ["Address"]}}, {"source": {"identifier": "ethereum.spurious_dragon.fork_types.Root", "specifier": 0, "path": "src/ethereum/spurious_dragon/fork_types.py"}, "content": {"type": ["attribute"], "name": ["Root"]}}, {"source": {"identifier": "ethereum.spurious_dragon.fork_types.Bloom", "specifier": 0, "path": "src/ethereum/spurious_dragon/fork_types.py"}, "content": {"type": ["attribute"], "name": ["Bloom"]}}, {"source": {"identifier": "ethereum.spurious_dragon.fork_types.TX_BASE_COST", "specifier": 0, "path": "src/ethereum/spurious_dragon/fork_types.py"}, "content": {"type": ["attribute"], "name": ["TX_BASE_COST"]}}, {"source": {"identifier": "ethereum.spurious_dragon.fork_types.TX_DATA_COST_PER_NON_ZERO", "specifier": 0, "path": "src/ethereum/spurious_dragon/fork_types.py"}, "content": {"type": ["attribute"], "name": ["TX_DATA_COST_PER_NON_ZERO"]}}, {"source": {"identifier": "ethereum.spurious_dragon.fork_types.TX_DATA_COST_PER_ZERO", "specifier": 0, "path": "src/ethereum/spurious_dragon/fork_types.py"}, "content": {"type": ["attribute"], "name": ["TX_DATA_COST_PER_ZERO"]}}, {"source": {"identifier": "ethereum.spurious_dragon.fork_types.TX_CREATE_COST", "specifier": 0, "path": "src/ethereum/spurious_dragon/fork_types.py"}, "content": {"type": ["attribute"], "name": ["TX_CREATE_COST"]}}, {"source": {"identifier": "ethereum.spurious_dragon.fork_types.Transaction", "specifier": 0, "path": "src/ethereum/spurious_dragon/fork_types.py"}, "content": {"type": ["class"], "name": ["Transaction"], "text": ["Atomic operation performed on the block chain."]}}, {"source": {"identifier": "ethereum.spurious_dragon.fork_types.Transaction.nonce", "specifier": 0, "path": "src/ethereum/spurious_dragon/fork_types.py"}, "content": {"type": ["attribute"], "name": ["nonce"]}}, {"source": {"identifier": "ethereum.spurious_dragon.fork_types.Transaction.gas_price", "specifier": 0, "path": "src/ethereum/spurious_dragon/fork_types.py"}, "content": {"type": ["attribute"], "name": ["gas_price"]}}, {"source": {"identifier": "ethereum.spurious_dragon.fork_types.Transaction.gas", "specifier": 0, "path": "src/ethereum/spurious_dragon/fork_types.py"}, "content": {"type": ["attribute"], "name": ["gas"]}}, {"source": {"identifier": "ethereum.spurious_dragon.fork_types.Transaction.to", "specifier": 0, "path": "src/ethereum/spurious_dragon/fork_types.py"}, "content": {"type": ["attribute"], "name": ["to"]}}, {"source": {"identifier": "ethereum.spurious_dragon.fork_types.Transaction.value", "specifier": 0, "path": "src/ethereum/spurious_dragon/fork_types.py"}, "content": {"type": ["attribute"], "name": ["value"]}}, {"source": {"identifier": "ethereum.spurious_dragon.fork_types.Transaction.data", "specifier": 0, "path": "src/ethereum/spurious_dragon/fork_types.py"}, "content": {"type": ["attribute"], "name": ["data"]}}, {"source": {"identifier": "ethereum.spurious_dragon.fork_types.Transaction.v", "specifier": 0, "path": "src/ethereum/spurious_dragon/fork_types.py"}, "content": {"type": ["attribute"], "name": ["v"]}}, {"source": {"identifier": "ethereum.spurious_dragon.fork_types.Transaction.r", "specifier": 0, "path": "src/ethereum/spurious_dragon/fork_types.py"}, "content": {"type": ["attribute"], "name": ["r"]}}, {"source": {"identifier": "ethereum.spurious_dragon.fork_types.Transaction.s", "specifier": 0, "path": "src/ethereum/spurious_dragon/fork_types.py"}, "content": {"type": ["attribute"], "name": ["s"]}}, {"source": {"identifier": "ethereum.spurious_dragon.fork_types.Account", "specifier": 0, "path": "src/ethereum/spurious_dragon/fork_types.py"}, "content": {"type": ["class"], "name": ["Account"], "text": ["State associated with an address."]}}, {"source": {"identifier": "ethereum.spurious_dragon.fork_types.Account.nonce", "specifier": 0, "path": "src/ethereum/spurious_dragon/fork_types.py"}, "content": {"type": ["attribute"], "name": ["nonce"]}}, {"source": {"identifier": "ethereum.spurious_dragon.fork_types.Account.balance", "specifier": 0, "path": "src/ethereum/spurious_dragon/fork_types.py"}, "content": {"type": ["attribute"], "name": ["balance"]}}, {"source": {"identifier": "ethereum.spurious_dragon.fork_types.Account.code", "specifier": 0, "path": "src/ethereum/spurious_dragon/fork_types.py"}, "content": {"type": ["attribute"], "name": ["code"]}}, {"source": {"identifier": "ethereum.spurious_dragon.fork_types.EMPTY_ACCOUNT", "specifier": 0, "path": "src/ethereum/spurious_dragon/fork_types.py"}, "content": {"type": ["attribute"], "name": ["EMPTY_ACCOUNT"]}}, {"source": {"identifier": "ethereum.spurious_dragon.fork_types.encode_account", "specifier": 0, "path": "src/ethereum/spurious_dragon/fork_types.py"}, "content": {"type": ["function"], "name": ["encode_account"], "text": ["Encode  Account  dataclass. Storage is not stored in the  Account  dataclass, so  Accounts  cannot be encoded with providing a storage root."]}}, {"source": {"identifier": "ethereum.spurious_dragon.fork_types.Header", "specifier": 0, "path": "src/ethereum/spurious_dragon/fork_types.py"}, "content": {"type": ["class"], "name": ["Header"], "text": ["Header portion of a block on the chain."]}}, {"source": {"identifier": "ethereum.spurious_dragon.fork_types.Header.parent_hash", "specifier": 0, "path": "src/ethereum/spurious_dragon/fork_types.py"}, "content": {"type": ["attribute"], "name": ["parent_hash"]}}, {"source": {"identifier": "ethereum.spurious_dragon.fork_types.Header.ommers_hash", "specifier": 0, "path": "src/ethereum/spurious_dragon/fork_types.py"}, "content": {"type": ["attribute"], "name": ["ommers_hash"]}}, {"source": {"identifier": "ethereum.spurious_dragon.fork_types.Header.coinbase", "specifier": 0, "path": "src/ethereum/spurious_dragon/fork_types.py"}, "content": {"type": ["attribute"], "name": ["coinbase"]}}, {"source": {"identifier": "ethereum.spurious_dragon.fork_types.Header.state_root", "specifier": 0, "path": "src/ethereum/spurious_dragon/fork_types.py"}, "content": {"type": ["attribute"], "name": ["state_root"]}}, {"source": {"identifier": "ethereum.spurious_dragon.fork_types.Header.transactions_root", "specifier": 0, "path": "src/ethereum/spurious_dragon/fork_types.py"}, "content": {"type": ["attribute"], "name": ["transactions_root"]}}, {"source": {"identifier": "ethereum.spurious_dragon.fork_types.Header.receipt_root", "specifier": 0, "path": "src/ethereum/spurious_dragon/fork_types.py"}, "content": {"type": ["attribute"], "name": ["receipt_root"]}}, {"source": {"identifier": "ethereum.spurious_dragon.fork_types.Header.bloom", "specifier": 0, "path": "src/ethereum/spurious_dragon/fork_types.py"}, "content": {"type": ["attribute"], "name": ["bloom"]}}, {"source": {"identifier": "ethereum.spurious_dragon.fork_types.Header.difficulty", "specifier": 0, "path": "src/ethereum/spurious_dragon/fork_types.py"}, "content": {"type": ["attribute"], "name": ["difficulty"]}}, {"source": {"identifier": "ethereum.spurious_dragon.fork_types.Header.number", "specifier": 0, "path": "src/ethereum/spurious_dragon/fork_types.py"}, "content": {"type": ["attribute"], "name": ["number"]}}, {"source": {"identifier": "ethereum.spurious_dragon.fork_types.Header.gas_limit", "specifier": 0, "path": "src/ethereum/spurious_dragon/fork_types.py"}, "content": {"type": ["attribute"], "name": ["gas_limit"]}}, {"source": {"identifier": "ethereum.spurious_dragon.fork_types.Header.gas_used", "specifier": 0, "path": "src/ethereum/spurious_dragon/fork_types.py"}, "content": {"type": ["attribute"], "name": ["gas_used"]}}, {"source": {"identifier": "ethereum.spurious_dragon.fork_types.Header.timestamp", "specifier": 0, "path": "src/ethereum/spurious_dragon/fork_types.py"}, "content": {"type": ["attribute"], "name": ["timestamp"]}}, {"source": {"identifier": "ethereum.spurious_dragon.fork_types.Header.extra_data", "specifier": 0, "path": "src/ethereum/spurious_dragon/fork_types.py"}, "content": {"type": ["attribute"], "name": ["extra_data"]}}, {"source": {"identifier": "ethereum.spurious_dragon.fork_types.Header.mix_digest", "specifier": 0, "path": "src/ethereum/spurious_dragon/fork_types.py"}, "content": {"type": ["attribute"], "name": ["mix_digest"]}}, {"source": {"identifier": "ethereum.spurious_dragon.fork_types.Header.nonce", "specifier": 0, "path": "src/ethereum/spurious_dragon/fork_types.py"}, "content": {"type": ["attribute"], "name": ["nonce"]}}, {"source": {"identifier": "ethereum.spurious_dragon.fork_types.Block", "specifier": 0, "path": "src/ethereum/spurious_dragon/fork_types.py"}, "content": {"type": ["class"], "name": ["Block"], "text": ["A complete block."]}}, {"source": {"identifier": "ethereum.spurious_dragon.fork_types.Block.header", "specifier": 0, "path": "src/ethereum/spurious_dragon/fork_types.py"}, "content": {"type": ["attribute"], "name": ["header"]}}, {"source": {"identifier": "ethereum.spurious_dragon.fork_types.Block.transactions", "specifier": 0, "path": "src/ethereum/spurious_dragon/fork_types.py"}, "content": {"type": ["attribute"], "name": ["transactions"]}}, {"source": {"identifier": "ethereum.spurious_dragon.fork_types.Block.ommers", "specifier": 0, "path": "src/ethereum/spurious_dragon/fork_types.py"}, "content": {"type": ["attribute"], "name": ["ommers"]}}, {"source": {"identifier": "ethereum.spurious_dragon.fork_types.Log", "specifier": 0, "path": "src/ethereum/spurious_dragon/fork_types.py"}, "content": {"type": ["class"], "name": ["Log"], "text": ["Data record produced during the execution of a transaction."]}}, {"source": {"identifier": "ethereum.spurious_dragon.fork_types.Log.address", "specifier": 0, "path": "src/ethereum/spurious_dragon/fork_types.py"}, "content": {"type": ["attribute"], "name": ["address"]}}, {"source": {"identifier": "ethereum.spurious_dragon.fork_types.Log.topics", "specifier": 0, "path": "src/ethereum/spurious_dragon/fork_types.py"}, "content": {"type": ["attribute"], "name": ["topics"]}}, {"source": {"identifier": "ethereum.spurious_dragon.fork_types.Log.data", "specifier": 0, "path": "src/ethereum/spurious_dragon/fork_types.py"}, "content": {"type": ["attribute"], "name": ["data"]}}, {"source": {"identifier": "ethereum.spurious_dragon.fork_types.Receipt", "specifier": 0, "path": "src/ethereum/spurious_dragon/fork_types.py"}, "content": {"type": ["class"], "name": ["Receipt"], "text": ["Result of a transaction."]}}, {"source": {"identifier": "ethereum.spurious_dragon.fork_types.Receipt.post_state", "specifier": 0, "path": "src/ethereum/spurious_dragon/fork_types.py"}, "content": {"type": ["attribute"], "name": ["post_state"]}}, {"source": {"identifier": "ethereum.spurious_dragon.fork_types.Receipt.cumulative_gas_used", "specifier": 0, "path": "src/ethereum/spurious_dragon/fork_types.py"}, "content": {"type": ["attribute"], "name": ["cumulative_gas_used"]}}, {"source": {"identifier": "ethereum.spurious_dragon.fork_types.Receipt.bloom", "specifier": 0, "path": "src/ethereum/spurious_dragon/fork_types.py"}, "content": {"type": ["attribute"], "name": ["bloom"]}}, {"source": {"identifier": "ethereum.spurious_dragon.fork_types.Receipt.logs", "specifier": 0, "path": "src/ethereum/spurious_dragon/fork_types.py"}, "content": {"type": ["attribute"], "name": ["logs"]}}, {"source": {"identifier": "ethereum_optimized.shanghai", "specifier": 0, "path": "src/ethereum_optimized/shanghai/__init__.py"}, "content": {"type": ["module"], "name": ["ethereum_optimized.shanghai"], "text": ["Optimized Implementations (London) ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local:"]}}, {"source": {"identifier": "ethereum_optimized.shanghai.monkey_patch_optimized_state_db", "specifier": 0, "path": "src/ethereum_optimized/shanghai/__init__.py"}, "content": {"type": ["function"], "name": ["monkey_patch_optimized_state_db"], "text": ["Replace the state interface with one that supports high performance updates and storing state in a database. This function must be called before the state interface is imported anywhere."]}}, {"source": {"identifier": "ethereum_optimized.shanghai.monkey_patch", "specifier": 0, "path": "src/ethereum_optimized/shanghai/__init__.py"}, "content": {"type": ["function"], "name": ["monkey_patch"], "text": ["Apply all monkey patches to swap in high performance implementations. This function must be called before any of the ethereum modules are imported anywhere."]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.precompiled_contracts.blake2f", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/precompiled_contracts/blake2f.py"}, "content": {"type": ["module"], "name": ["ethereum.muir_glacier.vm.precompiled_contracts.blake2f"], "text": ["Ethereum Virtual Machine (EVM) Blake2 PRECOMPILED CONTRACT ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementation of the  Blake2  precompiled contract."]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.precompiled_contracts.blake2f.blake2f", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/precompiled_contracts/blake2f.py"}, "content": {"type": ["function"], "name": ["blake2f"], "text": ["Writes the Blake2 hash to output. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.byzantium", "specifier": 0, "path": "src/ethereum/byzantium/__init__.py"}, "content": {"type": ["module"], "name": ["ethereum.byzantium"], "text": ["Ethereum Byzantium Hardfork ^^^^^^^^^^^^^^^^^^^^^^^^^^^ The sixth Ethereum hardfork."]}}, {"source": {"identifier": "ethereum.byzantium.MAINNET_FORK_BLOCK", "specifier": 0, "path": "src/ethereum/byzantium/__init__.py"}, "content": {"type": ["attribute"], "name": ["MAINNET_FORK_BLOCK"]}}, {"source": {"identifier": "ethereum.spurious_dragon.trie", "specifier": 0, "path": "src/ethereum/spurious_dragon/trie.py"}, "content": {"type": ["module"], "name": ["ethereum.spurious_dragon.trie"], "text": ["State Trie ^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction The state trie is the structure responsible for storing .fork_types.Account  objects."]}}, {"source": {"identifier": "ethereum.spurious_dragon.trie.EMPTY_TRIE_ROOT", "specifier": 0, "path": "src/ethereum/spurious_dragon/trie.py"}, "content": {"type": ["attribute"], "name": ["EMPTY_TRIE_ROOT"]}}, {"source": {"identifier": "ethereum.spurious_dragon.trie.Node", "specifier": 0, "path": "src/ethereum/spurious_dragon/trie.py"}, "content": {"type": ["attribute"], "name": ["Node"]}}, {"source": {"identifier": "ethereum.spurious_dragon.trie.K", "specifier": 0, "path": "src/ethereum/spurious_dragon/trie.py"}, "content": {"type": ["attribute"], "name": ["K"]}}, {"source": {"identifier": "ethereum.spurious_dragon.trie.V", "specifier": 0, "path": "src/ethereum/spurious_dragon/trie.py"}, "content": {"type": ["attribute"], "name": ["V"]}}, {"source": {"identifier": "ethereum.spurious_dragon.trie.LeafNode", "specifier": 0, "path": "src/ethereum/spurious_dragon/trie.py"}, "content": {"type": ["class"], "name": ["LeafNode"], "text": ["Leaf node in the Merkle Trie"]}}, {"source": {"identifier": "ethereum.spurious_dragon.trie.LeafNode.rest_of_key", "specifier": 0, "path": "src/ethereum/spurious_dragon/trie.py"}, "content": {"type": ["attribute"], "name": ["rest_of_key"]}}, {"source": {"identifier": "ethereum.spurious_dragon.trie.LeafNode.value", "specifier": 0, "path": "src/ethereum/spurious_dragon/trie.py"}, "content": {"type": ["attribute"], "name": ["value"]}}, {"source": {"identifier": "ethereum.spurious_dragon.trie.ExtensionNode", "specifier": 0, "path": "src/ethereum/spurious_dragon/trie.py"}, "content": {"type": ["class"], "name": ["ExtensionNode"], "text": ["Extension node in the Merkle Trie"]}}, {"source": {"identifier": "ethereum.spurious_dragon.trie.ExtensionNode.key_segment", "specifier": 0, "path": "src/ethereum/spurious_dragon/trie.py"}, "content": {"type": ["attribute"], "name": ["key_segment"]}}, {"source": {"identifier": "ethereum.spurious_dragon.trie.ExtensionNode.subnode", "specifier": 0, "path": "src/ethereum/spurious_dragon/trie.py"}, "content": {"type": ["attribute"], "name": ["subnode"]}}, {"source": {"identifier": "ethereum.spurious_dragon.trie.BranchNode", "specifier": 0, "path": "src/ethereum/spurious_dragon/trie.py"}, "content": {"type": ["class"], "name": ["BranchNode"], "text": ["Branch node in the Merkle Trie"]}}, {"source": {"identifier": "ethereum.spurious_dragon.trie.BranchNode.subnodes", "specifier": 0, "path": "src/ethereum/spurious_dragon/trie.py"}, "content": {"type": ["attribute"], "name": ["subnodes"]}}, {"source": {"identifier": "ethereum.spurious_dragon.trie.BranchNode.value", "specifier": 0, "path": "src/ethereum/spurious_dragon/trie.py"}, "content": {"type": ["attribute"], "name": ["value"]}}, {"source": {"identifier": "ethereum.spurious_dragon.trie.InternalNode", "specifier": 0, "path": "src/ethereum/spurious_dragon/trie.py"}, "content": {"type": ["attribute"], "name": ["InternalNode"]}}, {"source": {"identifier": "ethereum.spurious_dragon.trie.encode_internal_node", "specifier": 0, "path": "src/ethereum/spurious_dragon/trie.py"}, "content": {"type": ["function"], "name": ["encode_internal_node"], "text": ["Encodes a Merkle Trie node into its RLP form. The RLP will then be serialized into a  Bytes  and hashed unless it is less that 32 bytes when serialized. This function also accepts  None , representing the absence of a node, which is encoded to  b\"\" . Parameters node : Optional[InternalNode] The node to encode. Returns encoded :  rlp.RLP The node encoded as RLP."]}}, {"source": {"identifier": "ethereum.spurious_dragon.trie.encode_node", "specifier": 0, "path": "src/ethereum/spurious_dragon/trie.py"}, "content": {"type": ["function"], "name": ["encode_node"], "text": ["Encode a Node for storage in the Merkle Trie. Currently mostly an unimplemented stub."]}}, {"source": {"identifier": "ethereum.spurious_dragon.trie.Trie", "specifier": 0, "path": "src/ethereum/spurious_dragon/trie.py"}, "content": {"type": ["class"], "name": ["Trie"], "text": ["The Merkle Trie."]}}, {"source": {"identifier": "ethereum.spurious_dragon.trie.Trie.secured", "specifier": 0, "path": "src/ethereum/spurious_dragon/trie.py"}, "content": {"type": ["attribute"], "name": ["secured"]}}, {"source": {"identifier": "ethereum.spurious_dragon.trie.Trie.default", "specifier": 0, "path": "src/ethereum/spurious_dragon/trie.py"}, "content": {"type": ["attribute"], "name": ["default"]}}, {"source": {"identifier": "ethereum.spurious_dragon.trie.Trie._data", "specifier": 0, "path": "src/ethereum/spurious_dragon/trie.py"}, "content": {"type": ["attribute"], "name": ["_data"]}}, {"source": {"identifier": "ethereum.spurious_dragon.trie.copy_trie", "specifier": 0, "path": "src/ethereum/spurious_dragon/trie.py"}, "content": {"type": ["function"], "name": ["copy_trie"], "text": ["Create a copy of  trie . Since only frozen objects may be stored in tries, the contents are reused. Parameters trie:  Trie Trie to copy. Returns new_trie :  Trie[K, V] A copy of the trie."]}}, {"source": {"identifier": "ethereum.spurious_dragon.trie.trie_set", "specifier": 0, "path": "src/ethereum/spurious_dragon/trie.py"}, "content": {"type": ["function"], "name": ["trie_set"], "text": ["Stores an item in a Merkle Trie. This method deletes the key if  value == trie.default , because the Merkle Trie represents the default value by omitting it from the trie. Parameters trie:  Trie Trie to store in. key :  Bytes Key to lookup. value :  V Node to insert at  key ."]}}, {"source": {"identifier": "ethereum.spurious_dragon.trie.trie_get", "specifier": 0, "path": "src/ethereum/spurious_dragon/trie.py"}, "content": {"type": ["function"], "name": ["trie_get"], "text": ["Gets an item from the Merkle Trie. This method returns  trie.default  if the key is missing. Parameters trie: Trie to lookup in. key : Key to lookup. Returns node :  V Node at  key  in the trie."]}}, {"source": {"identifier": "ethereum.spurious_dragon.trie.common_prefix_length", "specifier": 0, "path": "src/ethereum/spurious_dragon/trie.py"}, "content": {"type": ["function"], "name": ["common_prefix_length"], "text": ["Find the longest common prefix of two sequences."]}}, {"source": {"identifier": "ethereum.spurious_dragon.trie.nibble_list_to_compact", "specifier": 0, "path": "src/ethereum/spurious_dragon/trie.py"}, "content": {"type": ["function"], "name": ["nibble_list_to_compact"], "text": ["Compresses nibble-list into a standard byte array with a flag. A nibble-list is a list of byte values no greater than  15 . The flag is encoded in high nibble of the highest byte. The flag nibble can be broken down into two two-bit flags. Highest nibble:: +---+---+----------+--------+\n| _ | _ | is_leaf | parity |\n+---+---+----------+--------+\n  3   2      1         0\n The lowest bit of the nibble encodes the parity of the length of the remaining nibbles --  0  when even and  1  when odd. The second lowest bit is used to distinguish leaf and extension nodes. The other two bits are not used. Parameters x : Array of nibbles. is_leaf : True if this is part of a leaf node, or false if it is an extension node. Returns compressed :  bytearray Compact byte array."]}}, {"source": {"identifier": "ethereum.spurious_dragon.trie.bytes_to_nibble_list", "specifier": 0, "path": "src/ethereum/spurious_dragon/trie.py"}, "content": {"type": ["function"], "name": ["bytes_to_nibble_list"], "text": ["Converts a  Bytes  into to a sequence of nibbles (bytes with value < 16). Parameters bytes_: The  Bytes  to convert. Returns nibble_list :  Bytes The  Bytes  in nibble-list format."]}}, {"source": {"identifier": "ethereum.spurious_dragon.trie._prepare_trie", "specifier": 0, "path": "src/ethereum/spurious_dragon/trie.py"}, "content": {"type": ["function"], "name": ["_prepare_trie"], "text": ["Prepares the trie for root calculation. Removes values that are empty, hashes the keys (if  secured == True ) and encodes all the nodes. Parameters trie : The  Trie  to prepare. get_storage_root : Function to get the storage root of an account. Needed to encode Account  objects. Returns out :  Mapping[ethereum.base_types.Bytes, Node] Object with keys mapped to nibble-byte form."]}}, {"source": {"identifier": "ethereum.spurious_dragon.trie.root", "specifier": 0, "path": "src/ethereum/spurious_dragon/trie.py"}, "content": {"type": ["function"], "name": ["root"], "text": ["Computes the root of a modified merkle patricia trie (MPT). Parameters trie : Trie  to get the root of. get_storage_root : Function to get the storage root of an account. Needed to encode Account  objects. Returns root :  .fork_types.Root MPT root of the underlying key-value pairs."]}}, {"source": {"identifier": "ethereum.spurious_dragon.trie.patricialize", "specifier": 0, "path": "src/ethereum/spurious_dragon/trie.py"}, "content": {"type": ["function"], "name": ["patricialize"], "text": ["Structural composition function. Used to recursively patricialize and merkleize a dictionary. Includes memoization of the tree structure and hashes. Parameters obj : Underlying trie key-value pairs, with keys in nibble-list format. level : Current trie level. Returns node :  ethereum.base_types.Bytes Root node of  obj ."]}}, {"source": {"identifier": "ethereum.shanghai.vm.precompiled_contracts.sha256", "specifier": 0, "path": "src/ethereum/shanghai/vm/precompiled_contracts/sha256.py"}, "content": {"type": ["module"], "name": ["ethereum.shanghai.vm.precompiled_contracts.sha256"], "text": ["Ethereum Virtual Machine (EVM) SHA256 PRECOMPILED CONTRACT ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementation of the  SHA256  precompiled contract."]}}, {"source": {"identifier": "ethereum.shanghai.vm.precompiled_contracts.sha256.sha256", "specifier": 0, "path": "src/ethereum/shanghai/vm/precompiled_contracts/sha256.py"}, "content": {"type": ["function"], "name": ["sha256"], "text": ["Writes the sha256 hash to output. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum_optimized.constantinople.fork", "specifier": 0, "path": "src/ethereum_optimized/constantinople/fork.py"}, "content": {"type": ["module"], "name": ["ethereum_optimized.constantinople.fork"], "text": ["Optimized Spec ^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction This module contains functions can be monkey patched into ethereum.constantinople.fork  to use alternate optimized implementations."]}}, {"source": {"identifier": "ethereum_optimized.constantinople.fork.validate_proof_of_work", "specifier": 0, "path": "src/ethereum_optimized/constantinople/fork.py"}, "content": {"type": ["function"], "name": ["validate_proof_of_work"], "text": ["See  ethereum.constantinople.fork.validate_proof_of_work ."]}}, {"source": {"identifier": "ethereum.byzantium.bloom", "specifier": 0, "path": "src/ethereum/byzantium/bloom.py"}, "content": {"type": ["module"], "name": ["ethereum.byzantium.bloom"], "text": ["Ethereum Logs Bloom ^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction This modules defines functions for calculating bloom filters of logs. For the general theory of bloom filters see e.g.  Wikipedia <https://en.wikipedia.org/wiki/Bloom_filter> _. Bloom filters are used to allow for efficient searching of logs by address and/or topic, by rapidly eliminating blocks and reciepts from their search."]}}, {"source": {"identifier": "ethereum.byzantium.bloom.add_to_bloom", "specifier": 0, "path": "src/ethereum/byzantium/bloom.py"}, "content": {"type": ["function"], "name": ["add_to_bloom"], "text": ["Add a bloom entry to the bloom filter ( bloom ). The number of hash functions used is 3. They are calculated by taking the least significant 11 bits from the first 3 16-bit words of the keccak_256()  hash of  bloom_entry . Parameters bloom : The bloom filter. bloom_entry : An entry which is to be added to bloom filter."]}}, {"source": {"identifier": "ethereum.byzantium.bloom.logs_bloom", "specifier": 0, "path": "src/ethereum/byzantium/bloom.py"}, "content": {"type": ["function"], "name": ["logs_bloom"], "text": ["Obtain the logs bloom from a list of log entries. The address and each topic of a log are added to the bloom filter. Parameters logs : List of logs for which the logs bloom is to be obtained. Returns logs_bloom :  Bloom The logs bloom obtained which is 256 bytes with some bits set as per the caller address and the log topics."]}}, {"source": {"identifier": "ethereum.spurious_dragon.fork", "specifier": 0, "path": "src/ethereum/spurious_dragon/fork.py"}, "content": {"type": ["module"], "name": ["ethereum.spurious_dragon.fork"], "text": ["Ethereum Specification ^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Entry point for the Ethereum specification."]}}, {"source": {"identifier": "ethereum.spurious_dragon.fork.BLOCK_REWARD", "specifier": 0, "path": "src/ethereum/spurious_dragon/fork.py"}, "content": {"type": ["attribute"], "name": ["BLOCK_REWARD"]}}, {"source": {"identifier": "ethereum.spurious_dragon.fork.GAS_LIMIT_ADJUSTMENT_FACTOR", "specifier": 0, "path": "src/ethereum/spurious_dragon/fork.py"}, "content": {"type": ["attribute"], "name": ["GAS_LIMIT_ADJUSTMENT_FACTOR"]}}, {"source": {"identifier": "ethereum.spurious_dragon.fork.GAS_LIMIT_MINIMUM", "specifier": 0, "path": "src/ethereum/spurious_dragon/fork.py"}, "content": {"type": ["attribute"], "name": ["GAS_LIMIT_MINIMUM"]}}, {"source": {"identifier": "ethereum.spurious_dragon.fork.MINIMUM_DIFFICULTY", "specifier": 0, "path": "src/ethereum/spurious_dragon/fork.py"}, "content": {"type": ["attribute"], "name": ["MINIMUM_DIFFICULTY"]}}, {"source": {"identifier": "ethereum.spurious_dragon.fork.MAX_OMMER_DEPTH", "specifier": 0, "path": "src/ethereum/spurious_dragon/fork.py"}, "content": {"type": ["attribute"], "name": ["MAX_OMMER_DEPTH"]}}, {"source": {"identifier": "ethereum.spurious_dragon.fork.BlockChain", "specifier": 0, "path": "src/ethereum/spurious_dragon/fork.py"}, "content": {"type": ["class"], "name": ["BlockChain"], "text": ["History and current state of the block chain."]}}, {"source": {"identifier": "ethereum.spurious_dragon.fork.BlockChain.blocks", "specifier": 0, "path": "src/ethereum/spurious_dragon/fork.py"}, "content": {"type": ["attribute"], "name": ["blocks"]}}, {"source": {"identifier": "ethereum.spurious_dragon.fork.BlockChain.state", "specifier": 0, "path": "src/ethereum/spurious_dragon/fork.py"}, "content": {"type": ["attribute"], "name": ["state"]}}, {"source": {"identifier": "ethereum.spurious_dragon.fork.BlockChain.chain_id", "specifier": 0, "path": "src/ethereum/spurious_dragon/fork.py"}, "content": {"type": ["attribute"], "name": ["chain_id"]}}, {"source": {"identifier": "ethereum.spurious_dragon.fork.apply_fork", "specifier": 0, "path": "src/ethereum/spurious_dragon/fork.py"}, "content": {"type": ["function"], "name": ["apply_fork"], "text": ["Transforms the state from the previous hard fork ( old ) into the block chain object for this hard fork and returns it. When forks need to implement an irregular state transition, this function is used to handle the irregularity. See the :ref: DAO Fork <dao-fork>  for an example. Parameters old : Previous block chain object. Returns new :  BlockChain Upgraded block chain object for this hard fork."]}}, {"source": {"identifier": "ethereum.spurious_dragon.fork.get_last_256_block_hashes", "specifier": 0, "path": "src/ethereum/spurious_dragon/fork.py"}, "content": {"type": ["function"], "name": ["get_last_256_block_hashes"], "text": ["Obtain the list of hashes of the previous 256 blocks in order of increasing block number. This function will return less hashes for the first 256 blocks. The  BLOCKHASH  opcode needs to access the latest hashes on the chain, therefore this function retrieves them. Parameters chain : History and current state. Returns recent_block_hashes :  List[Hash32] Hashes of the recent 256 blocks in order of increasing block number."]}}, {"source": {"identifier": "ethereum.spurious_dragon.fork.state_transition", "specifier": 0, "path": "src/ethereum/spurious_dragon/fork.py"}, "content": {"type": ["function"], "name": ["state_transition"], "text": ["Attempts to apply a block to an existing block chain. All parts of the block's contents need to be verified before being added to the chain. Blocks are verified by ensuring that the contents of the block make logical sense with the contents of the parent block. The information in the block's header must also match the corresponding information in the block. To implement Ethereum, in theory clients are only required to store the most recent 255 blocks of the chain since as far as execution is concerned, only those blocks are accessed. Practically, however, clients should store more blocks to handle reorgs. Parameters chain : History and current state. block : Block to apply to  chain ."]}}, {"source": {"identifier": "ethereum.spurious_dragon.fork.validate_header", "specifier": 0, "path": "src/ethereum/spurious_dragon/fork.py"}, "content": {"type": ["function"], "name": ["validate_header"], "text": ["Verifies a block header. In order to consider a block's header valid, the logic for the quantities in the header should match the logic for the block itself. For example the header timestamp should be greater than the block's parent timestamp because the block was created  after  the parent block. Additionally, the block's number should be directly folowing the parent block's number since it is the next block in the sequence. Parameters header : Header to check for correctness. parent_header : Parent Header of the header to check for correctness"]}}, {"source": {"identifier": "ethereum.spurious_dragon.fork.generate_header_hash_for_pow", "specifier": 0, "path": "src/ethereum/spurious_dragon/fork.py"}, "content": {"type": ["function"], "name": ["generate_header_hash_for_pow"], "text": ["Generate rlp hash of the header which is to be used for Proof-of-Work verification. In other words, the PoW artefacts  mix_digest  and  nonce  are ignored while calculating this hash. A particular PoW is valid for a single hash, that hash is computed by this function. The  nonce  and  mix_digest  are omitted from this hash because they are being changed by miners in their search for a sufficient proof-of-work. Parameters header : The header object for which the hash is to be generated. Returns hash :  Hash32 The PoW valid rlp hash of the passed in header."]}}, {"source": {"identifier": "ethereum.spurious_dragon.fork.validate_proof_of_work", "specifier": 0, "path": "src/ethereum/spurious_dragon/fork.py"}, "content": {"type": ["function"], "name": ["validate_proof_of_work"], "text": ["Validates the Proof of Work constraints. In order to verify that a miner's proof-of-work is valid for a block, a mix-digest  and  result  are calculated using the  hashimoto_light hash function. The mix digest is a hash of the header and the nonce that is passed through and it confirms whether or not proof-of-work was done on the correct block. The result is the actual hash value of the block. Parameters header : Header of interest."]}}, {"source": {"identifier": "ethereum.spurious_dragon.fork.check_transaction", "specifier": 0, "path": "src/ethereum/spurious_dragon/fork.py"}, "content": {"type": ["function"], "name": ["check_transaction"], "text": ["Check if the transaction is includable in the block. Parameters tx : The transaction. gas_available : The gas remaining in the block. chain_id : The ID of the current chain. Returns sender_address : The sender of the transaction. Raises InvalidBlock : If the transaction is not includable."]}}, {"source": {"identifier": "ethereum.spurious_dragon.fork.make_receipt", "specifier": 0, "path": "src/ethereum/spurious_dragon/fork.py"}, "content": {"type": ["function"], "name": ["make_receipt"], "text": ["Make the receipt for a transaction that was executed. Parameters tx : The executed transaction. post_state : The state root immediately after this transaction. cumulative_gas_used : The total gas used so far in the block after the transaction was executed. logs : The logs produced by the transaction. Returns receipt : The receipt for the transaction."]}}, {"source": {"identifier": "ethereum.spurious_dragon.fork.apply_body", "specifier": 0, "path": "src/ethereum/spurious_dragon/fork.py"}, "content": {"type": ["function"], "name": ["apply_body"], "text": ["Executes a block. Many of the contents of a block are stored in data structures called tries. There is a transactions trie which is similar to a ledger of the transactions stored in the current block. There is also a receipts trie which stores the results of executing a transaction, like the post state and gas used. This function creates and executes the block that is to be added to the chain. Parameters state : Current account state. block_hashes : List of hashes of the previous 256 blocks in the order of increasing block number. coinbase : Address of account which receives block reward and transaction fees. block_number : Position of the block within the chain. block_gas_limit : Initial amount of gas available for execution in this block. block_time : Time the block was produced, measured in seconds since the epoch. block_difficulty : Difficulty of the block. transactions : Transactions included in the block. ommers : Headers of ancestor blocks which are not direct parents (formerly uncles.) chain_id : ID of the executing chain. Returns gas_available :  ethereum.base_types.Uint Remaining gas after all transactions have been executed. transactions_root :  ethereum.fork_types.Root Trie root of all the transactions in the block. receipt_root :  ethereum.fork_types.Root Trie root of all the receipts in the block. block_logs_bloom :  Bloom Logs bloom of all the logs included in all the transactions of the block. state :  ethereum.fork_types.State State after all transactions have been executed."]}}, {"source": {"identifier": "ethereum.spurious_dragon.fork.validate_ommers", "specifier": 0, "path": "src/ethereum/spurious_dragon/fork.py"}, "content": {"type": ["function"], "name": ["validate_ommers"], "text": ["Validates the ommers mentioned in the block. An ommer block is a block that wasn't canonically added to the blockchain because it wasn't validated as fast as the canonical block but was mined at the same time. To be considered valid, the ommers must adhere to the rules defined in the Ethereum protocol. The maximum amount of ommers is 2 per block and there cannot be duplicate ommers in a block. Many of the other ommer contraints are listed in the in-line comments of this function. Parameters ommers : List of ommers mentioned in the current block. block_header: The header of current block. chain : History and current state."]}}, {"source": {"identifier": "ethereum.spurious_dragon.fork.pay_rewards", "specifier": 0, "path": "src/ethereum/spurious_dragon/fork.py"}, "content": {"type": ["function"], "name": ["pay_rewards"], "text": ["Pay rewards to the block miner as well as the ommers miners. The miner of the canonical block is rewarded with the predetermined block reward,  BLOCK_REWARD , plus a variable award based off of the number of ommer blocks that were mined around the same time, and included in the canonical block's header. An ommer block is a block that wasn't added to the canonical blockchain because it wasn't validated as fast as the accepted block but was mined at the same time. Although not all blocks that are mined are added to the canonical chain, miners are still paid a reward for their efforts. This reward is called an ommer reward and is calculated based on the number associated with the ommer block that they mined. Parameters state : Current account state. block_number : Position of the block within the chain. coinbase : Address of account which receives block reward and transaction fees. ommers : List of ommers mentioned in the current block."]}}, {"source": {"identifier": "ethereum.spurious_dragon.fork.process_transaction", "specifier": 0, "path": "src/ethereum/spurious_dragon/fork.py"}, "content": {"type": ["function"], "name": ["process_transaction"], "text": ["Execute a transaction against the provided environment. This function processes the actions needed to execute a transaction. It decrements the sender's account after calculating the gas fee and refunds them the proper amount after execution. Calling contracts, deploying code, and incrementing nonces are all examples of actions that happen within this function or from a call made within this function. Accounts that are marked for deletion are processed and destroyed after execution. Parameters env : Environment for the Ethereum Virtual Machine. tx : Transaction to execute. Returns gas_left :  ethereum.base_types.U256 Remaining gas after execution. logs :  Tuple[ethereum.fork_types.Log, ...] Logs generated during execution."]}}, {"source": {"identifier": "ethereum.spurious_dragon.fork.validate_transaction", "specifier": 0, "path": "src/ethereum/spurious_dragon/fork.py"}, "content": {"type": ["function"], "name": ["validate_transaction"], "text": ["Verifies a transaction. The gas in a transaction gets used to pay for the intrinsic cost of operations, therefore if there is insufficient gas then it would not be possible to execute a transaction and it will be declared invalid. Additionally, the nonce of a transaction must not equal or exceed the limit defined in  EIP-2681 <https://eips.ethereum.org/EIPS/eip-2681> _. In practice, defining the limit as  2**64-1  has no impact because sending  2**64-1  transactions is improbable. It's not strictly impossible though,  2**64-1  transactions is the entire capacity of the Ethereum blockchain at 2022 gas limits for a little over 22 years. Parameters tx : Transaction to validate. Returns verified :  bool True if the transaction can be executed, or False otherwise."]}}, {"source": {"identifier": "ethereum.spurious_dragon.fork.calculate_intrinsic_cost", "specifier": 0, "path": "src/ethereum/spurious_dragon/fork.py"}, "content": {"type": ["function"], "name": ["calculate_intrinsic_cost"], "text": ["Calculates the gas that is charged before execution is started. The intrinsic cost of the transaction is charged before execution has begun. Functions/operations in the EVM cost money to execute so this intrinsic cost is for the operations that need to be paid for as part of the transaction. Data transfer, for example, is part of this intrinsic cost. It costs ether to send data over the wire and that ether is accounted for in the intrinsic cost calculated in this function. This intrinsic cost must be calculated and paid for before execution in order for all operations to be implemented. Parameters tx : Transaction to compute the intrinsic cost of. Returns verified :  ethereum.base_types.Uint The intrinsic cost of the transaction."]}}, {"source": {"identifier": "ethereum.spurious_dragon.fork.recover_sender", "specifier": 0, "path": "src/ethereum/spurious_dragon/fork.py"}, "content": {"type": ["function"], "name": ["recover_sender"], "text": ["Extracts the sender address from a transaction. The v, r, and s values are the three parts that make up the signature of a transaction. In order to recover the sender of a transaction the two components needed are the signature ( v ,  r , and  s ) and the signing hash of the transaction. The sender's public key can be obtained with these two values and therefore the sender address can be retrieved. Parameters tx : Transaction of interest. chain_id : ID of the executing chain. Returns sender :  ethereum.fork_types.Address The address of the account that signed the transaction."]}}, {"source": {"identifier": "ethereum.spurious_dragon.fork.signing_hash_pre155", "specifier": 0, "path": "src/ethereum/spurious_dragon/fork.py"}, "content": {"type": ["function"], "name": ["signing_hash_pre155"], "text": ["Compute the hash of a transaction used in a legacy (pre EIP 155) signature. Parameters tx : Transaction of interest. Returns hash :  ethereum.crypto.hash.Hash32 Hash of the transaction."]}}, {"source": {"identifier": "ethereum.spurious_dragon.fork.signing_hash_155", "specifier": 0, "path": "src/ethereum/spurious_dragon/fork.py"}, "content": {"type": ["function"], "name": ["signing_hash_155"], "text": ["Compute the hash of a transaction used in a EIP 155 signature. Parameters tx : Transaction of interest. Returns hash :  ethereum.crypto.hash.Hash32 Hash of the transaction."]}}, {"source": {"identifier": "ethereum.spurious_dragon.fork.compute_header_hash", "specifier": 0, "path": "src/ethereum/spurious_dragon/fork.py"}, "content": {"type": ["function"], "name": ["compute_header_hash"], "text": ["Computes the hash of a block header. The header hash of a block is the canonical hash that is used to refer to a specific block and completely distinguishes a block from another. keccak256  is a function that produces a 256 bit hash of any input. It also takes in any number of bytes as an input and produces a single hash for them. A hash is a completely unique output for a single input. So an input corresponds to one unique hash that can be used to identify the input exactly. Prior to using the  keccak256  hash function, the header must be encoded using the Recursive-Length Prefix. See :ref: rlp . RLP encoding the header converts it into a space-efficient format that allows for easy transfer of data between nodes. The purpose of RLP is to encode arbitrarily nested arrays of binary data, and RLP is the primary encoding method used to serialize objects in Ethereum's execution layer. The only purpose of RLP is to encode structure; encoding specific data types (e.g. strings, floats) is left up to higher-order protocols. Parameters header : Header of interest. Returns hash :  ethereum.crypto.hash.Hash32 Hash of the header."]}}, {"source": {"identifier": "ethereum.spurious_dragon.fork.check_gas_limit", "specifier": 0, "path": "src/ethereum/spurious_dragon/fork.py"}, "content": {"type": ["function"], "name": ["check_gas_limit"], "text": ["Validates the gas limit for a block. The bounds of the gas limit,  max_adjustment_delta , is set as the quotient of the parent block's gas limit and the GAS_LIMIT_ADJUSTMENT_FACTOR . Therefore, if the gas limit that is passed through as a parameter is greater than or equal to the  sum  of the parent's gas and the adjustment delta then the limit for gas is too high and fails this function's check. Similarly, if the limit is less than or equal to the  difference  of the parent's gas and the adjustment delta  or  the predefined  GAS_LIMIT_MINIMUM  then this function's check fails because the gas limit doesn't allow for a sufficient or reasonable amount of gas to be used on a block. Parameters gas_limit : Gas limit to validate. parent_gas_limit : Gas limit of the parent block. Returns check :  bool True if gas limit constraints are satisfied, False otherwise."]}}, {"source": {"identifier": "ethereum.spurious_dragon.fork.calculate_block_difficulty", "specifier": 0, "path": "src/ethereum/spurious_dragon/fork.py"}, "content": {"type": ["function"], "name": ["calculate_block_difficulty"], "text": ["Computes difficulty of a block using its header and parent header. The difficulty is determined by the time the block was created after its parent. The  offset  is calculated using the parent block's difficulty, parent_difficulty , and the timestamp between blocks. This offset is then added to the parent difficulty and is stored as the  difficulty variable. If the time between the block and its parent is too short, the offset will result in a positive number thus making the sum of parent_difficulty  and  offset  to be a greater value in order to avoid mass forking. But, if the time is long enough, then the offset results in a negative value making the block less difficult than its parent. The base standard for a block's difficulty is the predefined value set for the genesis block since it has no parent. So, a block can't be less difficult than the genesis block, therefore each block's difficulty is set to the maximum value between the calculated difficulty and the  GENESIS_DIFFICULTY . Parameters block_number : Block number of the block. block_timestamp : Timestamp of the block. parent_timestamp : Timestamp of the parent block. parent_difficulty : difficulty of the parent block. Returns difficulty :  ethereum.base_types.Uint Computed difficulty for a block."]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.precompiled_contracts.mapping", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/precompiled_contracts/mapping.py"}, "content": {"type": ["module"], "name": ["ethereum.muir_glacier.vm.precompiled_contracts.mapping"], "text": ["Precompiled Contract Addresses ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Mapping of precompiled contracts their implementations."]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.precompiled_contracts.mapping.PRE_COMPILED_CONTRACTS", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/precompiled_contracts/mapping.py"}, "content": {"type": ["attribute"], "name": ["PRE_COMPILED_CONTRACTS"]}}, {"source": {"identifier": "ethereum_optimized.homestead.state_db", "specifier": 0, "path": "src/ethereum_optimized/homestead/state_db.py"}, "content": {"type": ["module"], "name": ["ethereum_optimized.homestead.state_db"], "text": ["Optimized State ^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction This module contains functions can be monkey patched into ethereum.homestead.state  to use an optimized database backed state."]}}, {"source": {"identifier": "ethereum_optimized.homestead.state_db.UnmodifiedType", "specifier": 0, "path": "src/ethereum_optimized/homestead/state_db.py"}, "content": {"type": ["class"], "name": ["UnmodifiedType"], "text": ["Sentinal type to represent a value that hasn't been modified."]}}, {"source": {"identifier": "ethereum_optimized.homestead.state_db.Unmodified", "specifier": 0, "path": "src/ethereum_optimized/homestead/state_db.py"}, "content": {"type": ["attribute"], "name": ["Unmodified"]}}, {"source": {"identifier": "ethereum_optimized.homestead.state_db.State", "specifier": 0, "path": "src/ethereum_optimized/homestead/state_db.py"}, "content": {"type": ["class"], "name": ["State"], "text": ["The State, backed by a LMDB database. When created with  State()  store the db in a temporary directory. When created with  State(path)  open or create the db located at  path ."]}}, {"source": {"identifier": "ethereum_optimized.homestead.state_db.State.default_path", "specifier": 0, "path": "src/ethereum_optimized/homestead/state_db.py"}, "content": {"type": ["attribute"], "name": ["default_path"]}}, {"source": {"identifier": "ethereum_optimized.homestead.state_db.State.db", "specifier": 0, "path": "src/ethereum_optimized/homestead/state_db.py"}, "content": {"type": ["attribute"], "name": ["db"]}}, {"source": {"identifier": "ethereum_optimized.homestead.state_db.State.dirty_accounts", "specifier": 0, "path": "src/ethereum_optimized/homestead/state_db.py"}, "content": {"type": ["attribute"], "name": ["dirty_accounts"]}}, {"source": {"identifier": "ethereum_optimized.homestead.state_db.State.dirty_storage", "specifier": 0, "path": "src/ethereum_optimized/homestead/state_db.py"}, "content": {"type": ["attribute"], "name": ["dirty_storage"]}}, {"source": {"identifier": "ethereum_optimized.homestead.state_db.State.destroyed_accounts", "specifier": 0, "path": "src/ethereum_optimized/homestead/state_db.py"}, "content": {"type": ["attribute"], "name": ["destroyed_accounts"]}}, {"source": {"identifier": "ethereum_optimized.homestead.state_db.State.tx_restore_points", "specifier": 0, "path": "src/ethereum_optimized/homestead/state_db.py"}, "content": {"type": ["attribute"], "name": ["tx_restore_points"]}}, {"source": {"identifier": "ethereum_optimized.homestead.state_db.State.journal", "specifier": 0, "path": "src/ethereum_optimized/homestead/state_db.py"}, "content": {"type": ["attribute"], "name": ["journal"]}}, {"source": {"identifier": "ethereum_optimized.homestead.state_db.State.__init__", "specifier": 0, "path": "src/ethereum_optimized/homestead/state_db.py"}, "content": {"type": ["function"], "name": ["__init__"]}}, {"source": {"identifier": "ethereum_optimized.homestead.state_db.State.__eq__", "specifier": 0, "path": "src/ethereum_optimized/homestead/state_db.py"}, "content": {"type": ["function"], "name": ["__eq__"], "text": ["Test for equality by comparing state roots."]}}, {"source": {"identifier": "ethereum_optimized.homestead.state_db.State.__enter__", "specifier": 0, "path": "src/ethereum_optimized/homestead/state_db.py"}, "content": {"type": ["function"], "name": ["__enter__"], "text": ["Support with statements"]}}, {"source": {"identifier": "ethereum_optimized.homestead.state_db.State.__exit__", "specifier": 0, "path": "src/ethereum_optimized/homestead/state_db.py"}, "content": {"type": ["function"], "name": ["__exit__"], "text": ["Support with statements"]}}, {"source": {"identifier": "ethereum_optimized.homestead.state_db.close_state", "specifier": 0, "path": "src/ethereum_optimized/homestead/state_db.py"}, "content": {"type": ["function"], "name": ["close_state"], "text": ["Close a state, releasing all resources it holds"]}}, {"source": {"identifier": "ethereum_optimized.homestead.state_db.get_metadata", "specifier": 0, "path": "src/ethereum_optimized/homestead/state_db.py"}, "content": {"type": ["function"], "name": ["get_metadata"], "text": ["Get a piece of metadata"]}}, {"source": {"identifier": "ethereum_optimized.homestead.state_db.set_metadata", "specifier": 0, "path": "src/ethereum_optimized/homestead/state_db.py"}, "content": {"type": ["function"], "name": ["set_metadata"], "text": ["Set a piece of metadata"]}}, {"source": {"identifier": "ethereum_optimized.homestead.state_db.begin_db_transaction", "specifier": 0, "path": "src/ethereum_optimized/homestead/state_db.py"}, "content": {"type": ["function"], "name": ["begin_db_transaction"], "text": ["Start a database transaction. A transaction is automatically started when a State  is created. Nesting of DB transactions is not supported (unlike non-db transactions). No operations are supported when not in a transaction."]}}, {"source": {"identifier": "ethereum_optimized.homestead.state_db.commit_db_transaction", "specifier": 0, "path": "src/ethereum_optimized/homestead/state_db.py"}, "content": {"type": ["function"], "name": ["commit_db_transaction"], "text": ["Commit the current database transaction."]}}, {"source": {"identifier": "ethereum_optimized.homestead.state_db.state_root", "specifier": 0, "path": "src/ethereum_optimized/homestead/state_db.py"}, "content": {"type": ["function"], "name": ["state_root"], "text": ["See  ethereum.homestead.state ."]}}, {"source": {"identifier": "ethereum_optimized.homestead.state_db.storage_root", "specifier": 0, "path": "src/ethereum_optimized/homestead/state_db.py"}, "content": {"type": ["function"], "name": ["storage_root"], "text": ["See  ethereum.homestead.state ."]}}, {"source": {"identifier": "ethereum_optimized.homestead.state_db.flush", "specifier": 0, "path": "src/ethereum_optimized/homestead/state_db.py"}, "content": {"type": ["function"], "name": ["flush"], "text": ["Send everything in the internal caches to the Rust layer."]}}, {"source": {"identifier": "ethereum_optimized.homestead.state_db.rollback_db_transaction", "specifier": 0, "path": "src/ethereum_optimized/homestead/state_db.py"}, "content": {"type": ["function"], "name": ["rollback_db_transaction"], "text": ["Rollback the current database transaction."]}}, {"source": {"identifier": "ethereum_optimized.homestead.state_db.begin_transaction", "specifier": 0, "path": "src/ethereum_optimized/homestead/state_db.py"}, "content": {"type": ["function"], "name": ["begin_transaction"], "text": ["See  ethereum.homestead.state ."]}}, {"source": {"identifier": "ethereum_optimized.homestead.state_db.commit_transaction", "specifier": 0, "path": "src/ethereum_optimized/homestead/state_db.py"}, "content": {"type": ["function"], "name": ["commit_transaction"], "text": ["See  ethereum.homestead.state ."]}}, {"source": {"identifier": "ethereum_optimized.homestead.state_db.rollback_transaction", "specifier": 0, "path": "src/ethereum_optimized/homestead/state_db.py"}, "content": {"type": ["function"], "name": ["rollback_transaction"], "text": ["See  ethereum.homestead.state ."]}}, {"source": {"identifier": "ethereum_optimized.homestead.state_db.get_storage", "specifier": 0, "path": "src/ethereum_optimized/homestead/state_db.py"}, "content": {"type": ["function"], "name": ["get_storage"], "text": ["See  ethereum.homestead.state ."]}}, {"source": {"identifier": "ethereum_optimized.homestead.state_db.get_storage_original", "specifier": 0, "path": "src/ethereum_optimized/homestead/state_db.py"}, "content": {"type": ["function"], "name": ["get_storage_original"], "text": ["See  ethereum.istanbul.state ."]}}, {"source": {"identifier": "ethereum_optimized.homestead.state_db.set_storage", "specifier": 0, "path": "src/ethereum_optimized/homestead/state_db.py"}, "content": {"type": ["function"], "name": ["set_storage"], "text": ["See  ethereum.homestead.state ."]}}, {"source": {"identifier": "ethereum_optimized.homestead.state_db.get_account_optional", "specifier": 0, "path": "src/ethereum_optimized/homestead/state_db.py"}, "content": {"type": ["function"], "name": ["get_account_optional"], "text": ["See  ethereum.homestead.state ."]}}, {"source": {"identifier": "ethereum_optimized.homestead.state_db.set_account", "specifier": 0, "path": "src/ethereum_optimized/homestead/state_db.py"}, "content": {"type": ["function"], "name": ["set_account"], "text": ["See  ethereum.homestead.state ."]}}, {"source": {"identifier": "ethereum_optimized.homestead.state_db.destroy_storage", "specifier": 0, "path": "src/ethereum_optimized/homestead/state_db.py"}, "content": {"type": ["function"], "name": ["destroy_storage"], "text": ["See  ethereum.homestead.state ."]}}, {"source": {"identifier": "ethereum.shanghai.vm.precompiled_contracts.modexp", "specifier": 0, "path": "src/ethereum/shanghai/vm/precompiled_contracts/modexp.py"}, "content": {"type": ["module"], "name": ["ethereum.shanghai.vm.precompiled_contracts.modexp"], "text": ["Ethereum Virtual Machine (EVM) MODEXP PRECOMPILED CONTRACT ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementation of the  MODEXP  precompiled contract."]}}, {"source": {"identifier": "ethereum.shanghai.vm.precompiled_contracts.modexp.GQUADDIVISOR", "specifier": 0, "path": "src/ethereum/shanghai/vm/precompiled_contracts/modexp.py"}, "content": {"type": ["attribute"], "name": ["GQUADDIVISOR"]}}, {"source": {"identifier": "ethereum.shanghai.vm.precompiled_contracts.modexp.modexp", "specifier": 0, "path": "src/ethereum/shanghai/vm/precompiled_contracts/modexp.py"}, "content": {"type": ["function"], "name": ["modexp"], "text": ["Calculates  (base**exp) % modulus  for arbitary sized  base ,  exp  and. modulus . The return value is the same length as the modulus."]}}, {"source": {"identifier": "ethereum.shanghai.vm.precompiled_contracts.modexp.complexity", "specifier": 0, "path": "src/ethereum/shanghai/vm/precompiled_contracts/modexp.py"}, "content": {"type": ["function"], "name": ["complexity"], "text": ["Estimate the complexity of performing a modular exponentiation. Parameters base_length : Length of the array representing the base integer. modulus_length : Length of the array representing the modulus integer. Returns complexity :  Uint Complexity of performing the operation."]}}, {"source": {"identifier": "ethereum.shanghai.vm.precompiled_contracts.modexp.iterations", "specifier": 0, "path": "src/ethereum/shanghai/vm/precompiled_contracts/modexp.py"}, "content": {"type": ["function"], "name": ["iterations"], "text": ["Calculate the number of iterations required to perform a modular exponentiation. Parameters exponent_length : Length of the array representing the exponent integer. exponent_head : First 32 bytes of the exponent (with leading zero padding if it is shorter than 32 bytes), as an unsigned integer. Returns iterations :  Uint Number of iterations."]}}, {"source": {"identifier": "ethereum.shanghai.vm.precompiled_contracts.modexp.gas_cost", "specifier": 0, "path": "src/ethereum/shanghai/vm/precompiled_contracts/modexp.py"}, "content": {"type": ["function"], "name": ["gas_cost"], "text": ["Calculate the gas cost of performing a modular exponentiation. Parameters base_length : Length of the array representing the base integer. modulus_length : Length of the array representing the modulus integer. exponent_length : Length of the array representing the exponent integer. exponent_head : First 32 bytes of the exponent (with leading zero padding if it is shorter than 32 bytes), as an unsigned integer. Returns gas_cost :  Uint Gas required for performing the operation."]}}, {"source": {"identifier": "ethereum.byzantium.fork_types", "specifier": 0, "path": "src/ethereum/byzantium/fork_types.py"}, "content": {"type": ["module"], "name": ["ethereum.byzantium.fork_types"], "text": ["Ethereum Types ^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Types re-used throughout the specification, which are specific to Ethereum."]}}, {"source": {"identifier": "ethereum.byzantium.fork_types.Address", "specifier": 0, "path": "src/ethereum/byzantium/fork_types.py"}, "content": {"type": ["attribute"], "name": ["Address"]}}, {"source": {"identifier": "ethereum.byzantium.fork_types.Root", "specifier": 0, "path": "src/ethereum/byzantium/fork_types.py"}, "content": {"type": ["attribute"], "name": ["Root"]}}, {"source": {"identifier": "ethereum.byzantium.fork_types.Bloom", "specifier": 0, "path": "src/ethereum/byzantium/fork_types.py"}, "content": {"type": ["attribute"], "name": ["Bloom"]}}, {"source": {"identifier": "ethereum.byzantium.fork_types.TX_BASE_COST", "specifier": 0, "path": "src/ethereum/byzantium/fork_types.py"}, "content": {"type": ["attribute"], "name": ["TX_BASE_COST"]}}, {"source": {"identifier": "ethereum.byzantium.fork_types.TX_DATA_COST_PER_NON_ZERO", "specifier": 0, "path": "src/ethereum/byzantium/fork_types.py"}, "content": {"type": ["attribute"], "name": ["TX_DATA_COST_PER_NON_ZERO"]}}, {"source": {"identifier": "ethereum.byzantium.fork_types.TX_DATA_COST_PER_ZERO", "specifier": 0, "path": "src/ethereum/byzantium/fork_types.py"}, "content": {"type": ["attribute"], "name": ["TX_DATA_COST_PER_ZERO"]}}, {"source": {"identifier": "ethereum.byzantium.fork_types.TX_CREATE_COST", "specifier": 0, "path": "src/ethereum/byzantium/fork_types.py"}, "content": {"type": ["attribute"], "name": ["TX_CREATE_COST"]}}, {"source": {"identifier": "ethereum.byzantium.fork_types.Transaction", "specifier": 0, "path": "src/ethereum/byzantium/fork_types.py"}, "content": {"type": ["class"], "name": ["Transaction"], "text": ["Atomic operation performed on the block chain."]}}, {"source": {"identifier": "ethereum.byzantium.fork_types.Transaction.nonce", "specifier": 0, "path": "src/ethereum/byzantium/fork_types.py"}, "content": {"type": ["attribute"], "name": ["nonce"]}}, {"source": {"identifier": "ethereum.byzantium.fork_types.Transaction.gas_price", "specifier": 0, "path": "src/ethereum/byzantium/fork_types.py"}, "content": {"type": ["attribute"], "name": ["gas_price"]}}, {"source": {"identifier": "ethereum.byzantium.fork_types.Transaction.gas", "specifier": 0, "path": "src/ethereum/byzantium/fork_types.py"}, "content": {"type": ["attribute"], "name": ["gas"]}}, {"source": {"identifier": "ethereum.byzantium.fork_types.Transaction.to", "specifier": 0, "path": "src/ethereum/byzantium/fork_types.py"}, "content": {"type": ["attribute"], "name": ["to"]}}, {"source": {"identifier": "ethereum.byzantium.fork_types.Transaction.value", "specifier": 0, "path": "src/ethereum/byzantium/fork_types.py"}, "content": {"type": ["attribute"], "name": ["value"]}}, {"source": {"identifier": "ethereum.byzantium.fork_types.Transaction.data", "specifier": 0, "path": "src/ethereum/byzantium/fork_types.py"}, "content": {"type": ["attribute"], "name": ["data"]}}, {"source": {"identifier": "ethereum.byzantium.fork_types.Transaction.v", "specifier": 0, "path": "src/ethereum/byzantium/fork_types.py"}, "content": {"type": ["attribute"], "name": ["v"]}}, {"source": {"identifier": "ethereum.byzantium.fork_types.Transaction.r", "specifier": 0, "path": "src/ethereum/byzantium/fork_types.py"}, "content": {"type": ["attribute"], "name": ["r"]}}, {"source": {"identifier": "ethereum.byzantium.fork_types.Transaction.s", "specifier": 0, "path": "src/ethereum/byzantium/fork_types.py"}, "content": {"type": ["attribute"], "name": ["s"]}}, {"source": {"identifier": "ethereum.byzantium.fork_types.Account", "specifier": 0, "path": "src/ethereum/byzantium/fork_types.py"}, "content": {"type": ["class"], "name": ["Account"], "text": ["State associated with an address."]}}, {"source": {"identifier": "ethereum.byzantium.fork_types.Account.nonce", "specifier": 0, "path": "src/ethereum/byzantium/fork_types.py"}, "content": {"type": ["attribute"], "name": ["nonce"]}}, {"source": {"identifier": "ethereum.byzantium.fork_types.Account.balance", "specifier": 0, "path": "src/ethereum/byzantium/fork_types.py"}, "content": {"type": ["attribute"], "name": ["balance"]}}, {"source": {"identifier": "ethereum.byzantium.fork_types.Account.code", "specifier": 0, "path": "src/ethereum/byzantium/fork_types.py"}, "content": {"type": ["attribute"], "name": ["code"]}}, {"source": {"identifier": "ethereum.byzantium.fork_types.EMPTY_ACCOUNT", "specifier": 0, "path": "src/ethereum/byzantium/fork_types.py"}, "content": {"type": ["attribute"], "name": ["EMPTY_ACCOUNT"]}}, {"source": {"identifier": "ethereum.byzantium.fork_types.encode_account", "specifier": 0, "path": "src/ethereum/byzantium/fork_types.py"}, "content": {"type": ["function"], "name": ["encode_account"], "text": ["Encode  Account  dataclass. Storage is not stored in the  Account  dataclass, so  Accounts  cannot be encoded with providing a storage root."]}}, {"source": {"identifier": "ethereum.byzantium.fork_types.Header", "specifier": 0, "path": "src/ethereum/byzantium/fork_types.py"}, "content": {"type": ["class"], "name": ["Header"], "text": ["Header portion of a block on the chain."]}}, {"source": {"identifier": "ethereum.byzantium.fork_types.Header.parent_hash", "specifier": 0, "path": "src/ethereum/byzantium/fork_types.py"}, "content": {"type": ["attribute"], "name": ["parent_hash"]}}, {"source": {"identifier": "ethereum.byzantium.fork_types.Header.ommers_hash", "specifier": 0, "path": "src/ethereum/byzantium/fork_types.py"}, "content": {"type": ["attribute"], "name": ["ommers_hash"]}}, {"source": {"identifier": "ethereum.byzantium.fork_types.Header.coinbase", "specifier": 0, "path": "src/ethereum/byzantium/fork_types.py"}, "content": {"type": ["attribute"], "name": ["coinbase"]}}, {"source": {"identifier": "ethereum.byzantium.fork_types.Header.state_root", "specifier": 0, "path": "src/ethereum/byzantium/fork_types.py"}, "content": {"type": ["attribute"], "name": ["state_root"]}}, {"source": {"identifier": "ethereum.byzantium.fork_types.Header.transactions_root", "specifier": 0, "path": "src/ethereum/byzantium/fork_types.py"}, "content": {"type": ["attribute"], "name": ["transactions_root"]}}, {"source": {"identifier": "ethereum.byzantium.fork_types.Header.receipt_root", "specifier": 0, "path": "src/ethereum/byzantium/fork_types.py"}, "content": {"type": ["attribute"], "name": ["receipt_root"]}}, {"source": {"identifier": "ethereum.byzantium.fork_types.Header.bloom", "specifier": 0, "path": "src/ethereum/byzantium/fork_types.py"}, "content": {"type": ["attribute"], "name": ["bloom"]}}, {"source": {"identifier": "ethereum.byzantium.fork_types.Header.difficulty", "specifier": 0, "path": "src/ethereum/byzantium/fork_types.py"}, "content": {"type": ["attribute"], "name": ["difficulty"]}}, {"source": {"identifier": "ethereum.byzantium.fork_types.Header.number", "specifier": 0, "path": "src/ethereum/byzantium/fork_types.py"}, "content": {"type": ["attribute"], "name": ["number"]}}, {"source": {"identifier": "ethereum.byzantium.fork_types.Header.gas_limit", "specifier": 0, "path": "src/ethereum/byzantium/fork_types.py"}, "content": {"type": ["attribute"], "name": ["gas_limit"]}}, {"source": {"identifier": "ethereum.byzantium.fork_types.Header.gas_used", "specifier": 0, "path": "src/ethereum/byzantium/fork_types.py"}, "content": {"type": ["attribute"], "name": ["gas_used"]}}, {"source": {"identifier": "ethereum.byzantium.fork_types.Header.timestamp", "specifier": 0, "path": "src/ethereum/byzantium/fork_types.py"}, "content": {"type": ["attribute"], "name": ["timestamp"]}}, {"source": {"identifier": "ethereum.byzantium.fork_types.Header.extra_data", "specifier": 0, "path": "src/ethereum/byzantium/fork_types.py"}, "content": {"type": ["attribute"], "name": ["extra_data"]}}, {"source": {"identifier": "ethereum.byzantium.fork_types.Header.mix_digest", "specifier": 0, "path": "src/ethereum/byzantium/fork_types.py"}, "content": {"type": ["attribute"], "name": ["mix_digest"]}}, {"source": {"identifier": "ethereum.byzantium.fork_types.Header.nonce", "specifier": 0, "path": "src/ethereum/byzantium/fork_types.py"}, "content": {"type": ["attribute"], "name": ["nonce"]}}, {"source": {"identifier": "ethereum.byzantium.fork_types.Block", "specifier": 0, "path": "src/ethereum/byzantium/fork_types.py"}, "content": {"type": ["class"], "name": ["Block"], "text": ["A complete block."]}}, {"source": {"identifier": "ethereum.byzantium.fork_types.Block.header", "specifier": 0, "path": "src/ethereum/byzantium/fork_types.py"}, "content": {"type": ["attribute"], "name": ["header"]}}, {"source": {"identifier": "ethereum.byzantium.fork_types.Block.transactions", "specifier": 0, "path": "src/ethereum/byzantium/fork_types.py"}, "content": {"type": ["attribute"], "name": ["transactions"]}}, {"source": {"identifier": "ethereum.byzantium.fork_types.Block.ommers", "specifier": 0, "path": "src/ethereum/byzantium/fork_types.py"}, "content": {"type": ["attribute"], "name": ["ommers"]}}, {"source": {"identifier": "ethereum.byzantium.fork_types.Log", "specifier": 0, "path": "src/ethereum/byzantium/fork_types.py"}, "content": {"type": ["class"], "name": ["Log"], "text": ["Data record produced during the execution of a transaction."]}}, {"source": {"identifier": "ethereum.byzantium.fork_types.Log.address", "specifier": 0, "path": "src/ethereum/byzantium/fork_types.py"}, "content": {"type": ["attribute"], "name": ["address"]}}, {"source": {"identifier": "ethereum.byzantium.fork_types.Log.topics", "specifier": 0, "path": "src/ethereum/byzantium/fork_types.py"}, "content": {"type": ["attribute"], "name": ["topics"]}}, {"source": {"identifier": "ethereum.byzantium.fork_types.Log.data", "specifier": 0, "path": "src/ethereum/byzantium/fork_types.py"}, "content": {"type": ["attribute"], "name": ["data"]}}, {"source": {"identifier": "ethereum.byzantium.fork_types.Receipt", "specifier": 0, "path": "src/ethereum/byzantium/fork_types.py"}, "content": {"type": ["class"], "name": ["Receipt"], "text": ["Result of a transaction."]}}, {"source": {"identifier": "ethereum.byzantium.fork_types.Receipt.succeeded", "specifier": 0, "path": "src/ethereum/byzantium/fork_types.py"}, "content": {"type": ["attribute"], "name": ["succeeded"]}}, {"source": {"identifier": "ethereum.byzantium.fork_types.Receipt.cumulative_gas_used", "specifier": 0, "path": "src/ethereum/byzantium/fork_types.py"}, "content": {"type": ["attribute"], "name": ["cumulative_gas_used"]}}, {"source": {"identifier": "ethereum.byzantium.fork_types.Receipt.bloom", "specifier": 0, "path": "src/ethereum/byzantium/fork_types.py"}, "content": {"type": ["attribute"], "name": ["bloom"]}}, {"source": {"identifier": "ethereum.byzantium.fork_types.Receipt.logs", "specifier": 0, "path": "src/ethereum/byzantium/fork_types.py"}, "content": {"type": ["attribute"], "name": ["logs"]}}, {"source": {"identifier": "ethereum_optimized.tangerine_whistle", "specifier": 0, "path": "src/ethereum_optimized/tangerine_whistle/__init__.py"}, "content": {"type": ["module"], "name": ["ethereum_optimized.tangerine_whistle"], "text": ["Optimized Implementations (Tangerine Whistle) ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local:"]}}, {"source": {"identifier": "ethereum_optimized.tangerine_whistle.monkey_patch_optimized_state_db", "specifier": 0, "path": "src/ethereum_optimized/tangerine_whistle/__init__.py"}, "content": {"type": ["function"], "name": ["monkey_patch_optimized_state_db"], "text": ["Replace the state interface with one that supports high performance updates and storing state in a database. This function must be called before the state interface is imported anywhere."]}}, {"source": {"identifier": "ethereum_optimized.tangerine_whistle.monkey_patch_optimized_spec", "specifier": 0, "path": "src/ethereum_optimized/tangerine_whistle/__init__.py"}, "content": {"type": ["function"], "name": ["monkey_patch_optimized_spec"], "text": ["Replace the ethash implementation with one that supports higher performance. This function must be called before the spec interface is imported anywhere."]}}, {"source": {"identifier": "ethereum_optimized.tangerine_whistle.monkey_patch", "specifier": 0, "path": "src/ethereum_optimized/tangerine_whistle/__init__.py"}, "content": {"type": ["function"], "name": ["monkey_patch"], "text": ["Apply all monkey patches to swap in high performance implementations. This function must be called before any of the ethereum modules are imported anywhere."]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.memory", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/memory.py"}, "content": {"type": ["module"], "name": ["ethereum.spurious_dragon.vm.memory"], "text": ["Ethereum Virtual Machine (EVM) Memory ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction EVM memory operations."]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.memory.memory_write", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/memory.py"}, "content": {"type": ["function"], "name": ["memory_write"], "text": ["Writes to memory. Parameters memory : Memory contents of the EVM. start_position : Starting pointer to the memory. value : Data to write to memory."]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.memory.memory_read_bytes", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/memory.py"}, "content": {"type": ["function"], "name": ["memory_read_bytes"], "text": ["Read bytes from memory. Parameters memory : Memory contents of the EVM. start_position : Starting pointer to the memory. size : Size of the data that needs to be read from  start_position . Returns data_bytes : Data read from memory."]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.memory.buffer_read", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/memory.py"}, "content": {"type": ["function"], "name": ["buffer_read"], "text": ["Read bytes from a buffer. Padding with zeros if neccesary. Parameters buffer : Memory contents of the EVM. start_position : Starting pointer to the memory. size : Size of the data that needs to be read from  start_position . Returns data_bytes : Data read from memory."]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.precompiled_contracts", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/precompiled_contracts/__init__.py"}, "content": {"type": ["module"], "name": ["ethereum.muir_glacier.vm.precompiled_contracts"], "text": ["Precompiled Contract Addresses ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Addresses of precompiled contracts and mappings to their implementations."]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.precompiled_contracts.__all__", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/precompiled_contracts/__init__.py"}, "content": {"type": ["attribute"], "name": ["__all__"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.precompiled_contracts.ECRECOVER_ADDRESS", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/precompiled_contracts/__init__.py"}, "content": {"type": ["attribute"], "name": ["ECRECOVER_ADDRESS"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.precompiled_contracts.SHA256_ADDRESS", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/precompiled_contracts/__init__.py"}, "content": {"type": ["attribute"], "name": ["SHA256_ADDRESS"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.precompiled_contracts.RIPEMD160_ADDRESS", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/precompiled_contracts/__init__.py"}, "content": {"type": ["attribute"], "name": ["RIPEMD160_ADDRESS"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.precompiled_contracts.IDENTITY_ADDRESS", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/precompiled_contracts/__init__.py"}, "content": {"type": ["attribute"], "name": ["IDENTITY_ADDRESS"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.precompiled_contracts.MODEXP_ADDRESS", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/precompiled_contracts/__init__.py"}, "content": {"type": ["attribute"], "name": ["MODEXP_ADDRESS"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.precompiled_contracts.ALT_BN128_ADD_ADDRESS", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/precompiled_contracts/__init__.py"}, "content": {"type": ["attribute"], "name": ["ALT_BN128_ADD_ADDRESS"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.precompiled_contracts.ALT_BN128_MUL_ADDRESS", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/precompiled_contracts/__init__.py"}, "content": {"type": ["attribute"], "name": ["ALT_BN128_MUL_ADDRESS"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.precompiled_contracts.ALT_BN128_PAIRING_CHECK_ADDRESS", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/precompiled_contracts/__init__.py"}, "content": {"type": ["attribute"], "name": ["ALT_BN128_PAIRING_CHECK_ADDRESS"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.precompiled_contracts.BLAKE2F_ADDRESS", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/precompiled_contracts/__init__.py"}, "content": {"type": ["attribute"], "name": ["BLAKE2F_ADDRESS"]}}, {"source": {"identifier": "ethereum.shanghai.vm.precompiled_contracts.ecrecover", "specifier": 0, "path": "src/ethereum/shanghai/vm/precompiled_contracts/ecrecover.py"}, "content": {"type": ["module"], "name": ["ethereum.shanghai.vm.precompiled_contracts.ecrecover"], "text": ["Ethereum Virtual Machine (EVM) ECRECOVER PRECOMPILED CONTRACT ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementation of the ECRECOVER precompiled contract."]}}, {"source": {"identifier": "ethereum.shanghai.vm.precompiled_contracts.ecrecover.ecrecover", "specifier": 0, "path": "src/ethereum/shanghai/vm/precompiled_contracts/ecrecover.py"}, "content": {"type": ["function"], "name": ["ecrecover"], "text": ["Decrypts the address using elliptic curve DSA recovery mechanism and writes the address to output. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.byzantium.trie", "specifier": 0, "path": "src/ethereum/byzantium/trie.py"}, "content": {"type": ["module"], "name": ["ethereum.byzantium.trie"], "text": ["State Trie ^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction The state trie is the structure responsible for storing .fork_types.Account  objects."]}}, {"source": {"identifier": "ethereum.byzantium.trie.EMPTY_TRIE_ROOT", "specifier": 0, "path": "src/ethereum/byzantium/trie.py"}, "content": {"type": ["attribute"], "name": ["EMPTY_TRIE_ROOT"]}}, {"source": {"identifier": "ethereum.byzantium.trie.Node", "specifier": 0, "path": "src/ethereum/byzantium/trie.py"}, "content": {"type": ["attribute"], "name": ["Node"]}}, {"source": {"identifier": "ethereum.byzantium.trie.K", "specifier": 0, "path": "src/ethereum/byzantium/trie.py"}, "content": {"type": ["attribute"], "name": ["K"]}}, {"source": {"identifier": "ethereum.byzantium.trie.V", "specifier": 0, "path": "src/ethereum/byzantium/trie.py"}, "content": {"type": ["attribute"], "name": ["V"]}}, {"source": {"identifier": "ethereum.byzantium.trie.LeafNode", "specifier": 0, "path": "src/ethereum/byzantium/trie.py"}, "content": {"type": ["class"], "name": ["LeafNode"], "text": ["Leaf node in the Merkle Trie"]}}, {"source": {"identifier": "ethereum.byzantium.trie.LeafNode.rest_of_key", "specifier": 0, "path": "src/ethereum/byzantium/trie.py"}, "content": {"type": ["attribute"], "name": ["rest_of_key"]}}, {"source": {"identifier": "ethereum.byzantium.trie.LeafNode.value", "specifier": 0, "path": "src/ethereum/byzantium/trie.py"}, "content": {"type": ["attribute"], "name": ["value"]}}, {"source": {"identifier": "ethereum.byzantium.trie.ExtensionNode", "specifier": 0, "path": "src/ethereum/byzantium/trie.py"}, "content": {"type": ["class"], "name": ["ExtensionNode"], "text": ["Extension node in the Merkle Trie"]}}, {"source": {"identifier": "ethereum.byzantium.trie.ExtensionNode.key_segment", "specifier": 0, "path": "src/ethereum/byzantium/trie.py"}, "content": {"type": ["attribute"], "name": ["key_segment"]}}, {"source": {"identifier": "ethereum.byzantium.trie.ExtensionNode.subnode", "specifier": 0, "path": "src/ethereum/byzantium/trie.py"}, "content": {"type": ["attribute"], "name": ["subnode"]}}, {"source": {"identifier": "ethereum.byzantium.trie.BranchNode", "specifier": 0, "path": "src/ethereum/byzantium/trie.py"}, "content": {"type": ["class"], "name": ["BranchNode"], "text": ["Branch node in the Merkle Trie"]}}, {"source": {"identifier": "ethereum.byzantium.trie.BranchNode.subnodes", "specifier": 0, "path": "src/ethereum/byzantium/trie.py"}, "content": {"type": ["attribute"], "name": ["subnodes"]}}, {"source": {"identifier": "ethereum.byzantium.trie.BranchNode.value", "specifier": 0, "path": "src/ethereum/byzantium/trie.py"}, "content": {"type": ["attribute"], "name": ["value"]}}, {"source": {"identifier": "ethereum.byzantium.trie.InternalNode", "specifier": 0, "path": "src/ethereum/byzantium/trie.py"}, "content": {"type": ["attribute"], "name": ["InternalNode"]}}, {"source": {"identifier": "ethereum.byzantium.trie.encode_internal_node", "specifier": 0, "path": "src/ethereum/byzantium/trie.py"}, "content": {"type": ["function"], "name": ["encode_internal_node"], "text": ["Encodes a Merkle Trie node into its RLP form. The RLP will then be serialized into a  Bytes  and hashed unless it is less that 32 bytes when serialized. This function also accepts  None , representing the absence of a node, which is encoded to  b\"\" . Parameters node : Optional[InternalNode] The node to encode. Returns encoded :  rlp.RLP The node encoded as RLP."]}}, {"source": {"identifier": "ethereum.byzantium.trie.encode_node", "specifier": 0, "path": "src/ethereum/byzantium/trie.py"}, "content": {"type": ["function"], "name": ["encode_node"], "text": ["Encode a Node for storage in the Merkle Trie. Currently mostly an unimplemented stub."]}}, {"source": {"identifier": "ethereum.byzantium.trie.Trie", "specifier": 0, "path": "src/ethereum/byzantium/trie.py"}, "content": {"type": ["class"], "name": ["Trie"], "text": ["The Merkle Trie."]}}, {"source": {"identifier": "ethereum.byzantium.trie.Trie.secured", "specifier": 0, "path": "src/ethereum/byzantium/trie.py"}, "content": {"type": ["attribute"], "name": ["secured"]}}, {"source": {"identifier": "ethereum.byzantium.trie.Trie.default", "specifier": 0, "path": "src/ethereum/byzantium/trie.py"}, "content": {"type": ["attribute"], "name": ["default"]}}, {"source": {"identifier": "ethereum.byzantium.trie.Trie._data", "specifier": 0, "path": "src/ethereum/byzantium/trie.py"}, "content": {"type": ["attribute"], "name": ["_data"]}}, {"source": {"identifier": "ethereum.byzantium.trie.copy_trie", "specifier": 0, "path": "src/ethereum/byzantium/trie.py"}, "content": {"type": ["function"], "name": ["copy_trie"], "text": ["Create a copy of  trie . Since only frozen objects may be stored in tries, the contents are reused. Parameters trie:  Trie Trie to copy. Returns new_trie :  Trie[K, V] A copy of the trie."]}}, {"source": {"identifier": "ethereum.byzantium.trie.trie_set", "specifier": 0, "path": "src/ethereum/byzantium/trie.py"}, "content": {"type": ["function"], "name": ["trie_set"], "text": ["Stores an item in a Merkle Trie. This method deletes the key if  value == trie.default , because the Merkle Trie represents the default value by omitting it from the trie. Parameters trie:  Trie Trie to store in. key :  Bytes Key to lookup. value :  V Node to insert at  key ."]}}, {"source": {"identifier": "ethereum.byzantium.trie.trie_get", "specifier": 0, "path": "src/ethereum/byzantium/trie.py"}, "content": {"type": ["function"], "name": ["trie_get"], "text": ["Gets an item from the Merkle Trie. This method returns  trie.default  if the key is missing. Parameters trie: Trie to lookup in. key : Key to lookup. Returns node :  V Node at  key  in the trie."]}}, {"source": {"identifier": "ethereum.byzantium.trie.common_prefix_length", "specifier": 0, "path": "src/ethereum/byzantium/trie.py"}, "content": {"type": ["function"], "name": ["common_prefix_length"], "text": ["Find the longest common prefix of two sequences."]}}, {"source": {"identifier": "ethereum.byzantium.trie.nibble_list_to_compact", "specifier": 0, "path": "src/ethereum/byzantium/trie.py"}, "content": {"type": ["function"], "name": ["nibble_list_to_compact"], "text": ["Compresses nibble-list into a standard byte array with a flag. A nibble-list is a list of byte values no greater than  15 . The flag is encoded in high nibble of the highest byte. The flag nibble can be broken down into two two-bit flags. Highest nibble:: +---+---+----------+--------+\n| _ | _ | is_leaf | parity |\n+---+---+----------+--------+\n  3   2      1         0\n The lowest bit of the nibble encodes the parity of the length of the remaining nibbles --  0  when even and  1  when odd. The second lowest bit is used to distinguish leaf and extension nodes. The other two bits are not used. Parameters x : Array of nibbles. is_leaf : True if this is part of a leaf node, or false if it is an extension node. Returns compressed :  bytearray Compact byte array."]}}, {"source": {"identifier": "ethereum.byzantium.trie.bytes_to_nibble_list", "specifier": 0, "path": "src/ethereum/byzantium/trie.py"}, "content": {"type": ["function"], "name": ["bytes_to_nibble_list"], "text": ["Converts a  Bytes  into to a sequence of nibbles (bytes with value < 16). Parameters bytes_: The  Bytes  to convert. Returns nibble_list :  Bytes The  Bytes  in nibble-list format."]}}, {"source": {"identifier": "ethereum.byzantium.trie._prepare_trie", "specifier": 0, "path": "src/ethereum/byzantium/trie.py"}, "content": {"type": ["function"], "name": ["_prepare_trie"], "text": ["Prepares the trie for root calculation. Removes values that are empty, hashes the keys (if  secured == True ) and encodes all the nodes. Parameters trie : The  Trie  to prepare. get_storage_root : Function to get the storage root of an account. Needed to encode Account  objects. Returns out :  Mapping[ethereum.base_types.Bytes, Node] Object with keys mapped to nibble-byte form."]}}, {"source": {"identifier": "ethereum.byzantium.trie.root", "specifier": 0, "path": "src/ethereum/byzantium/trie.py"}, "content": {"type": ["function"], "name": ["root"], "text": ["Computes the root of a modified merkle patricia trie (MPT). Parameters trie : Trie  to get the root of. get_storage_root : Function to get the storage root of an account. Needed to encode Account  objects. Returns root :  .fork_types.Root MPT root of the underlying key-value pairs."]}}, {"source": {"identifier": "ethereum.byzantium.trie.patricialize", "specifier": 0, "path": "src/ethereum/byzantium/trie.py"}, "content": {"type": ["function"], "name": ["patricialize"], "text": ["Structural composition function. Used to recursively patricialize and merkleize a dictionary. Includes memoization of the tree structure and hashes. Parameters obj : Underlying trie key-value pairs, with keys in nibble-list format. level : Current trie level. Returns node :  ethereum.base_types.Bytes Root node of  obj ."]}}, {"source": {"identifier": "ethereum_optimized.homestead", "specifier": 0, "path": "src/ethereum_optimized/homestead/__init__.py"}, "content": {"type": ["module"], "name": ["ethereum_optimized.homestead"], "text": ["Optimized Implementations (Homestead) ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local:"]}}, {"source": {"identifier": "ethereum_optimized.homestead.monkey_patch_optimized_state_db", "specifier": 0, "path": "src/ethereum_optimized/homestead/__init__.py"}, "content": {"type": ["function"], "name": ["monkey_patch_optimized_state_db"], "text": ["Replace the state interface with one that supports high performance updates and storing state in a database. This function must be called before the state interface is imported anywhere."]}}, {"source": {"identifier": "ethereum_optimized.homestead.monkey_patch_optimized_spec", "specifier": 0, "path": "src/ethereum_optimized/homestead/__init__.py"}, "content": {"type": ["function"], "name": ["monkey_patch_optimized_spec"], "text": ["Replace the ethash implementation with one that supports higher performance. This function must be called before the spec interface is imported anywhere."]}}, {"source": {"identifier": "ethereum_optimized.homestead.monkey_patch", "specifier": 0, "path": "src/ethereum_optimized/homestead/__init__.py"}, "content": {"type": ["function"], "name": ["monkey_patch"], "text": ["Apply all monkey patches to swap in high performance implementations. This function must be called before any of the ethereum modules are imported anywhere."]}}, {"source": {"identifier": "ethereum.byzantium.fork", "specifier": 0, "path": "src/ethereum/byzantium/fork.py"}, "content": {"type": ["module"], "name": ["ethereum.byzantium.fork"], "text": ["Ethereum Specification ^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Entry point for the Ethereum specification."]}}, {"source": {"identifier": "ethereum.byzantium.fork.BLOCK_REWARD", "specifier": 0, "path": "src/ethereum/byzantium/fork.py"}, "content": {"type": ["attribute"], "name": ["BLOCK_REWARD"]}}, {"source": {"identifier": "ethereum.byzantium.fork.GAS_LIMIT_ADJUSTMENT_FACTOR", "specifier": 0, "path": "src/ethereum/byzantium/fork.py"}, "content": {"type": ["attribute"], "name": ["GAS_LIMIT_ADJUSTMENT_FACTOR"]}}, {"source": {"identifier": "ethereum.byzantium.fork.GAS_LIMIT_MINIMUM", "specifier": 0, "path": "src/ethereum/byzantium/fork.py"}, "content": {"type": ["attribute"], "name": ["GAS_LIMIT_MINIMUM"]}}, {"source": {"identifier": "ethereum.byzantium.fork.MINIMUM_DIFFICULTY", "specifier": 0, "path": "src/ethereum/byzantium/fork.py"}, "content": {"type": ["attribute"], "name": ["MINIMUM_DIFFICULTY"]}}, {"source": {"identifier": "ethereum.byzantium.fork.MAX_OMMER_DEPTH", "specifier": 0, "path": "src/ethereum/byzantium/fork.py"}, "content": {"type": ["attribute"], "name": ["MAX_OMMER_DEPTH"]}}, {"source": {"identifier": "ethereum.byzantium.fork.BOMB_DELAY_BLOCKS", "specifier": 0, "path": "src/ethereum/byzantium/fork.py"}, "content": {"type": ["attribute"], "name": ["BOMB_DELAY_BLOCKS"]}}, {"source": {"identifier": "ethereum.byzantium.fork.EMPTY_OMMER_HASH", "specifier": 0, "path": "src/ethereum/byzantium/fork.py"}, "content": {"type": ["attribute"], "name": ["EMPTY_OMMER_HASH"]}}, {"source": {"identifier": "ethereum.byzantium.fork.BlockChain", "specifier": 0, "path": "src/ethereum/byzantium/fork.py"}, "content": {"type": ["class"], "name": ["BlockChain"], "text": ["History and current state of the block chain."]}}, {"source": {"identifier": "ethereum.byzantium.fork.BlockChain.blocks", "specifier": 0, "path": "src/ethereum/byzantium/fork.py"}, "content": {"type": ["attribute"], "name": ["blocks"]}}, {"source": {"identifier": "ethereum.byzantium.fork.BlockChain.state", "specifier": 0, "path": "src/ethereum/byzantium/fork.py"}, "content": {"type": ["attribute"], "name": ["state"]}}, {"source": {"identifier": "ethereum.byzantium.fork.BlockChain.chain_id", "specifier": 0, "path": "src/ethereum/byzantium/fork.py"}, "content": {"type": ["attribute"], "name": ["chain_id"]}}, {"source": {"identifier": "ethereum.byzantium.fork.apply_fork", "specifier": 0, "path": "src/ethereum/byzantium/fork.py"}, "content": {"type": ["function"], "name": ["apply_fork"], "text": ["Transforms the state from the previous hard fork ( old ) into the block chain object for this hard fork and returns it. When forks need to implement an irregular state transition, this function is used to handle the irregularity. See the :ref: DAO Fork <dao-fork>  for an example. Parameters old : Previous block chain object. Returns new :  BlockChain Upgraded block chain object for this hard fork."]}}, {"source": {"identifier": "ethereum.byzantium.fork.get_last_256_block_hashes", "specifier": 0, "path": "src/ethereum/byzantium/fork.py"}, "content": {"type": ["function"], "name": ["get_last_256_block_hashes"], "text": ["Obtain the list of hashes of the previous 256 blocks in order of increasing block number. This function will return less hashes for the first 256 blocks. The  BLOCKHASH  opcode needs to access the latest hashes on the chain, therefore this function retrieves them. Parameters chain : History and current state. Returns recent_block_hashes :  List[Hash32] Hashes of the recent 256 blocks in order of increasing block number."]}}, {"source": {"identifier": "ethereum.byzantium.fork.state_transition", "specifier": 0, "path": "src/ethereum/byzantium/fork.py"}, "content": {"type": ["function"], "name": ["state_transition"], "text": ["Attempts to apply a block to an existing block chain. All parts of the block's contents need to be verified before being added to the chain. Blocks are verified by ensuring that the contents of the block make logical sense with the contents of the parent block. The information in the block's header must also match the corresponding information in the block. To implement Ethereum, in theory clients are only required to store the most recent 255 blocks of the chain since as far as execution is concerned, only those blocks are accessed. Practically, however, clients should store more blocks to handle reorgs. Parameters chain : History and current state. block : Block to apply to  chain ."]}}, {"source": {"identifier": "ethereum.byzantium.fork.validate_header", "specifier": 0, "path": "src/ethereum/byzantium/fork.py"}, "content": {"type": ["function"], "name": ["validate_header"], "text": ["Verifies a block header. In order to consider a block's header valid, the logic for the quantities in the header should match the logic for the block itself. For example the header timestamp should be greater than the block's parent timestamp because the block was created  after  the parent block. Additionally, the block's number should be directly folowing the parent block's number since it is the next block in the sequence. Parameters header : Header to check for correctness. parent_header : Parent Header of the header to check for correctness"]}}, {"source": {"identifier": "ethereum.byzantium.fork.generate_header_hash_for_pow", "specifier": 0, "path": "src/ethereum/byzantium/fork.py"}, "content": {"type": ["function"], "name": ["generate_header_hash_for_pow"], "text": ["Generate rlp hash of the header which is to be used for Proof-of-Work verification. In other words, the PoW artefacts  mix_digest  and  nonce  are ignored while calculating this hash. A particular PoW is valid for a single hash, that hash is computed by this function. The  nonce  and  mix_digest  are omitted from this hash because they are being changed by miners in their search for a sufficient proof-of-work. Parameters header : The header object for which the hash is to be generated. Returns hash :  Hash32 The PoW valid rlp hash of the passed in header."]}}, {"source": {"identifier": "ethereum.byzantium.fork.validate_proof_of_work", "specifier": 0, "path": "src/ethereum/byzantium/fork.py"}, "content": {"type": ["function"], "name": ["validate_proof_of_work"], "text": ["Validates the Proof of Work constraints. In order to verify that a miner's proof-of-work is valid for a block, a mix-digest  and  result  are calculated using the  hashimoto_light hash function. The mix digest is a hash of the header and the nonce that is passed through and it confirms whether or not proof-of-work was done on the correct block. The result is the actual hash value of the block. Parameters header : Header of interest."]}}, {"source": {"identifier": "ethereum.byzantium.fork.check_transaction", "specifier": 0, "path": "src/ethereum/byzantium/fork.py"}, "content": {"type": ["function"], "name": ["check_transaction"], "text": ["Check if the transaction is includable in the block. Parameters tx : The transaction. gas_available : The gas remaining in the block. chain_id : The ID of the current chain. Returns sender_address : The sender of the transaction. Raises InvalidBlock : If the transaction is not includable."]}}, {"source": {"identifier": "ethereum.byzantium.fork.make_receipt", "specifier": 0, "path": "src/ethereum/byzantium/fork.py"}, "content": {"type": ["function"], "name": ["make_receipt"], "text": ["Make the receipt for a transaction that was executed. Parameters tx : The executed transaction. has_erred : Whether the top level frame of the transaction exited with an error. cumulative_gas_used : The total gas used so far in the block after the transaction was executed. logs : The logs produced by the transaction. Returns receipt : The receipt for the transaction."]}}, {"source": {"identifier": "ethereum.byzantium.fork.apply_body", "specifier": 0, "path": "src/ethereum/byzantium/fork.py"}, "content": {"type": ["function"], "name": ["apply_body"], "text": ["Executes a block. Many of the contents of a block are stored in data structures called tries. There is a transactions trie which is similar to a ledger of the transactions stored in the current block. There is also a receipts trie which stores the results of executing a transaction, like the post state and gas used. This function creates and executes the block that is to be added to the chain. Parameters state : Current account state. block_hashes : List of hashes of the previous 256 blocks in the order of increasing block number. coinbase : Address of account which receives block reward and transaction fees. block_number : Position of the block within the chain. block_gas_limit : Initial amount of gas available for execution in this block. block_time : Time the block was produced, measured in seconds since the epoch. block_difficulty : Difficulty of the block. transactions : Transactions included in the block. ommers : Headers of ancestor blocks which are not direct parents (formerly uncles.) chain_id : ID of the executing chain. Returns gas_available :  ethereum.base_types.Uint Remaining gas after all transactions have been executed. transactions_root :  ethereum.fork_types.Root Trie root of all the transactions in the block. receipt_root :  ethereum.fork_types.Root Trie root of all the receipts in the block. block_logs_bloom :  Bloom Logs bloom of all the logs included in all the transactions of the block. state :  ethereum.fork_types.State State after all transactions have been executed."]}}, {"source": {"identifier": "ethereum.byzantium.fork.validate_ommers", "specifier": 0, "path": "src/ethereum/byzantium/fork.py"}, "content": {"type": ["function"], "name": ["validate_ommers"], "text": ["Validates the ommers mentioned in the block. An ommer block is a block that wasn't canonically added to the blockchain because it wasn't validated as fast as the canonical block but was mined at the same time. To be considered valid, the ommers must adhere to the rules defined in the Ethereum protocol. The maximum amount of ommers is 2 per block and there cannot be duplicate ommers in a block. Many of the other ommer contraints are listed in the in-line comments of this function. Parameters ommers : List of ommers mentioned in the current block. block_header: The header of current block. chain : History and current state."]}}, {"source": {"identifier": "ethereum.byzantium.fork.pay_rewards", "specifier": 0, "path": "src/ethereum/byzantium/fork.py"}, "content": {"type": ["function"], "name": ["pay_rewards"], "text": ["Pay rewards to the block miner as well as the ommers miners. The miner of the canonical block is rewarded with the predetermined block reward,  BLOCK_REWARD , plus a variable award based off of the number of ommer blocks that were mined around the same time, and included in the canonical block's header. An ommer block is a block that wasn't added to the canonical blockchain because it wasn't validated as fast as the accepted block but was mined at the same time. Although not all blocks that are mined are added to the canonical chain, miners are still paid a reward for their efforts. This reward is called an ommer reward and is calculated based on the number associated with the ommer block that they mined. Parameters state : Current account state. block_number : Position of the block within the chain. coinbase : Address of account which receives block reward and transaction fees. ommers : List of ommers mentioned in the current block."]}}, {"source": {"identifier": "ethereum.byzantium.fork.process_transaction", "specifier": 0, "path": "src/ethereum/byzantium/fork.py"}, "content": {"type": ["function"], "name": ["process_transaction"], "text": ["Execute a transaction against the provided environment. This function processes the actions needed to execute a transaction. It decrements the sender's account after calculating the gas fee and refunds them the proper amount after execution. Calling contracts, deploying code, and incrementing nonces are all examples of actions that happen within this function or from a call made within this function. Accounts that are marked for deletion are processed and destroyed after execution. Parameters env : Environment for the Ethereum Virtual Machine. tx : Transaction to execute. Returns gas_left :  ethereum.base_types.U256 Remaining gas after execution. logs :  Tuple[ethereum.fork_types.Log, ...] Logs generated during execution."]}}, {"source": {"identifier": "ethereum.byzantium.fork.validate_transaction", "specifier": 0, "path": "src/ethereum/byzantium/fork.py"}, "content": {"type": ["function"], "name": ["validate_transaction"], "text": ["Verifies a transaction. The gas in a transaction gets used to pay for the intrinsic cost of operations, therefore if there is insufficient gas then it would not be possible to execute a transaction and it will be declared invalid. Additionally, the nonce of a transaction must not equal or exceed the limit defined in  EIP-2681 <https://eips.ethereum.org/EIPS/eip-2681> _. In practice, defining the limit as  2**64-1  has no impact because sending  2**64-1  transactions is improbable. It's not strictly impossible though,  2**64-1  transactions is the entire capacity of the Ethereum blockchain at 2022 gas limits for a little over 22 years. Parameters tx : Transaction to validate. Returns verified :  bool True if the transaction can be executed, or False otherwise."]}}, {"source": {"identifier": "ethereum.byzantium.fork.calculate_intrinsic_cost", "specifier": 0, "path": "src/ethereum/byzantium/fork.py"}, "content": {"type": ["function"], "name": ["calculate_intrinsic_cost"], "text": ["Calculates the gas that is charged before execution is started. The intrinsic cost of the transaction is charged before execution has begun. Functions/operations in the EVM cost money to execute so this intrinsic cost is for the operations that need to be paid for as part of the transaction. Data transfer, for example, is part of this intrinsic cost. It costs ether to send data over the wire and that ether is accounted for in the intrinsic cost calculated in this function. This intrinsic cost must be calculated and paid for before execution in order for all operations to be implemented. Parameters tx : Transaction to compute the intrinsic cost of. Returns verified :  ethereum.base_types.Uint The intrinsic cost of the transaction."]}}, {"source": {"identifier": "ethereum.byzantium.fork.recover_sender", "specifier": 0, "path": "src/ethereum/byzantium/fork.py"}, "content": {"type": ["function"], "name": ["recover_sender"], "text": ["Extracts the sender address from a transaction. The v, r, and s values are the three parts that make up the signature of a transaction. In order to recover the sender of a transaction the two components needed are the signature ( v ,  r , and  s ) and the signing hash of the transaction. The sender's public key can be obtained with these two values and therefore the sender address can be retrieved. Parameters tx : Transaction of interest. chain_id : ID of the executing chain. Returns sender :  ethereum.fork_types.Address The address of the account that signed the transaction."]}}, {"source": {"identifier": "ethereum.byzantium.fork.signing_hash_pre155", "specifier": 0, "path": "src/ethereum/byzantium/fork.py"}, "content": {"type": ["function"], "name": ["signing_hash_pre155"], "text": ["Compute the hash of a transaction used in a legacy (pre EIP 155) signature. Parameters tx : Transaction of interest. Returns hash :  ethereum.crypto.hash.Hash32 Hash of the transaction."]}}, {"source": {"identifier": "ethereum.byzantium.fork.signing_hash_155", "specifier": 0, "path": "src/ethereum/byzantium/fork.py"}, "content": {"type": ["function"], "name": ["signing_hash_155"], "text": ["Compute the hash of a transaction used in a EIP 155 signature. Parameters tx : Transaction of interest. Returns hash :  ethereum.crypto.hash.Hash32 Hash of the transaction."]}}, {"source": {"identifier": "ethereum.byzantium.fork.compute_header_hash", "specifier": 0, "path": "src/ethereum/byzantium/fork.py"}, "content": {"type": ["function"], "name": ["compute_header_hash"], "text": ["Computes the hash of a block header. The header hash of a block is the canonical hash that is used to refer to a specific block and completely distinguishes a block from another. keccak256  is a function that produces a 256 bit hash of any input. It also takes in any number of bytes as an input and produces a single hash for them. A hash is a completely unique output for a single input. So an input corresponds to one unique hash that can be used to identify the input exactly. Prior to using the  keccak256  hash function, the header must be encoded using the Recursive-Length Prefix. See :ref: rlp . RLP encoding the header converts it into a space-efficient format that allows for easy transfer of data between nodes. The purpose of RLP is to encode arbitrarily nested arrays of binary data, and RLP is the primary encoding method used to serialize objects in Ethereum's execution layer. The only purpose of RLP is to encode structure; encoding specific data types (e.g. strings, floats) is left up to higher-order protocols. Parameters header : Header of interest. Returns hash :  ethereum.crypto.hash.Hash32 Hash of the header."]}}, {"source": {"identifier": "ethereum.byzantium.fork.check_gas_limit", "specifier": 0, "path": "src/ethereum/byzantium/fork.py"}, "content": {"type": ["function"], "name": ["check_gas_limit"], "text": ["Validates the gas limit for a block. The bounds of the gas limit,  max_adjustment_delta , is set as the quotient of the parent block's gas limit and the GAS_LIMIT_ADJUSTMENT_FACTOR . Therefore, if the gas limit that is passed through as a parameter is greater than or equal to the  sum  of the parent's gas and the adjustment delta then the limit for gas is too high and fails this function's check. Similarly, if the limit is less than or equal to the  difference  of the parent's gas and the adjustment delta  or  the predefined  GAS_LIMIT_MINIMUM  then this function's check fails because the gas limit doesn't allow for a sufficient or reasonable amount of gas to be used on a block. Parameters gas_limit : Gas limit to validate. parent_gas_limit : Gas limit of the parent block. Returns check :  bool True if gas limit constraints are satisfied, False otherwise."]}}, {"source": {"identifier": "ethereum.byzantium.fork.calculate_block_difficulty", "specifier": 0, "path": "src/ethereum/byzantium/fork.py"}, "content": {"type": ["function"], "name": ["calculate_block_difficulty"], "text": ["Computes difficulty of a block using its header and parent header. The difficulty is determined by the time the block was created after its parent. The  offset  is calculated using the parent block's difficulty, parent_difficulty , and the timestamp between blocks. This offset is then added to the parent difficulty and is stored as the  difficulty variable. If the time between the block and its parent is too short, the offset will result in a positive number thus making the sum of parent_difficulty  and  offset  to be a greater value in order to avoid mass forking. But, if the time is long enough, then the offset results in a negative value making the block less difficult than its parent. The base standard for a block's difficulty is the predefined value set for the genesis block since it has no parent. So, a block can't be less difficult than the genesis block, therefore each block's difficulty is set to the maximum value between the calculated difficulty and the  GENESIS_DIFFICULTY . Parameters block_number : Block number of the block. block_timestamp : Timestamp of the block. parent_timestamp : Timestamp of the parent block. parent_difficulty : difficulty of the parent block. parent_has_ommers: does the parent have ommers. Returns difficulty :  ethereum.base_types.Uint Computed difficulty for a block."]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.exceptions", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/exceptions.py"}, "content": {"type": ["module"], "name": ["ethereum.spurious_dragon.vm.exceptions"], "text": ["Ethereum Virtual Machine (EVM) Exceptions ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Exceptions which cause the EVM to halt exceptionally."]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.exceptions.ExceptionalHalt", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/exceptions.py"}, "content": {"type": ["class"], "name": ["ExceptionalHalt"], "text": ["Indicates that the EVM has experienced an exceptional halt. This causes execution to immediately end with all gas being consumed."]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.exceptions.StackUnderflowError", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/exceptions.py"}, "content": {"type": ["class"], "name": ["StackUnderflowError"], "text": ["Occurs when a pop is executed on an empty stack."]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.exceptions.StackOverflowError", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/exceptions.py"}, "content": {"type": ["class"], "name": ["StackOverflowError"], "text": ["Occurs when a push is executed on a stack at max capacity."]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.exceptions.OutOfGasError", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/exceptions.py"}, "content": {"type": ["class"], "name": ["OutOfGasError"], "text": ["Occurs when an operation costs more than the amount of gas left in the frame."]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.exceptions.InvalidOpcode", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/exceptions.py"}, "content": {"type": ["class"], "name": ["InvalidOpcode"], "text": ["Raised when an invalid opcode is encountered."]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.exceptions.InvalidJumpDestError", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/exceptions.py"}, "content": {"type": ["class"], "name": ["InvalidJumpDestError"], "text": ["Occurs when the destination of a jump operation doesn't meet any of the following criteria: The jump destination is less than the length of the code. The jump destination should have the  JUMPDEST  opcode (0x5B). The jump destination shouldn't be part of the data corresponding to PUSH-N  opcodes."]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.exceptions.StackDepthLimitError", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/exceptions.py"}, "content": {"type": ["class"], "name": ["StackDepthLimitError"], "text": ["Raised when the message depth is greater than  1024"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.precompiled_contracts.alt_bn128", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/precompiled_contracts/alt_bn128.py"}, "content": {"type": ["module"], "name": ["ethereum.muir_glacier.vm.precompiled_contracts.alt_bn128"], "text": ["Ethereum Virtual Machine (EVM) ALT_BN128 CONTRACTS ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementation of the ALT_BN128 precompiled contracts."]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.precompiled_contracts.alt_bn128.alt_bn128_add", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/precompiled_contracts/alt_bn128.py"}, "content": {"type": ["function"], "name": ["alt_bn128_add"], "text": ["The ALT_BN128 addition precompiled contract. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.precompiled_contracts.alt_bn128.alt_bn128_mul", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/precompiled_contracts/alt_bn128.py"}, "content": {"type": ["function"], "name": ["alt_bn128_mul"], "text": ["The ALT_BN128 multiplication precompiled contract. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.precompiled_contracts.alt_bn128.alt_bn128_pairing_check", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/precompiled_contracts/alt_bn128.py"}, "content": {"type": ["function"], "name": ["alt_bn128_pairing_check"], "text": ["The ALT_BN128 pairing check precompiled contract. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum_optimized.berlin", "specifier": 0, "path": "src/ethereum_optimized/berlin/__init__.py"}, "content": {"type": ["module"], "name": ["ethereum_optimized.berlin"], "text": ["Optimized Implementations (Berlin) ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local:"]}}, {"source": {"identifier": "ethereum_optimized.berlin.monkey_patch_optimized_state_db", "specifier": 0, "path": "src/ethereum_optimized/berlin/__init__.py"}, "content": {"type": ["function"], "name": ["monkey_patch_optimized_state_db"], "text": ["Replace the state interface with one that supports high performance updates and storing state in a database. This function must be called before the state interface is imported anywhere."]}}, {"source": {"identifier": "ethereum_optimized.berlin.monkey_patch_optimized_spec", "specifier": 0, "path": "src/ethereum_optimized/berlin/__init__.py"}, "content": {"type": ["function"], "name": ["monkey_patch_optimized_spec"], "text": ["Replace the ethash implementation with one that supports higher performance. This function must be called before the spec interface is imported anywhere."]}}, {"source": {"identifier": "ethereum_optimized.berlin.monkey_patch", "specifier": 0, "path": "src/ethereum_optimized/berlin/__init__.py"}, "content": {"type": ["function"], "name": ["monkey_patch"], "text": ["Apply all monkey patches to swap in high performance implementations. This function must be called before any of the ethereum modules are imported anywhere."]}}, {"source": {"identifier": "ethereum.shanghai.vm.precompiled_contracts.identity", "specifier": 0, "path": "src/ethereum/shanghai/vm/precompiled_contracts/identity.py"}, "content": {"type": ["module"], "name": ["ethereum.shanghai.vm.precompiled_contracts.identity"], "text": ["Ethereum Virtual Machine (EVM) IDENTITY PRECOMPILED CONTRACT ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementation of the  IDENTITY  precompiled contract."]}}, {"source": {"identifier": "ethereum.shanghai.vm.precompiled_contracts.identity.identity", "specifier": 0, "path": "src/ethereum/shanghai/vm/precompiled_contracts/identity.py"}, "content": {"type": ["function"], "name": ["identity"], "text": ["Writes the message data to output. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum_optimized.constantinople", "specifier": 0, "path": "src/ethereum_optimized/constantinople/__init__.py"}, "content": {"type": ["module"], "name": ["ethereum_optimized.constantinople"], "text": ["Optimized Implementations (Constantinople) ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local:"]}}, {"source": {"identifier": "ethereum_optimized.constantinople.monkey_patch_optimized_state_db", "specifier": 0, "path": "src/ethereum_optimized/constantinople/__init__.py"}, "content": {"type": ["function"], "name": ["monkey_patch_optimized_state_db"], "text": ["Replace the state interface with one that supports high performance updates and storing state in a database. This function must be called before the state interface is imported anywhere."]}}, {"source": {"identifier": "ethereum_optimized.constantinople.monkey_patch_optimized_spec", "specifier": 0, "path": "src/ethereum_optimized/constantinople/__init__.py"}, "content": {"type": ["function"], "name": ["monkey_patch_optimized_spec"], "text": ["Replace the ethash implementation with one that supports higher performance. This function must be called before the spec interface is imported anywhere."]}}, {"source": {"identifier": "ethereum_optimized.constantinople.monkey_patch", "specifier": 0, "path": "src/ethereum_optimized/constantinople/__init__.py"}, "content": {"type": ["function"], "name": ["monkey_patch"], "text": ["Apply all monkey patches to swap in high performance implementations. This function must be called before any of the ethereum modules are imported anywhere."]}}, {"source": {"identifier": "ethereum.byzantium.vm.memory", "specifier": 0, "path": "src/ethereum/byzantium/vm/memory.py"}, "content": {"type": ["module"], "name": ["ethereum.byzantium.vm.memory"], "text": ["Ethereum Virtual Machine (EVM) Memory ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction EVM memory operations."]}}, {"source": {"identifier": "ethereum.byzantium.vm.memory.memory_write", "specifier": 0, "path": "src/ethereum/byzantium/vm/memory.py"}, "content": {"type": ["function"], "name": ["memory_write"], "text": ["Writes to memory. Parameters memory : Memory contents of the EVM. start_position : Starting pointer to the memory. value : Data to write to memory."]}}, {"source": {"identifier": "ethereum.byzantium.vm.memory.memory_read_bytes", "specifier": 0, "path": "src/ethereum/byzantium/vm/memory.py"}, "content": {"type": ["function"], "name": ["memory_read_bytes"], "text": ["Read bytes from memory. Parameters memory : Memory contents of the EVM. start_position : Starting pointer to the memory. size : Size of the data that needs to be read from  start_position . Returns data_bytes : Data read from memory."]}}, {"source": {"identifier": "ethereum.byzantium.vm.memory.buffer_read", "specifier": 0, "path": "src/ethereum/byzantium/vm/memory.py"}, "content": {"type": ["function"], "name": ["buffer_read"], "text": ["Read bytes from a buffer. Padding with zeros if neccesary. Parameters buffer : Memory contents of the EVM. start_position : Starting pointer to the memory. size : Size of the data that needs to be read from  start_position . Returns data_bytes : Data read from memory."]}}, {"source": {"identifier": "ethereum_optimized.constantinople.state_db", "specifier": 0, "path": "src/ethereum_optimized/constantinople/state_db.py"}, "content": {"type": ["module"], "name": ["ethereum_optimized.constantinople.state_db"], "text": ["Optimized State ^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction This module contains functions can be monkey patched into ethereum.constantinople.state  to use an optimized database backed state."]}}, {"source": {"identifier": "ethereum_optimized.constantinople.state_db.UnmodifiedType", "specifier": 0, "path": "src/ethereum_optimized/constantinople/state_db.py"}, "content": {"type": ["class"], "name": ["UnmodifiedType"], "text": ["Sentinal type to represent a value that hasn't been modified."]}}, {"source": {"identifier": "ethereum_optimized.constantinople.state_db.Unmodified", "specifier": 0, "path": "src/ethereum_optimized/constantinople/state_db.py"}, "content": {"type": ["attribute"], "name": ["Unmodified"]}}, {"source": {"identifier": "ethereum_optimized.constantinople.state_db.State", "specifier": 0, "path": "src/ethereum_optimized/constantinople/state_db.py"}, "content": {"type": ["class"], "name": ["State"], "text": ["The State, backed by a LMDB database. When created with  State()  store the db in a temporary directory. When created with  State(path)  open or create the db located at  path ."]}}, {"source": {"identifier": "ethereum_optimized.constantinople.state_db.State.default_path", "specifier": 0, "path": "src/ethereum_optimized/constantinople/state_db.py"}, "content": {"type": ["attribute"], "name": ["default_path"]}}, {"source": {"identifier": "ethereum_optimized.constantinople.state_db.State.db", "specifier": 0, "path": "src/ethereum_optimized/constantinople/state_db.py"}, "content": {"type": ["attribute"], "name": ["db"]}}, {"source": {"identifier": "ethereum_optimized.constantinople.state_db.State.dirty_accounts", "specifier": 0, "path": "src/ethereum_optimized/constantinople/state_db.py"}, "content": {"type": ["attribute"], "name": ["dirty_accounts"]}}, {"source": {"identifier": "ethereum_optimized.constantinople.state_db.State.dirty_storage", "specifier": 0, "path": "src/ethereum_optimized/constantinople/state_db.py"}, "content": {"type": ["attribute"], "name": ["dirty_storage"]}}, {"source": {"identifier": "ethereum_optimized.constantinople.state_db.State.destroyed_accounts", "specifier": 0, "path": "src/ethereum_optimized/constantinople/state_db.py"}, "content": {"type": ["attribute"], "name": ["destroyed_accounts"]}}, {"source": {"identifier": "ethereum_optimized.constantinople.state_db.State.tx_restore_points", "specifier": 0, "path": "src/ethereum_optimized/constantinople/state_db.py"}, "content": {"type": ["attribute"], "name": ["tx_restore_points"]}}, {"source": {"identifier": "ethereum_optimized.constantinople.state_db.State.journal", "specifier": 0, "path": "src/ethereum_optimized/constantinople/state_db.py"}, "content": {"type": ["attribute"], "name": ["journal"]}}, {"source": {"identifier": "ethereum_optimized.constantinople.state_db.State.__init__", "specifier": 0, "path": "src/ethereum_optimized/constantinople/state_db.py"}, "content": {"type": ["function"], "name": ["__init__"]}}, {"source": {"identifier": "ethereum_optimized.constantinople.state_db.State.__eq__", "specifier": 0, "path": "src/ethereum_optimized/constantinople/state_db.py"}, "content": {"type": ["function"], "name": ["__eq__"], "text": ["Test for equality by comparing state roots."]}}, {"source": {"identifier": "ethereum_optimized.constantinople.state_db.State.__enter__", "specifier": 0, "path": "src/ethereum_optimized/constantinople/state_db.py"}, "content": {"type": ["function"], "name": ["__enter__"], "text": ["Support with statements"]}}, {"source": {"identifier": "ethereum_optimized.constantinople.state_db.State.__exit__", "specifier": 0, "path": "src/ethereum_optimized/constantinople/state_db.py"}, "content": {"type": ["function"], "name": ["__exit__"], "text": ["Support with statements"]}}, {"source": {"identifier": "ethereum_optimized.constantinople.state_db.close_state", "specifier": 0, "path": "src/ethereum_optimized/constantinople/state_db.py"}, "content": {"type": ["function"], "name": ["close_state"], "text": ["Close a state, releasing all resources it holds"]}}, {"source": {"identifier": "ethereum_optimized.constantinople.state_db.get_metadata", "specifier": 0, "path": "src/ethereum_optimized/constantinople/state_db.py"}, "content": {"type": ["function"], "name": ["get_metadata"], "text": ["Get a piece of metadata"]}}, {"source": {"identifier": "ethereum_optimized.constantinople.state_db.set_metadata", "specifier": 0, "path": "src/ethereum_optimized/constantinople/state_db.py"}, "content": {"type": ["function"], "name": ["set_metadata"], "text": ["Set a piece of metadata"]}}, {"source": {"identifier": "ethereum_optimized.constantinople.state_db.begin_db_transaction", "specifier": 0, "path": "src/ethereum_optimized/constantinople/state_db.py"}, "content": {"type": ["function"], "name": ["begin_db_transaction"], "text": ["Start a database transaction. A transaction is automatically started when a State  is created. Nesting of DB transactions is not supported (unlike non-db transactions). No operations are supported when not in a transaction."]}}, {"source": {"identifier": "ethereum_optimized.constantinople.state_db.commit_db_transaction", "specifier": 0, "path": "src/ethereum_optimized/constantinople/state_db.py"}, "content": {"type": ["function"], "name": ["commit_db_transaction"], "text": ["Commit the current database transaction."]}}, {"source": {"identifier": "ethereum_optimized.constantinople.state_db.state_root", "specifier": 0, "path": "src/ethereum_optimized/constantinople/state_db.py"}, "content": {"type": ["function"], "name": ["state_root"], "text": ["See  ethereum.constantinople.state ."]}}, {"source": {"identifier": "ethereum_optimized.constantinople.state_db.storage_root", "specifier": 0, "path": "src/ethereum_optimized/constantinople/state_db.py"}, "content": {"type": ["function"], "name": ["storage_root"], "text": ["See  ethereum.constantinople.state ."]}}, {"source": {"identifier": "ethereum_optimized.constantinople.state_db.flush", "specifier": 0, "path": "src/ethereum_optimized/constantinople/state_db.py"}, "content": {"type": ["function"], "name": ["flush"], "text": ["Send everything in the internal caches to the Rust layer."]}}, {"source": {"identifier": "ethereum_optimized.constantinople.state_db.rollback_db_transaction", "specifier": 0, "path": "src/ethereum_optimized/constantinople/state_db.py"}, "content": {"type": ["function"], "name": ["rollback_db_transaction"], "text": ["Rollback the current database transaction."]}}, {"source": {"identifier": "ethereum_optimized.constantinople.state_db.begin_transaction", "specifier": 0, "path": "src/ethereum_optimized/constantinople/state_db.py"}, "content": {"type": ["function"], "name": ["begin_transaction"], "text": ["See  ethereum.constantinople.state ."]}}, {"source": {"identifier": "ethereum_optimized.constantinople.state_db.commit_transaction", "specifier": 0, "path": "src/ethereum_optimized/constantinople/state_db.py"}, "content": {"type": ["function"], "name": ["commit_transaction"], "text": ["See  ethereum.constantinople.state ."]}}, {"source": {"identifier": "ethereum_optimized.constantinople.state_db.rollback_transaction", "specifier": 0, "path": "src/ethereum_optimized/constantinople/state_db.py"}, "content": {"type": ["function"], "name": ["rollback_transaction"], "text": ["See  ethereum.constantinople.state ."]}}, {"source": {"identifier": "ethereum_optimized.constantinople.state_db.get_storage", "specifier": 0, "path": "src/ethereum_optimized/constantinople/state_db.py"}, "content": {"type": ["function"], "name": ["get_storage"], "text": ["See  ethereum.constantinople.state ."]}}, {"source": {"identifier": "ethereum_optimized.constantinople.state_db.get_storage_original", "specifier": 0, "path": "src/ethereum_optimized/constantinople/state_db.py"}, "content": {"type": ["function"], "name": ["get_storage_original"], "text": ["See  ethereum.istanbul.state ."]}}, {"source": {"identifier": "ethereum_optimized.constantinople.state_db.set_storage", "specifier": 0, "path": "src/ethereum_optimized/constantinople/state_db.py"}, "content": {"type": ["function"], "name": ["set_storage"], "text": ["See  ethereum.constantinople.state ."]}}, {"source": {"identifier": "ethereum_optimized.constantinople.state_db.get_account_optional", "specifier": 0, "path": "src/ethereum_optimized/constantinople/state_db.py"}, "content": {"type": ["function"], "name": ["get_account_optional"], "text": ["See  ethereum.constantinople.state ."]}}, {"source": {"identifier": "ethereum_optimized.constantinople.state_db.set_account", "specifier": 0, "path": "src/ethereum_optimized/constantinople/state_db.py"}, "content": {"type": ["function"], "name": ["set_account"], "text": ["See  ethereum.constantinople.state ."]}}, {"source": {"identifier": "ethereum_optimized.constantinople.state_db.destroy_storage", "specifier": 0, "path": "src/ethereum_optimized/constantinople/state_db.py"}, "content": {"type": ["function"], "name": ["destroy_storage"], "text": ["See  ethereum.constantinople.state ."]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/__init__.py"}, "content": {"type": ["module"], "name": ["ethereum.spurious_dragon.vm"], "text": ["Ethereum Virtual Machine (EVM) ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction The abstract computer which runs the code stored in an .fork_types.Account ."]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.__all__", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["__all__"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.Environment", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/__init__.py"}, "content": {"type": ["class"], "name": ["Environment"], "text": ["Items external to the virtual machine itself, provided by the environment."]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.Environment.caller", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["caller"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.Environment.block_hashes", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["block_hashes"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.Environment.origin", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["origin"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.Environment.coinbase", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["coinbase"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.Environment.number", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["number"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.Environment.gas_limit", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["gas_limit"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.Environment.gas_price", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["gas_price"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.Environment.time", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["time"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.Environment.difficulty", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["difficulty"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.Environment.state", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["state"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.Message", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/__init__.py"}, "content": {"type": ["class"], "name": ["Message"], "text": ["Items that are used by contract creation or message call."]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.Message.caller", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["caller"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.Message.target", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["target"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.Message.current_target", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["current_target"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.Message.gas", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["gas"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.Message.value", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["value"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.Message.data", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["data"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.Message.code_address", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["code_address"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.Message.code", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["code"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.Message.depth", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["depth"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.Message.should_transfer_value", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["should_transfer_value"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.Evm", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/__init__.py"}, "content": {"type": ["class"], "name": ["Evm"], "text": ["The internal state of the virtual machine."]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.Evm.pc", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["pc"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.Evm.stack", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["stack"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.Evm.memory", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["memory"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.Evm.code", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["code"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.Evm.gas_left", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["gas_left"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.Evm.env", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["env"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.Evm.valid_jump_destinations", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["valid_jump_destinations"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.Evm.logs", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["logs"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.Evm.refund_counter", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["refund_counter"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.Evm.running", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["running"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.Evm.message", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["message"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.Evm.output", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["output"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.Evm.accounts_to_delete", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["accounts_to_delete"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.Evm.touched_accounts", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["touched_accounts"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.Evm.has_erred", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["has_erred"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.incorporate_child_on_success", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/__init__.py"}, "content": {"type": ["function"], "name": ["incorporate_child_on_success"], "text": ["Incorporate the state of a successful  child_evm  into the parent  evm . Parameters evm : The parent  EVM . child_evm : The child evm to incorporate."]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.incorporate_child_on_error", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/__init__.py"}, "content": {"type": ["function"], "name": ["incorporate_child_on_error"], "text": ["Incorporate the state of an unsuccessful  child_evm  into the parent  evm . Parameters evm : The parent  EVM . child_evm : The child evm to incorporate."]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.precompiled_contracts.ripemd160", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/precompiled_contracts/ripemd160.py"}, "content": {"type": ["module"], "name": ["ethereum.muir_glacier.vm.precompiled_contracts.ripemd160"], "text": ["Ethereum Virtual Machine (EVM) RIPEMD160 PRECOMPILED CONTRACT ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementation of the  RIPEMD160  precompiled contract."]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.precompiled_contracts.ripemd160.ripemd160", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/precompiled_contracts/ripemd160.py"}, "content": {"type": ["function"], "name": ["ripemd160"], "text": ["Writes the ripemd160 hash to output. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.memory", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/memory.py"}, "content": {"type": ["module"], "name": ["ethereum.shanghai.vm.instructions.memory"], "text": ["Ethereum Virtual Machine (EVM) Memory Instructions ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementations of the EVM Memory instructions."]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.memory.mstore", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/memory.py"}, "content": {"type": ["function"], "name": ["mstore"], "text": ["Stores a word to memory. This also expands the memory, if the memory is insufficient to store the word. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.memory.mstore8", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/memory.py"}, "content": {"type": ["function"], "name": ["mstore8"], "text": ["Stores a byte to memory. This also expands the memory, if the memory is insufficient to store the word. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.memory.mload", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/memory.py"}, "content": {"type": ["function"], "name": ["mload"], "text": ["Load word from memory. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.memory.msize", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/memory.py"}, "content": {"type": ["function"], "name": ["msize"], "text": ["Push the size of active memory in bytes onto the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum_optimized.shanghai.state_db", "specifier": 0, "path": "src/ethereum_optimized/shanghai/state_db.py"}, "content": {"type": ["module"], "name": ["ethereum_optimized.shanghai.state_db"], "text": ["Optimized State ^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction This module contains functions can be monkey patched into ethereum.shanghai.state  to use an optimized database backed state."]}}, {"source": {"identifier": "ethereum_optimized.shanghai.state_db.UnmodifiedType", "specifier": 0, "path": "src/ethereum_optimized/shanghai/state_db.py"}, "content": {"type": ["class"], "name": ["UnmodifiedType"], "text": ["Sentinal type to represent a value that hasn't been modified."]}}, {"source": {"identifier": "ethereum_optimized.shanghai.state_db.Unmodified", "specifier": 0, "path": "src/ethereum_optimized/shanghai/state_db.py"}, "content": {"type": ["attribute"], "name": ["Unmodified"]}}, {"source": {"identifier": "ethereum_optimized.shanghai.state_db.State", "specifier": 0, "path": "src/ethereum_optimized/shanghai/state_db.py"}, "content": {"type": ["class"], "name": ["State"], "text": ["The State, backed by a LMDB database. When created with  State()  store the db in a temporary directory. When created with  State(path)  open or create the db located at  path ."]}}, {"source": {"identifier": "ethereum_optimized.shanghai.state_db.State.default_path", "specifier": 0, "path": "src/ethereum_optimized/shanghai/state_db.py"}, "content": {"type": ["attribute"], "name": ["default_path"]}}, {"source": {"identifier": "ethereum_optimized.shanghai.state_db.State.db", "specifier": 0, "path": "src/ethereum_optimized/shanghai/state_db.py"}, "content": {"type": ["attribute"], "name": ["db"]}}, {"source": {"identifier": "ethereum_optimized.shanghai.state_db.State.dirty_accounts", "specifier": 0, "path": "src/ethereum_optimized/shanghai/state_db.py"}, "content": {"type": ["attribute"], "name": ["dirty_accounts"]}}, {"source": {"identifier": "ethereum_optimized.shanghai.state_db.State.dirty_storage", "specifier": 0, "path": "src/ethereum_optimized/shanghai/state_db.py"}, "content": {"type": ["attribute"], "name": ["dirty_storage"]}}, {"source": {"identifier": "ethereum_optimized.shanghai.state_db.State.destroyed_accounts", "specifier": 0, "path": "src/ethereum_optimized/shanghai/state_db.py"}, "content": {"type": ["attribute"], "name": ["destroyed_accounts"]}}, {"source": {"identifier": "ethereum_optimized.shanghai.state_db.State.tx_restore_points", "specifier": 0, "path": "src/ethereum_optimized/shanghai/state_db.py"}, "content": {"type": ["attribute"], "name": ["tx_restore_points"]}}, {"source": {"identifier": "ethereum_optimized.shanghai.state_db.State.journal", "specifier": 0, "path": "src/ethereum_optimized/shanghai/state_db.py"}, "content": {"type": ["attribute"], "name": ["journal"]}}, {"source": {"identifier": "ethereum_optimized.shanghai.state_db.State.__init__", "specifier": 0, "path": "src/ethereum_optimized/shanghai/state_db.py"}, "content": {"type": ["function"], "name": ["__init__"]}}, {"source": {"identifier": "ethereum_optimized.shanghai.state_db.State.__eq__", "specifier": 0, "path": "src/ethereum_optimized/shanghai/state_db.py"}, "content": {"type": ["function"], "name": ["__eq__"], "text": ["Test for equality by comparing state roots."]}}, {"source": {"identifier": "ethereum_optimized.shanghai.state_db.State.__enter__", "specifier": 0, "path": "src/ethereum_optimized/shanghai/state_db.py"}, "content": {"type": ["function"], "name": ["__enter__"], "text": ["Support with statements"]}}, {"source": {"identifier": "ethereum_optimized.shanghai.state_db.State.__exit__", "specifier": 0, "path": "src/ethereum_optimized/shanghai/state_db.py"}, "content": {"type": ["function"], "name": ["__exit__"], "text": ["Support with statements"]}}, {"source": {"identifier": "ethereum_optimized.shanghai.state_db.close_state", "specifier": 0, "path": "src/ethereum_optimized/shanghai/state_db.py"}, "content": {"type": ["function"], "name": ["close_state"], "text": ["Close a state, releasing all resources it holds"]}}, {"source": {"identifier": "ethereum_optimized.shanghai.state_db.get_metadata", "specifier": 0, "path": "src/ethereum_optimized/shanghai/state_db.py"}, "content": {"type": ["function"], "name": ["get_metadata"], "text": ["Get a piece of metadata"]}}, {"source": {"identifier": "ethereum_optimized.shanghai.state_db.set_metadata", "specifier": 0, "path": "src/ethereum_optimized/shanghai/state_db.py"}, "content": {"type": ["function"], "name": ["set_metadata"], "text": ["Set a piece of metadata"]}}, {"source": {"identifier": "ethereum_optimized.shanghai.state_db.begin_db_transaction", "specifier": 0, "path": "src/ethereum_optimized/shanghai/state_db.py"}, "content": {"type": ["function"], "name": ["begin_db_transaction"], "text": ["Start a database transaction. A transaction is automatically started when a State  is created. Nesting of DB transactions is not supported (unlike non-db transactions). No operations are supported when not in a transaction."]}}, {"source": {"identifier": "ethereum_optimized.shanghai.state_db.commit_db_transaction", "specifier": 0, "path": "src/ethereum_optimized/shanghai/state_db.py"}, "content": {"type": ["function"], "name": ["commit_db_transaction"], "text": ["Commit the current database transaction."]}}, {"source": {"identifier": "ethereum_optimized.shanghai.state_db.state_root", "specifier": 0, "path": "src/ethereum_optimized/shanghai/state_db.py"}, "content": {"type": ["function"], "name": ["state_root"], "text": ["See  ethereum.shanghai.state ."]}}, {"source": {"identifier": "ethereum_optimized.shanghai.state_db.storage_root", "specifier": 0, "path": "src/ethereum_optimized/shanghai/state_db.py"}, "content": {"type": ["function"], "name": ["storage_root"], "text": ["See  ethereum.shanghai.state ."]}}, {"source": {"identifier": "ethereum_optimized.shanghai.state_db.flush", "specifier": 0, "path": "src/ethereum_optimized/shanghai/state_db.py"}, "content": {"type": ["function"], "name": ["flush"], "text": ["Send everything in the internal caches to the Rust layer."]}}, {"source": {"identifier": "ethereum_optimized.shanghai.state_db.rollback_db_transaction", "specifier": 0, "path": "src/ethereum_optimized/shanghai/state_db.py"}, "content": {"type": ["function"], "name": ["rollback_db_transaction"], "text": ["Rollback the current database transaction."]}}, {"source": {"identifier": "ethereum_optimized.shanghai.state_db.begin_transaction", "specifier": 0, "path": "src/ethereum_optimized/shanghai/state_db.py"}, "content": {"type": ["function"], "name": ["begin_transaction"], "text": ["See  ethereum.shanghai.state ."]}}, {"source": {"identifier": "ethereum_optimized.shanghai.state_db.commit_transaction", "specifier": 0, "path": "src/ethereum_optimized/shanghai/state_db.py"}, "content": {"type": ["function"], "name": ["commit_transaction"], "text": ["See  ethereum.shanghai.state ."]}}, {"source": {"identifier": "ethereum_optimized.shanghai.state_db.rollback_transaction", "specifier": 0, "path": "src/ethereum_optimized/shanghai/state_db.py"}, "content": {"type": ["function"], "name": ["rollback_transaction"], "text": ["See  ethereum.shanghai.state ."]}}, {"source": {"identifier": "ethereum_optimized.shanghai.state_db.get_storage", "specifier": 0, "path": "src/ethereum_optimized/shanghai/state_db.py"}, "content": {"type": ["function"], "name": ["get_storage"], "text": ["See  ethereum.shanghai.state ."]}}, {"source": {"identifier": "ethereum_optimized.shanghai.state_db.get_storage_original", "specifier": 0, "path": "src/ethereum_optimized/shanghai/state_db.py"}, "content": {"type": ["function"], "name": ["get_storage_original"], "text": ["See  ethereum.istanbul.state ."]}}, {"source": {"identifier": "ethereum_optimized.shanghai.state_db.set_storage", "specifier": 0, "path": "src/ethereum_optimized/shanghai/state_db.py"}, "content": {"type": ["function"], "name": ["set_storage"], "text": ["See  ethereum.shanghai.state ."]}}, {"source": {"identifier": "ethereum_optimized.shanghai.state_db.get_account_optional", "specifier": 0, "path": "src/ethereum_optimized/shanghai/state_db.py"}, "content": {"type": ["function"], "name": ["get_account_optional"], "text": ["See  ethereum.shanghai.state ."]}}, {"source": {"identifier": "ethereum_optimized.shanghai.state_db.set_account", "specifier": 0, "path": "src/ethereum_optimized/shanghai/state_db.py"}, "content": {"type": ["function"], "name": ["set_account"], "text": ["See  ethereum.shanghai.state ."]}}, {"source": {"identifier": "ethereum_optimized.shanghai.state_db.destroy_storage", "specifier": 0, "path": "src/ethereum_optimized/shanghai/state_db.py"}, "content": {"type": ["function"], "name": ["destroy_storage"], "text": ["See  ethereum.shanghai.state ."]}}, {"source": {"identifier": "ethereum.byzantium.vm.exceptions", "specifier": 0, "path": "src/ethereum/byzantium/vm/exceptions.py"}, "content": {"type": ["module"], "name": ["ethereum.byzantium.vm.exceptions"], "text": ["Ethereum Virtual Machine (EVM) Exceptions ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Exceptions which cause the EVM to halt exceptionally."]}}, {"source": {"identifier": "ethereum.byzantium.vm.exceptions.ExceptionalHalt", "specifier": 0, "path": "src/ethereum/byzantium/vm/exceptions.py"}, "content": {"type": ["class"], "name": ["ExceptionalHalt"], "text": ["Indicates that the EVM has experienced an exceptional halt. This causes execution to immediately end with all gas being consumed."]}}, {"source": {"identifier": "ethereum.byzantium.vm.exceptions.Revert", "specifier": 0, "path": "src/ethereum/byzantium/vm/exceptions.py"}, "content": {"type": ["class"], "name": ["Revert"], "text": ["Raised by the  REVERT  opcode. Unlike other EVM exceptions this does not result in the consumption of all gas."]}}, {"source": {"identifier": "ethereum.byzantium.vm.exceptions.StackUnderflowError", "specifier": 0, "path": "src/ethereum/byzantium/vm/exceptions.py"}, "content": {"type": ["class"], "name": ["StackUnderflowError"], "text": ["Occurs when a pop is executed on an empty stack."]}}, {"source": {"identifier": "ethereum.byzantium.vm.exceptions.StackOverflowError", "specifier": 0, "path": "src/ethereum/byzantium/vm/exceptions.py"}, "content": {"type": ["class"], "name": ["StackOverflowError"], "text": ["Occurs when a push is executed on a stack at max capacity."]}}, {"source": {"identifier": "ethereum.byzantium.vm.exceptions.OutOfGasError", "specifier": 0, "path": "src/ethereum/byzantium/vm/exceptions.py"}, "content": {"type": ["class"], "name": ["OutOfGasError"], "text": ["Occurs when an operation costs more than the amount of gas left in the frame."]}}, {"source": {"identifier": "ethereum.byzantium.vm.exceptions.InvalidOpcode", "specifier": 0, "path": "src/ethereum/byzantium/vm/exceptions.py"}, "content": {"type": ["class"], "name": ["InvalidOpcode"], "text": ["Raised when an invalid opcode is encountered."]}}, {"source": {"identifier": "ethereum.byzantium.vm.exceptions.InvalidJumpDestError", "specifier": 0, "path": "src/ethereum/byzantium/vm/exceptions.py"}, "content": {"type": ["class"], "name": ["InvalidJumpDestError"], "text": ["Occurs when the destination of a jump operation doesn't meet any of the following criteria: The jump destination is less than the length of the code. The jump destination should have the  JUMPDEST  opcode (0x5B). The jump destination shouldn't be part of the data corresponding to PUSH-N  opcodes."]}}, {"source": {"identifier": "ethereum.byzantium.vm.exceptions.StackDepthLimitError", "specifier": 0, "path": "src/ethereum/byzantium/vm/exceptions.py"}, "content": {"type": ["class"], "name": ["StackDepthLimitError"], "text": ["Raised when the message depth is greater than  1024"]}}, {"source": {"identifier": "ethereum.byzantium.vm.exceptions.WriteInStaticContext", "specifier": 0, "path": "src/ethereum/byzantium/vm/exceptions.py"}, "content": {"type": ["class"], "name": ["WriteInStaticContext"], "text": ["Raised when an attempt is made to modify the state while operating inside of a STATICCALL context."]}}, {"source": {"identifier": "ethereum.byzantium.vm.exceptions.OutOfBoundsRead", "specifier": 0, "path": "src/ethereum/byzantium/vm/exceptions.py"}, "content": {"type": ["class"], "name": ["OutOfBoundsRead"], "text": ["Raised when an attempt was made to read data beyond the boundaries of the buffer."]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.runtime", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/runtime.py"}, "content": {"type": ["module"], "name": ["ethereum.spurious_dragon.vm.runtime"], "text": ["Ethereum Virtual Machine (EVM) Runtime Operations ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Runtime related operations used while executing EVM code."]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.runtime.get_valid_jump_destinations", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/runtime.py"}, "content": {"type": ["function"], "name": ["get_valid_jump_destinations"], "text": ["Analyze the evm code to obtain the set of valid jump destinations. Valid jump destinations are defined as follows: * The jump destination is less than the length of the code. * The jump destination should have the  JUMPDEST  opcode (0x5B). * The jump destination shouldn't be part of the data corresponding to PUSH-N  opcodes. Note - Jump destinations are 0-indexed. Parameters code : The EVM code which is to be executed. Returns valid_jump_destinations:  Set[Uint] The set of valid jump destinations in the code."]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.precompiled_contracts.sha256", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/precompiled_contracts/sha256.py"}, "content": {"type": ["module"], "name": ["ethereum.muir_glacier.vm.precompiled_contracts.sha256"], "text": ["Ethereum Virtual Machine (EVM) SHA256 PRECOMPILED CONTRACT ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementation of the  SHA256  precompiled contract."]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.precompiled_contracts.sha256.sha256", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/precompiled_contracts/sha256.py"}, "content": {"type": ["function"], "name": ["sha256"], "text": ["Writes the sha256 hash to output. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum_optimized.tangerine_whistle.fork", "specifier": 0, "path": "src/ethereum_optimized/tangerine_whistle/fork.py"}, "content": {"type": ["module"], "name": ["ethereum_optimized.tangerine_whistle.fork"], "text": ["Optimized Spec ^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction This module contains functions can be monkey patched into ethereum.tangerine_whistle.fork  to use alternate optimized implementations."]}}, {"source": {"identifier": "ethereum_optimized.tangerine_whistle.fork.validate_proof_of_work", "specifier": 0, "path": "src/ethereum_optimized/tangerine_whistle/fork.py"}, "content": {"type": ["function"], "name": ["validate_proof_of_work"], "text": ["See  ethereum.tangerine_whistle.fork.validate_proof_of_work ."]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.system", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/system.py"}, "content": {"type": ["module"], "name": ["ethereum.shanghai.vm.instructions.system"], "text": ["Ethereum Virtual Machine (EVM) System Instructions ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementations of the EVM system related instructions."]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.system.generic_create", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/system.py"}, "content": {"type": ["function"], "name": ["generic_create"], "text": ["Core logic used by the  CREATE*  family of opcodes."]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.system.create", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/system.py"}, "content": {"type": ["function"], "name": ["create"], "text": ["Creates a new account with associated code. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.system.create2", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/system.py"}, "content": {"type": ["function"], "name": ["create2"], "text": ["Creates a new account with associated code. It's similar to CREATE opcode except that the address of new account depends on the init_code instead of the nonce of sender. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.system.return_", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/system.py"}, "content": {"type": ["function"], "name": ["return_"], "text": ["Halts execution returning output data. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.system.generic_call", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/system.py"}, "content": {"type": ["function"], "name": ["generic_call"], "text": ["Perform the core logic of the  CALL*  family of opcodes."]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.system.call", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/system.py"}, "content": {"type": ["function"], "name": ["call"], "text": ["Message-call into an account. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.system.callcode", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/system.py"}, "content": {"type": ["function"], "name": ["callcode"], "text": ["Message-call into this account with alternative account\u2019s code. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.system.selfdestruct", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/system.py"}, "content": {"type": ["function"], "name": ["selfdestruct"], "text": ["Halt execution and register account for later deletion. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.system.delegatecall", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/system.py"}, "content": {"type": ["function"], "name": ["delegatecall"], "text": ["Message-call into an account. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.system.staticcall", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/system.py"}, "content": {"type": ["function"], "name": ["staticcall"], "text": ["Message-call into an account. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.system.revert", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/system.py"}, "content": {"type": ["function"], "name": ["revert"], "text": ["Stop execution and revert state changes, without consuming all provided gas and also has the ability to return a reason Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.byzantium.vm", "specifier": 0, "path": "src/ethereum/byzantium/vm/__init__.py"}, "content": {"type": ["module"], "name": ["ethereum.byzantium.vm"], "text": ["Ethereum Virtual Machine (EVM) ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction The abstract computer which runs the code stored in an .fork_types.Account ."]}}, {"source": {"identifier": "ethereum.byzantium.vm.__all__", "specifier": 0, "path": "src/ethereum/byzantium/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["__all__"]}}, {"source": {"identifier": "ethereum.byzantium.vm.Environment", "specifier": 0, "path": "src/ethereum/byzantium/vm/__init__.py"}, "content": {"type": ["class"], "name": ["Environment"], "text": ["Items external to the virtual machine itself, provided by the environment."]}}, {"source": {"identifier": "ethereum.byzantium.vm.Environment.caller", "specifier": 0, "path": "src/ethereum/byzantium/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["caller"]}}, {"source": {"identifier": "ethereum.byzantium.vm.Environment.block_hashes", "specifier": 0, "path": "src/ethereum/byzantium/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["block_hashes"]}}, {"source": {"identifier": "ethereum.byzantium.vm.Environment.origin", "specifier": 0, "path": "src/ethereum/byzantium/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["origin"]}}, {"source": {"identifier": "ethereum.byzantium.vm.Environment.coinbase", "specifier": 0, "path": "src/ethereum/byzantium/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["coinbase"]}}, {"source": {"identifier": "ethereum.byzantium.vm.Environment.number", "specifier": 0, "path": "src/ethereum/byzantium/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["number"]}}, {"source": {"identifier": "ethereum.byzantium.vm.Environment.gas_limit", "specifier": 0, "path": "src/ethereum/byzantium/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["gas_limit"]}}, {"source": {"identifier": "ethereum.byzantium.vm.Environment.gas_price", "specifier": 0, "path": "src/ethereum/byzantium/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["gas_price"]}}, {"source": {"identifier": "ethereum.byzantium.vm.Environment.time", "specifier": 0, "path": "src/ethereum/byzantium/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["time"]}}, {"source": {"identifier": "ethereum.byzantium.vm.Environment.difficulty", "specifier": 0, "path": "src/ethereum/byzantium/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["difficulty"]}}, {"source": {"identifier": "ethereum.byzantium.vm.Environment.state", "specifier": 0, "path": "src/ethereum/byzantium/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["state"]}}, {"source": {"identifier": "ethereum.byzantium.vm.Message", "specifier": 0, "path": "src/ethereum/byzantium/vm/__init__.py"}, "content": {"type": ["class"], "name": ["Message"], "text": ["Items that are used by contract creation or message call."]}}, {"source": {"identifier": "ethereum.byzantium.vm.Message.caller", "specifier": 0, "path": "src/ethereum/byzantium/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["caller"]}}, {"source": {"identifier": "ethereum.byzantium.vm.Message.target", "specifier": 0, "path": "src/ethereum/byzantium/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["target"]}}, {"source": {"identifier": "ethereum.byzantium.vm.Message.current_target", "specifier": 0, "path": "src/ethereum/byzantium/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["current_target"]}}, {"source": {"identifier": "ethereum.byzantium.vm.Message.gas", "specifier": 0, "path": "src/ethereum/byzantium/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["gas"]}}, {"source": {"identifier": "ethereum.byzantium.vm.Message.value", "specifier": 0, "path": "src/ethereum/byzantium/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["value"]}}, {"source": {"identifier": "ethereum.byzantium.vm.Message.data", "specifier": 0, "path": "src/ethereum/byzantium/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["data"]}}, {"source": {"identifier": "ethereum.byzantium.vm.Message.code_address", "specifier": 0, "path": "src/ethereum/byzantium/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["code_address"]}}, {"source": {"identifier": "ethereum.byzantium.vm.Message.code", "specifier": 0, "path": "src/ethereum/byzantium/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["code"]}}, {"source": {"identifier": "ethereum.byzantium.vm.Message.depth", "specifier": 0, "path": "src/ethereum/byzantium/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["depth"]}}, {"source": {"identifier": "ethereum.byzantium.vm.Message.should_transfer_value", "specifier": 0, "path": "src/ethereum/byzantium/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["should_transfer_value"]}}, {"source": {"identifier": "ethereum.byzantium.vm.Message.is_static", "specifier": 0, "path": "src/ethereum/byzantium/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["is_static"]}}, {"source": {"identifier": "ethereum.byzantium.vm.Evm", "specifier": 0, "path": "src/ethereum/byzantium/vm/__init__.py"}, "content": {"type": ["class"], "name": ["Evm"], "text": ["The internal state of the virtual machine."]}}, {"source": {"identifier": "ethereum.byzantium.vm.Evm.pc", "specifier": 0, "path": "src/ethereum/byzantium/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["pc"]}}, {"source": {"identifier": "ethereum.byzantium.vm.Evm.stack", "specifier": 0, "path": "src/ethereum/byzantium/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["stack"]}}, {"source": {"identifier": "ethereum.byzantium.vm.Evm.memory", "specifier": 0, "path": "src/ethereum/byzantium/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["memory"]}}, {"source": {"identifier": "ethereum.byzantium.vm.Evm.code", "specifier": 0, "path": "src/ethereum/byzantium/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["code"]}}, {"source": {"identifier": "ethereum.byzantium.vm.Evm.gas_left", "specifier": 0, "path": "src/ethereum/byzantium/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["gas_left"]}}, {"source": {"identifier": "ethereum.byzantium.vm.Evm.env", "specifier": 0, "path": "src/ethereum/byzantium/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["env"]}}, {"source": {"identifier": "ethereum.byzantium.vm.Evm.valid_jump_destinations", "specifier": 0, "path": "src/ethereum/byzantium/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["valid_jump_destinations"]}}, {"source": {"identifier": "ethereum.byzantium.vm.Evm.logs", "specifier": 0, "path": "src/ethereum/byzantium/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["logs"]}}, {"source": {"identifier": "ethereum.byzantium.vm.Evm.refund_counter", "specifier": 0, "path": "src/ethereum/byzantium/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["refund_counter"]}}, {"source": {"identifier": "ethereum.byzantium.vm.Evm.running", "specifier": 0, "path": "src/ethereum/byzantium/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["running"]}}, {"source": {"identifier": "ethereum.byzantium.vm.Evm.message", "specifier": 0, "path": "src/ethereum/byzantium/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["message"]}}, {"source": {"identifier": "ethereum.byzantium.vm.Evm.output", "specifier": 0, "path": "src/ethereum/byzantium/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["output"]}}, {"source": {"identifier": "ethereum.byzantium.vm.Evm.accounts_to_delete", "specifier": 0, "path": "src/ethereum/byzantium/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["accounts_to_delete"]}}, {"source": {"identifier": "ethereum.byzantium.vm.Evm.touched_accounts", "specifier": 0, "path": "src/ethereum/byzantium/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["touched_accounts"]}}, {"source": {"identifier": "ethereum.byzantium.vm.Evm.has_erred", "specifier": 0, "path": "src/ethereum/byzantium/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["has_erred"]}}, {"source": {"identifier": "ethereum.byzantium.vm.Evm.return_data", "specifier": 0, "path": "src/ethereum/byzantium/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["return_data"]}}, {"source": {"identifier": "ethereum.byzantium.vm.Evm.error", "specifier": 0, "path": "src/ethereum/byzantium/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["error"]}}, {"source": {"identifier": "ethereum.byzantium.vm.incorporate_child_on_success", "specifier": 0, "path": "src/ethereum/byzantium/vm/__init__.py"}, "content": {"type": ["function"], "name": ["incorporate_child_on_success"], "text": ["Incorporate the state of a successful  child_evm  into the parent  evm . Parameters evm : The parent  EVM . child_evm : The child evm to incorporate."]}}, {"source": {"identifier": "ethereum.byzantium.vm.incorporate_child_on_error", "specifier": 0, "path": "src/ethereum/byzantium/vm/__init__.py"}, "content": {"type": ["function"], "name": ["incorporate_child_on_error"], "text": ["Incorporate the state of an unsuccessful  child_evm  into the parent  evm . Parameters evm : The parent  EVM . child_evm : The child evm to incorporate."]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.interpreter", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/interpreter.py"}, "content": {"type": ["module"], "name": ["ethereum.spurious_dragon.vm.interpreter"], "text": ["Ethereum Virtual Machine (EVM) Interpreter ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction A straightforward interpreter that executes EVM code."]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.interpreter.STACK_DEPTH_LIMIT", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/interpreter.py"}, "content": {"type": ["attribute"], "name": ["STACK_DEPTH_LIMIT"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.interpreter.MAX_CODE_SIZE", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/interpreter.py"}, "content": {"type": ["attribute"], "name": ["MAX_CODE_SIZE"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.interpreter.MessageCallOutput", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/interpreter.py"}, "content": {"type": ["class"], "name": ["MessageCallOutput"], "text": ["Output of a particular message call Contains the following:   1. `gas_left`: remaining gas after execution.\n  2. `refund_counter`: gas to refund after execution.\n  3. `logs`: list of `Log` generated during execution.\n  4. `accounts_to_delete`: Contracts which have self-destructed.\n  5. `touched_accounts`: Accounts that have been touched.\n  6. `has_erred`: True if execution has caused an error.\n"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.interpreter.MessageCallOutput.gas_left", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/interpreter.py"}, "content": {"type": ["attribute"], "name": ["gas_left"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.interpreter.MessageCallOutput.refund_counter", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/interpreter.py"}, "content": {"type": ["attribute"], "name": ["refund_counter"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.interpreter.MessageCallOutput.logs", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/interpreter.py"}, "content": {"type": ["attribute"], "name": ["logs"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.interpreter.MessageCallOutput.accounts_to_delete", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/interpreter.py"}, "content": {"type": ["attribute"], "name": ["accounts_to_delete"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.interpreter.MessageCallOutput.touched_accounts", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/interpreter.py"}, "content": {"type": ["attribute"], "name": ["touched_accounts"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.interpreter.MessageCallOutput.has_erred", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/interpreter.py"}, "content": {"type": ["attribute"], "name": ["has_erred"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.interpreter.process_message_call", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/interpreter.py"}, "content": {"type": ["function"], "name": ["process_message_call"], "text": ["If  message.current  is empty then it creates a smart contract else it executes a call from the  message.caller  to the  message.target . Parameters message : Transaction specific items. env : External items required for EVM execution. Returns output :  MessageCallOutput Output of the message call"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.interpreter.process_create_message", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/interpreter.py"}, "content": {"type": ["function"], "name": ["process_create_message"], "text": ["Executes a call to create a smart contract. Parameters message : Transaction specific items. env : External items required for EVM execution. Returns evm: :py:class: ~ethereum.spurious_dragon.vm.Evm Items containing execution specific objects."]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.interpreter.process_message", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/interpreter.py"}, "content": {"type": ["function"], "name": ["process_message"], "text": ["Executes a call to create a smart contract. Parameters message : Transaction specific items. env : External items required for EVM execution. Returns evm: :py:class: ~ethereum.spurious_dragon.vm.Evm Items containing execution specific objects"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.interpreter.execute_code", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/interpreter.py"}, "content": {"type": ["function"], "name": ["execute_code"], "text": ["Executes bytecode present in the  message . Parameters message : Transaction specific items. env : External items required for EVM execution. Returns evm:  ethereum.vm.EVM Items containing execution specific objects"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.precompiled_contracts.modexp", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/precompiled_contracts/modexp.py"}, "content": {"type": ["module"], "name": ["ethereum.muir_glacier.vm.precompiled_contracts.modexp"], "text": ["Ethereum Virtual Machine (EVM) MODEXP PRECOMPILED CONTRACT ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementation of the  MODEXP  precompiled contract."]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.precompiled_contracts.modexp.GQUADDIVISOR", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/precompiled_contracts/modexp.py"}, "content": {"type": ["attribute"], "name": ["GQUADDIVISOR"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.precompiled_contracts.modexp.modexp", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/precompiled_contracts/modexp.py"}, "content": {"type": ["function"], "name": ["modexp"], "text": ["Calculates  (base**exp) % modulus  for arbitary sized  base ,  exp  and. modulus . The return value is the same length as the modulus."]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.precompiled_contracts.modexp.get_mult_complexity", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/precompiled_contracts/modexp.py"}, "content": {"type": ["function"], "name": ["get_mult_complexity"], "text": ["Estimate the complexity of performing Karatsuba multiplication."]}}, {"source": {"identifier": "ethereum_optimized.spurious_dragon.state_db", "specifier": 0, "path": "src/ethereum_optimized/spurious_dragon/state_db.py"}, "content": {"type": ["module"], "name": ["ethereum_optimized.spurious_dragon.state_db"], "text": ["Optimized State ^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction This module contains functions can be monkey patched into ethereum.spurious_dragon.state  to use an optimized database backed state."]}}, {"source": {"identifier": "ethereum_optimized.spurious_dragon.state_db.UnmodifiedType", "specifier": 0, "path": "src/ethereum_optimized/spurious_dragon/state_db.py"}, "content": {"type": ["class"], "name": ["UnmodifiedType"], "text": ["Sentinal type to represent a value that hasn't been modified."]}}, {"source": {"identifier": "ethereum_optimized.spurious_dragon.state_db.Unmodified", "specifier": 0, "path": "src/ethereum_optimized/spurious_dragon/state_db.py"}, "content": {"type": ["attribute"], "name": ["Unmodified"]}}, {"source": {"identifier": "ethereum_optimized.spurious_dragon.state_db.State", "specifier": 0, "path": "src/ethereum_optimized/spurious_dragon/state_db.py"}, "content": {"type": ["class"], "name": ["State"], "text": ["The State, backed by a LMDB database. When created with  State()  store the db in a temporary directory. When created with  State(path)  open or create the db located at  path ."]}}, {"source": {"identifier": "ethereum_optimized.spurious_dragon.state_db.State.default_path", "specifier": 0, "path": "src/ethereum_optimized/spurious_dragon/state_db.py"}, "content": {"type": ["attribute"], "name": ["default_path"]}}, {"source": {"identifier": "ethereum_optimized.spurious_dragon.state_db.State.db", "specifier": 0, "path": "src/ethereum_optimized/spurious_dragon/state_db.py"}, "content": {"type": ["attribute"], "name": ["db"]}}, {"source": {"identifier": "ethereum_optimized.spurious_dragon.state_db.State.dirty_accounts", "specifier": 0, "path": "src/ethereum_optimized/spurious_dragon/state_db.py"}, "content": {"type": ["attribute"], "name": ["dirty_accounts"]}}, {"source": {"identifier": "ethereum_optimized.spurious_dragon.state_db.State.dirty_storage", "specifier": 0, "path": "src/ethereum_optimized/spurious_dragon/state_db.py"}, "content": {"type": ["attribute"], "name": ["dirty_storage"]}}, {"source": {"identifier": "ethereum_optimized.spurious_dragon.state_db.State.destroyed_accounts", "specifier": 0, "path": "src/ethereum_optimized/spurious_dragon/state_db.py"}, "content": {"type": ["attribute"], "name": ["destroyed_accounts"]}}, {"source": {"identifier": "ethereum_optimized.spurious_dragon.state_db.State.tx_restore_points", "specifier": 0, "path": "src/ethereum_optimized/spurious_dragon/state_db.py"}, "content": {"type": ["attribute"], "name": ["tx_restore_points"]}}, {"source": {"identifier": "ethereum_optimized.spurious_dragon.state_db.State.journal", "specifier": 0, "path": "src/ethereum_optimized/spurious_dragon/state_db.py"}, "content": {"type": ["attribute"], "name": ["journal"]}}, {"source": {"identifier": "ethereum_optimized.spurious_dragon.state_db.State.__init__", "specifier": 0, "path": "src/ethereum_optimized/spurious_dragon/state_db.py"}, "content": {"type": ["function"], "name": ["__init__"]}}, {"source": {"identifier": "ethereum_optimized.spurious_dragon.state_db.State.__eq__", "specifier": 0, "path": "src/ethereum_optimized/spurious_dragon/state_db.py"}, "content": {"type": ["function"], "name": ["__eq__"], "text": ["Test for equality by comparing state roots."]}}, {"source": {"identifier": "ethereum_optimized.spurious_dragon.state_db.State.__enter__", "specifier": 0, "path": "src/ethereum_optimized/spurious_dragon/state_db.py"}, "content": {"type": ["function"], "name": ["__enter__"], "text": ["Support with statements"]}}, {"source": {"identifier": "ethereum_optimized.spurious_dragon.state_db.State.__exit__", "specifier": 0, "path": "src/ethereum_optimized/spurious_dragon/state_db.py"}, "content": {"type": ["function"], "name": ["__exit__"], "text": ["Support with statements"]}}, {"source": {"identifier": "ethereum_optimized.spurious_dragon.state_db.close_state", "specifier": 0, "path": "src/ethereum_optimized/spurious_dragon/state_db.py"}, "content": {"type": ["function"], "name": ["close_state"], "text": ["Close a state, releasing all resources it holds"]}}, {"source": {"identifier": "ethereum_optimized.spurious_dragon.state_db.get_metadata", "specifier": 0, "path": "src/ethereum_optimized/spurious_dragon/state_db.py"}, "content": {"type": ["function"], "name": ["get_metadata"], "text": ["Get a piece of metadata"]}}, {"source": {"identifier": "ethereum_optimized.spurious_dragon.state_db.set_metadata", "specifier": 0, "path": "src/ethereum_optimized/spurious_dragon/state_db.py"}, "content": {"type": ["function"], "name": ["set_metadata"], "text": ["Set a piece of metadata"]}}, {"source": {"identifier": "ethereum_optimized.spurious_dragon.state_db.begin_db_transaction", "specifier": 0, "path": "src/ethereum_optimized/spurious_dragon/state_db.py"}, "content": {"type": ["function"], "name": ["begin_db_transaction"], "text": ["Start a database transaction. A transaction is automatically started when a State  is created. Nesting of DB transactions is not supported (unlike non-db transactions). No operations are supported when not in a transaction."]}}, {"source": {"identifier": "ethereum_optimized.spurious_dragon.state_db.commit_db_transaction", "specifier": 0, "path": "src/ethereum_optimized/spurious_dragon/state_db.py"}, "content": {"type": ["function"], "name": ["commit_db_transaction"], "text": ["Commit the current database transaction."]}}, {"source": {"identifier": "ethereum_optimized.spurious_dragon.state_db.state_root", "specifier": 0, "path": "src/ethereum_optimized/spurious_dragon/state_db.py"}, "content": {"type": ["function"], "name": ["state_root"], "text": ["See  ethereum.spurious_dragon.state ."]}}, {"source": {"identifier": "ethereum_optimized.spurious_dragon.state_db.storage_root", "specifier": 0, "path": "src/ethereum_optimized/spurious_dragon/state_db.py"}, "content": {"type": ["function"], "name": ["storage_root"], "text": ["See  ethereum.spurious_dragon.state ."]}}, {"source": {"identifier": "ethereum_optimized.spurious_dragon.state_db.flush", "specifier": 0, "path": "src/ethereum_optimized/spurious_dragon/state_db.py"}, "content": {"type": ["function"], "name": ["flush"], "text": ["Send everything in the internal caches to the Rust layer."]}}, {"source": {"identifier": "ethereum_optimized.spurious_dragon.state_db.rollback_db_transaction", "specifier": 0, "path": "src/ethereum_optimized/spurious_dragon/state_db.py"}, "content": {"type": ["function"], "name": ["rollback_db_transaction"], "text": ["Rollback the current database transaction."]}}, {"source": {"identifier": "ethereum_optimized.spurious_dragon.state_db.begin_transaction", "specifier": 0, "path": "src/ethereum_optimized/spurious_dragon/state_db.py"}, "content": {"type": ["function"], "name": ["begin_transaction"], "text": ["See  ethereum.spurious_dragon.state ."]}}, {"source": {"identifier": "ethereum_optimized.spurious_dragon.state_db.commit_transaction", "specifier": 0, "path": "src/ethereum_optimized/spurious_dragon/state_db.py"}, "content": {"type": ["function"], "name": ["commit_transaction"], "text": ["See  ethereum.spurious_dragon.state ."]}}, {"source": {"identifier": "ethereum_optimized.spurious_dragon.state_db.rollback_transaction", "specifier": 0, "path": "src/ethereum_optimized/spurious_dragon/state_db.py"}, "content": {"type": ["function"], "name": ["rollback_transaction"], "text": ["See  ethereum.spurious_dragon.state ."]}}, {"source": {"identifier": "ethereum_optimized.spurious_dragon.state_db.get_storage", "specifier": 0, "path": "src/ethereum_optimized/spurious_dragon/state_db.py"}, "content": {"type": ["function"], "name": ["get_storage"], "text": ["See  ethereum.spurious_dragon.state ."]}}, {"source": {"identifier": "ethereum_optimized.spurious_dragon.state_db.get_storage_original", "specifier": 0, "path": "src/ethereum_optimized/spurious_dragon/state_db.py"}, "content": {"type": ["function"], "name": ["get_storage_original"], "text": ["See  ethereum.istanbul.state ."]}}, {"source": {"identifier": "ethereum_optimized.spurious_dragon.state_db.set_storage", "specifier": 0, "path": "src/ethereum_optimized/spurious_dragon/state_db.py"}, "content": {"type": ["function"], "name": ["set_storage"], "text": ["See  ethereum.spurious_dragon.state ."]}}, {"source": {"identifier": "ethereum_optimized.spurious_dragon.state_db.get_account_optional", "specifier": 0, "path": "src/ethereum_optimized/spurious_dragon/state_db.py"}, "content": {"type": ["function"], "name": ["get_account_optional"], "text": ["See  ethereum.spurious_dragon.state ."]}}, {"source": {"identifier": "ethereum_optimized.spurious_dragon.state_db.set_account", "specifier": 0, "path": "src/ethereum_optimized/spurious_dragon/state_db.py"}, "content": {"type": ["function"], "name": ["set_account"], "text": ["See  ethereum.spurious_dragon.state ."]}}, {"source": {"identifier": "ethereum_optimized.spurious_dragon.state_db.destroy_storage", "specifier": 0, "path": "src/ethereum_optimized/spurious_dragon/state_db.py"}, "content": {"type": ["function"], "name": ["destroy_storage"], "text": ["See  ethereum.spurious_dragon.state ."]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/__init__.py"}, "content": {"type": ["module"], "name": ["ethereum.shanghai.vm.instructions"], "text": ["EVM Instruction Encoding (Opcodes) ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Machine readable representations of EVM instructions, and a mapping to their implementations."]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.Ops", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/__init__.py"}, "content": {"type": ["class"], "name": ["Ops"], "text": ["Enum for EVM Opcodes"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.Ops.ADD", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["ADD"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.Ops.MUL", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["MUL"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.Ops.SUB", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SUB"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.Ops.DIV", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DIV"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.Ops.SDIV", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SDIV"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.Ops.MOD", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["MOD"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.Ops.SMOD", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SMOD"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.Ops.ADDMOD", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["ADDMOD"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.Ops.MULMOD", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["MULMOD"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.Ops.EXP", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["EXP"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.Ops.SIGNEXTEND", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SIGNEXTEND"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.Ops.LT", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["LT"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.Ops.GT", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["GT"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.Ops.SLT", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SLT"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.Ops.SGT", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SGT"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.Ops.EQ", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["EQ"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.Ops.ISZERO", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["ISZERO"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.Ops.AND", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["AND"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.Ops.OR", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["OR"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.Ops.XOR", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["XOR"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.Ops.NOT", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["NOT"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.Ops.BYTE", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["BYTE"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.Ops.SHL", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SHL"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.Ops.SHR", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SHR"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.Ops.SAR", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SAR"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.Ops.KECCAK", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["KECCAK"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.Ops.ADDRESS", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["ADDRESS"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.Ops.BALANCE", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["BALANCE"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.Ops.ORIGIN", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["ORIGIN"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.Ops.CALLER", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["CALLER"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.Ops.CALLVALUE", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["CALLVALUE"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.Ops.CALLDATALOAD", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["CALLDATALOAD"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.Ops.CALLDATASIZE", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["CALLDATASIZE"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.Ops.CALLDATACOPY", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["CALLDATACOPY"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.Ops.CODESIZE", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["CODESIZE"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.Ops.CODECOPY", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["CODECOPY"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.Ops.GASPRICE", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["GASPRICE"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.Ops.EXTCODESIZE", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["EXTCODESIZE"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.Ops.EXTCODECOPY", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["EXTCODECOPY"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.Ops.RETURNDATASIZE", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["RETURNDATASIZE"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.Ops.RETURNDATACOPY", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["RETURNDATACOPY"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.Ops.EXTCODEHASH", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["EXTCODEHASH"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.Ops.BLOCKHASH", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["BLOCKHASH"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.Ops.COINBASE", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["COINBASE"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.Ops.TIMESTAMP", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["TIMESTAMP"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.Ops.NUMBER", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["NUMBER"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.Ops.PREVRANDAO", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PREVRANDAO"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.Ops.GASLIMIT", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["GASLIMIT"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.Ops.CHAINID", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["CHAINID"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.Ops.SELFBALANCE", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SELFBALANCE"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.Ops.BASEFEE", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["BASEFEE"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.Ops.STOP", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["STOP"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.Ops.JUMP", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["JUMP"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.Ops.JUMPI", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["JUMPI"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.Ops.PC", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PC"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.Ops.GAS", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["GAS"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.Ops.JUMPDEST", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["JUMPDEST"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.Ops.SLOAD", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SLOAD"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.Ops.SSTORE", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SSTORE"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.Ops.POP", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["POP"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.Ops.PUSH0", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH0"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.Ops.PUSH1", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH1"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.Ops.PUSH2", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH2"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.Ops.PUSH3", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH3"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.Ops.PUSH4", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH4"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.Ops.PUSH5", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH5"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.Ops.PUSH6", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH6"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.Ops.PUSH7", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH7"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.Ops.PUSH8", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH8"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.Ops.PUSH9", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH9"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.Ops.PUSH10", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH10"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.Ops.PUSH11", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH11"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.Ops.PUSH12", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH12"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.Ops.PUSH13", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH13"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.Ops.PUSH14", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH14"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.Ops.PUSH15", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH15"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.Ops.PUSH16", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH16"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.Ops.PUSH17", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH17"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.Ops.PUSH18", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH18"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.Ops.PUSH19", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH19"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.Ops.PUSH20", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH20"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.Ops.PUSH21", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH21"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.Ops.PUSH22", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH22"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.Ops.PUSH23", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH23"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.Ops.PUSH24", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH24"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.Ops.PUSH25", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH25"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.Ops.PUSH26", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH26"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.Ops.PUSH27", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH27"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.Ops.PUSH28", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH28"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.Ops.PUSH29", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH29"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.Ops.PUSH30", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH30"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.Ops.PUSH31", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH31"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.Ops.PUSH32", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH32"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.Ops.DUP1", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP1"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.Ops.DUP2", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP2"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.Ops.DUP3", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP3"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.Ops.DUP4", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP4"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.Ops.DUP5", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP5"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.Ops.DUP6", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP6"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.Ops.DUP7", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP7"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.Ops.DUP8", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP8"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.Ops.DUP9", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP9"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.Ops.DUP10", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP10"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.Ops.DUP11", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP11"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.Ops.DUP12", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP12"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.Ops.DUP13", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP13"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.Ops.DUP14", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP14"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.Ops.DUP15", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP15"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.Ops.DUP16", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP16"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.Ops.SWAP1", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP1"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.Ops.SWAP2", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP2"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.Ops.SWAP3", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP3"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.Ops.SWAP4", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP4"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.Ops.SWAP5", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP5"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.Ops.SWAP6", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP6"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.Ops.SWAP7", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP7"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.Ops.SWAP8", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP8"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.Ops.SWAP9", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP9"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.Ops.SWAP10", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP10"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.Ops.SWAP11", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP11"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.Ops.SWAP12", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP12"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.Ops.SWAP13", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP13"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.Ops.SWAP14", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP14"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.Ops.SWAP15", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP15"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.Ops.SWAP16", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP16"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.Ops.MLOAD", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["MLOAD"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.Ops.MSTORE", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["MSTORE"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.Ops.MSTORE8", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["MSTORE8"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.Ops.MSIZE", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["MSIZE"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.Ops.LOG0", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["LOG0"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.Ops.LOG1", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["LOG1"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.Ops.LOG2", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["LOG2"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.Ops.LOG3", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["LOG3"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.Ops.LOG4", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["LOG4"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.Ops.CREATE", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["CREATE"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.Ops.RETURN", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["RETURN"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.Ops.CALL", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["CALL"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.Ops.CALLCODE", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["CALLCODE"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.Ops.DELEGATECALL", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DELEGATECALL"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.Ops.STATICCALL", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["STATICCALL"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.Ops.REVERT", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["REVERT"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.Ops.SELFDESTRUCT", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SELFDESTRUCT"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.Ops.CREATE2", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["CREATE2"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.op_implementation", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["op_implementation"]}}, {"source": {"identifier": "ethereum.byzantium.vm.runtime", "specifier": 0, "path": "src/ethereum/byzantium/vm/runtime.py"}, "content": {"type": ["module"], "name": ["ethereum.byzantium.vm.runtime"], "text": ["Ethereum Virtual Machine (EVM) Runtime Operations ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Runtime related operations used while executing EVM code."]}}, {"source": {"identifier": "ethereum.byzantium.vm.runtime.get_valid_jump_destinations", "specifier": 0, "path": "src/ethereum/byzantium/vm/runtime.py"}, "content": {"type": ["function"], "name": ["get_valid_jump_destinations"], "text": ["Analyze the evm code to obtain the set of valid jump destinations. Valid jump destinations are defined as follows: * The jump destination is less than the length of the code. * The jump destination should have the  JUMPDEST  opcode (0x5B). * The jump destination shouldn't be part of the data corresponding to PUSH-N  opcodes. Note - Jump destinations are 0-indexed. Parameters code : The EVM code which is to be executed. Returns valid_jump_destinations:  Set[Uint] The set of valid jump destinations in the code."]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.stack", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/stack.py"}, "content": {"type": ["module"], "name": ["ethereum.spurious_dragon.vm.stack"], "text": ["Ethereum Virtual Machine (EVM) Stack ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementation of the stack operators for the EVM."]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.stack.pop", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/stack.py"}, "content": {"type": ["function"], "name": ["pop"], "text": ["Pops the top item off of  stack . Parameters stack : EVM stack. Returns value :  U256 The top element on the stack."]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.stack.push", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/stack.py"}, "content": {"type": ["function"], "name": ["push"], "text": ["Pushes  value  onto  stack . Parameters stack : EVM stack. value : Item to be pushed onto  stack ."]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.precompiled_contracts.ecrecover", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/precompiled_contracts/ecrecover.py"}, "content": {"type": ["module"], "name": ["ethereum.muir_glacier.vm.precompiled_contracts.ecrecover"], "text": ["Ethereum Virtual Machine (EVM) ECRECOVER PRECOMPILED CONTRACT ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementation of the ECRECOVER precompiled contract."]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.precompiled_contracts.ecrecover.ecrecover", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/precompiled_contracts/ecrecover.py"}, "content": {"type": ["function"], "name": ["ecrecover"], "text": ["Decrypts the address using elliptic curve DSA recovery mechanism and writes the address to output. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum_optimized.homestead.fork", "specifier": 0, "path": "src/ethereum_optimized/homestead/fork.py"}, "content": {"type": ["module"], "name": ["ethereum_optimized.homestead.fork"], "text": ["Optimized Spec ^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction This module contains functions can be monkey patched into ethereum.homestead.fork  to use alternate optimized implementations."]}}, {"source": {"identifier": "ethereum_optimized.homestead.fork.validate_proof_of_work", "specifier": 0, "path": "src/ethereum_optimized/homestead/fork.py"}, "content": {"type": ["function"], "name": ["validate_proof_of_work"], "text": ["See  ethereum.homestead.fork.validate_proof_of_work ."]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.control_flow", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/control_flow.py"}, "content": {"type": ["module"], "name": ["ethereum.shanghai.vm.instructions.control_flow"], "text": ["Ethereum Virtual Machine (EVM) Control Flow Instructions ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementations of the EVM control flow instructions."]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.control_flow.stop", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/control_flow.py"}, "content": {"type": ["function"], "name": ["stop"], "text": ["Stop further execution of EVM code. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.control_flow.jump", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/control_flow.py"}, "content": {"type": ["function"], "name": ["jump"], "text": ["Alter the program counter to the location specified by the top of the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.control_flow.jumpi", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/control_flow.py"}, "content": {"type": ["function"], "name": ["jumpi"], "text": ["Alter the program counter to the specified location if and only if a condition is true. If the condition is not true, then the program counter would increase only by 1. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.control_flow.pc", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/control_flow.py"}, "content": {"type": ["function"], "name": ["pc"], "text": ["Push onto the stack the value of the program counter after reaching the current instruction and without increasing it for the next instruction. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.control_flow.gas_left", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/control_flow.py"}, "content": {"type": ["function"], "name": ["gas_left"], "text": ["Push the amount of available gas (including the corresponding reduction for the cost of this instruction) onto the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.control_flow.jumpdest", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/control_flow.py"}, "content": {"type": ["function"], "name": ["jumpdest"], "text": ["Mark a valid destination for jumps. This is a noop, present only to be used by  JUMP  and  JUMPI  opcodes to verify that their jump is valid. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.byzantium.vm.interpreter", "specifier": 0, "path": "src/ethereum/byzantium/vm/interpreter.py"}, "content": {"type": ["module"], "name": ["ethereum.byzantium.vm.interpreter"], "text": ["Ethereum Virtual Machine (EVM) Interpreter ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction A straightforward interpreter that executes EVM code."]}}, {"source": {"identifier": "ethereum.byzantium.vm.interpreter.STACK_DEPTH_LIMIT", "specifier": 0, "path": "src/ethereum/byzantium/vm/interpreter.py"}, "content": {"type": ["attribute"], "name": ["STACK_DEPTH_LIMIT"]}}, {"source": {"identifier": "ethereum.byzantium.vm.interpreter.MAX_CODE_SIZE", "specifier": 0, "path": "src/ethereum/byzantium/vm/interpreter.py"}, "content": {"type": ["attribute"], "name": ["MAX_CODE_SIZE"]}}, {"source": {"identifier": "ethereum.byzantium.vm.interpreter.MessageCallOutput", "specifier": 0, "path": "src/ethereum/byzantium/vm/interpreter.py"}, "content": {"type": ["class"], "name": ["MessageCallOutput"], "text": ["Output of a particular message call Contains the following:   1. `gas_left`: remaining gas after execution.\n  2. `refund_counter`: gas to refund after execution.\n  3. `logs`: list of `Log` generated during execution.\n  4. `accounts_to_delete`: Contracts which have self-destructed.\n  5. `touched_accounts`: Accounts that have been touched.\n  6. `has_erred`: True if execution has caused an error.\n"]}}, {"source": {"identifier": "ethereum.byzantium.vm.interpreter.MessageCallOutput.gas_left", "specifier": 0, "path": "src/ethereum/byzantium/vm/interpreter.py"}, "content": {"type": ["attribute"], "name": ["gas_left"]}}, {"source": {"identifier": "ethereum.byzantium.vm.interpreter.MessageCallOutput.refund_counter", "specifier": 0, "path": "src/ethereum/byzantium/vm/interpreter.py"}, "content": {"type": ["attribute"], "name": ["refund_counter"]}}, {"source": {"identifier": "ethereum.byzantium.vm.interpreter.MessageCallOutput.logs", "specifier": 0, "path": "src/ethereum/byzantium/vm/interpreter.py"}, "content": {"type": ["attribute"], "name": ["logs"]}}, {"source": {"identifier": "ethereum.byzantium.vm.interpreter.MessageCallOutput.accounts_to_delete", "specifier": 0, "path": "src/ethereum/byzantium/vm/interpreter.py"}, "content": {"type": ["attribute"], "name": ["accounts_to_delete"]}}, {"source": {"identifier": "ethereum.byzantium.vm.interpreter.MessageCallOutput.touched_accounts", "specifier": 0, "path": "src/ethereum/byzantium/vm/interpreter.py"}, "content": {"type": ["attribute"], "name": ["touched_accounts"]}}, {"source": {"identifier": "ethereum.byzantium.vm.interpreter.MessageCallOutput.has_erred", "specifier": 0, "path": "src/ethereum/byzantium/vm/interpreter.py"}, "content": {"type": ["attribute"], "name": ["has_erred"]}}, {"source": {"identifier": "ethereum.byzantium.vm.interpreter.process_message_call", "specifier": 0, "path": "src/ethereum/byzantium/vm/interpreter.py"}, "content": {"type": ["function"], "name": ["process_message_call"], "text": ["If  message.current  is empty then it creates a smart contract else it executes a call from the  message.caller  to the  message.target . Parameters message : Transaction specific items. env : External items required for EVM execution. Returns output :  MessageCallOutput Output of the message call"]}}, {"source": {"identifier": "ethereum.byzantium.vm.interpreter.process_create_message", "specifier": 0, "path": "src/ethereum/byzantium/vm/interpreter.py"}, "content": {"type": ["function"], "name": ["process_create_message"], "text": ["Executes a call to create a smart contract. Parameters message : Transaction specific items. env : External items required for EVM execution. Returns evm: :py:class: ~ethereum.byzantium.vm.Evm Items containing execution specific objects."]}}, {"source": {"identifier": "ethereum.byzantium.vm.interpreter.process_message", "specifier": 0, "path": "src/ethereum/byzantium/vm/interpreter.py"}, "content": {"type": ["function"], "name": ["process_message"], "text": ["Executes a call to create a smart contract. Parameters message : Transaction specific items. env : External items required for EVM execution. Returns evm: :py:class: ~ethereum.byzantium.vm.Evm Items containing execution specific objects"]}}, {"source": {"identifier": "ethereum.byzantium.vm.interpreter.execute_code", "specifier": 0, "path": "src/ethereum/byzantium/vm/interpreter.py"}, "content": {"type": ["function"], "name": ["execute_code"], "text": ["Executes bytecode present in the  message . Parameters message : Transaction specific items. env : External items required for EVM execution. Returns evm:  ethereum.vm.EVM Items containing execution specific objects"]}}, {"source": {"identifier": "ethereum_optimized.tangerine_whistle.state_db", "specifier": 0, "path": "src/ethereum_optimized/tangerine_whistle/state_db.py"}, "content": {"type": ["module"], "name": ["ethereum_optimized.tangerine_whistle.state_db"], "text": ["Optimized State ^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction This module contains functions can be monkey patched into ethereum.tangerine_whistle.state  to use an optimized database backed state."]}}, {"source": {"identifier": "ethereum_optimized.tangerine_whistle.state_db.UnmodifiedType", "specifier": 0, "path": "src/ethereum_optimized/tangerine_whistle/state_db.py"}, "content": {"type": ["class"], "name": ["UnmodifiedType"], "text": ["Sentinal type to represent a value that hasn't been modified."]}}, {"source": {"identifier": "ethereum_optimized.tangerine_whistle.state_db.Unmodified", "specifier": 0, "path": "src/ethereum_optimized/tangerine_whistle/state_db.py"}, "content": {"type": ["attribute"], "name": ["Unmodified"]}}, {"source": {"identifier": "ethereum_optimized.tangerine_whistle.state_db.State", "specifier": 0, "path": "src/ethereum_optimized/tangerine_whistle/state_db.py"}, "content": {"type": ["class"], "name": ["State"], "text": ["The State, backed by a LMDB database. When created with  State()  store the db in a temporary directory. When created with  State(path)  open or create the db located at  path ."]}}, {"source": {"identifier": "ethereum_optimized.tangerine_whistle.state_db.State.default_path", "specifier": 0, "path": "src/ethereum_optimized/tangerine_whistle/state_db.py"}, "content": {"type": ["attribute"], "name": ["default_path"]}}, {"source": {"identifier": "ethereum_optimized.tangerine_whistle.state_db.State.db", "specifier": 0, "path": "src/ethereum_optimized/tangerine_whistle/state_db.py"}, "content": {"type": ["attribute"], "name": ["db"]}}, {"source": {"identifier": "ethereum_optimized.tangerine_whistle.state_db.State.dirty_accounts", "specifier": 0, "path": "src/ethereum_optimized/tangerine_whistle/state_db.py"}, "content": {"type": ["attribute"], "name": ["dirty_accounts"]}}, {"source": {"identifier": "ethereum_optimized.tangerine_whistle.state_db.State.dirty_storage", "specifier": 0, "path": "src/ethereum_optimized/tangerine_whistle/state_db.py"}, "content": {"type": ["attribute"], "name": ["dirty_storage"]}}, {"source": {"identifier": "ethereum_optimized.tangerine_whistle.state_db.State.destroyed_accounts", "specifier": 0, "path": "src/ethereum_optimized/tangerine_whistle/state_db.py"}, "content": {"type": ["attribute"], "name": ["destroyed_accounts"]}}, {"source": {"identifier": "ethereum_optimized.tangerine_whistle.state_db.State.tx_restore_points", "specifier": 0, "path": "src/ethereum_optimized/tangerine_whistle/state_db.py"}, "content": {"type": ["attribute"], "name": ["tx_restore_points"]}}, {"source": {"identifier": "ethereum_optimized.tangerine_whistle.state_db.State.journal", "specifier": 0, "path": "src/ethereum_optimized/tangerine_whistle/state_db.py"}, "content": {"type": ["attribute"], "name": ["journal"]}}, {"source": {"identifier": "ethereum_optimized.tangerine_whistle.state_db.State.__init__", "specifier": 0, "path": "src/ethereum_optimized/tangerine_whistle/state_db.py"}, "content": {"type": ["function"], "name": ["__init__"]}}, {"source": {"identifier": "ethereum_optimized.tangerine_whistle.state_db.State.__eq__", "specifier": 0, "path": "src/ethereum_optimized/tangerine_whistle/state_db.py"}, "content": {"type": ["function"], "name": ["__eq__"], "text": ["Test for equality by comparing state roots."]}}, {"source": {"identifier": "ethereum_optimized.tangerine_whistle.state_db.State.__enter__", "specifier": 0, "path": "src/ethereum_optimized/tangerine_whistle/state_db.py"}, "content": {"type": ["function"], "name": ["__enter__"], "text": ["Support with statements"]}}, {"source": {"identifier": "ethereum_optimized.tangerine_whistle.state_db.State.__exit__", "specifier": 0, "path": "src/ethereum_optimized/tangerine_whistle/state_db.py"}, "content": {"type": ["function"], "name": ["__exit__"], "text": ["Support with statements"]}}, {"source": {"identifier": "ethereum_optimized.tangerine_whistle.state_db.close_state", "specifier": 0, "path": "src/ethereum_optimized/tangerine_whistle/state_db.py"}, "content": {"type": ["function"], "name": ["close_state"], "text": ["Close a state, releasing all resources it holds"]}}, {"source": {"identifier": "ethereum_optimized.tangerine_whistle.state_db.get_metadata", "specifier": 0, "path": "src/ethereum_optimized/tangerine_whistle/state_db.py"}, "content": {"type": ["function"], "name": ["get_metadata"], "text": ["Get a piece of metadata"]}}, {"source": {"identifier": "ethereum_optimized.tangerine_whistle.state_db.set_metadata", "specifier": 0, "path": "src/ethereum_optimized/tangerine_whistle/state_db.py"}, "content": {"type": ["function"], "name": ["set_metadata"], "text": ["Set a piece of metadata"]}}, {"source": {"identifier": "ethereum_optimized.tangerine_whistle.state_db.begin_db_transaction", "specifier": 0, "path": "src/ethereum_optimized/tangerine_whistle/state_db.py"}, "content": {"type": ["function"], "name": ["begin_db_transaction"], "text": ["Start a database transaction. A transaction is automatically started when a State  is created. Nesting of DB transactions is not supported (unlike non-db transactions). No operations are supported when not in a transaction."]}}, {"source": {"identifier": "ethereum_optimized.tangerine_whistle.state_db.commit_db_transaction", "specifier": 0, "path": "src/ethereum_optimized/tangerine_whistle/state_db.py"}, "content": {"type": ["function"], "name": ["commit_db_transaction"], "text": ["Commit the current database transaction."]}}, {"source": {"identifier": "ethereum_optimized.tangerine_whistle.state_db.state_root", "specifier": 0, "path": "src/ethereum_optimized/tangerine_whistle/state_db.py"}, "content": {"type": ["function"], "name": ["state_root"], "text": ["See  ethereum.tangerine_whistle.state ."]}}, {"source": {"identifier": "ethereum_optimized.tangerine_whistle.state_db.storage_root", "specifier": 0, "path": "src/ethereum_optimized/tangerine_whistle/state_db.py"}, "content": {"type": ["function"], "name": ["storage_root"], "text": ["See  ethereum.tangerine_whistle.state ."]}}, {"source": {"identifier": "ethereum_optimized.tangerine_whistle.state_db.flush", "specifier": 0, "path": "src/ethereum_optimized/tangerine_whistle/state_db.py"}, "content": {"type": ["function"], "name": ["flush"], "text": ["Send everything in the internal caches to the Rust layer."]}}, {"source": {"identifier": "ethereum_optimized.tangerine_whistle.state_db.rollback_db_transaction", "specifier": 0, "path": "src/ethereum_optimized/tangerine_whistle/state_db.py"}, "content": {"type": ["function"], "name": ["rollback_db_transaction"], "text": ["Rollback the current database transaction."]}}, {"source": {"identifier": "ethereum_optimized.tangerine_whistle.state_db.begin_transaction", "specifier": 0, "path": "src/ethereum_optimized/tangerine_whistle/state_db.py"}, "content": {"type": ["function"], "name": ["begin_transaction"], "text": ["See  ethereum.tangerine_whistle.state ."]}}, {"source": {"identifier": "ethereum_optimized.tangerine_whistle.state_db.commit_transaction", "specifier": 0, "path": "src/ethereum_optimized/tangerine_whistle/state_db.py"}, "content": {"type": ["function"], "name": ["commit_transaction"], "text": ["See  ethereum.tangerine_whistle.state ."]}}, {"source": {"identifier": "ethereum_optimized.tangerine_whistle.state_db.rollback_transaction", "specifier": 0, "path": "src/ethereum_optimized/tangerine_whistle/state_db.py"}, "content": {"type": ["function"], "name": ["rollback_transaction"], "text": ["See  ethereum.tangerine_whistle.state ."]}}, {"source": {"identifier": "ethereum_optimized.tangerine_whistle.state_db.get_storage", "specifier": 0, "path": "src/ethereum_optimized/tangerine_whistle/state_db.py"}, "content": {"type": ["function"], "name": ["get_storage"], "text": ["See  ethereum.tangerine_whistle.state ."]}}, {"source": {"identifier": "ethereum_optimized.tangerine_whistle.state_db.get_storage_original", "specifier": 0, "path": "src/ethereum_optimized/tangerine_whistle/state_db.py"}, "content": {"type": ["function"], "name": ["get_storage_original"], "text": ["See  ethereum.istanbul.state ."]}}, {"source": {"identifier": "ethereum_optimized.tangerine_whistle.state_db.set_storage", "specifier": 0, "path": "src/ethereum_optimized/tangerine_whistle/state_db.py"}, "content": {"type": ["function"], "name": ["set_storage"], "text": ["See  ethereum.tangerine_whistle.state ."]}}, {"source": {"identifier": "ethereum_optimized.tangerine_whistle.state_db.get_account_optional", "specifier": 0, "path": "src/ethereum_optimized/tangerine_whistle/state_db.py"}, "content": {"type": ["function"], "name": ["get_account_optional"], "text": ["See  ethereum.tangerine_whistle.state ."]}}, {"source": {"identifier": "ethereum_optimized.tangerine_whistle.state_db.set_account", "specifier": 0, "path": "src/ethereum_optimized/tangerine_whistle/state_db.py"}, "content": {"type": ["function"], "name": ["set_account"], "text": ["See  ethereum.tangerine_whistle.state ."]}}, {"source": {"identifier": "ethereum_optimized.tangerine_whistle.state_db.destroy_storage", "specifier": 0, "path": "src/ethereum_optimized/tangerine_whistle/state_db.py"}, "content": {"type": ["function"], "name": ["destroy_storage"], "text": ["See  ethereum.tangerine_whistle.state ."]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.gas", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/gas.py"}, "content": {"type": ["module"], "name": ["ethereum.spurious_dragon.vm.gas"], "text": ["Ethereum Virtual Machine (EVM) Gas ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction EVM gas constants and calculators."]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.gas.GAS_JUMPDEST", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_JUMPDEST"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.gas.GAS_BASE", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_BASE"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.gas.GAS_VERY_LOW", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_VERY_LOW"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.gas.GAS_SLOAD", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_SLOAD"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.gas.GAS_STORAGE_SET", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_STORAGE_SET"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.gas.GAS_STORAGE_UPDATE", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_STORAGE_UPDATE"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.gas.GAS_STORAGE_CLEAR_REFUND", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_STORAGE_CLEAR_REFUND"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.gas.GAS_LOW", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_LOW"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.gas.GAS_MID", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_MID"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.gas.GAS_HIGH", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_HIGH"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.gas.GAS_EXPONENTIATION", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_EXPONENTIATION"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.gas.GAS_EXPONENTIATION_PER_BYTE", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_EXPONENTIATION_PER_BYTE"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.gas.GAS_MEMORY", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_MEMORY"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.gas.GAS_KECCAK256", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_KECCAK256"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.gas.GAS_KECCAK256_WORD", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_KECCAK256_WORD"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.gas.GAS_COPY", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_COPY"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.gas.GAS_BLOCK_HASH", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_BLOCK_HASH"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.gas.GAS_EXTERNAL", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_EXTERNAL"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.gas.GAS_BALANCE", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_BALANCE"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.gas.GAS_LOG", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_LOG"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.gas.GAS_LOG_DATA", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_LOG_DATA"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.gas.GAS_LOG_TOPIC", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_LOG_TOPIC"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.gas.GAS_CREATE", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_CREATE"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.gas.GAS_CODE_DEPOSIT", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_CODE_DEPOSIT"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.gas.GAS_ZERO", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_ZERO"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.gas.GAS_CALL", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_CALL"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.gas.GAS_NEW_ACCOUNT", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_NEW_ACCOUNT"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.gas.GAS_CALL_VALUE", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_CALL_VALUE"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.gas.GAS_CALL_STIPEND", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_CALL_STIPEND"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.gas.GAS_SELF_DESTRUCT", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_SELF_DESTRUCT"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.gas.GAS_SELF_DESTRUCT_NEW_ACCOUNT", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_SELF_DESTRUCT_NEW_ACCOUNT"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.gas.REFUND_SELF_DESTRUCT", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["REFUND_SELF_DESTRUCT"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.gas.GAS_ECRECOVER", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_ECRECOVER"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.gas.GAS_SHA256", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_SHA256"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.gas.GAS_SHA256_WORD", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_SHA256_WORD"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.gas.GAS_RIPEMD160", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_RIPEMD160"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.gas.GAS_RIPEMD160_WORD", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_RIPEMD160_WORD"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.gas.GAS_IDENTITY", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_IDENTITY"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.gas.GAS_IDENTITY_WORD", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_IDENTITY_WORD"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.gas.ExtendMemory", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/gas.py"}, "content": {"type": ["class"], "name": ["ExtendMemory"], "text": ["Define the parameters for memory extension in opcodes cost :  ethereum.base_types.Uint The gas required to perform the extension expand_by :  ethereum.base_types.Uint The size by which the memory will be extended"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.gas.ExtendMemory.cost", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["cost"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.gas.ExtendMemory.expand_by", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["expand_by"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.gas.MessageCallGas", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/gas.py"}, "content": {"type": ["class"], "name": ["MessageCallGas"], "text": ["Define the gas cost and stipend for executing the call opcodes. cost :  ethereum.base_types.Uint The non-refundable portion of gas reserved for executing the call opcode. stipend :  ethereum.base_types.Uint The portion of gas available to sub-calls that is refundable if not consumed"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.gas.MessageCallGas.cost", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["cost"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.gas.MessageCallGas.stipend", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["stipend"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.gas.charge_gas", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/gas.py"}, "content": {"type": ["function"], "name": ["charge_gas"], "text": ["Subtracts  amount  from  evm.gas_left . Parameters evm : The current EVM. amount : The amount of gas the current operation requires."]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.gas.calculate_memory_gas_cost", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/gas.py"}, "content": {"type": ["function"], "name": ["calculate_memory_gas_cost"], "text": ["Calculates the gas cost for allocating memory to the smallest multiple of 32 bytes, such that the allocated size is at least as big as the given size. Parameters size_in_bytes : The size of the data in bytes. Returns total_gas_cost :  ethereum.base_types.Uint The gas cost for storing data in memory."]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.gas.calculate_gas_extend_memory", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/gas.py"}, "content": {"type": ["function"], "name": ["calculate_gas_extend_memory"], "text": ["Calculates the gas amount to extend memory Parameters memory : Memory contents of the EVM. extensions: List of extensions to be made to the memory. Consists of a tuple of start position and size. Returns extend_memory:  ExtendMemory"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.gas.calculate_message_call_gas", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/gas.py"}, "content": {"type": ["function"], "name": ["calculate_message_call_gas"], "text": ["Calculates the MessageCallGas (cost and stipend) for executing call Opcodes. Parameters value: The amount of  ETH  that needs to be transferred. gas : The amount of gas provided to the message-call. gas_left : The amount of gas left in the current frame. memory_cost : The amount needed to extend the memory in the current frame. extra_gas : The amount of gas needed for transferring value + creating a new account inside a message call. call_stipend : The amount of stipend provided to a message call to execute code while transferring value(ETH). Returns message_call_gas:  MessageCallGas"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.gas.max_message_call_gas", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/gas.py"}, "content": {"type": ["function"], "name": ["max_message_call_gas"], "text": ["Calculates the maximum gas that is allowed for making a message call Parameters gas : The amount of gas provided to the message-call. Returns max_allowed_message_call_gas:  ethereum.base_types.Uint The maximum gas allowed for making the message-call."]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.precompiled_contracts.identity", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/precompiled_contracts/identity.py"}, "content": {"type": ["module"], "name": ["ethereum.muir_glacier.vm.precompiled_contracts.identity"], "text": ["Ethereum Virtual Machine (EVM) IDENTITY PRECOMPILED CONTRACT ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementation of the  IDENTITY  precompiled contract."]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.precompiled_contracts.identity.identity", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/precompiled_contracts/identity.py"}, "content": {"type": ["function"], "name": ["identity"], "text": ["Writes the message data to output. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.comparison", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/comparison.py"}, "content": {"type": ["module"], "name": ["ethereum.shanghai.vm.instructions.comparison"], "text": ["Ethereum Virtual Machine (EVM) Comparison Instructions ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementations of the EVM Comparison instructions."]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.comparison.less_than", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/comparison.py"}, "content": {"type": ["function"], "name": ["less_than"], "text": ["Checks if the top element is less than the next top element. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.comparison.signed_less_than", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/comparison.py"}, "content": {"type": ["function"], "name": ["signed_less_than"], "text": ["Signed less-than comparison. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.comparison.greater_than", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/comparison.py"}, "content": {"type": ["function"], "name": ["greater_than"], "text": ["Checks if the top element is greater than the next top element. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.comparison.signed_greater_than", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/comparison.py"}, "content": {"type": ["function"], "name": ["signed_greater_than"], "text": ["Signed greater-than comparison. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.comparison.equal", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/comparison.py"}, "content": {"type": ["function"], "name": ["equal"], "text": ["Checks if the top element is equal to the next top element. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.comparison.is_zero", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/comparison.py"}, "content": {"type": ["function"], "name": ["is_zero"], "text": ["Checks if the top element is equal to 0. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum_optimized.berlin.state_db", "specifier": 0, "path": "src/ethereum_optimized/berlin/state_db.py"}, "content": {"type": ["module"], "name": ["ethereum_optimized.berlin.state_db"], "text": ["Optimized State ^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction This module contains functions can be monkey patched into ethereum.berlin.state  to use an optimized database backed state."]}}, {"source": {"identifier": "ethereum_optimized.berlin.state_db.UnmodifiedType", "specifier": 0, "path": "src/ethereum_optimized/berlin/state_db.py"}, "content": {"type": ["class"], "name": ["UnmodifiedType"], "text": ["Sentinal type to represent a value that hasn't been modified."]}}, {"source": {"identifier": "ethereum_optimized.berlin.state_db.Unmodified", "specifier": 0, "path": "src/ethereum_optimized/berlin/state_db.py"}, "content": {"type": ["attribute"], "name": ["Unmodified"]}}, {"source": {"identifier": "ethereum_optimized.berlin.state_db.State", "specifier": 0, "path": "src/ethereum_optimized/berlin/state_db.py"}, "content": {"type": ["class"], "name": ["State"], "text": ["The State, backed by a LMDB database. When created with  State()  store the db in a temporary directory. When created with  State(path)  open or create the db located at  path ."]}}, {"source": {"identifier": "ethereum_optimized.berlin.state_db.State.default_path", "specifier": 0, "path": "src/ethereum_optimized/berlin/state_db.py"}, "content": {"type": ["attribute"], "name": ["default_path"]}}, {"source": {"identifier": "ethereum_optimized.berlin.state_db.State.db", "specifier": 0, "path": "src/ethereum_optimized/berlin/state_db.py"}, "content": {"type": ["attribute"], "name": ["db"]}}, {"source": {"identifier": "ethereum_optimized.berlin.state_db.State.dirty_accounts", "specifier": 0, "path": "src/ethereum_optimized/berlin/state_db.py"}, "content": {"type": ["attribute"], "name": ["dirty_accounts"]}}, {"source": {"identifier": "ethereum_optimized.berlin.state_db.State.dirty_storage", "specifier": 0, "path": "src/ethereum_optimized/berlin/state_db.py"}, "content": {"type": ["attribute"], "name": ["dirty_storage"]}}, {"source": {"identifier": "ethereum_optimized.berlin.state_db.State.destroyed_accounts", "specifier": 0, "path": "src/ethereum_optimized/berlin/state_db.py"}, "content": {"type": ["attribute"], "name": ["destroyed_accounts"]}}, {"source": {"identifier": "ethereum_optimized.berlin.state_db.State.tx_restore_points", "specifier": 0, "path": "src/ethereum_optimized/berlin/state_db.py"}, "content": {"type": ["attribute"], "name": ["tx_restore_points"]}}, {"source": {"identifier": "ethereum_optimized.berlin.state_db.State.journal", "specifier": 0, "path": "src/ethereum_optimized/berlin/state_db.py"}, "content": {"type": ["attribute"], "name": ["journal"]}}, {"source": {"identifier": "ethereum_optimized.berlin.state_db.State.__init__", "specifier": 0, "path": "src/ethereum_optimized/berlin/state_db.py"}, "content": {"type": ["function"], "name": ["__init__"]}}, {"source": {"identifier": "ethereum_optimized.berlin.state_db.State.__eq__", "specifier": 0, "path": "src/ethereum_optimized/berlin/state_db.py"}, "content": {"type": ["function"], "name": ["__eq__"], "text": ["Test for equality by comparing state roots."]}}, {"source": {"identifier": "ethereum_optimized.berlin.state_db.State.__enter__", "specifier": 0, "path": "src/ethereum_optimized/berlin/state_db.py"}, "content": {"type": ["function"], "name": ["__enter__"], "text": ["Support with statements"]}}, {"source": {"identifier": "ethereum_optimized.berlin.state_db.State.__exit__", "specifier": 0, "path": "src/ethereum_optimized/berlin/state_db.py"}, "content": {"type": ["function"], "name": ["__exit__"], "text": ["Support with statements"]}}, {"source": {"identifier": "ethereum_optimized.berlin.state_db.close_state", "specifier": 0, "path": "src/ethereum_optimized/berlin/state_db.py"}, "content": {"type": ["function"], "name": ["close_state"], "text": ["Close a state, releasing all resources it holds"]}}, {"source": {"identifier": "ethereum_optimized.berlin.state_db.get_metadata", "specifier": 0, "path": "src/ethereum_optimized/berlin/state_db.py"}, "content": {"type": ["function"], "name": ["get_metadata"], "text": ["Get a piece of metadata"]}}, {"source": {"identifier": "ethereum_optimized.berlin.state_db.set_metadata", "specifier": 0, "path": "src/ethereum_optimized/berlin/state_db.py"}, "content": {"type": ["function"], "name": ["set_metadata"], "text": ["Set a piece of metadata"]}}, {"source": {"identifier": "ethereum_optimized.berlin.state_db.begin_db_transaction", "specifier": 0, "path": "src/ethereum_optimized/berlin/state_db.py"}, "content": {"type": ["function"], "name": ["begin_db_transaction"], "text": ["Start a database transaction. A transaction is automatically started when a State  is created. Nesting of DB transactions is not supported (unlike non-db transactions). No operations are supported when not in a transaction."]}}, {"source": {"identifier": "ethereum_optimized.berlin.state_db.commit_db_transaction", "specifier": 0, "path": "src/ethereum_optimized/berlin/state_db.py"}, "content": {"type": ["function"], "name": ["commit_db_transaction"], "text": ["Commit the current database transaction."]}}, {"source": {"identifier": "ethereum_optimized.berlin.state_db.state_root", "specifier": 0, "path": "src/ethereum_optimized/berlin/state_db.py"}, "content": {"type": ["function"], "name": ["state_root"], "text": ["See  ethereum.berlin.state ."]}}, {"source": {"identifier": "ethereum_optimized.berlin.state_db.storage_root", "specifier": 0, "path": "src/ethereum_optimized/berlin/state_db.py"}, "content": {"type": ["function"], "name": ["storage_root"], "text": ["See  ethereum.berlin.state ."]}}, {"source": {"identifier": "ethereum_optimized.berlin.state_db.flush", "specifier": 0, "path": "src/ethereum_optimized/berlin/state_db.py"}, "content": {"type": ["function"], "name": ["flush"], "text": ["Send everything in the internal caches to the Rust layer."]}}, {"source": {"identifier": "ethereum_optimized.berlin.state_db.rollback_db_transaction", "specifier": 0, "path": "src/ethereum_optimized/berlin/state_db.py"}, "content": {"type": ["function"], "name": ["rollback_db_transaction"], "text": ["Rollback the current database transaction."]}}, {"source": {"identifier": "ethereum_optimized.berlin.state_db.begin_transaction", "specifier": 0, "path": "src/ethereum_optimized/berlin/state_db.py"}, "content": {"type": ["function"], "name": ["begin_transaction"], "text": ["See  ethereum.berlin.state ."]}}, {"source": {"identifier": "ethereum_optimized.berlin.state_db.commit_transaction", "specifier": 0, "path": "src/ethereum_optimized/berlin/state_db.py"}, "content": {"type": ["function"], "name": ["commit_transaction"], "text": ["See  ethereum.berlin.state ."]}}, {"source": {"identifier": "ethereum_optimized.berlin.state_db.rollback_transaction", "specifier": 0, "path": "src/ethereum_optimized/berlin/state_db.py"}, "content": {"type": ["function"], "name": ["rollback_transaction"], "text": ["See  ethereum.berlin.state ."]}}, {"source": {"identifier": "ethereum_optimized.berlin.state_db.get_storage", "specifier": 0, "path": "src/ethereum_optimized/berlin/state_db.py"}, "content": {"type": ["function"], "name": ["get_storage"], "text": ["See  ethereum.berlin.state ."]}}, {"source": {"identifier": "ethereum_optimized.berlin.state_db.get_storage_original", "specifier": 0, "path": "src/ethereum_optimized/berlin/state_db.py"}, "content": {"type": ["function"], "name": ["get_storage_original"], "text": ["See  ethereum.istanbul.state ."]}}, {"source": {"identifier": "ethereum_optimized.berlin.state_db.set_storage", "specifier": 0, "path": "src/ethereum_optimized/berlin/state_db.py"}, "content": {"type": ["function"], "name": ["set_storage"], "text": ["See  ethereum.berlin.state ."]}}, {"source": {"identifier": "ethereum_optimized.berlin.state_db.get_account_optional", "specifier": 0, "path": "src/ethereum_optimized/berlin/state_db.py"}, "content": {"type": ["function"], "name": ["get_account_optional"], "text": ["See  ethereum.berlin.state ."]}}, {"source": {"identifier": "ethereum_optimized.berlin.state_db.set_account", "specifier": 0, "path": "src/ethereum_optimized/berlin/state_db.py"}, "content": {"type": ["function"], "name": ["set_account"], "text": ["See  ethereum.berlin.state ."]}}, {"source": {"identifier": "ethereum_optimized.berlin.state_db.destroy_storage", "specifier": 0, "path": "src/ethereum_optimized/berlin/state_db.py"}, "content": {"type": ["function"], "name": ["destroy_storage"], "text": ["See  ethereum.berlin.state ."]}}, {"source": {"identifier": "ethereum.byzantium.vm.stack", "specifier": 0, "path": "src/ethereum/byzantium/vm/stack.py"}, "content": {"type": ["module"], "name": ["ethereum.byzantium.vm.stack"], "text": ["Ethereum Virtual Machine (EVM) Stack ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementation of the stack operators for the EVM."]}}, {"source": {"identifier": "ethereum.byzantium.vm.stack.pop", "specifier": 0, "path": "src/ethereum/byzantium/vm/stack.py"}, "content": {"type": ["function"], "name": ["pop"], "text": ["Pops the top item off of  stack . Parameters stack : EVM stack. Returns value :  U256 The top element on the stack."]}}, {"source": {"identifier": "ethereum.byzantium.vm.stack.push", "specifier": 0, "path": "src/ethereum/byzantium/vm/stack.py"}, "content": {"type": ["function"], "name": ["push"], "text": ["Pushes  value  onto  stack . Parameters stack : EVM stack. value : Item to be pushed onto  stack ."]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.precompiled_contracts.mapping", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/precompiled_contracts/mapping.py"}, "content": {"type": ["module"], "name": ["ethereum.spurious_dragon.vm.precompiled_contracts.mapping"], "text": ["Precompiled Contract Addresses ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Mapping of precompiled contracts their implementations."]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.precompiled_contracts.mapping.PRE_COMPILED_CONTRACTS", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/precompiled_contracts/mapping.py"}, "content": {"type": ["attribute"], "name": ["PRE_COMPILED_CONTRACTS"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.memory", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/memory.py"}, "content": {"type": ["module"], "name": ["ethereum.muir_glacier.vm.instructions.memory"], "text": ["Ethereum Virtual Machine (EVM) Memory Instructions ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementations of the EVM Memory instructions."]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.memory.mstore", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/memory.py"}, "content": {"type": ["function"], "name": ["mstore"], "text": ["Stores a word to memory. This also expands the memory, if the memory is insufficient to store the word. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.memory.mstore8", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/memory.py"}, "content": {"type": ["function"], "name": ["mstore8"], "text": ["Stores a byte to memory. This also expands the memory, if the memory is insufficient to store the word. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.memory.mload", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/memory.py"}, "content": {"type": ["function"], "name": ["mload"], "text": ["Load word from memory. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.memory.msize", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/memory.py"}, "content": {"type": ["function"], "name": ["msize"], "text": ["Push the size of active memory in bytes onto the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.log", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/log.py"}, "content": {"type": ["module"], "name": ["ethereum.shanghai.vm.instructions.log"], "text": ["Ethereum Virtual Machine (EVM) Logging Instructions ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementations of the EVM logging instructions."]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.log.log_n", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/log.py"}, "content": {"type": ["function"], "name": ["log_n"], "text": ["Appends a log entry, having  num_topics  topics, to the evm logs. This will also expand the memory if the data (required by the log entry) corresponding to the memory is not accessible. Parameters evm : The current EVM frame. num_topics : The number of topics to be included in the log entry."]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.log.log0", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/log.py"}, "content": {"type": ["attribute"], "name": ["log0"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.log.log1", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/log.py"}, "content": {"type": ["attribute"], "name": ["log1"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.log.log2", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/log.py"}, "content": {"type": ["attribute"], "name": ["log2"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.log.log3", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/log.py"}, "content": {"type": ["attribute"], "name": ["log3"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.log.log4", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/log.py"}, "content": {"type": ["attribute"], "name": ["log4"]}}, {"source": {"identifier": "ethereum.byzantium.vm.gas", "specifier": 0, "path": "src/ethereum/byzantium/vm/gas.py"}, "content": {"type": ["module"], "name": ["ethereum.byzantium.vm.gas"], "text": ["Ethereum Virtual Machine (EVM) Gas ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction EVM gas constants and calculators."]}}, {"source": {"identifier": "ethereum.byzantium.vm.gas.GAS_JUMPDEST", "specifier": 0, "path": "src/ethereum/byzantium/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_JUMPDEST"]}}, {"source": {"identifier": "ethereum.byzantium.vm.gas.GAS_BASE", "specifier": 0, "path": "src/ethereum/byzantium/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_BASE"]}}, {"source": {"identifier": "ethereum.byzantium.vm.gas.GAS_VERY_LOW", "specifier": 0, "path": "src/ethereum/byzantium/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_VERY_LOW"]}}, {"source": {"identifier": "ethereum.byzantium.vm.gas.GAS_SLOAD", "specifier": 0, "path": "src/ethereum/byzantium/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_SLOAD"]}}, {"source": {"identifier": "ethereum.byzantium.vm.gas.GAS_STORAGE_SET", "specifier": 0, "path": "src/ethereum/byzantium/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_STORAGE_SET"]}}, {"source": {"identifier": "ethereum.byzantium.vm.gas.GAS_STORAGE_UPDATE", "specifier": 0, "path": "src/ethereum/byzantium/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_STORAGE_UPDATE"]}}, {"source": {"identifier": "ethereum.byzantium.vm.gas.GAS_STORAGE_CLEAR_REFUND", "specifier": 0, "path": "src/ethereum/byzantium/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_STORAGE_CLEAR_REFUND"]}}, {"source": {"identifier": "ethereum.byzantium.vm.gas.GAS_LOW", "specifier": 0, "path": "src/ethereum/byzantium/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_LOW"]}}, {"source": {"identifier": "ethereum.byzantium.vm.gas.GAS_MID", "specifier": 0, "path": "src/ethereum/byzantium/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_MID"]}}, {"source": {"identifier": "ethereum.byzantium.vm.gas.GAS_HIGH", "specifier": 0, "path": "src/ethereum/byzantium/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_HIGH"]}}, {"source": {"identifier": "ethereum.byzantium.vm.gas.GAS_EXPONENTIATION", "specifier": 0, "path": "src/ethereum/byzantium/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_EXPONENTIATION"]}}, {"source": {"identifier": "ethereum.byzantium.vm.gas.GAS_EXPONENTIATION_PER_BYTE", "specifier": 0, "path": "src/ethereum/byzantium/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_EXPONENTIATION_PER_BYTE"]}}, {"source": {"identifier": "ethereum.byzantium.vm.gas.GAS_MEMORY", "specifier": 0, "path": "src/ethereum/byzantium/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_MEMORY"]}}, {"source": {"identifier": "ethereum.byzantium.vm.gas.GAS_KECCAK256", "specifier": 0, "path": "src/ethereum/byzantium/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_KECCAK256"]}}, {"source": {"identifier": "ethereum.byzantium.vm.gas.GAS_KECCAK256_WORD", "specifier": 0, "path": "src/ethereum/byzantium/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_KECCAK256_WORD"]}}, {"source": {"identifier": "ethereum.byzantium.vm.gas.GAS_COPY", "specifier": 0, "path": "src/ethereum/byzantium/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_COPY"]}}, {"source": {"identifier": "ethereum.byzantium.vm.gas.GAS_BLOCK_HASH", "specifier": 0, "path": "src/ethereum/byzantium/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_BLOCK_HASH"]}}, {"source": {"identifier": "ethereum.byzantium.vm.gas.GAS_EXTERNAL", "specifier": 0, "path": "src/ethereum/byzantium/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_EXTERNAL"]}}, {"source": {"identifier": "ethereum.byzantium.vm.gas.GAS_BALANCE", "specifier": 0, "path": "src/ethereum/byzantium/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_BALANCE"]}}, {"source": {"identifier": "ethereum.byzantium.vm.gas.GAS_LOG", "specifier": 0, "path": "src/ethereum/byzantium/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_LOG"]}}, {"source": {"identifier": "ethereum.byzantium.vm.gas.GAS_LOG_DATA", "specifier": 0, "path": "src/ethereum/byzantium/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_LOG_DATA"]}}, {"source": {"identifier": "ethereum.byzantium.vm.gas.GAS_LOG_TOPIC", "specifier": 0, "path": "src/ethereum/byzantium/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_LOG_TOPIC"]}}, {"source": {"identifier": "ethereum.byzantium.vm.gas.GAS_CREATE", "specifier": 0, "path": "src/ethereum/byzantium/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_CREATE"]}}, {"source": {"identifier": "ethereum.byzantium.vm.gas.GAS_CODE_DEPOSIT", "specifier": 0, "path": "src/ethereum/byzantium/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_CODE_DEPOSIT"]}}, {"source": {"identifier": "ethereum.byzantium.vm.gas.GAS_ZERO", "specifier": 0, "path": "src/ethereum/byzantium/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_ZERO"]}}, {"source": {"identifier": "ethereum.byzantium.vm.gas.GAS_CALL", "specifier": 0, "path": "src/ethereum/byzantium/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_CALL"]}}, {"source": {"identifier": "ethereum.byzantium.vm.gas.GAS_NEW_ACCOUNT", "specifier": 0, "path": "src/ethereum/byzantium/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_NEW_ACCOUNT"]}}, {"source": {"identifier": "ethereum.byzantium.vm.gas.GAS_CALL_VALUE", "specifier": 0, "path": "src/ethereum/byzantium/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_CALL_VALUE"]}}, {"source": {"identifier": "ethereum.byzantium.vm.gas.GAS_CALL_STIPEND", "specifier": 0, "path": "src/ethereum/byzantium/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_CALL_STIPEND"]}}, {"source": {"identifier": "ethereum.byzantium.vm.gas.GAS_SELF_DESTRUCT", "specifier": 0, "path": "src/ethereum/byzantium/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_SELF_DESTRUCT"]}}, {"source": {"identifier": "ethereum.byzantium.vm.gas.GAS_SELF_DESTRUCT_NEW_ACCOUNT", "specifier": 0, "path": "src/ethereum/byzantium/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_SELF_DESTRUCT_NEW_ACCOUNT"]}}, {"source": {"identifier": "ethereum.byzantium.vm.gas.REFUND_SELF_DESTRUCT", "specifier": 0, "path": "src/ethereum/byzantium/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["REFUND_SELF_DESTRUCT"]}}, {"source": {"identifier": "ethereum.byzantium.vm.gas.GAS_ECRECOVER", "specifier": 0, "path": "src/ethereum/byzantium/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_ECRECOVER"]}}, {"source": {"identifier": "ethereum.byzantium.vm.gas.GAS_SHA256", "specifier": 0, "path": "src/ethereum/byzantium/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_SHA256"]}}, {"source": {"identifier": "ethereum.byzantium.vm.gas.GAS_SHA256_WORD", "specifier": 0, "path": "src/ethereum/byzantium/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_SHA256_WORD"]}}, {"source": {"identifier": "ethereum.byzantium.vm.gas.GAS_RIPEMD160", "specifier": 0, "path": "src/ethereum/byzantium/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_RIPEMD160"]}}, {"source": {"identifier": "ethereum.byzantium.vm.gas.GAS_RIPEMD160_WORD", "specifier": 0, "path": "src/ethereum/byzantium/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_RIPEMD160_WORD"]}}, {"source": {"identifier": "ethereum.byzantium.vm.gas.GAS_IDENTITY", "specifier": 0, "path": "src/ethereum/byzantium/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_IDENTITY"]}}, {"source": {"identifier": "ethereum.byzantium.vm.gas.GAS_IDENTITY_WORD", "specifier": 0, "path": "src/ethereum/byzantium/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_IDENTITY_WORD"]}}, {"source": {"identifier": "ethereum.byzantium.vm.gas.GAS_RETURN_DATA_COPY", "specifier": 0, "path": "src/ethereum/byzantium/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_RETURN_DATA_COPY"]}}, {"source": {"identifier": "ethereum.byzantium.vm.gas.ExtendMemory", "specifier": 0, "path": "src/ethereum/byzantium/vm/gas.py"}, "content": {"type": ["class"], "name": ["ExtendMemory"], "text": ["Define the parameters for memory extension in opcodes cost :  ethereum.base_types.Uint The gas required to perform the extension expand_by :  ethereum.base_types.Uint The size by which the memory will be extended"]}}, {"source": {"identifier": "ethereum.byzantium.vm.gas.ExtendMemory.cost", "specifier": 0, "path": "src/ethereum/byzantium/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["cost"]}}, {"source": {"identifier": "ethereum.byzantium.vm.gas.ExtendMemory.expand_by", "specifier": 0, "path": "src/ethereum/byzantium/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["expand_by"]}}, {"source": {"identifier": "ethereum.byzantium.vm.gas.MessageCallGas", "specifier": 0, "path": "src/ethereum/byzantium/vm/gas.py"}, "content": {"type": ["class"], "name": ["MessageCallGas"], "text": ["Define the gas cost and stipend for executing the call opcodes. cost :  ethereum.base_types.Uint The non-refundable portion of gas reserved for executing the call opcode. stipend :  ethereum.base_types.Uint The portion of gas available to sub-calls that is refundable if not consumed"]}}, {"source": {"identifier": "ethereum.byzantium.vm.gas.MessageCallGas.cost", "specifier": 0, "path": "src/ethereum/byzantium/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["cost"]}}, {"source": {"identifier": "ethereum.byzantium.vm.gas.MessageCallGas.stipend", "specifier": 0, "path": "src/ethereum/byzantium/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["stipend"]}}, {"source": {"identifier": "ethereum.byzantium.vm.gas.charge_gas", "specifier": 0, "path": "src/ethereum/byzantium/vm/gas.py"}, "content": {"type": ["function"], "name": ["charge_gas"], "text": ["Subtracts  amount  from  evm.gas_left . Parameters evm : The current EVM. amount : The amount of gas the current operation requires."]}}, {"source": {"identifier": "ethereum.byzantium.vm.gas.calculate_memory_gas_cost", "specifier": 0, "path": "src/ethereum/byzantium/vm/gas.py"}, "content": {"type": ["function"], "name": ["calculate_memory_gas_cost"], "text": ["Calculates the gas cost for allocating memory to the smallest multiple of 32 bytes, such that the allocated size is at least as big as the given size. Parameters size_in_bytes : The size of the data in bytes. Returns total_gas_cost :  ethereum.base_types.Uint The gas cost for storing data in memory."]}}, {"source": {"identifier": "ethereum.byzantium.vm.gas.calculate_gas_extend_memory", "specifier": 0, "path": "src/ethereum/byzantium/vm/gas.py"}, "content": {"type": ["function"], "name": ["calculate_gas_extend_memory"], "text": ["Calculates the gas amount to extend memory Parameters memory : Memory contents of the EVM. extensions: List of extensions to be made to the memory. Consists of a tuple of start position and size. Returns extend_memory:  ExtendMemory"]}}, {"source": {"identifier": "ethereum.byzantium.vm.gas.calculate_message_call_gas", "specifier": 0, "path": "src/ethereum/byzantium/vm/gas.py"}, "content": {"type": ["function"], "name": ["calculate_message_call_gas"], "text": ["Calculates the MessageCallGas (cost and stipend) for executing call Opcodes. Parameters value: The amount of  ETH  that needs to be transferred. gas : The amount of gas provided to the message-call. gas_left : The amount of gas left in the current frame. memory_cost : The amount needed to extend the memory in the current frame. extra_gas : The amount of gas needed for transferring value + creating a new account inside a message call. call_stipend : The amount of stipend provided to a message call to execute code while transferring value(ETH). Returns message_call_gas:  MessageCallGas"]}}, {"source": {"identifier": "ethereum.byzantium.vm.gas.max_message_call_gas", "specifier": 0, "path": "src/ethereum/byzantium/vm/gas.py"}, "content": {"type": ["function"], "name": ["max_message_call_gas"], "text": ["Calculates the maximum gas that is allowed for making a message call Parameters gas : The amount of gas provided to the message-call. Returns max_allowed_message_call_gas:  ethereum.base_types.Uint The maximum gas allowed for making the message-call."]}}, {"source": {"identifier": "ethereum_optimized.london.state_db", "specifier": 0, "path": "src/ethereum_optimized/london/state_db.py"}, "content": {"type": ["module"], "name": ["ethereum_optimized.london.state_db"], "text": ["Optimized State ^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction This module contains functions can be monkey patched into ethereum.london.state  to use an optimized database backed state."]}}, {"source": {"identifier": "ethereum_optimized.london.state_db.UnmodifiedType", "specifier": 0, "path": "src/ethereum_optimized/london/state_db.py"}, "content": {"type": ["class"], "name": ["UnmodifiedType"], "text": ["Sentinal type to represent a value that hasn't been modified."]}}, {"source": {"identifier": "ethereum_optimized.london.state_db.Unmodified", "specifier": 0, "path": "src/ethereum_optimized/london/state_db.py"}, "content": {"type": ["attribute"], "name": ["Unmodified"]}}, {"source": {"identifier": "ethereum_optimized.london.state_db.State", "specifier": 0, "path": "src/ethereum_optimized/london/state_db.py"}, "content": {"type": ["class"], "name": ["State"], "text": ["The State, backed by a LMDB database. When created with  State()  store the db in a temporary directory. When created with  State(path)  open or create the db located at  path ."]}}, {"source": {"identifier": "ethereum_optimized.london.state_db.State.default_path", "specifier": 0, "path": "src/ethereum_optimized/london/state_db.py"}, "content": {"type": ["attribute"], "name": ["default_path"]}}, {"source": {"identifier": "ethereum_optimized.london.state_db.State.db", "specifier": 0, "path": "src/ethereum_optimized/london/state_db.py"}, "content": {"type": ["attribute"], "name": ["db"]}}, {"source": {"identifier": "ethereum_optimized.london.state_db.State.dirty_accounts", "specifier": 0, "path": "src/ethereum_optimized/london/state_db.py"}, "content": {"type": ["attribute"], "name": ["dirty_accounts"]}}, {"source": {"identifier": "ethereum_optimized.london.state_db.State.dirty_storage", "specifier": 0, "path": "src/ethereum_optimized/london/state_db.py"}, "content": {"type": ["attribute"], "name": ["dirty_storage"]}}, {"source": {"identifier": "ethereum_optimized.london.state_db.State.destroyed_accounts", "specifier": 0, "path": "src/ethereum_optimized/london/state_db.py"}, "content": {"type": ["attribute"], "name": ["destroyed_accounts"]}}, {"source": {"identifier": "ethereum_optimized.london.state_db.State.tx_restore_points", "specifier": 0, "path": "src/ethereum_optimized/london/state_db.py"}, "content": {"type": ["attribute"], "name": ["tx_restore_points"]}}, {"source": {"identifier": "ethereum_optimized.london.state_db.State.journal", "specifier": 0, "path": "src/ethereum_optimized/london/state_db.py"}, "content": {"type": ["attribute"], "name": ["journal"]}}, {"source": {"identifier": "ethereum_optimized.london.state_db.State.__init__", "specifier": 0, "path": "src/ethereum_optimized/london/state_db.py"}, "content": {"type": ["function"], "name": ["__init__"]}}, {"source": {"identifier": "ethereum_optimized.london.state_db.State.__eq__", "specifier": 0, "path": "src/ethereum_optimized/london/state_db.py"}, "content": {"type": ["function"], "name": ["__eq__"], "text": ["Test for equality by comparing state roots."]}}, {"source": {"identifier": "ethereum_optimized.london.state_db.State.__enter__", "specifier": 0, "path": "src/ethereum_optimized/london/state_db.py"}, "content": {"type": ["function"], "name": ["__enter__"], "text": ["Support with statements"]}}, {"source": {"identifier": "ethereum_optimized.london.state_db.State.__exit__", "specifier": 0, "path": "src/ethereum_optimized/london/state_db.py"}, "content": {"type": ["function"], "name": ["__exit__"], "text": ["Support with statements"]}}, {"source": {"identifier": "ethereum_optimized.london.state_db.close_state", "specifier": 0, "path": "src/ethereum_optimized/london/state_db.py"}, "content": {"type": ["function"], "name": ["close_state"], "text": ["Close a state, releasing all resources it holds"]}}, {"source": {"identifier": "ethereum_optimized.london.state_db.get_metadata", "specifier": 0, "path": "src/ethereum_optimized/london/state_db.py"}, "content": {"type": ["function"], "name": ["get_metadata"], "text": ["Get a piece of metadata"]}}, {"source": {"identifier": "ethereum_optimized.london.state_db.set_metadata", "specifier": 0, "path": "src/ethereum_optimized/london/state_db.py"}, "content": {"type": ["function"], "name": ["set_metadata"], "text": ["Set a piece of metadata"]}}, {"source": {"identifier": "ethereum_optimized.london.state_db.begin_db_transaction", "specifier": 0, "path": "src/ethereum_optimized/london/state_db.py"}, "content": {"type": ["function"], "name": ["begin_db_transaction"], "text": ["Start a database transaction. A transaction is automatically started when a State  is created. Nesting of DB transactions is not supported (unlike non-db transactions). No operations are supported when not in a transaction."]}}, {"source": {"identifier": "ethereum_optimized.london.state_db.commit_db_transaction", "specifier": 0, "path": "src/ethereum_optimized/london/state_db.py"}, "content": {"type": ["function"], "name": ["commit_db_transaction"], "text": ["Commit the current database transaction."]}}, {"source": {"identifier": "ethereum_optimized.london.state_db.state_root", "specifier": 0, "path": "src/ethereum_optimized/london/state_db.py"}, "content": {"type": ["function"], "name": ["state_root"], "text": ["See  ethereum.london.state ."]}}, {"source": {"identifier": "ethereum_optimized.london.state_db.storage_root", "specifier": 0, "path": "src/ethereum_optimized/london/state_db.py"}, "content": {"type": ["function"], "name": ["storage_root"], "text": ["See  ethereum.london.state ."]}}, {"source": {"identifier": "ethereum_optimized.london.state_db.flush", "specifier": 0, "path": "src/ethereum_optimized/london/state_db.py"}, "content": {"type": ["function"], "name": ["flush"], "text": ["Send everything in the internal caches to the Rust layer."]}}, {"source": {"identifier": "ethereum_optimized.london.state_db.rollback_db_transaction", "specifier": 0, "path": "src/ethereum_optimized/london/state_db.py"}, "content": {"type": ["function"], "name": ["rollback_db_transaction"], "text": ["Rollback the current database transaction."]}}, {"source": {"identifier": "ethereum_optimized.london.state_db.begin_transaction", "specifier": 0, "path": "src/ethereum_optimized/london/state_db.py"}, "content": {"type": ["function"], "name": ["begin_transaction"], "text": ["See  ethereum.london.state ."]}}, {"source": {"identifier": "ethereum_optimized.london.state_db.commit_transaction", "specifier": 0, "path": "src/ethereum_optimized/london/state_db.py"}, "content": {"type": ["function"], "name": ["commit_transaction"], "text": ["See  ethereum.london.state ."]}}, {"source": {"identifier": "ethereum_optimized.london.state_db.rollback_transaction", "specifier": 0, "path": "src/ethereum_optimized/london/state_db.py"}, "content": {"type": ["function"], "name": ["rollback_transaction"], "text": ["See  ethereum.london.state ."]}}, {"source": {"identifier": "ethereum_optimized.london.state_db.get_storage", "specifier": 0, "path": "src/ethereum_optimized/london/state_db.py"}, "content": {"type": ["function"], "name": ["get_storage"], "text": ["See  ethereum.london.state ."]}}, {"source": {"identifier": "ethereum_optimized.london.state_db.get_storage_original", "specifier": 0, "path": "src/ethereum_optimized/london/state_db.py"}, "content": {"type": ["function"], "name": ["get_storage_original"], "text": ["See  ethereum.istanbul.state ."]}}, {"source": {"identifier": "ethereum_optimized.london.state_db.set_storage", "specifier": 0, "path": "src/ethereum_optimized/london/state_db.py"}, "content": {"type": ["function"], "name": ["set_storage"], "text": ["See  ethereum.london.state ."]}}, {"source": {"identifier": "ethereum_optimized.london.state_db.get_account_optional", "specifier": 0, "path": "src/ethereum_optimized/london/state_db.py"}, "content": {"type": ["function"], "name": ["get_account_optional"], "text": ["See  ethereum.london.state ."]}}, {"source": {"identifier": "ethereum_optimized.london.state_db.set_account", "specifier": 0, "path": "src/ethereum_optimized/london/state_db.py"}, "content": {"type": ["function"], "name": ["set_account"], "text": ["See  ethereum.london.state ."]}}, {"source": {"identifier": "ethereum_optimized.london.state_db.destroy_storage", "specifier": 0, "path": "src/ethereum_optimized/london/state_db.py"}, "content": {"type": ["function"], "name": ["destroy_storage"], "text": ["See  ethereum.london.state ."]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.precompiled_contracts", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/precompiled_contracts/__init__.py"}, "content": {"type": ["module"], "name": ["ethereum.spurious_dragon.vm.precompiled_contracts"], "text": ["Precompiled Contract Addresses ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Addresses of precompiled contracts and mappings to their implementations."]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.precompiled_contracts.__all__", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/precompiled_contracts/__init__.py"}, "content": {"type": ["attribute"], "name": ["__all__"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.precompiled_contracts.ECRECOVER_ADDRESS", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/precompiled_contracts/__init__.py"}, "content": {"type": ["attribute"], "name": ["ECRECOVER_ADDRESS"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.precompiled_contracts.SHA256_ADDRESS", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/precompiled_contracts/__init__.py"}, "content": {"type": ["attribute"], "name": ["SHA256_ADDRESS"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.precompiled_contracts.RIPEMD160_ADDRESS", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/precompiled_contracts/__init__.py"}, "content": {"type": ["attribute"], "name": ["RIPEMD160_ADDRESS"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.precompiled_contracts.IDENTITY_ADDRESS", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/precompiled_contracts/__init__.py"}, "content": {"type": ["attribute"], "name": ["IDENTITY_ADDRESS"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.system", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/system.py"}, "content": {"type": ["module"], "name": ["ethereum.muir_glacier.vm.instructions.system"], "text": ["Ethereum Virtual Machine (EVM) System Instructions ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementations of the EVM system related instructions."]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.system.generic_create", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/system.py"}, "content": {"type": ["function"], "name": ["generic_create"], "text": ["Core logic used by the  CREATE*  family of opcodes."]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.system.create", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/system.py"}, "content": {"type": ["function"], "name": ["create"], "text": ["Creates a new account with associated code. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.system.create2", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/system.py"}, "content": {"type": ["function"], "name": ["create2"], "text": ["Creates a new account with associated code. It's similar to CREATE opcode except that the address of new account depends on the init_code instead of the nonce of sender. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.system.return_", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/system.py"}, "content": {"type": ["function"], "name": ["return_"], "text": ["Halts execution returning output data. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.system.generic_call", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/system.py"}, "content": {"type": ["function"], "name": ["generic_call"], "text": ["Perform the core logic of the  CALL*  family of opcodes."]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.system.call", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/system.py"}, "content": {"type": ["function"], "name": ["call"], "text": ["Message-call into an account. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.system.callcode", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/system.py"}, "content": {"type": ["function"], "name": ["callcode"], "text": ["Message-call into this account with alternative account\u2019s code. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.system.selfdestruct", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/system.py"}, "content": {"type": ["function"], "name": ["selfdestruct"], "text": ["Halt execution and register account for later deletion. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.system.delegatecall", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/system.py"}, "content": {"type": ["function"], "name": ["delegatecall"], "text": ["Message-call into an account. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.system.staticcall", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/system.py"}, "content": {"type": ["function"], "name": ["staticcall"], "text": ["Message-call into an account. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.system.revert", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/system.py"}, "content": {"type": ["function"], "name": ["revert"], "text": ["Stop execution and revert state changes, without consuming all provided gas and also has the ability to return a reason Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.storage", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/storage.py"}, "content": {"type": ["module"], "name": ["ethereum.shanghai.vm.instructions.storage"], "text": ["Ethereum Virtual Machine (EVM) Storage Instructions ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementations of the EVM storage related instructions."]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.storage.sload", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/storage.py"}, "content": {"type": ["function"], "name": ["sload"], "text": ["Loads to the stack, the value corresponding to a certain key from the storage of the current account. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.storage.sstore", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/storage.py"}, "content": {"type": ["function"], "name": ["sstore"], "text": ["Stores a value at a certain key in the current context's storage. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum_optimized.london.fork", "specifier": 0, "path": "src/ethereum_optimized/london/fork.py"}, "content": {"type": ["module"], "name": ["ethereum_optimized.london.fork"], "text": ["Optimized Spec ^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction This module contains functions can be monkey patched into ethereum.london.fork  to use alternate optimized implementations."]}}, {"source": {"identifier": "ethereum_optimized.london.fork.validate_proof_of_work", "specifier": 0, "path": "src/ethereum_optimized/london/fork.py"}, "content": {"type": ["function"], "name": ["validate_proof_of_work"], "text": ["See  ethereum.london.fork.validate_proof_of_work ."]}}, {"source": {"identifier": "ethereum.byzantium.vm.precompiled_contracts.mapping", "specifier": 0, "path": "src/ethereum/byzantium/vm/precompiled_contracts/mapping.py"}, "content": {"type": ["module"], "name": ["ethereum.byzantium.vm.precompiled_contracts.mapping"], "text": ["Precompiled Contract Addresses ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Mapping of precompiled contracts their implementations."]}}, {"source": {"identifier": "ethereum.byzantium.vm.precompiled_contracts.mapping.PRE_COMPILED_CONTRACTS", "specifier": 0, "path": "src/ethereum/byzantium/vm/precompiled_contracts/mapping.py"}, "content": {"type": ["attribute"], "name": ["PRE_COMPILED_CONTRACTS"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.precompiled_contracts.ripemd160", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/precompiled_contracts/ripemd160.py"}, "content": {"type": ["module"], "name": ["ethereum.spurious_dragon.vm.precompiled_contracts.ripemd160"], "text": ["Ethereum Virtual Machine (EVM) RIPEMD160 PRECOMPILED CONTRACT ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementation of the  RIPEMD160  precompiled contract."]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.precompiled_contracts.ripemd160.ripemd160", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/precompiled_contracts/ripemd160.py"}, "content": {"type": ["function"], "name": ["ripemd160"], "text": ["Writes the ripemd160 hash to output. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/__init__.py"}, "content": {"type": ["module"], "name": ["ethereum.muir_glacier.vm.instructions"], "text": ["EVM Instruction Encoding (Opcodes) ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Machine readable representations of EVM instructions, and a mapping to their implementations."]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.Ops", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/__init__.py"}, "content": {"type": ["class"], "name": ["Ops"], "text": ["Enum for EVM Opcodes"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.Ops.ADD", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["ADD"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.Ops.MUL", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["MUL"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.Ops.SUB", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SUB"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.Ops.DIV", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DIV"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.Ops.SDIV", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SDIV"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.Ops.MOD", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["MOD"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.Ops.SMOD", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SMOD"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.Ops.ADDMOD", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["ADDMOD"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.Ops.MULMOD", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["MULMOD"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.Ops.EXP", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["EXP"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.Ops.SIGNEXTEND", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SIGNEXTEND"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.Ops.LT", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["LT"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.Ops.GT", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["GT"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.Ops.SLT", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SLT"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.Ops.SGT", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SGT"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.Ops.EQ", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["EQ"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.Ops.ISZERO", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["ISZERO"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.Ops.AND", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["AND"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.Ops.OR", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["OR"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.Ops.XOR", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["XOR"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.Ops.NOT", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["NOT"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.Ops.BYTE", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["BYTE"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.Ops.SHL", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SHL"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.Ops.SHR", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SHR"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.Ops.SAR", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SAR"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.Ops.KECCAK", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["KECCAK"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.Ops.ADDRESS", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["ADDRESS"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.Ops.BALANCE", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["BALANCE"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.Ops.ORIGIN", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["ORIGIN"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.Ops.CALLER", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["CALLER"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.Ops.CALLVALUE", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["CALLVALUE"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.Ops.CALLDATALOAD", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["CALLDATALOAD"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.Ops.CALLDATASIZE", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["CALLDATASIZE"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.Ops.CALLDATACOPY", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["CALLDATACOPY"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.Ops.CODESIZE", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["CODESIZE"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.Ops.CODECOPY", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["CODECOPY"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.Ops.GASPRICE", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["GASPRICE"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.Ops.EXTCODESIZE", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["EXTCODESIZE"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.Ops.EXTCODECOPY", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["EXTCODECOPY"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.Ops.RETURNDATASIZE", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["RETURNDATASIZE"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.Ops.RETURNDATACOPY", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["RETURNDATACOPY"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.Ops.EXTCODEHASH", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["EXTCODEHASH"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.Ops.BLOCKHASH", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["BLOCKHASH"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.Ops.COINBASE", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["COINBASE"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.Ops.TIMESTAMP", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["TIMESTAMP"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.Ops.NUMBER", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["NUMBER"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.Ops.DIFFICULTY", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DIFFICULTY"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.Ops.GASLIMIT", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["GASLIMIT"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.Ops.CHAINID", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["CHAINID"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.Ops.SELFBALANCE", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SELFBALANCE"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.Ops.STOP", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["STOP"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.Ops.JUMP", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["JUMP"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.Ops.JUMPI", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["JUMPI"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.Ops.PC", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PC"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.Ops.GAS", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["GAS"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.Ops.JUMPDEST", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["JUMPDEST"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.Ops.SLOAD", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SLOAD"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.Ops.SSTORE", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SSTORE"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.Ops.POP", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["POP"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.Ops.PUSH1", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH1"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.Ops.PUSH2", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH2"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.Ops.PUSH3", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH3"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.Ops.PUSH4", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH4"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.Ops.PUSH5", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH5"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.Ops.PUSH6", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH6"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.Ops.PUSH7", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH7"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.Ops.PUSH8", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH8"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.Ops.PUSH9", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH9"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.Ops.PUSH10", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH10"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.Ops.PUSH11", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH11"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.Ops.PUSH12", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH12"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.Ops.PUSH13", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH13"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.Ops.PUSH14", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH14"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.Ops.PUSH15", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH15"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.Ops.PUSH16", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH16"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.Ops.PUSH17", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH17"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.Ops.PUSH18", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH18"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.Ops.PUSH19", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH19"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.Ops.PUSH20", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH20"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.Ops.PUSH21", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH21"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.Ops.PUSH22", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH22"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.Ops.PUSH23", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH23"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.Ops.PUSH24", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH24"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.Ops.PUSH25", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH25"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.Ops.PUSH26", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH26"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.Ops.PUSH27", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH27"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.Ops.PUSH28", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH28"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.Ops.PUSH29", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH29"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.Ops.PUSH30", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH30"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.Ops.PUSH31", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH31"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.Ops.PUSH32", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH32"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.Ops.DUP1", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP1"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.Ops.DUP2", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP2"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.Ops.DUP3", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP3"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.Ops.DUP4", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP4"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.Ops.DUP5", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP5"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.Ops.DUP6", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP6"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.Ops.DUP7", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP7"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.Ops.DUP8", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP8"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.Ops.DUP9", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP9"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.Ops.DUP10", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP10"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.Ops.DUP11", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP11"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.Ops.DUP12", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP12"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.Ops.DUP13", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP13"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.Ops.DUP14", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP14"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.Ops.DUP15", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP15"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.Ops.DUP16", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP16"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.Ops.SWAP1", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP1"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.Ops.SWAP2", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP2"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.Ops.SWAP3", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP3"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.Ops.SWAP4", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP4"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.Ops.SWAP5", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP5"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.Ops.SWAP6", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP6"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.Ops.SWAP7", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP7"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.Ops.SWAP8", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP8"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.Ops.SWAP9", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP9"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.Ops.SWAP10", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP10"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.Ops.SWAP11", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP11"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.Ops.SWAP12", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP12"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.Ops.SWAP13", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP13"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.Ops.SWAP14", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP14"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.Ops.SWAP15", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP15"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.Ops.SWAP16", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP16"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.Ops.MLOAD", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["MLOAD"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.Ops.MSTORE", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["MSTORE"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.Ops.MSTORE8", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["MSTORE8"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.Ops.MSIZE", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["MSIZE"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.Ops.LOG0", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["LOG0"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.Ops.LOG1", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["LOG1"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.Ops.LOG2", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["LOG2"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.Ops.LOG3", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["LOG3"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.Ops.LOG4", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["LOG4"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.Ops.CREATE", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["CREATE"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.Ops.RETURN", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["RETURN"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.Ops.CALL", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["CALL"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.Ops.CALLCODE", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["CALLCODE"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.Ops.DELEGATECALL", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DELEGATECALL"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.Ops.STATICCALL", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["STATICCALL"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.Ops.REVERT", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["REVERT"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.Ops.SELFDESTRUCT", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SELFDESTRUCT"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.Ops.CREATE2", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["CREATE2"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.op_implementation", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["op_implementation"]}}, {"source": {"identifier": "ethereum_optimized.gray_glacier", "specifier": 0, "path": "src/ethereum_optimized/gray_glacier/__init__.py"}, "content": {"type": ["module"], "name": ["ethereum_optimized.gray_glacier"], "text": ["Optimized Implementations (Gray Glacier) ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local:"]}}, {"source": {"identifier": "ethereum_optimized.gray_glacier.monkey_patch_optimized_state_db", "specifier": 0, "path": "src/ethereum_optimized/gray_glacier/__init__.py"}, "content": {"type": ["function"], "name": ["monkey_patch_optimized_state_db"], "text": ["Replace the state interface with one that supports high performance updates and storing state in a database. This function must be called before the state interface is imported anywhere."]}}, {"source": {"identifier": "ethereum_optimized.gray_glacier.monkey_patch_optimized_spec", "specifier": 0, "path": "src/ethereum_optimized/gray_glacier/__init__.py"}, "content": {"type": ["function"], "name": ["monkey_patch_optimized_spec"], "text": ["Replace the ethash implementation with one that supports higher performance. This function must be called before the spec interface is imported anywhere."]}}, {"source": {"identifier": "ethereum_optimized.gray_glacier.monkey_patch", "specifier": 0, "path": "src/ethereum_optimized/gray_glacier/__init__.py"}, "content": {"type": ["function"], "name": ["monkey_patch"], "text": ["Apply all monkey patches to swap in high performance implementations. This function must be called before any of the ethereum modules are imported anywhere."]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.block", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/block.py"}, "content": {"type": ["module"], "name": ["ethereum.shanghai.vm.instructions.block"], "text": ["Ethereum Virtual Machine (EVM) Block Instructions ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementations of the EVM block instructions."]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.block.block_hash", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/block.py"}, "content": {"type": ["function"], "name": ["block_hash"], "text": ["Push the hash of one of the 256 most recent complete blocks onto the stack. The block number to hash is present at the top of the stack. Parameters evm : The current EVM frame. Raises :py:class: ~ethereum.shanghai.vm.exceptions.StackUnderflowError If  len(stack)  is less than  1 . :py:class: ~ethereum.shanghai.vm.exceptions.OutOfGasError If  evm.gas_left  is less than  20 ."]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.block.coinbase", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/block.py"}, "content": {"type": ["function"], "name": ["coinbase"], "text": ["Push the current block's beneficiary address (address of the block miner) onto the stack. Here the current block refers to the block in which the currently executing transaction/call resides. Parameters evm : The current EVM frame. Raises :py:class: ~ethereum.shanghai.vm.exceptions.StackOverflowError If  len(stack)  is equal to  1024 . :py:class: ~ethereum.shanghai.vm.exceptions.OutOfGasError If  evm.gas_left  is less than  2 ."]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.block.timestamp", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/block.py"}, "content": {"type": ["function"], "name": ["timestamp"], "text": ["Push the current block's timestamp onto the stack. Here the timestamp being referred is actually the unix timestamp in seconds. Here the current block refers to the block in which the currently executing transaction/call resides. Parameters evm : The current EVM frame. Raises :py:class: ~ethereum.shanghai.vm.exceptions.StackOverflowError If  len(stack)  is equal to  1024 . :py:class: ~ethereum.shanghai.vm.exceptions.OutOfGasError If  evm.gas_left  is less than  2 ."]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.block.number", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/block.py"}, "content": {"type": ["function"], "name": ["number"], "text": ["Push the current block's number onto the stack. Here the current block refers to the block in which the currently executing transaction/call resides. Parameters evm : The current EVM frame. Raises :py:class: ~ethereum.shanghai.vm.exceptions.StackOverflowError If  len(stack)  is equal to  1024 . :py:class: ~ethereum.shanghai.vm.exceptions.OutOfGasError If  evm.gas_left  is less than  2 ."]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.block.prev_randao", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/block.py"}, "content": {"type": ["function"], "name": ["prev_randao"], "text": ["Push the  prev_randao  value onto the stack. The  prev_randao  value is the random output of the beacon chain's randomness oracle for the previous block. Parameters evm : The current EVM frame. Raises :py:class: ~ethereum.shanghai.vm.exceptions.StackOverflowError If  len(stack)  is equal to  1024 . :py:class: ~ethereum.shanghai.vm.exceptions.OutOfGasError If  evm.gas_left  is less than  2 ."]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.block.gas_limit", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/block.py"}, "content": {"type": ["function"], "name": ["gas_limit"], "text": ["Push the current block's gas limit onto the stack. Here the current block refers to the block in which the currently executing transaction/call resides. Parameters evm : The current EVM frame. Raises :py:class: ~ethereum.shanghai.vm.exceptions.StackOverflowError If  len(stack)  is equal to  1024 . :py:class: ~ethereum.shanghai.vm.exceptions.OutOfGasError If  evm.gas_left  is less than  2 ."]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.block.chain_id", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/block.py"}, "content": {"type": ["function"], "name": ["chain_id"], "text": ["Push the chain id onto the stack. Parameters evm : The current EVM frame. Raises :py:class: ~ethereum.shanghai.vm.exceptions.StackOverflowError If  len(stack)  is equal to  1024 . :py:class: ~ethereum.shanghai.vm.exceptions.OutOfGasError If  evm.gas_left  is less than  2 ."]}}, {"source": {"identifier": "ethereum.byzantium.vm.precompiled_contracts", "specifier": 0, "path": "src/ethereum/byzantium/vm/precompiled_contracts/__init__.py"}, "content": {"type": ["module"], "name": ["ethereum.byzantium.vm.precompiled_contracts"], "text": ["Precompiled Contract Addresses ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Addresses of precompiled contracts and mappings to their implementations."]}}, {"source": {"identifier": "ethereum.byzantium.vm.precompiled_contracts.__all__", "specifier": 0, "path": "src/ethereum/byzantium/vm/precompiled_contracts/__init__.py"}, "content": {"type": ["attribute"], "name": ["__all__"]}}, {"source": {"identifier": "ethereum.byzantium.vm.precompiled_contracts.ECRECOVER_ADDRESS", "specifier": 0, "path": "src/ethereum/byzantium/vm/precompiled_contracts/__init__.py"}, "content": {"type": ["attribute"], "name": ["ECRECOVER_ADDRESS"]}}, {"source": {"identifier": "ethereum.byzantium.vm.precompiled_contracts.SHA256_ADDRESS", "specifier": 0, "path": "src/ethereum/byzantium/vm/precompiled_contracts/__init__.py"}, "content": {"type": ["attribute"], "name": ["SHA256_ADDRESS"]}}, {"source": {"identifier": "ethereum.byzantium.vm.precompiled_contracts.RIPEMD160_ADDRESS", "specifier": 0, "path": "src/ethereum/byzantium/vm/precompiled_contracts/__init__.py"}, "content": {"type": ["attribute"], "name": ["RIPEMD160_ADDRESS"]}}, {"source": {"identifier": "ethereum.byzantium.vm.precompiled_contracts.IDENTITY_ADDRESS", "specifier": 0, "path": "src/ethereum/byzantium/vm/precompiled_contracts/__init__.py"}, "content": {"type": ["attribute"], "name": ["IDENTITY_ADDRESS"]}}, {"source": {"identifier": "ethereum.byzantium.vm.precompiled_contracts.MODEXP_ADDRESS", "specifier": 0, "path": "src/ethereum/byzantium/vm/precompiled_contracts/__init__.py"}, "content": {"type": ["attribute"], "name": ["MODEXP_ADDRESS"]}}, {"source": {"identifier": "ethereum.byzantium.vm.precompiled_contracts.ALT_BN128_ADD_ADDRESS", "specifier": 0, "path": "src/ethereum/byzantium/vm/precompiled_contracts/__init__.py"}, "content": {"type": ["attribute"], "name": ["ALT_BN128_ADD_ADDRESS"]}}, {"source": {"identifier": "ethereum.byzantium.vm.precompiled_contracts.ALT_BN128_MUL_ADDRESS", "specifier": 0, "path": "src/ethereum/byzantium/vm/precompiled_contracts/__init__.py"}, "content": {"type": ["attribute"], "name": ["ALT_BN128_MUL_ADDRESS"]}}, {"source": {"identifier": "ethereum.byzantium.vm.precompiled_contracts.ALT_BN128_PAIRING_CHECK_ADDRESS", "specifier": 0, "path": "src/ethereum/byzantium/vm/precompiled_contracts/__init__.py"}, "content": {"type": ["attribute"], "name": ["ALT_BN128_PAIRING_CHECK_ADDRESS"]}}, {"source": {"identifier": "ethereum_optimized.gray_glacier.state_db", "specifier": 0, "path": "src/ethereum_optimized/gray_glacier/state_db.py"}, "content": {"type": ["module"], "name": ["ethereum_optimized.gray_glacier.state_db"], "text": ["Optimized State ^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction This module contains functions can be monkey patched into ethereum.gray_glacier.state  to use an optimized database backed state."]}}, {"source": {"identifier": "ethereum_optimized.gray_glacier.state_db.UnmodifiedType", "specifier": 0, "path": "src/ethereum_optimized/gray_glacier/state_db.py"}, "content": {"type": ["class"], "name": ["UnmodifiedType"], "text": ["Sentinal type to represent a value that hasn't been modified."]}}, {"source": {"identifier": "ethereum_optimized.gray_glacier.state_db.Unmodified", "specifier": 0, "path": "src/ethereum_optimized/gray_glacier/state_db.py"}, "content": {"type": ["attribute"], "name": ["Unmodified"]}}, {"source": {"identifier": "ethereum_optimized.gray_glacier.state_db.State", "specifier": 0, "path": "src/ethereum_optimized/gray_glacier/state_db.py"}, "content": {"type": ["class"], "name": ["State"], "text": ["The State, backed by a LMDB database. When created with  State()  store the db in a temporary directory. When created with  State(path)  open or create the db located at  path ."]}}, {"source": {"identifier": "ethereum_optimized.gray_glacier.state_db.State.default_path", "specifier": 0, "path": "src/ethereum_optimized/gray_glacier/state_db.py"}, "content": {"type": ["attribute"], "name": ["default_path"]}}, {"source": {"identifier": "ethereum_optimized.gray_glacier.state_db.State.db", "specifier": 0, "path": "src/ethereum_optimized/gray_glacier/state_db.py"}, "content": {"type": ["attribute"], "name": ["db"]}}, {"source": {"identifier": "ethereum_optimized.gray_glacier.state_db.State.dirty_accounts", "specifier": 0, "path": "src/ethereum_optimized/gray_glacier/state_db.py"}, "content": {"type": ["attribute"], "name": ["dirty_accounts"]}}, {"source": {"identifier": "ethereum_optimized.gray_glacier.state_db.State.dirty_storage", "specifier": 0, "path": "src/ethereum_optimized/gray_glacier/state_db.py"}, "content": {"type": ["attribute"], "name": ["dirty_storage"]}}, {"source": {"identifier": "ethereum_optimized.gray_glacier.state_db.State.destroyed_accounts", "specifier": 0, "path": "src/ethereum_optimized/gray_glacier/state_db.py"}, "content": {"type": ["attribute"], "name": ["destroyed_accounts"]}}, {"source": {"identifier": "ethereum_optimized.gray_glacier.state_db.State.tx_restore_points", "specifier": 0, "path": "src/ethereum_optimized/gray_glacier/state_db.py"}, "content": {"type": ["attribute"], "name": ["tx_restore_points"]}}, {"source": {"identifier": "ethereum_optimized.gray_glacier.state_db.State.journal", "specifier": 0, "path": "src/ethereum_optimized/gray_glacier/state_db.py"}, "content": {"type": ["attribute"], "name": ["journal"]}}, {"source": {"identifier": "ethereum_optimized.gray_glacier.state_db.State.__init__", "specifier": 0, "path": "src/ethereum_optimized/gray_glacier/state_db.py"}, "content": {"type": ["function"], "name": ["__init__"]}}, {"source": {"identifier": "ethereum_optimized.gray_glacier.state_db.State.__eq__", "specifier": 0, "path": "src/ethereum_optimized/gray_glacier/state_db.py"}, "content": {"type": ["function"], "name": ["__eq__"], "text": ["Test for equality by comparing state roots."]}}, {"source": {"identifier": "ethereum_optimized.gray_glacier.state_db.State.__enter__", "specifier": 0, "path": "src/ethereum_optimized/gray_glacier/state_db.py"}, "content": {"type": ["function"], "name": ["__enter__"], "text": ["Support with statements"]}}, {"source": {"identifier": "ethereum_optimized.gray_glacier.state_db.State.__exit__", "specifier": 0, "path": "src/ethereum_optimized/gray_glacier/state_db.py"}, "content": {"type": ["function"], "name": ["__exit__"], "text": ["Support with statements"]}}, {"source": {"identifier": "ethereum_optimized.gray_glacier.state_db.close_state", "specifier": 0, "path": "src/ethereum_optimized/gray_glacier/state_db.py"}, "content": {"type": ["function"], "name": ["close_state"], "text": ["Close a state, releasing all resources it holds"]}}, {"source": {"identifier": "ethereum_optimized.gray_glacier.state_db.get_metadata", "specifier": 0, "path": "src/ethereum_optimized/gray_glacier/state_db.py"}, "content": {"type": ["function"], "name": ["get_metadata"], "text": ["Get a piece of metadata"]}}, {"source": {"identifier": "ethereum_optimized.gray_glacier.state_db.set_metadata", "specifier": 0, "path": "src/ethereum_optimized/gray_glacier/state_db.py"}, "content": {"type": ["function"], "name": ["set_metadata"], "text": ["Set a piece of metadata"]}}, {"source": {"identifier": "ethereum_optimized.gray_glacier.state_db.begin_db_transaction", "specifier": 0, "path": "src/ethereum_optimized/gray_glacier/state_db.py"}, "content": {"type": ["function"], "name": ["begin_db_transaction"], "text": ["Start a database transaction. A transaction is automatically started when a State  is created. Nesting of DB transactions is not supported (unlike non-db transactions). No operations are supported when not in a transaction."]}}, {"source": {"identifier": "ethereum_optimized.gray_glacier.state_db.commit_db_transaction", "specifier": 0, "path": "src/ethereum_optimized/gray_glacier/state_db.py"}, "content": {"type": ["function"], "name": ["commit_db_transaction"], "text": ["Commit the current database transaction."]}}, {"source": {"identifier": "ethereum_optimized.gray_glacier.state_db.state_root", "specifier": 0, "path": "src/ethereum_optimized/gray_glacier/state_db.py"}, "content": {"type": ["function"], "name": ["state_root"], "text": ["See  ethereum.gray_glacier.state ."]}}, {"source": {"identifier": "ethereum_optimized.gray_glacier.state_db.storage_root", "specifier": 0, "path": "src/ethereum_optimized/gray_glacier/state_db.py"}, "content": {"type": ["function"], "name": ["storage_root"], "text": ["See  ethereum.gray_glacier.state ."]}}, {"source": {"identifier": "ethereum_optimized.gray_glacier.state_db.flush", "specifier": 0, "path": "src/ethereum_optimized/gray_glacier/state_db.py"}, "content": {"type": ["function"], "name": ["flush"], "text": ["Send everything in the internal caches to the Rust layer."]}}, {"source": {"identifier": "ethereum_optimized.gray_glacier.state_db.rollback_db_transaction", "specifier": 0, "path": "src/ethereum_optimized/gray_glacier/state_db.py"}, "content": {"type": ["function"], "name": ["rollback_db_transaction"], "text": ["Rollback the current database transaction."]}}, {"source": {"identifier": "ethereum_optimized.gray_glacier.state_db.begin_transaction", "specifier": 0, "path": "src/ethereum_optimized/gray_glacier/state_db.py"}, "content": {"type": ["function"], "name": ["begin_transaction"], "text": ["See  ethereum.gray_glacier.state ."]}}, {"source": {"identifier": "ethereum_optimized.gray_glacier.state_db.commit_transaction", "specifier": 0, "path": "src/ethereum_optimized/gray_glacier/state_db.py"}, "content": {"type": ["function"], "name": ["commit_transaction"], "text": ["See  ethereum.gray_glacier.state ."]}}, {"source": {"identifier": "ethereum_optimized.gray_glacier.state_db.rollback_transaction", "specifier": 0, "path": "src/ethereum_optimized/gray_glacier/state_db.py"}, "content": {"type": ["function"], "name": ["rollback_transaction"], "text": ["See  ethereum.gray_glacier.state ."]}}, {"source": {"identifier": "ethereum_optimized.gray_glacier.state_db.get_storage", "specifier": 0, "path": "src/ethereum_optimized/gray_glacier/state_db.py"}, "content": {"type": ["function"], "name": ["get_storage"], "text": ["See  ethereum.gray_glacier.state ."]}}, {"source": {"identifier": "ethereum_optimized.gray_glacier.state_db.get_storage_original", "specifier": 0, "path": "src/ethereum_optimized/gray_glacier/state_db.py"}, "content": {"type": ["function"], "name": ["get_storage_original"], "text": ["See  ethereum.istanbul.state ."]}}, {"source": {"identifier": "ethereum_optimized.gray_glacier.state_db.set_storage", "specifier": 0, "path": "src/ethereum_optimized/gray_glacier/state_db.py"}, "content": {"type": ["function"], "name": ["set_storage"], "text": ["See  ethereum.gray_glacier.state ."]}}, {"source": {"identifier": "ethereum_optimized.gray_glacier.state_db.get_account_optional", "specifier": 0, "path": "src/ethereum_optimized/gray_glacier/state_db.py"}, "content": {"type": ["function"], "name": ["get_account_optional"], "text": ["See  ethereum.gray_glacier.state ."]}}, {"source": {"identifier": "ethereum_optimized.gray_glacier.state_db.set_account", "specifier": 0, "path": "src/ethereum_optimized/gray_glacier/state_db.py"}, "content": {"type": ["function"], "name": ["set_account"], "text": ["See  ethereum.gray_glacier.state ."]}}, {"source": {"identifier": "ethereum_optimized.gray_glacier.state_db.destroy_storage", "specifier": 0, "path": "src/ethereum_optimized/gray_glacier/state_db.py"}, "content": {"type": ["function"], "name": ["destroy_storage"], "text": ["See  ethereum.gray_glacier.state ."]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.precompiled_contracts.sha256", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/precompiled_contracts/sha256.py"}, "content": {"type": ["module"], "name": ["ethereum.spurious_dragon.vm.precompiled_contracts.sha256"], "text": ["Ethereum Virtual Machine (EVM) SHA256 PRECOMPILED CONTRACT ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementation of the  SHA256  precompiled contract."]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.precompiled_contracts.sha256.sha256", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/precompiled_contracts/sha256.py"}, "content": {"type": ["function"], "name": ["sha256"], "text": ["Writes the sha256 hash to output. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.control_flow", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/control_flow.py"}, "content": {"type": ["module"], "name": ["ethereum.muir_glacier.vm.instructions.control_flow"], "text": ["Ethereum Virtual Machine (EVM) Control Flow Instructions ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementations of the EVM control flow instructions."]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.control_flow.stop", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/control_flow.py"}, "content": {"type": ["function"], "name": ["stop"], "text": ["Stop further execution of EVM code. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.control_flow.jump", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/control_flow.py"}, "content": {"type": ["function"], "name": ["jump"], "text": ["Alter the program counter to the location specified by the top of the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.control_flow.jumpi", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/control_flow.py"}, "content": {"type": ["function"], "name": ["jumpi"], "text": ["Alter the program counter to the specified location if and only if a condition is true. If the condition is not true, then the program counter would increase only by 1. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.control_flow.pc", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/control_flow.py"}, "content": {"type": ["function"], "name": ["pc"], "text": ["Push onto the stack the value of the program counter after reaching the current instruction and without increasing it for the next instruction. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.control_flow.gas_left", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/control_flow.py"}, "content": {"type": ["function"], "name": ["gas_left"], "text": ["Push the amount of available gas (including the corresponding reduction for the cost of this instruction) onto the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.control_flow.jumpdest", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/control_flow.py"}, "content": {"type": ["function"], "name": ["jumpdest"], "text": ["Mark a valid destination for jumps. This is a noop, present only to be used by  JUMP  and  JUMPI  opcodes to verify that their jump is valid. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.arithmetic", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/arithmetic.py"}, "content": {"type": ["module"], "name": ["ethereum.shanghai.vm.instructions.arithmetic"], "text": ["Ethereum Virtual Machine (EVM) Arithmetic Instructions ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementations of the EVM Arithmetic instructions."]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.arithmetic.add", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/arithmetic.py"}, "content": {"type": ["function"], "name": ["add"], "text": ["Adds the top two elements of the stack together, and pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.arithmetic.sub", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/arithmetic.py"}, "content": {"type": ["function"], "name": ["sub"], "text": ["Subtracts the top two elements of the stack, and pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.arithmetic.mul", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/arithmetic.py"}, "content": {"type": ["function"], "name": ["mul"], "text": ["Multiply the top two elements of the stack, and pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.arithmetic.div", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/arithmetic.py"}, "content": {"type": ["function"], "name": ["div"], "text": ["Integer division of the top two elements of the stack. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.arithmetic.sdiv", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/arithmetic.py"}, "content": {"type": ["function"], "name": ["sdiv"], "text": ["Signed integer division of the top two elements of the stack. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.arithmetic.mod", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/arithmetic.py"}, "content": {"type": ["function"], "name": ["mod"], "text": ["Modulo remainder of the top two elements of the stack. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.arithmetic.smod", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/arithmetic.py"}, "content": {"type": ["function"], "name": ["smod"], "text": ["Signed modulo remainder of the top two elements of the stack. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.arithmetic.addmod", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/arithmetic.py"}, "content": {"type": ["function"], "name": ["addmod"], "text": ["Modulo addition of the top 2 elements with the 3rd element. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.arithmetic.mulmod", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/arithmetic.py"}, "content": {"type": ["function"], "name": ["mulmod"], "text": ["Modulo multiplication of the top 2 elements with the 3rd element. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.arithmetic.exp", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/arithmetic.py"}, "content": {"type": ["function"], "name": ["exp"], "text": ["Exponential operation of the top 2 elements. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.arithmetic.signextend", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/arithmetic.py"}, "content": {"type": ["function"], "name": ["signextend"], "text": ["Sign extend operation. In other words, extend a signed number which fits in N bytes to 32 bytes. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum_optimized.gray_glacier.fork", "specifier": 0, "path": "src/ethereum_optimized/gray_glacier/fork.py"}, "content": {"type": ["module"], "name": ["ethereum_optimized.gray_glacier.fork"], "text": ["Optimized Spec ^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction This module contains functions can be monkey patched into ethereum.gray_glacier.fork  to use alternate optimized implementations."]}}, {"source": {"identifier": "ethereum_optimized.gray_glacier.fork.validate_proof_of_work", "specifier": 0, "path": "src/ethereum_optimized/gray_glacier/fork.py"}, "content": {"type": ["function"], "name": ["validate_proof_of_work"], "text": ["See  ethereum.gray_glacier.fork.validate_proof_of_work ."]}}, {"source": {"identifier": "ethereum.byzantium.vm.precompiled_contracts.alt_bn128", "specifier": 0, "path": "src/ethereum/byzantium/vm/precompiled_contracts/alt_bn128.py"}, "content": {"type": ["module"], "name": ["ethereum.byzantium.vm.precompiled_contracts.alt_bn128"], "text": ["Ethereum Virtual Machine (EVM) ALT_BN128 CONTRACTS ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementation of the ALT_BN128 precompiled contracts."]}}, {"source": {"identifier": "ethereum.byzantium.vm.precompiled_contracts.alt_bn128.alt_bn128_add", "specifier": 0, "path": "src/ethereum/byzantium/vm/precompiled_contracts/alt_bn128.py"}, "content": {"type": ["function"], "name": ["alt_bn128_add"], "text": ["The ALT_BN128 addition precompiled contract. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.byzantium.vm.precompiled_contracts.alt_bn128.alt_bn128_mul", "specifier": 0, "path": "src/ethereum/byzantium/vm/precompiled_contracts/alt_bn128.py"}, "content": {"type": ["function"], "name": ["alt_bn128_mul"], "text": ["The ALT_BN128 multiplication precompiled contract. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.byzantium.vm.precompiled_contracts.alt_bn128.alt_bn128_pairing_check", "specifier": 0, "path": "src/ethereum/byzantium/vm/precompiled_contracts/alt_bn128.py"}, "content": {"type": ["function"], "name": ["alt_bn128_pairing_check"], "text": ["The ALT_BN128 pairing check precompiled contract. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.precompiled_contracts.ecrecover", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/precompiled_contracts/ecrecover.py"}, "content": {"type": ["module"], "name": ["ethereum.spurious_dragon.vm.precompiled_contracts.ecrecover"], "text": ["Ethereum Virtual Machine (EVM) ECRECOVER PRECOMPILED CONTRACT ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementation of the ECRECOVER precompiled contract."]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.precompiled_contracts.ecrecover.ecrecover", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/precompiled_contracts/ecrecover.py"}, "content": {"type": ["function"], "name": ["ecrecover"], "text": ["Decrypts the address using elliptic curve DSA recovery mechanism and writes the address to output. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.comparison", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/comparison.py"}, "content": {"type": ["module"], "name": ["ethereum.muir_glacier.vm.instructions.comparison"], "text": ["Ethereum Virtual Machine (EVM) Comparison Instructions ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementations of the EVM Comparison instructions."]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.comparison.less_than", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/comparison.py"}, "content": {"type": ["function"], "name": ["less_than"], "text": ["Checks if the top element is less than the next top element. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.comparison.signed_less_than", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/comparison.py"}, "content": {"type": ["function"], "name": ["signed_less_than"], "text": ["Signed less-than comparison. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.comparison.greater_than", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/comparison.py"}, "content": {"type": ["function"], "name": ["greater_than"], "text": ["Checks if the top element is greater than the next top element. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.comparison.signed_greater_than", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/comparison.py"}, "content": {"type": ["function"], "name": ["signed_greater_than"], "text": ["Signed greater-than comparison. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.comparison.equal", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/comparison.py"}, "content": {"type": ["function"], "name": ["equal"], "text": ["Checks if the top element is equal to the next top element. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.comparison.is_zero", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/comparison.py"}, "content": {"type": ["function"], "name": ["is_zero"], "text": ["Checks if the top element is equal to 0. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum_optimized.arrow_glacier", "specifier": 0, "path": "src/ethereum_optimized/arrow_glacier/__init__.py"}, "content": {"type": ["module"], "name": ["ethereum_optimized.arrow_glacier"], "text": ["Optimized Implementations (Arrow Glacier) ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local:"]}}, {"source": {"identifier": "ethereum_optimized.arrow_glacier.monkey_patch_optimized_state_db", "specifier": 0, "path": "src/ethereum_optimized/arrow_glacier/__init__.py"}, "content": {"type": ["function"], "name": ["monkey_patch_optimized_state_db"], "text": ["Replace the state interface with one that supports high performance updates and storing state in a database. This function must be called before the state interface is imported anywhere."]}}, {"source": {"identifier": "ethereum_optimized.arrow_glacier.monkey_patch_optimized_spec", "specifier": 0, "path": "src/ethereum_optimized/arrow_glacier/__init__.py"}, "content": {"type": ["function"], "name": ["monkey_patch_optimized_spec"], "text": ["Replace the ethash implementation with one that supports higher performance. This function must be called before the spec interface is imported anywhere."]}}, {"source": {"identifier": "ethereum_optimized.arrow_glacier.monkey_patch", "specifier": 0, "path": "src/ethereum_optimized/arrow_glacier/__init__.py"}, "content": {"type": ["function"], "name": ["monkey_patch"], "text": ["Apply all monkey patches to swap in high performance implementations. This function must be called before any of the ethereum modules are imported anywhere."]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.keccak", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/keccak.py"}, "content": {"type": ["module"], "name": ["ethereum.shanghai.vm.instructions.keccak"], "text": ["Ethereum Virtual Machine (EVM) Keccak Instructions ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementations of the EVM keccak instructions."]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.keccak.keccak", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/keccak.py"}, "content": {"type": ["function"], "name": ["keccak"], "text": ["Pushes to the stack the Keccak-256 hash of a region of memory. This also expands the memory, in case the memory is insufficient to access the data's memory location. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.byzantium.vm.precompiled_contracts.ripemd160", "specifier": 0, "path": "src/ethereum/byzantium/vm/precompiled_contracts/ripemd160.py"}, "content": {"type": ["module"], "name": ["ethereum.byzantium.vm.precompiled_contracts.ripemd160"], "text": ["Ethereum Virtual Machine (EVM) RIPEMD160 PRECOMPILED CONTRACT ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementation of the  RIPEMD160  precompiled contract."]}}, {"source": {"identifier": "ethereum.byzantium.vm.precompiled_contracts.ripemd160.ripemd160", "specifier": 0, "path": "src/ethereum/byzantium/vm/precompiled_contracts/ripemd160.py"}, "content": {"type": ["function"], "name": ["ripemd160"], "text": ["Writes the ripemd160 hash to output. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum_optimized.arrow_glacier.state_db", "specifier": 0, "path": "src/ethereum_optimized/arrow_glacier/state_db.py"}, "content": {"type": ["module"], "name": ["ethereum_optimized.arrow_glacier.state_db"], "text": ["Optimized State ^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction This module contains functions can be monkey patched into ethereum.arrow_glacier.state  to use an optimized database backed state."]}}, {"source": {"identifier": "ethereum_optimized.arrow_glacier.state_db.UnmodifiedType", "specifier": 0, "path": "src/ethereum_optimized/arrow_glacier/state_db.py"}, "content": {"type": ["class"], "name": ["UnmodifiedType"], "text": ["Sentinal type to represent a value that hasn't been modified."]}}, {"source": {"identifier": "ethereum_optimized.arrow_glacier.state_db.Unmodified", "specifier": 0, "path": "src/ethereum_optimized/arrow_glacier/state_db.py"}, "content": {"type": ["attribute"], "name": ["Unmodified"]}}, {"source": {"identifier": "ethereum_optimized.arrow_glacier.state_db.State", "specifier": 0, "path": "src/ethereum_optimized/arrow_glacier/state_db.py"}, "content": {"type": ["class"], "name": ["State"], "text": ["The State, backed by a LMDB database. When created with  State()  store the db in a temporary directory. When created with  State(path)  open or create the db located at  path ."]}}, {"source": {"identifier": "ethereum_optimized.arrow_glacier.state_db.State.default_path", "specifier": 0, "path": "src/ethereum_optimized/arrow_glacier/state_db.py"}, "content": {"type": ["attribute"], "name": ["default_path"]}}, {"source": {"identifier": "ethereum_optimized.arrow_glacier.state_db.State.db", "specifier": 0, "path": "src/ethereum_optimized/arrow_glacier/state_db.py"}, "content": {"type": ["attribute"], "name": ["db"]}}, {"source": {"identifier": "ethereum_optimized.arrow_glacier.state_db.State.dirty_accounts", "specifier": 0, "path": "src/ethereum_optimized/arrow_glacier/state_db.py"}, "content": {"type": ["attribute"], "name": ["dirty_accounts"]}}, {"source": {"identifier": "ethereum_optimized.arrow_glacier.state_db.State.dirty_storage", "specifier": 0, "path": "src/ethereum_optimized/arrow_glacier/state_db.py"}, "content": {"type": ["attribute"], "name": ["dirty_storage"]}}, {"source": {"identifier": "ethereum_optimized.arrow_glacier.state_db.State.destroyed_accounts", "specifier": 0, "path": "src/ethereum_optimized/arrow_glacier/state_db.py"}, "content": {"type": ["attribute"], "name": ["destroyed_accounts"]}}, {"source": {"identifier": "ethereum_optimized.arrow_glacier.state_db.State.tx_restore_points", "specifier": 0, "path": "src/ethereum_optimized/arrow_glacier/state_db.py"}, "content": {"type": ["attribute"], "name": ["tx_restore_points"]}}, {"source": {"identifier": "ethereum_optimized.arrow_glacier.state_db.State.journal", "specifier": 0, "path": "src/ethereum_optimized/arrow_glacier/state_db.py"}, "content": {"type": ["attribute"], "name": ["journal"]}}, {"source": {"identifier": "ethereum_optimized.arrow_glacier.state_db.State.__init__", "specifier": 0, "path": "src/ethereum_optimized/arrow_glacier/state_db.py"}, "content": {"type": ["function"], "name": ["__init__"]}}, {"source": {"identifier": "ethereum_optimized.arrow_glacier.state_db.State.__eq__", "specifier": 0, "path": "src/ethereum_optimized/arrow_glacier/state_db.py"}, "content": {"type": ["function"], "name": ["__eq__"], "text": ["Test for equality by comparing state roots."]}}, {"source": {"identifier": "ethereum_optimized.arrow_glacier.state_db.State.__enter__", "specifier": 0, "path": "src/ethereum_optimized/arrow_glacier/state_db.py"}, "content": {"type": ["function"], "name": ["__enter__"], "text": ["Support with statements"]}}, {"source": {"identifier": "ethereum_optimized.arrow_glacier.state_db.State.__exit__", "specifier": 0, "path": "src/ethereum_optimized/arrow_glacier/state_db.py"}, "content": {"type": ["function"], "name": ["__exit__"], "text": ["Support with statements"]}}, {"source": {"identifier": "ethereum_optimized.arrow_glacier.state_db.close_state", "specifier": 0, "path": "src/ethereum_optimized/arrow_glacier/state_db.py"}, "content": {"type": ["function"], "name": ["close_state"], "text": ["Close a state, releasing all resources it holds"]}}, {"source": {"identifier": "ethereum_optimized.arrow_glacier.state_db.get_metadata", "specifier": 0, "path": "src/ethereum_optimized/arrow_glacier/state_db.py"}, "content": {"type": ["function"], "name": ["get_metadata"], "text": ["Get a piece of metadata"]}}, {"source": {"identifier": "ethereum_optimized.arrow_glacier.state_db.set_metadata", "specifier": 0, "path": "src/ethereum_optimized/arrow_glacier/state_db.py"}, "content": {"type": ["function"], "name": ["set_metadata"], "text": ["Set a piece of metadata"]}}, {"source": {"identifier": "ethereum_optimized.arrow_glacier.state_db.begin_db_transaction", "specifier": 0, "path": "src/ethereum_optimized/arrow_glacier/state_db.py"}, "content": {"type": ["function"], "name": ["begin_db_transaction"], "text": ["Start a database transaction. A transaction is automatically started when a State  is created. Nesting of DB transactions is not supported (unlike non-db transactions). No operations are supported when not in a transaction."]}}, {"source": {"identifier": "ethereum_optimized.arrow_glacier.state_db.commit_db_transaction", "specifier": 0, "path": "src/ethereum_optimized/arrow_glacier/state_db.py"}, "content": {"type": ["function"], "name": ["commit_db_transaction"], "text": ["Commit the current database transaction."]}}, {"source": {"identifier": "ethereum_optimized.arrow_glacier.state_db.state_root", "specifier": 0, "path": "src/ethereum_optimized/arrow_glacier/state_db.py"}, "content": {"type": ["function"], "name": ["state_root"], "text": ["See  ethereum.arrow_glacier.state ."]}}, {"source": {"identifier": "ethereum_optimized.arrow_glacier.state_db.storage_root", "specifier": 0, "path": "src/ethereum_optimized/arrow_glacier/state_db.py"}, "content": {"type": ["function"], "name": ["storage_root"], "text": ["See  ethereum.arrow_glacier.state ."]}}, {"source": {"identifier": "ethereum_optimized.arrow_glacier.state_db.flush", "specifier": 0, "path": "src/ethereum_optimized/arrow_glacier/state_db.py"}, "content": {"type": ["function"], "name": ["flush"], "text": ["Send everything in the internal caches to the Rust layer."]}}, {"source": {"identifier": "ethereum_optimized.arrow_glacier.state_db.rollback_db_transaction", "specifier": 0, "path": "src/ethereum_optimized/arrow_glacier/state_db.py"}, "content": {"type": ["function"], "name": ["rollback_db_transaction"], "text": ["Rollback the current database transaction."]}}, {"source": {"identifier": "ethereum_optimized.arrow_glacier.state_db.begin_transaction", "specifier": 0, "path": "src/ethereum_optimized/arrow_glacier/state_db.py"}, "content": {"type": ["function"], "name": ["begin_transaction"], "text": ["See  ethereum.arrow_glacier.state ."]}}, {"source": {"identifier": "ethereum_optimized.arrow_glacier.state_db.commit_transaction", "specifier": 0, "path": "src/ethereum_optimized/arrow_glacier/state_db.py"}, "content": {"type": ["function"], "name": ["commit_transaction"], "text": ["See  ethereum.arrow_glacier.state ."]}}, {"source": {"identifier": "ethereum_optimized.arrow_glacier.state_db.rollback_transaction", "specifier": 0, "path": "src/ethereum_optimized/arrow_glacier/state_db.py"}, "content": {"type": ["function"], "name": ["rollback_transaction"], "text": ["See  ethereum.arrow_glacier.state ."]}}, {"source": {"identifier": "ethereum_optimized.arrow_glacier.state_db.get_storage", "specifier": 0, "path": "src/ethereum_optimized/arrow_glacier/state_db.py"}, "content": {"type": ["function"], "name": ["get_storage"], "text": ["See  ethereum.arrow_glacier.state ."]}}, {"source": {"identifier": "ethereum_optimized.arrow_glacier.state_db.get_storage_original", "specifier": 0, "path": "src/ethereum_optimized/arrow_glacier/state_db.py"}, "content": {"type": ["function"], "name": ["get_storage_original"], "text": ["See  ethereum.istanbul.state ."]}}, {"source": {"identifier": "ethereum_optimized.arrow_glacier.state_db.set_storage", "specifier": 0, "path": "src/ethereum_optimized/arrow_glacier/state_db.py"}, "content": {"type": ["function"], "name": ["set_storage"], "text": ["See  ethereum.arrow_glacier.state ."]}}, {"source": {"identifier": "ethereum_optimized.arrow_glacier.state_db.get_account_optional", "specifier": 0, "path": "src/ethereum_optimized/arrow_glacier/state_db.py"}, "content": {"type": ["function"], "name": ["get_account_optional"], "text": ["See  ethereum.arrow_glacier.state ."]}}, {"source": {"identifier": "ethereum_optimized.arrow_glacier.state_db.set_account", "specifier": 0, "path": "src/ethereum_optimized/arrow_glacier/state_db.py"}, "content": {"type": ["function"], "name": ["set_account"], "text": ["See  ethereum.arrow_glacier.state ."]}}, {"source": {"identifier": "ethereum_optimized.arrow_glacier.state_db.destroy_storage", "specifier": 0, "path": "src/ethereum_optimized/arrow_glacier/state_db.py"}, "content": {"type": ["function"], "name": ["destroy_storage"], "text": ["See  ethereum.arrow_glacier.state ."]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.precompiled_contracts.identity", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/precompiled_contracts/identity.py"}, "content": {"type": ["module"], "name": ["ethereum.spurious_dragon.vm.precompiled_contracts.identity"], "text": ["Ethereum Virtual Machine (EVM) IDENTITY PRECOMPILED CONTRACT ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementation of the  IDENTITY  precompiled contract."]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.precompiled_contracts.identity.identity", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/precompiled_contracts/identity.py"}, "content": {"type": ["function"], "name": ["identity"], "text": ["Writes the message data to output. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.log", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/log.py"}, "content": {"type": ["module"], "name": ["ethereum.muir_glacier.vm.instructions.log"], "text": ["Ethereum Virtual Machine (EVM) Logging Instructions ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementations of the EVM logging instructions."]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.log.log_n", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/log.py"}, "content": {"type": ["function"], "name": ["log_n"], "text": ["Appends a log entry, having  num_topics  topics, to the evm logs. This will also expand the memory if the data (required by the log entry) corresponding to the memory is not accessible. Parameters evm : The current EVM frame. num_topics : The number of topics to be included in the log entry."]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.log.log0", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/log.py"}, "content": {"type": ["attribute"], "name": ["log0"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.log.log1", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/log.py"}, "content": {"type": ["attribute"], "name": ["log1"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.log.log2", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/log.py"}, "content": {"type": ["attribute"], "name": ["log2"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.log.log3", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/log.py"}, "content": {"type": ["attribute"], "name": ["log3"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.log.log4", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/log.py"}, "content": {"type": ["attribute"], "name": ["log4"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.bitwise", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/bitwise.py"}, "content": {"type": ["module"], "name": ["ethereum.shanghai.vm.instructions.bitwise"], "text": ["Ethereum Virtual Machine (EVM) Bitwise Instructions ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementations of the EVM bitwise instructions."]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.bitwise.bitwise_and", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/bitwise.py"}, "content": {"type": ["function"], "name": ["bitwise_and"], "text": ["Bitwise AND operation of the top 2 elements of the stack. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.bitwise.bitwise_or", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/bitwise.py"}, "content": {"type": ["function"], "name": ["bitwise_or"], "text": ["Bitwise OR operation of the top 2 elements of the stack. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.bitwise.bitwise_xor", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/bitwise.py"}, "content": {"type": ["function"], "name": ["bitwise_xor"], "text": ["Bitwise XOR operation of the top 2 elements of the stack. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.bitwise.bitwise_not", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/bitwise.py"}, "content": {"type": ["function"], "name": ["bitwise_not"], "text": ["Bitwise NOT operation of the top element of the stack. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.bitwise.get_byte", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/bitwise.py"}, "content": {"type": ["function"], "name": ["get_byte"], "text": ["For a word (defined by next top element of the stack), retrieve the Nth byte (0-indexed and defined by top element of stack) from the left (most significant) to right (least significant). Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.bitwise.bitwise_shl", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/bitwise.py"}, "content": {"type": ["function"], "name": ["bitwise_shl"], "text": ["Logical shift left (SHL) operation of the top 2 elements of the stack. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.bitwise.bitwise_shr", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/bitwise.py"}, "content": {"type": ["function"], "name": ["bitwise_shr"], "text": ["Logical shift right (SHR) operation of the top 2 elements of the stack. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.bitwise.bitwise_sar", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/bitwise.py"}, "content": {"type": ["function"], "name": ["bitwise_sar"], "text": ["Arithmetic shift right (SAR) operation of the top 2 elements of the stack. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum_optimized.arrow_glacier.fork", "specifier": 0, "path": "src/ethereum_optimized/arrow_glacier/fork.py"}, "content": {"type": ["module"], "name": ["ethereum_optimized.arrow_glacier.fork"], "text": ["Optimized Spec ^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction This module contains functions can be monkey patched into ethereum.arrow_glacier.fork  to use alternate optimized implementations."]}}, {"source": {"identifier": "ethereum_optimized.arrow_glacier.fork.validate_proof_of_work", "specifier": 0, "path": "src/ethereum_optimized/arrow_glacier/fork.py"}, "content": {"type": ["function"], "name": ["validate_proof_of_work"], "text": ["See  ethereum.arrow_glacier.fork.validate_proof_of_work ."]}}, {"source": {"identifier": "ethereum.byzantium.vm.precompiled_contracts.sha256", "specifier": 0, "path": "src/ethereum/byzantium/vm/precompiled_contracts/sha256.py"}, "content": {"type": ["module"], "name": ["ethereum.byzantium.vm.precompiled_contracts.sha256"], "text": ["Ethereum Virtual Machine (EVM) SHA256 PRECOMPILED CONTRACT ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementation of the  SHA256  precompiled contract."]}}, {"source": {"identifier": "ethereum.byzantium.vm.precompiled_contracts.sha256.sha256", "specifier": 0, "path": "src/ethereum/byzantium/vm/precompiled_contracts/sha256.py"}, "content": {"type": ["function"], "name": ["sha256"], "text": ["Writes the sha256 hash to output. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.memory", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/memory.py"}, "content": {"type": ["module"], "name": ["ethereum.spurious_dragon.vm.instructions.memory"], "text": ["Ethereum Virtual Machine (EVM) Memory Instructions ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementations of the EVM Memory instructions."]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.memory.mstore", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/memory.py"}, "content": {"type": ["function"], "name": ["mstore"], "text": ["Stores a word to memory. This also expands the memory, if the memory is insufficient to store the word. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.memory.mstore8", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/memory.py"}, "content": {"type": ["function"], "name": ["mstore8"], "text": ["Stores a byte to memory. This also expands the memory, if the memory is insufficient to store the word. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.memory.mload", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/memory.py"}, "content": {"type": ["function"], "name": ["mload"], "text": ["Load word from memory. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.memory.msize", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/memory.py"}, "content": {"type": ["function"], "name": ["msize"], "text": ["Push the size of active memory in bytes onto the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.storage", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/storage.py"}, "content": {"type": ["module"], "name": ["ethereum.muir_glacier.vm.instructions.storage"], "text": ["Ethereum Virtual Machine (EVM) Storage Instructions ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementations of the EVM storage related instructions."]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.storage.sload", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/storage.py"}, "content": {"type": ["function"], "name": ["sload"], "text": ["Loads to the stack, the value corresponding to a certain key from the storage of the current account. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.storage.sstore", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/storage.py"}, "content": {"type": ["function"], "name": ["sstore"], "text": ["Stores a value at a certain key in the current context's storage. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum_optimized.istanbul", "specifier": 0, "path": "src/ethereum_optimized/istanbul/__init__.py"}, "content": {"type": ["module"], "name": ["ethereum_optimized.istanbul"], "text": ["Optimized Implementations (Istanbul) ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local:"]}}, {"source": {"identifier": "ethereum_optimized.istanbul.monkey_patch_optimized_state_db", "specifier": 0, "path": "src/ethereum_optimized/istanbul/__init__.py"}, "content": {"type": ["function"], "name": ["monkey_patch_optimized_state_db"], "text": ["Replace the state interface with one that supports high performance updates and storing state in a database. This function must be called before the state interface is imported anywhere."]}}, {"source": {"identifier": "ethereum_optimized.istanbul.monkey_patch_optimized_spec", "specifier": 0, "path": "src/ethereum_optimized/istanbul/__init__.py"}, "content": {"type": ["function"], "name": ["monkey_patch_optimized_spec"], "text": ["Replace the ethash implementation with one that supports higher performance. This function must be called before the spec interface is imported anywhere."]}}, {"source": {"identifier": "ethereum_optimized.istanbul.monkey_patch", "specifier": 0, "path": "src/ethereum_optimized/istanbul/__init__.py"}, "content": {"type": ["function"], "name": ["monkey_patch"], "text": ["Apply all monkey patches to swap in high performance implementations. This function must be called before any of the ethereum modules are imported anywhere."]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.environment", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/environment.py"}, "content": {"type": ["module"], "name": ["ethereum.shanghai.vm.instructions.environment"], "text": ["Ethereum Virtual Machine (EVM) Environmental Instructions ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementations of the EVM environment related instructions."]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.environment.address", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["address"], "text": ["Pushes the address of the current executing account to the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.environment.balance", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["balance"], "text": ["Pushes the balance of the given account onto the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.environment.origin", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["origin"], "text": ["Pushes the address of the original transaction sender to the stack. The origin address can only be an EOA. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.environment.caller", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["caller"], "text": ["Pushes the address of the caller onto the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.environment.callvalue", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["callvalue"], "text": ["Push the value (in wei) sent with the call onto the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.environment.calldataload", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["calldataload"], "text": ["Push a word (32 bytes) of the input data belonging to the current environment onto the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.environment.calldatasize", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["calldatasize"], "text": ["Push the size of input data in current environment onto the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.environment.calldatacopy", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["calldatacopy"], "text": ["Copy a portion of the input data in current environment to memory. This will also expand the memory, in case that the memory is insufficient to store the data. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.environment.codesize", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["codesize"], "text": ["Push the size of code running in current environment onto the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.environment.codecopy", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["codecopy"], "text": ["Copy a portion of the code in current environment to memory. This will also expand the memory, in case that the memory is insufficient to store the data. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.environment.gasprice", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["gasprice"], "text": ["Push the gas price used in current environment onto the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.environment.extcodesize", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["extcodesize"], "text": ["Push the code size of a given account onto the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.environment.extcodecopy", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["extcodecopy"], "text": ["Copy a portion of an account's code to memory. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.environment.returndatasize", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["returndatasize"], "text": ["Pushes the size of the return data buffer onto the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.environment.returndatacopy", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["returndatacopy"], "text": ["Copies data from the return data buffer code to memory Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.environment.extcodehash", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["extcodehash"], "text": ["Returns the keccak256 hash of a contract\u2019s bytecode Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.environment.self_balance", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["self_balance"], "text": ["Pushes the balance of the current address to the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.environment.base_fee", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["base_fee"], "text": ["Pushes the base fee of the current block on to the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.byzantium.vm.precompiled_contracts.modexp", "specifier": 0, "path": "src/ethereum/byzantium/vm/precompiled_contracts/modexp.py"}, "content": {"type": ["module"], "name": ["ethereum.byzantium.vm.precompiled_contracts.modexp"], "text": ["Ethereum Virtual Machine (EVM) MODEXP PRECOMPILED CONTRACT ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementation of the  MODEXP  precompiled contract."]}}, {"source": {"identifier": "ethereum.byzantium.vm.precompiled_contracts.modexp.GQUADDIVISOR", "specifier": 0, "path": "src/ethereum/byzantium/vm/precompiled_contracts/modexp.py"}, "content": {"type": ["attribute"], "name": ["GQUADDIVISOR"]}}, {"source": {"identifier": "ethereum.byzantium.vm.precompiled_contracts.modexp.modexp", "specifier": 0, "path": "src/ethereum/byzantium/vm/precompiled_contracts/modexp.py"}, "content": {"type": ["function"], "name": ["modexp"], "text": ["Calculates  (base**exp) % modulus  for arbitary sized  base ,  exp  and. modulus . The return value is the same length as the modulus."]}}, {"source": {"identifier": "ethereum.byzantium.vm.precompiled_contracts.modexp.get_mult_complexity", "specifier": 0, "path": "src/ethereum/byzantium/vm/precompiled_contracts/modexp.py"}, "content": {"type": ["function"], "name": ["get_mult_complexity"], "text": ["Estimate the complexity of performing Karatsuba multiplication."]}}, {"source": {"identifier": "ethereum_optimized.istanbul.state_db", "specifier": 0, "path": "src/ethereum_optimized/istanbul/state_db.py"}, "content": {"type": ["module"], "name": ["ethereum_optimized.istanbul.state_db"], "text": ["Optimized State ^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction This module contains functions can be monkey patched into ethereum.istanbul.state  to use an optimized database backed state."]}}, {"source": {"identifier": "ethereum_optimized.istanbul.state_db.UnmodifiedType", "specifier": 0, "path": "src/ethereum_optimized/istanbul/state_db.py"}, "content": {"type": ["class"], "name": ["UnmodifiedType"], "text": ["Sentinal type to represent a value that hasn't been modified."]}}, {"source": {"identifier": "ethereum_optimized.istanbul.state_db.Unmodified", "specifier": 0, "path": "src/ethereum_optimized/istanbul/state_db.py"}, "content": {"type": ["attribute"], "name": ["Unmodified"]}}, {"source": {"identifier": "ethereum_optimized.istanbul.state_db.State", "specifier": 0, "path": "src/ethereum_optimized/istanbul/state_db.py"}, "content": {"type": ["class"], "name": ["State"], "text": ["The State, backed by a LMDB database. When created with  State()  store the db in a temporary directory. When created with  State(path)  open or create the db located at  path ."]}}, {"source": {"identifier": "ethereum_optimized.istanbul.state_db.State.default_path", "specifier": 0, "path": "src/ethereum_optimized/istanbul/state_db.py"}, "content": {"type": ["attribute"], "name": ["default_path"]}}, {"source": {"identifier": "ethereum_optimized.istanbul.state_db.State.db", "specifier": 0, "path": "src/ethereum_optimized/istanbul/state_db.py"}, "content": {"type": ["attribute"], "name": ["db"]}}, {"source": {"identifier": "ethereum_optimized.istanbul.state_db.State.dirty_accounts", "specifier": 0, "path": "src/ethereum_optimized/istanbul/state_db.py"}, "content": {"type": ["attribute"], "name": ["dirty_accounts"]}}, {"source": {"identifier": "ethereum_optimized.istanbul.state_db.State.dirty_storage", "specifier": 0, "path": "src/ethereum_optimized/istanbul/state_db.py"}, "content": {"type": ["attribute"], "name": ["dirty_storage"]}}, {"source": {"identifier": "ethereum_optimized.istanbul.state_db.State.destroyed_accounts", "specifier": 0, "path": "src/ethereum_optimized/istanbul/state_db.py"}, "content": {"type": ["attribute"], "name": ["destroyed_accounts"]}}, {"source": {"identifier": "ethereum_optimized.istanbul.state_db.State.tx_restore_points", "specifier": 0, "path": "src/ethereum_optimized/istanbul/state_db.py"}, "content": {"type": ["attribute"], "name": ["tx_restore_points"]}}, {"source": {"identifier": "ethereum_optimized.istanbul.state_db.State.journal", "specifier": 0, "path": "src/ethereum_optimized/istanbul/state_db.py"}, "content": {"type": ["attribute"], "name": ["journal"]}}, {"source": {"identifier": "ethereum_optimized.istanbul.state_db.State.__init__", "specifier": 0, "path": "src/ethereum_optimized/istanbul/state_db.py"}, "content": {"type": ["function"], "name": ["__init__"]}}, {"source": {"identifier": "ethereum_optimized.istanbul.state_db.State.__eq__", "specifier": 0, "path": "src/ethereum_optimized/istanbul/state_db.py"}, "content": {"type": ["function"], "name": ["__eq__"], "text": ["Test for equality by comparing state roots."]}}, {"source": {"identifier": "ethereum_optimized.istanbul.state_db.State.__enter__", "specifier": 0, "path": "src/ethereum_optimized/istanbul/state_db.py"}, "content": {"type": ["function"], "name": ["__enter__"], "text": ["Support with statements"]}}, {"source": {"identifier": "ethereum_optimized.istanbul.state_db.State.__exit__", "specifier": 0, "path": "src/ethereum_optimized/istanbul/state_db.py"}, "content": {"type": ["function"], "name": ["__exit__"], "text": ["Support with statements"]}}, {"source": {"identifier": "ethereum_optimized.istanbul.state_db.close_state", "specifier": 0, "path": "src/ethereum_optimized/istanbul/state_db.py"}, "content": {"type": ["function"], "name": ["close_state"], "text": ["Close a state, releasing all resources it holds"]}}, {"source": {"identifier": "ethereum_optimized.istanbul.state_db.get_metadata", "specifier": 0, "path": "src/ethereum_optimized/istanbul/state_db.py"}, "content": {"type": ["function"], "name": ["get_metadata"], "text": ["Get a piece of metadata"]}}, {"source": {"identifier": "ethereum_optimized.istanbul.state_db.set_metadata", "specifier": 0, "path": "src/ethereum_optimized/istanbul/state_db.py"}, "content": {"type": ["function"], "name": ["set_metadata"], "text": ["Set a piece of metadata"]}}, {"source": {"identifier": "ethereum_optimized.istanbul.state_db.begin_db_transaction", "specifier": 0, "path": "src/ethereum_optimized/istanbul/state_db.py"}, "content": {"type": ["function"], "name": ["begin_db_transaction"], "text": ["Start a database transaction. A transaction is automatically started when a State  is created. Nesting of DB transactions is not supported (unlike non-db transactions). No operations are supported when not in a transaction."]}}, {"source": {"identifier": "ethereum_optimized.istanbul.state_db.commit_db_transaction", "specifier": 0, "path": "src/ethereum_optimized/istanbul/state_db.py"}, "content": {"type": ["function"], "name": ["commit_db_transaction"], "text": ["Commit the current database transaction."]}}, {"source": {"identifier": "ethereum_optimized.istanbul.state_db.state_root", "specifier": 0, "path": "src/ethereum_optimized/istanbul/state_db.py"}, "content": {"type": ["function"], "name": ["state_root"], "text": ["See  ethereum.istanbul.state ."]}}, {"source": {"identifier": "ethereum_optimized.istanbul.state_db.storage_root", "specifier": 0, "path": "src/ethereum_optimized/istanbul/state_db.py"}, "content": {"type": ["function"], "name": ["storage_root"], "text": ["See  ethereum.istanbul.state ."]}}, {"source": {"identifier": "ethereum_optimized.istanbul.state_db.flush", "specifier": 0, "path": "src/ethereum_optimized/istanbul/state_db.py"}, "content": {"type": ["function"], "name": ["flush"], "text": ["Send everything in the internal caches to the Rust layer."]}}, {"source": {"identifier": "ethereum_optimized.istanbul.state_db.rollback_db_transaction", "specifier": 0, "path": "src/ethereum_optimized/istanbul/state_db.py"}, "content": {"type": ["function"], "name": ["rollback_db_transaction"], "text": ["Rollback the current database transaction."]}}, {"source": {"identifier": "ethereum_optimized.istanbul.state_db.begin_transaction", "specifier": 0, "path": "src/ethereum_optimized/istanbul/state_db.py"}, "content": {"type": ["function"], "name": ["begin_transaction"], "text": ["See  ethereum.istanbul.state ."]}}, {"source": {"identifier": "ethereum_optimized.istanbul.state_db.commit_transaction", "specifier": 0, "path": "src/ethereum_optimized/istanbul/state_db.py"}, "content": {"type": ["function"], "name": ["commit_transaction"], "text": ["See  ethereum.istanbul.state ."]}}, {"source": {"identifier": "ethereum_optimized.istanbul.state_db.rollback_transaction", "specifier": 0, "path": "src/ethereum_optimized/istanbul/state_db.py"}, "content": {"type": ["function"], "name": ["rollback_transaction"], "text": ["See  ethereum.istanbul.state ."]}}, {"source": {"identifier": "ethereum_optimized.istanbul.state_db.get_storage", "specifier": 0, "path": "src/ethereum_optimized/istanbul/state_db.py"}, "content": {"type": ["function"], "name": ["get_storage"], "text": ["See  ethereum.istanbul.state ."]}}, {"source": {"identifier": "ethereum_optimized.istanbul.state_db.get_storage_original", "specifier": 0, "path": "src/ethereum_optimized/istanbul/state_db.py"}, "content": {"type": ["function"], "name": ["get_storage_original"], "text": ["See  ethereum.istanbul.state ."]}}, {"source": {"identifier": "ethereum_optimized.istanbul.state_db.set_storage", "specifier": 0, "path": "src/ethereum_optimized/istanbul/state_db.py"}, "content": {"type": ["function"], "name": ["set_storage"], "text": ["See  ethereum.istanbul.state ."]}}, {"source": {"identifier": "ethereum_optimized.istanbul.state_db.get_account_optional", "specifier": 0, "path": "src/ethereum_optimized/istanbul/state_db.py"}, "content": {"type": ["function"], "name": ["get_account_optional"], "text": ["See  ethereum.istanbul.state ."]}}, {"source": {"identifier": "ethereum_optimized.istanbul.state_db.set_account", "specifier": 0, "path": "src/ethereum_optimized/istanbul/state_db.py"}, "content": {"type": ["function"], "name": ["set_account"], "text": ["See  ethereum.istanbul.state ."]}}, {"source": {"identifier": "ethereum_optimized.istanbul.state_db.destroy_storage", "specifier": 0, "path": "src/ethereum_optimized/istanbul/state_db.py"}, "content": {"type": ["function"], "name": ["destroy_storage"], "text": ["See  ethereum.istanbul.state ."]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.system", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/system.py"}, "content": {"type": ["module"], "name": ["ethereum.spurious_dragon.vm.instructions.system"], "text": ["Ethereum Virtual Machine (EVM) System Instructions ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementations of the EVM system related instructions."]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.system.create", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/system.py"}, "content": {"type": ["function"], "name": ["create"], "text": ["Creates a new account with associated code. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.system.return_", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/system.py"}, "content": {"type": ["function"], "name": ["return_"], "text": ["Halts execution returning output data. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.system.generic_call", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/system.py"}, "content": {"type": ["function"], "name": ["generic_call"], "text": ["Perform the core logic of the  CALL*  family of opcodes."]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.system.call", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/system.py"}, "content": {"type": ["function"], "name": ["call"], "text": ["Message-call into an account. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.system.callcode", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/system.py"}, "content": {"type": ["function"], "name": ["callcode"], "text": ["Message-call into this account with alternative account\u2019s code. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.system.selfdestruct", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/system.py"}, "content": {"type": ["function"], "name": ["selfdestruct"], "text": ["Halt execution and register account for later deletion. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.system.delegatecall", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/system.py"}, "content": {"type": ["function"], "name": ["delegatecall"], "text": ["Message-call into an account. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.block", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/block.py"}, "content": {"type": ["module"], "name": ["ethereum.muir_glacier.vm.instructions.block"], "text": ["Ethereum Virtual Machine (EVM) Block Instructions ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementations of the EVM block instructions."]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.block.block_hash", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/block.py"}, "content": {"type": ["function"], "name": ["block_hash"], "text": ["Push the hash of one of the 256 most recent complete blocks onto the stack. The block number to hash is present at the top of the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.block.coinbase", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/block.py"}, "content": {"type": ["function"], "name": ["coinbase"], "text": ["Push the current block's beneficiary address (address of the block miner) onto the stack. Here the current block refers to the block in which the currently executing transaction/call resides. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.block.timestamp", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/block.py"}, "content": {"type": ["function"], "name": ["timestamp"], "text": ["Push the current block's timestamp onto the stack. Here the timestamp being referred is actually the unix timestamp in seconds. Here the current block refers to the block in which the currently executing transaction/call resides. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.block.number", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/block.py"}, "content": {"type": ["function"], "name": ["number"], "text": ["Push the current block's number onto the stack. Here the current block refers to the block in which the currently executing transaction/call resides. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.block.difficulty", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/block.py"}, "content": {"type": ["function"], "name": ["difficulty"], "text": ["Push the current block's difficulty onto the stack. Here the current block refers to the block in which the currently executing transaction/call resides. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.block.gas_limit", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/block.py"}, "content": {"type": ["function"], "name": ["gas_limit"], "text": ["Push the current block's gas limit onto the stack. Here the current block refers to the block in which the currently executing transaction/call resides. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.block.chain_id", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/block.py"}, "content": {"type": ["function"], "name": ["chain_id"], "text": ["Push the chain id onto the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.stack", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/stack.py"}, "content": {"type": ["module"], "name": ["ethereum.shanghai.vm.instructions.stack"], "text": ["Ethereum Virtual Machine (EVM) Stack Instructions ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementations of the EVM stack related instructions."]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.stack.pop", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/stack.py"}, "content": {"type": ["function"], "name": ["pop"], "text": ["Remove item from stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.stack.push_n", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/stack.py"}, "content": {"type": ["function"], "name": ["push_n"], "text": ["Pushes a N-byte immediate onto the stack. Push zero if num_bytes is zero. Parameters evm : The current EVM frame. num_bytes : The number of immediate bytes to be read from the code and pushed to the stack. Push zero if num_bytes is zero."]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.stack.dup_n", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/stack.py"}, "content": {"type": ["function"], "name": ["dup_n"], "text": ["Duplicate the Nth stack item (from top of the stack) to the top of stack. Parameters evm : The current EVM frame. item_number : The stack item number (0-indexed from top of stack) to be duplicated to the top of stack."]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.stack.swap_n", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/stack.py"}, "content": {"type": ["function"], "name": ["swap_n"], "text": ["Swap the top and the  item_number  element of the stack, where the top of the stack is position zero. If  item_number  is zero, this function does nothing (which should not be possible, since there is no  SWAP0  instruction). Parameters evm : The current EVM frame. item_number : The stack item number (0-indexed from top of stack) to be swapped with the top of stack element."]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.stack.push0", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push0"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.stack.push1", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push1"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.stack.push2", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push2"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.stack.push3", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push3"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.stack.push4", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push4"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.stack.push5", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push5"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.stack.push6", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push6"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.stack.push7", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push7"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.stack.push8", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push8"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.stack.push9", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push9"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.stack.push10", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push10"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.stack.push11", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push11"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.stack.push12", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push12"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.stack.push13", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push13"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.stack.push14", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push14"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.stack.push15", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push15"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.stack.push16", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push16"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.stack.push17", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push17"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.stack.push18", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push18"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.stack.push19", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push19"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.stack.push20", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push20"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.stack.push21", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push21"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.stack.push22", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push22"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.stack.push23", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push23"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.stack.push24", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push24"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.stack.push25", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push25"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.stack.push26", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push26"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.stack.push27", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push27"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.stack.push28", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push28"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.stack.push29", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push29"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.stack.push30", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push30"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.stack.push31", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push31"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.stack.push32", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push32"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.stack.dup1", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup1"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.stack.dup2", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup2"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.stack.dup3", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup3"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.stack.dup4", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup4"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.stack.dup5", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup5"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.stack.dup6", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup6"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.stack.dup7", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup7"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.stack.dup8", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup8"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.stack.dup9", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup9"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.stack.dup10", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup10"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.stack.dup11", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup11"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.stack.dup12", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup12"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.stack.dup13", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup13"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.stack.dup14", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup14"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.stack.dup15", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup15"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.stack.dup16", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup16"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.stack.swap1", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap1"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.stack.swap2", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap2"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.stack.swap3", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap3"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.stack.swap4", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap4"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.stack.swap5", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap5"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.stack.swap6", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap6"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.stack.swap7", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap7"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.stack.swap8", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap8"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.stack.swap9", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap9"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.stack.swap10", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap10"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.stack.swap11", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap11"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.stack.swap12", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap12"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.stack.swap13", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap13"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.stack.swap14", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap14"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.stack.swap15", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap15"]}}, {"source": {"identifier": "ethereum.shanghai.vm.instructions.stack.swap16", "specifier": 0, "path": "src/ethereum/shanghai/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap16"]}}, {"source": {"identifier": "ethereum_optimized.istanbul.fork", "specifier": 0, "path": "src/ethereum_optimized/istanbul/fork.py"}, "content": {"type": ["module"], "name": ["ethereum_optimized.istanbul.fork"], "text": ["Optimized Spec ^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction This module contains functions can be monkey patched into ethereum.istanbul.fork  to use alternate optimized implementations."]}}, {"source": {"identifier": "ethereum_optimized.istanbul.fork.validate_proof_of_work", "specifier": 0, "path": "src/ethereum_optimized/istanbul/fork.py"}, "content": {"type": ["function"], "name": ["validate_proof_of_work"], "text": ["See  ethereum.istanbul.fork.validate_proof_of_work ."]}}, {"source": {"identifier": "ethereum.byzantium.vm.precompiled_contracts.ecrecover", "specifier": 0, "path": "src/ethereum/byzantium/vm/precompiled_contracts/ecrecover.py"}, "content": {"type": ["module"], "name": ["ethereum.byzantium.vm.precompiled_contracts.ecrecover"], "text": ["Ethereum Virtual Machine (EVM) ECRECOVER PRECOMPILED CONTRACT ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementation of the ECRECOVER precompiled contract."]}}, {"source": {"identifier": "ethereum.byzantium.vm.precompiled_contracts.ecrecover.ecrecover", "specifier": 0, "path": "src/ethereum/byzantium/vm/precompiled_contracts/ecrecover.py"}, "content": {"type": ["function"], "name": ["ecrecover"], "text": ["Decrypts the address using elliptic curve DSA recovery mechanism and writes the address to output. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/__init__.py"}, "content": {"type": ["module"], "name": ["ethereum.spurious_dragon.vm.instructions"], "text": ["EVM Instruction Encoding (Opcodes) ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Machine readable representations of EVM instructions, and a mapping to their implementations."]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.Ops", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/__init__.py"}, "content": {"type": ["class"], "name": ["Ops"], "text": ["Enum for EVM Opcodes"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.Ops.ADD", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["ADD"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.Ops.MUL", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["MUL"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.Ops.SUB", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SUB"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.Ops.DIV", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DIV"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.Ops.SDIV", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SDIV"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.Ops.MOD", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["MOD"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.Ops.SMOD", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SMOD"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.Ops.ADDMOD", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["ADDMOD"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.Ops.MULMOD", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["MULMOD"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.Ops.EXP", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["EXP"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.Ops.SIGNEXTEND", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SIGNEXTEND"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.Ops.LT", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["LT"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.Ops.GT", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["GT"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.Ops.SLT", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SLT"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.Ops.SGT", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SGT"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.Ops.EQ", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["EQ"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.Ops.ISZERO", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["ISZERO"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.Ops.AND", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["AND"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.Ops.OR", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["OR"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.Ops.XOR", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["XOR"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.Ops.NOT", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["NOT"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.Ops.BYTE", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["BYTE"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.Ops.KECCAK", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["KECCAK"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.Ops.ADDRESS", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["ADDRESS"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.Ops.BALANCE", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["BALANCE"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.Ops.ORIGIN", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["ORIGIN"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.Ops.CALLER", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["CALLER"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.Ops.CALLVALUE", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["CALLVALUE"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.Ops.CALLDATALOAD", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["CALLDATALOAD"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.Ops.CALLDATASIZE", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["CALLDATASIZE"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.Ops.CALLDATACOPY", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["CALLDATACOPY"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.Ops.CODESIZE", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["CODESIZE"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.Ops.CODECOPY", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["CODECOPY"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.Ops.GASPRICE", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["GASPRICE"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.Ops.EXTCODESIZE", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["EXTCODESIZE"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.Ops.EXTCODECOPY", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["EXTCODECOPY"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.Ops.BLOCKHASH", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["BLOCKHASH"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.Ops.COINBASE", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["COINBASE"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.Ops.TIMESTAMP", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["TIMESTAMP"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.Ops.NUMBER", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["NUMBER"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.Ops.DIFFICULTY", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DIFFICULTY"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.Ops.GASLIMIT", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["GASLIMIT"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.Ops.STOP", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["STOP"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.Ops.JUMP", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["JUMP"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.Ops.JUMPI", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["JUMPI"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.Ops.PC", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PC"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.Ops.GAS", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["GAS"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.Ops.JUMPDEST", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["JUMPDEST"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.Ops.SLOAD", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SLOAD"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.Ops.SSTORE", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SSTORE"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.Ops.POP", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["POP"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.Ops.PUSH1", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH1"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.Ops.PUSH2", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH2"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.Ops.PUSH3", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH3"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.Ops.PUSH4", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH4"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.Ops.PUSH5", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH5"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.Ops.PUSH6", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH6"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.Ops.PUSH7", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH7"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.Ops.PUSH8", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH8"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.Ops.PUSH9", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH9"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.Ops.PUSH10", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH10"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.Ops.PUSH11", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH11"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.Ops.PUSH12", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH12"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.Ops.PUSH13", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH13"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.Ops.PUSH14", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH14"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.Ops.PUSH15", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH15"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.Ops.PUSH16", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH16"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.Ops.PUSH17", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH17"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.Ops.PUSH18", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH18"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.Ops.PUSH19", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH19"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.Ops.PUSH20", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH20"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.Ops.PUSH21", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH21"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.Ops.PUSH22", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH22"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.Ops.PUSH23", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH23"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.Ops.PUSH24", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH24"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.Ops.PUSH25", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH25"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.Ops.PUSH26", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH26"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.Ops.PUSH27", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH27"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.Ops.PUSH28", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH28"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.Ops.PUSH29", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH29"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.Ops.PUSH30", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH30"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.Ops.PUSH31", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH31"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.Ops.PUSH32", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH32"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.Ops.DUP1", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP1"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.Ops.DUP2", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP2"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.Ops.DUP3", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP3"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.Ops.DUP4", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP4"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.Ops.DUP5", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP5"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.Ops.DUP6", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP6"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.Ops.DUP7", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP7"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.Ops.DUP8", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP8"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.Ops.DUP9", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP9"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.Ops.DUP10", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP10"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.Ops.DUP11", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP11"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.Ops.DUP12", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP12"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.Ops.DUP13", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP13"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.Ops.DUP14", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP14"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.Ops.DUP15", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP15"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.Ops.DUP16", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP16"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.Ops.SWAP1", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP1"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.Ops.SWAP2", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP2"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.Ops.SWAP3", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP3"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.Ops.SWAP4", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP4"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.Ops.SWAP5", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP5"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.Ops.SWAP6", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP6"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.Ops.SWAP7", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP7"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.Ops.SWAP8", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP8"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.Ops.SWAP9", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP9"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.Ops.SWAP10", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP10"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.Ops.SWAP11", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP11"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.Ops.SWAP12", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP12"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.Ops.SWAP13", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP13"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.Ops.SWAP14", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP14"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.Ops.SWAP15", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP15"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.Ops.SWAP16", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP16"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.Ops.MLOAD", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["MLOAD"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.Ops.MSTORE", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["MSTORE"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.Ops.MSTORE8", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["MSTORE8"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.Ops.MSIZE", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["MSIZE"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.Ops.LOG0", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["LOG0"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.Ops.LOG1", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["LOG1"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.Ops.LOG2", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["LOG2"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.Ops.LOG3", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["LOG3"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.Ops.LOG4", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["LOG4"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.Ops.CREATE", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["CREATE"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.Ops.RETURN", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["RETURN"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.Ops.CALL", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["CALL"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.Ops.CALLCODE", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["CALLCODE"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.Ops.DELEGATECALL", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DELEGATECALL"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.Ops.SELFDESTRUCT", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SELFDESTRUCT"]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.op_implementation", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["op_implementation"]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.arithmetic", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/arithmetic.py"}, "content": {"type": ["module"], "name": ["ethereum.muir_glacier.vm.instructions.arithmetic"], "text": ["Ethereum Virtual Machine (EVM) Arithmetic Instructions ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementations of the EVM Arithmetic instructions."]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.arithmetic.add", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/arithmetic.py"}, "content": {"type": ["function"], "name": ["add"], "text": ["Adds the top two elements of the stack together, and pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.arithmetic.sub", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/arithmetic.py"}, "content": {"type": ["function"], "name": ["sub"], "text": ["Subtracts the top two elements of the stack, and pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.arithmetic.mul", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/arithmetic.py"}, "content": {"type": ["function"], "name": ["mul"], "text": ["Multiply the top two elements of the stack, and pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.arithmetic.div", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/arithmetic.py"}, "content": {"type": ["function"], "name": ["div"], "text": ["Integer division of the top two elements of the stack. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.arithmetic.sdiv", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/arithmetic.py"}, "content": {"type": ["function"], "name": ["sdiv"], "text": ["Signed integer division of the top two elements of the stack. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.arithmetic.mod", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/arithmetic.py"}, "content": {"type": ["function"], "name": ["mod"], "text": ["Modulo remainder of the top two elements of the stack. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.arithmetic.smod", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/arithmetic.py"}, "content": {"type": ["function"], "name": ["smod"], "text": ["Signed modulo remainder of the top two elements of the stack. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.arithmetic.addmod", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/arithmetic.py"}, "content": {"type": ["function"], "name": ["addmod"], "text": ["Modulo addition of the top 2 elements with the 3rd element. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.arithmetic.mulmod", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/arithmetic.py"}, "content": {"type": ["function"], "name": ["mulmod"], "text": ["Modulo multiplication of the top 2 elements with the 3rd element. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.arithmetic.exp", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/arithmetic.py"}, "content": {"type": ["function"], "name": ["exp"], "text": ["Exponential operation of the top 2 elements. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.arithmetic.signextend", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/arithmetic.py"}, "content": {"type": ["function"], "name": ["signextend"], "text": ["Sign extend operation. In other words, extend a signed number which fits in N bytes to 32 bytes. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum_optimized.frontier", "specifier": 0, "path": "src/ethereum_optimized/frontier/__init__.py"}, "content": {"type": ["module"], "name": ["ethereum_optimized.frontier"], "text": ["Optimized Implementations (Frontier) ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local:"]}}, {"source": {"identifier": "ethereum_optimized.frontier.monkey_patch_optimized_state_db", "specifier": 0, "path": "src/ethereum_optimized/frontier/__init__.py"}, "content": {"type": ["function"], "name": ["monkey_patch_optimized_state_db"], "text": ["Replace the state interface with one that supports high performance updates and storing state in a database. This function must be called before the state interface is imported anywhere."]}}, {"source": {"identifier": "ethereum_optimized.frontier.monkey_patch_optimized_spec", "specifier": 0, "path": "src/ethereum_optimized/frontier/__init__.py"}, "content": {"type": ["function"], "name": ["monkey_patch_optimized_spec"], "text": ["Replace the ethash implementation with one that supports higher performance. This function must be called before the spec interface is imported anywhere."]}}, {"source": {"identifier": "ethereum_optimized.frontier.monkey_patch", "specifier": 0, "path": "src/ethereum_optimized/frontier/__init__.py"}, "content": {"type": ["function"], "name": ["monkey_patch"], "text": ["Apply all monkey patches to swap in high performance implementations. This function must be called before any of the ethereum modules are imported anywhere."]}}, {"source": {"identifier": "ethereum.shanghai.utils", "specifier": 0, "path": "src/ethereum/shanghai/utils/__init__.py"}, "content": {"type": ["module"], "name": ["ethereum.shanghai.utils"], "text": ["Hardfork Utility Functions ^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Utility functions used in this shanghai version of specification."]}}, {"source": {"identifier": "ethereum.byzantium.vm.precompiled_contracts.identity", "specifier": 0, "path": "src/ethereum/byzantium/vm/precompiled_contracts/identity.py"}, "content": {"type": ["module"], "name": ["ethereum.byzantium.vm.precompiled_contracts.identity"], "text": ["Ethereum Virtual Machine (EVM) IDENTITY PRECOMPILED CONTRACT ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementation of the  IDENTITY  precompiled contract."]}}, {"source": {"identifier": "ethereum.byzantium.vm.precompiled_contracts.identity.identity", "specifier": 0, "path": "src/ethereum/byzantium/vm/precompiled_contracts/identity.py"}, "content": {"type": ["function"], "name": ["identity"], "text": ["Writes the message data to output. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum_optimized.frontier.state_db", "specifier": 0, "path": "src/ethereum_optimized/frontier/state_db.py"}, "content": {"type": ["module"], "name": ["ethereum_optimized.frontier.state_db"], "text": ["Optimized State ^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction This module contains functions can be monkey patched into ethereum.frontier.state  to use an optimized database backed state."]}}, {"source": {"identifier": "ethereum_optimized.frontier.state_db.UnmodifiedType", "specifier": 0, "path": "src/ethereum_optimized/frontier/state_db.py"}, "content": {"type": ["class"], "name": ["UnmodifiedType"], "text": ["Sentinal type to represent a value that hasn't been modified."]}}, {"source": {"identifier": "ethereum_optimized.frontier.state_db.Unmodified", "specifier": 0, "path": "src/ethereum_optimized/frontier/state_db.py"}, "content": {"type": ["attribute"], "name": ["Unmodified"]}}, {"source": {"identifier": "ethereum_optimized.frontier.state_db.State", "specifier": 0, "path": "src/ethereum_optimized/frontier/state_db.py"}, "content": {"type": ["class"], "name": ["State"], "text": ["The State, backed by a LMDB database. When created with  State()  store the db in a temporary directory. When created with  State(path)  open or create the db located at  path ."]}}, {"source": {"identifier": "ethereum_optimized.frontier.state_db.State.default_path", "specifier": 0, "path": "src/ethereum_optimized/frontier/state_db.py"}, "content": {"type": ["attribute"], "name": ["default_path"]}}, {"source": {"identifier": "ethereum_optimized.frontier.state_db.State.db", "specifier": 0, "path": "src/ethereum_optimized/frontier/state_db.py"}, "content": {"type": ["attribute"], "name": ["db"]}}, {"source": {"identifier": "ethereum_optimized.frontier.state_db.State.dirty_accounts", "specifier": 0, "path": "src/ethereum_optimized/frontier/state_db.py"}, "content": {"type": ["attribute"], "name": ["dirty_accounts"]}}, {"source": {"identifier": "ethereum_optimized.frontier.state_db.State.dirty_storage", "specifier": 0, "path": "src/ethereum_optimized/frontier/state_db.py"}, "content": {"type": ["attribute"], "name": ["dirty_storage"]}}, {"source": {"identifier": "ethereum_optimized.frontier.state_db.State.destroyed_accounts", "specifier": 0, "path": "src/ethereum_optimized/frontier/state_db.py"}, "content": {"type": ["attribute"], "name": ["destroyed_accounts"]}}, {"source": {"identifier": "ethereum_optimized.frontier.state_db.State.tx_restore_points", "specifier": 0, "path": "src/ethereum_optimized/frontier/state_db.py"}, "content": {"type": ["attribute"], "name": ["tx_restore_points"]}}, {"source": {"identifier": "ethereum_optimized.frontier.state_db.State.journal", "specifier": 0, "path": "src/ethereum_optimized/frontier/state_db.py"}, "content": {"type": ["attribute"], "name": ["journal"]}}, {"source": {"identifier": "ethereum_optimized.frontier.state_db.State.__init__", "specifier": 0, "path": "src/ethereum_optimized/frontier/state_db.py"}, "content": {"type": ["function"], "name": ["__init__"]}}, {"source": {"identifier": "ethereum_optimized.frontier.state_db.State.__eq__", "specifier": 0, "path": "src/ethereum_optimized/frontier/state_db.py"}, "content": {"type": ["function"], "name": ["__eq__"], "text": ["Test for equality by comparing state roots."]}}, {"source": {"identifier": "ethereum_optimized.frontier.state_db.State.__enter__", "specifier": 0, "path": "src/ethereum_optimized/frontier/state_db.py"}, "content": {"type": ["function"], "name": ["__enter__"], "text": ["Support with statements"]}}, {"source": {"identifier": "ethereum_optimized.frontier.state_db.State.__exit__", "specifier": 0, "path": "src/ethereum_optimized/frontier/state_db.py"}, "content": {"type": ["function"], "name": ["__exit__"], "text": ["Support with statements"]}}, {"source": {"identifier": "ethereum_optimized.frontier.state_db.close_state", "specifier": 0, "path": "src/ethereum_optimized/frontier/state_db.py"}, "content": {"type": ["function"], "name": ["close_state"], "text": ["Close a state, releasing all resources it holds"]}}, {"source": {"identifier": "ethereum_optimized.frontier.state_db.get_metadata", "specifier": 0, "path": "src/ethereum_optimized/frontier/state_db.py"}, "content": {"type": ["function"], "name": ["get_metadata"], "text": ["Get a piece of metadata"]}}, {"source": {"identifier": "ethereum_optimized.frontier.state_db.set_metadata", "specifier": 0, "path": "src/ethereum_optimized/frontier/state_db.py"}, "content": {"type": ["function"], "name": ["set_metadata"], "text": ["Set a piece of metadata"]}}, {"source": {"identifier": "ethereum_optimized.frontier.state_db.begin_db_transaction", "specifier": 0, "path": "src/ethereum_optimized/frontier/state_db.py"}, "content": {"type": ["function"], "name": ["begin_db_transaction"], "text": ["Start a database transaction. A transaction is automatically started when a State  is created. Nesting of DB transactions is not supported (unlike non-db transactions). No operations are supported when not in a transaction."]}}, {"source": {"identifier": "ethereum_optimized.frontier.state_db.commit_db_transaction", "specifier": 0, "path": "src/ethereum_optimized/frontier/state_db.py"}, "content": {"type": ["function"], "name": ["commit_db_transaction"], "text": ["Commit the current database transaction."]}}, {"source": {"identifier": "ethereum_optimized.frontier.state_db.state_root", "specifier": 0, "path": "src/ethereum_optimized/frontier/state_db.py"}, "content": {"type": ["function"], "name": ["state_root"], "text": ["See  ethereum.frontier.state ."]}}, {"source": {"identifier": "ethereum_optimized.frontier.state_db.storage_root", "specifier": 0, "path": "src/ethereum_optimized/frontier/state_db.py"}, "content": {"type": ["function"], "name": ["storage_root"], "text": ["See  ethereum.frontier.state ."]}}, {"source": {"identifier": "ethereum_optimized.frontier.state_db.flush", "specifier": 0, "path": "src/ethereum_optimized/frontier/state_db.py"}, "content": {"type": ["function"], "name": ["flush"], "text": ["Send everything in the internal caches to the Rust layer."]}}, {"source": {"identifier": "ethereum_optimized.frontier.state_db.rollback_db_transaction", "specifier": 0, "path": "src/ethereum_optimized/frontier/state_db.py"}, "content": {"type": ["function"], "name": ["rollback_db_transaction"], "text": ["Rollback the current database transaction."]}}, {"source": {"identifier": "ethereum_optimized.frontier.state_db.begin_transaction", "specifier": 0, "path": "src/ethereum_optimized/frontier/state_db.py"}, "content": {"type": ["function"], "name": ["begin_transaction"], "text": ["See  ethereum.frontier.state ."]}}, {"source": {"identifier": "ethereum_optimized.frontier.state_db.commit_transaction", "specifier": 0, "path": "src/ethereum_optimized/frontier/state_db.py"}, "content": {"type": ["function"], "name": ["commit_transaction"], "text": ["See  ethereum.frontier.state ."]}}, {"source": {"identifier": "ethereum_optimized.frontier.state_db.rollback_transaction", "specifier": 0, "path": "src/ethereum_optimized/frontier/state_db.py"}, "content": {"type": ["function"], "name": ["rollback_transaction"], "text": ["See  ethereum.frontier.state ."]}}, {"source": {"identifier": "ethereum_optimized.frontier.state_db.get_storage", "specifier": 0, "path": "src/ethereum_optimized/frontier/state_db.py"}, "content": {"type": ["function"], "name": ["get_storage"], "text": ["See  ethereum.frontier.state ."]}}, {"source": {"identifier": "ethereum_optimized.frontier.state_db.get_storage_original", "specifier": 0, "path": "src/ethereum_optimized/frontier/state_db.py"}, "content": {"type": ["function"], "name": ["get_storage_original"], "text": ["See  ethereum.istanbul.state ."]}}, {"source": {"identifier": "ethereum_optimized.frontier.state_db.set_storage", "specifier": 0, "path": "src/ethereum_optimized/frontier/state_db.py"}, "content": {"type": ["function"], "name": ["set_storage"], "text": ["See  ethereum.frontier.state ."]}}, {"source": {"identifier": "ethereum_optimized.frontier.state_db.get_account_optional", "specifier": 0, "path": "src/ethereum_optimized/frontier/state_db.py"}, "content": {"type": ["function"], "name": ["get_account_optional"], "text": ["See  ethereum.frontier.state ."]}}, {"source": {"identifier": "ethereum_optimized.frontier.state_db.set_account", "specifier": 0, "path": "src/ethereum_optimized/frontier/state_db.py"}, "content": {"type": ["function"], "name": ["set_account"], "text": ["See  ethereum.frontier.state ."]}}, {"source": {"identifier": "ethereum_optimized.frontier.state_db.destroy_storage", "specifier": 0, "path": "src/ethereum_optimized/frontier/state_db.py"}, "content": {"type": ["function"], "name": ["destroy_storage"], "text": ["See  ethereum.frontier.state ."]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.control_flow", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/control_flow.py"}, "content": {"type": ["module"], "name": ["ethereum.spurious_dragon.vm.instructions.control_flow"], "text": ["Ethereum Virtual Machine (EVM) Control Flow Instructions ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementations of the EVM control flow instructions."]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.control_flow.stop", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/control_flow.py"}, "content": {"type": ["function"], "name": ["stop"], "text": ["Stop further execution of EVM code. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.control_flow.jump", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/control_flow.py"}, "content": {"type": ["function"], "name": ["jump"], "text": ["Alter the program counter to the location specified by the top of the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.control_flow.jumpi", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/control_flow.py"}, "content": {"type": ["function"], "name": ["jumpi"], "text": ["Alter the program counter to the specified location if and only if a condition is true. If the condition is not true, then the program counter would increase only by 1. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.control_flow.pc", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/control_flow.py"}, "content": {"type": ["function"], "name": ["pc"], "text": ["Push onto the stack the value of the program counter after reaching the current instruction and without increasing it for the next instruction. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.control_flow.gas_left", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/control_flow.py"}, "content": {"type": ["function"], "name": ["gas_left"], "text": ["Push the amount of available gas (including the corresponding reduction for the cost of this instruction) onto the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.control_flow.jumpdest", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/control_flow.py"}, "content": {"type": ["function"], "name": ["jumpdest"], "text": ["Mark a valid destination for jumps. This is a noop, present only to be used by  JUMP  and  JUMPI  opcodes to verify that their jump is valid. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.keccak", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/keccak.py"}, "content": {"type": ["module"], "name": ["ethereum.muir_glacier.vm.instructions.keccak"], "text": ["Ethereum Virtual Machine (EVM) Keccak Instructions ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementations of the EVM keccak instructions."]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.keccak.keccak", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/keccak.py"}, "content": {"type": ["function"], "name": ["keccak"], "text": ["Pushes to the stack the Keccak-256 hash of a region of memory. This also expands the memory, in case the memory is insufficient to access the data's memory location. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.shanghai.utils.address", "specifier": 0, "path": "src/ethereum/shanghai/utils/address.py"}, "content": {"type": ["module"], "name": ["ethereum.shanghai.utils.address"], "text": ["Hardfork Utility Functions For Addresses ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Address specific functions used in this shanghai version of specification."]}}, {"source": {"identifier": "ethereum.shanghai.utils.address.to_address", "specifier": 0, "path": "src/ethereum/shanghai/utils/address.py"}, "content": {"type": ["function"], "name": ["to_address"], "text": ["Convert a Uint or U256 value to a valid address (20 bytes). Parameters data : The string to be converted to bytes. Returns address :  Address The obtained address."]}}, {"source": {"identifier": "ethereum.shanghai.utils.address.compute_contract_address", "specifier": 0, "path": "src/ethereum/shanghai/utils/address.py"}, "content": {"type": ["function"], "name": ["compute_contract_address"], "text": ["Computes address of the new account that needs to be created. Parameters address : The address of the account that wants to create the new account. nonce : The transaction count of the account that wants to create the new account. Returns address:  Address The computed address of the new account."]}}, {"source": {"identifier": "ethereum.shanghai.utils.address.compute_create2_contract_address", "specifier": 0, "path": "src/ethereum/shanghai/utils/address.py"}, "content": {"type": ["function"], "name": ["compute_create2_contract_address"], "text": ["Computes address of the new account that needs to be created, which is based on the sender address, salt and the call data as well. Parameters address : The address of the account that wants to create the new account. salt : Address generation salt. call_data : The code of the new account which is to be created. Returns address:  ethereum.shanghai.fork_types.Address The computed address of the new account."]}}, {"source": {"identifier": "ethereum_optimized.frontier.fork", "specifier": 0, "path": "src/ethereum_optimized/frontier/fork.py"}, "content": {"type": ["module"], "name": ["ethereum_optimized.frontier.fork"], "text": ["Optimized Spec ^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction This module contains functions can be monkey patched into ethereum.frontier.fork  to use alternate optimized implementations."]}}, {"source": {"identifier": "ethereum_optimized.frontier.fork.validate_proof_of_work", "specifier": 0, "path": "src/ethereum_optimized/frontier/fork.py"}, "content": {"type": ["function"], "name": ["validate_proof_of_work"], "text": ["See  ethereum.frontier.fork.validate_proof_of_work ."]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.memory", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/memory.py"}, "content": {"type": ["module"], "name": ["ethereum.byzantium.vm.instructions.memory"], "text": ["Ethereum Virtual Machine (EVM) Memory Instructions ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementations of the EVM Memory instructions."]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.memory.mstore", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/memory.py"}, "content": {"type": ["function"], "name": ["mstore"], "text": ["Stores a word to memory. This also expands the memory, if the memory is insufficient to store the word. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.memory.mstore8", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/memory.py"}, "content": {"type": ["function"], "name": ["mstore8"], "text": ["Stores a byte to memory. This also expands the memory, if the memory is insufficient to store the word. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.memory.mload", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/memory.py"}, "content": {"type": ["function"], "name": ["mload"], "text": ["Load word from memory. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.memory.msize", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/memory.py"}, "content": {"type": ["function"], "name": ["msize"], "text": ["Push the size of active memory in bytes onto the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.comparison", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/comparison.py"}, "content": {"type": ["module"], "name": ["ethereum.spurious_dragon.vm.instructions.comparison"], "text": ["Ethereum Virtual Machine (EVM) Comparison Instructions ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementations of the EVM Comparison instructions."]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.comparison.less_than", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/comparison.py"}, "content": {"type": ["function"], "name": ["less_than"], "text": ["Checks if the top element is less than the next top element. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.comparison.signed_less_than", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/comparison.py"}, "content": {"type": ["function"], "name": ["signed_less_than"], "text": ["Signed less-than comparison. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.comparison.greater_than", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/comparison.py"}, "content": {"type": ["function"], "name": ["greater_than"], "text": ["Checks if the top element is greater than the next top element. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.comparison.signed_greater_than", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/comparison.py"}, "content": {"type": ["function"], "name": ["signed_greater_than"], "text": ["Signed greater-than comparison. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.comparison.equal", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/comparison.py"}, "content": {"type": ["function"], "name": ["equal"], "text": ["Checks if the top element is equal to the next top element. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.spurious_dragon.vm.instructions.comparison.is_zero", "specifier": 0, "path": "src/ethereum/spurious_dragon/vm/instructions/comparison.py"}, "content": {"type": ["function"], "name": ["is_zero"], "text": ["Checks if the top element is equal to 0. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.bitwise", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/bitwise.py"}, "content": {"type": ["module"], "name": ["ethereum.muir_glacier.vm.instructions.bitwise"], "text": ["Ethereum Virtual Machine (EVM) Bitwise Instructions ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementations of the EVM bitwise instructions."]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.bitwise.bitwise_and", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/bitwise.py"}, "content": {"type": ["function"], "name": ["bitwise_and"], "text": ["Bitwise AND operation of the top 2 elements of the stack. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.bitwise.bitwise_or", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/bitwise.py"}, "content": {"type": ["function"], "name": ["bitwise_or"], "text": ["Bitwise OR operation of the top 2 elements of the stack. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.bitwise.bitwise_xor", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/bitwise.py"}, "content": {"type": ["function"], "name": ["bitwise_xor"], "text": ["Bitwise XOR operation of the top 2 elements of the stack. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.bitwise.bitwise_not", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/bitwise.py"}, "content": {"type": ["function"], "name": ["bitwise_not"], "text": ["Bitwise NOT operation of the top element of the stack. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.bitwise.get_byte", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/bitwise.py"}, "content": {"type": ["function"], "name": ["get_byte"], "text": ["For a word (defined by next top element of the stack), retrieve the Nth byte (0-indexed and defined by top element of stack) from the left (most significant) to right (least significant). Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.bitwise.bitwise_shl", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/bitwise.py"}, "content": {"type": ["function"], "name": ["bitwise_shl"], "text": ["Logical shift left (SHL) operation of the top 2 elements of the stack. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.bitwise.bitwise_shr", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/bitwise.py"}, "content": {"type": ["function"], "name": ["bitwise_shr"], "text": ["Logical shift right (SHR) operation of the top 2 elements of the stack. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.muir_glacier.vm.instructions.bitwise.bitwise_sar", "specifier": 0, "path": "src/ethereum/muir_glacier/vm/instructions/bitwise.py"}, "content": {"type": ["function"], "name": ["bitwise_sar"], "text": ["Arithmetic shift right (SAR) operation of the top 2 elements of the stack. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum_optimized.dao_fork", "specifier": 0, "path": "src/ethereum_optimized/dao_fork/__init__.py"}, "content": {"type": ["module"], "name": ["ethereum_optimized.dao_fork"], "text": ["Optimized Implementations (Dao_fork) ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local:"]}}, {"source": {"identifier": "ethereum_optimized.dao_fork.monkey_patch_optimized_state_db", "specifier": 0, "path": "src/ethereum_optimized/dao_fork/__init__.py"}, "content": {"type": ["function"], "name": ["monkey_patch_optimized_state_db"], "text": ["Replace the state interface with one that supports high performance updates and storing state in a database. This function must be called before the state interface is imported anywhere."]}}, {"source": {"identifier": "ethereum_optimized.dao_fork.monkey_patch_optimized_spec", "specifier": 0, "path": "src/ethereum_optimized/dao_fork/__init__.py"}, "content": {"type": ["function"], "name": ["monkey_patch_optimized_spec"], "text": ["Replace the ethash implementation with one that supports higher performance. This function must be called before the spec interface is imported anywhere."]}}, {"source": {"identifier": "ethereum_optimized.dao_fork.monkey_patch", "specifier": 0, "path": "src/ethereum_optimized/dao_fork/__init__.py"}, "content": {"type": ["function"], "name": ["monkey_patch"], "text": ["Apply all monkey patches to swap in high performance implementations. This function must be called before any of the ethereum modules are imported anywhere."]}}, {"source": {"identifier": "ethereum.shanghai.utils.message", "specifier": 0, "path": "src/ethereum/shanghai/utils/message.py"}, "content": {"type": ["module"], "name": ["ethereum.shanghai.utils.message"], "text": ["Hardfork Utility Functions For The Message Data-structure ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Message specific functions used in this shanghai version of specification."]}}, {"source": {"identifier": "ethereum.shanghai.utils.message.prepare_message", "specifier": 0, "path": "src/ethereum/shanghai/utils/message.py"}, "content": {"type": ["function"], "name": ["prepare_message"], "text": ["Execute a transaction against the provided environment. Parameters caller : Address which initiated the transaction target : Address whose code will be executed value : Value to be transferred. data : Array of bytes provided to the code in  target . gas : Gas provided for the code in  target . env : Environment for the Ethereum Virtual Machine. code_address : This is usually same as the  target  address except when an alternative accounts code needs to be executed. eg.  CALLCODE  calling a precompile. should_transfer_value : if True ETH should be transferred while executing a message call. is_static: if True then it prevents all state-changing operations from being executed. preaccessed_addresses: Addresses that should be marked as accessed prior to the message call preaccessed_storage_keys: Storage keys that should be marked as accessed prior to the message call Returns message:  ethereum.shanghai.vm.Message Items containing contract creation or message call specific data."]}}, {"source": {"identifier": "ethereum_optimized.dao_fork.state_db", "specifier": 0, "path": "src/ethereum_optimized/dao_fork/state_db.py"}, "content": {"type": ["module"], "name": ["ethereum_optimized.dao_fork.state_db"], "text": ["Optimized State ^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction This module contains functions can be monkey patched into ethereum.dao_fork.state  to use an optimized database backed state."]}}, {"source": {"identifier": "ethereum_optimized.dao_fork.state_db.UnmodifiedType", "specifier": 0, "path": "src/ethereum_optimized/dao_fork/state_db.py"}, "content": {"type": ["class"], "name": ["UnmodifiedType"], "text": ["Sentinal type to represent a value that hasn't been modified."]}}, {"source": {"identifier": "ethereum_optimized.dao_fork.state_db.Unmodified", "specifier": 0, "path": "src/ethereum_optimized/dao_fork/state_db.py"}, "content": {"type": ["attribute"], "name": ["Unmodified"]}}, {"source": {"identifier": "ethereum_optimized.dao_fork.state_db.State", "specifier": 0, "path": "src/ethereum_optimized/dao_fork/state_db.py"}, "content": {"type": ["class"], "name": ["State"], "text": ["The State, backed by a LMDB database. When created with  State()  store the db in a temporary directory. When created with  State(path)  open or create the db located at  path ."]}}, {"source": {"identifier": "ethereum_optimized.dao_fork.state_db.State.default_path", "specifier": 0, "path": "src/ethereum_optimized/dao_fork/state_db.py"}, "content": {"type": ["attribute"], "name": ["default_path"]}}, {"source": {"identifier": "ethereum_optimized.dao_fork.state_db.State.db", "specifier": 0, "path": "src/ethereum_optimized/dao_fork/state_db.py"}, "content": {"type": ["attribute"], "name": ["db"]}}, {"source": {"identifier": "ethereum_optimized.dao_fork.state_db.State.dirty_accounts", "specifier": 0, "path": "src/ethereum_optimized/dao_fork/state_db.py"}, "content": {"type": ["attribute"], "name": ["dirty_accounts"]}}, {"source": {"identifier": "ethereum_optimized.dao_fork.state_db.State.dirty_storage", "specifier": 0, "path": "src/ethereum_optimized/dao_fork/state_db.py"}, "content": {"type": ["attribute"], "name": ["dirty_storage"]}}, {"source": {"identifier": "ethereum_optimized.dao_fork.state_db.State.destroyed_accounts", "specifier": 0, "path": "src/ethereum_optimized/dao_fork/state_db.py"}, "content": {"type": ["attribute"], "name": ["destroyed_accounts"]}}, {"source": {"identifier": "ethereum_optimized.dao_fork.state_db.State.tx_restore_points", "specifier": 0, "path": "src/ethereum_optimized/dao_fork/state_db.py"}, "content": {"type": ["attribute"], "name": ["tx_restore_points"]}}, {"source": {"identifier": "ethereum_optimized.dao_fork.state_db.State.journal", "specifier": 0, "path": "src/ethereum_optimized/dao_fork/state_db.py"}, "content": {"type": ["attribute"], "name": ["journal"]}}, {"source": {"identifier": "ethereum_optimized.dao_fork.state_db.State.__init__", "specifier": 0, "path": "src/ethereum_optimized/dao_fork/state_db.py"}, "content": {"type": ["function"], "name": ["__init__"]}}, {"source": {"identifier": "ethereum_optimized.dao_fork.state_db.State.__eq__", "specifier": 0, "path": "src/ethereum_optimized/dao_fork/state_db.py"}, "content": {"type": ["function"], "name": ["__eq__"], "text": ["Test for equality by comparing state roots."]}}, {"source": {"identifier": "ethereum_optimized.dao_fork.state_db.State.__enter__", "specifier": 0, "path": "src/ethereum_optimized/dao_fork/state_db.py"}, "content": {"type": ["function"], "name": ["__enter__"], "text": ["Support with statements"]}}, {"source": {"identifier": "ethereum_optimized.dao_fork.state_db.State.__exit__", "specifier": 0, "path": "src/ethereum_optimized/dao_fork/state_db.py"}, "content": {"type": ["function"], "name": ["__exit__"], "text": ["Support with statements"]}}, {"source": {"identifier": "ethereum_optimized.dao_fork.state_db.close_state", "specifier": 0, "path": "src/ethereum_optimized/dao_fork/state_db.py"}, "content": {"type": ["function"], "name": ["close_state"], "text": ["Close a state, releasing all resources it holds"]}}, {"source": {"identifier": "ethereum_optimized.dao_fork.state_db.get_metadata", "specifier": 0, "path": "src/ethereum_optimized/dao_fork/state_db.py"}, "content": {"type": ["function"], "name": ["get_metadata"], "text": ["Get a piece of metadata"]}}, {"source": {"identifier": "ethereum_optimized.dao_fork.state_db.set_metadata", "specifier": 0, "path": "src/ethereum_optimized/dao_fork/state_db.py"}, "content": {"type": ["function"], "name": ["set_metadata"], "text": ["Set a piece of metadata"]}}, {"source": {"identifier": "ethereum_optimized.dao_fork.state_db.begin_db_transaction", "specifier": 0, "path": "src/ethereum_optimized/dao_fork/state_db.py"}, "content": {"type": ["function"], "name": ["begin_db_transaction"], "text": ["Start a database transaction. A transaction is automatically started when a State  is created. Nesting of DB transactions is not supported (unlike non-db transactions). No operations are supported when not in a transaction."]}}, {"source": {"identifier": "ethereum_optimized.dao_fork.state_db.commit_db_transaction", "specifier": 0, "path": "src/ethereum_optimized/dao_fork/state_db.py"}, "content": {"type": ["function"], "name": ["commit_db_transaction"], "text": ["Commit the current database transaction."]}}, {"source": {"identifier": "ethereum_optimized.dao_fork.state_db.state_root", "specifier": 0, "path": "src/ethereum_optimized/dao_fork/state_db.py"}, "content": {"type": ["function"], "name": ["state_root"], "text": ["See  ethereum.dao_fork.state ."]}}, {"source": {"identifier": "ethereum_optimized.dao_fork.state_db.storage_root", "specifier": 0, "path": "src/ethereum_optimized/dao_fork/state_db.py"}, "content": {"type": ["function"], "name": ["storage_root"], "text": ["See  ethereum.dao_fork.state ."]}}, {"source": {"identifier": "ethereum_optimized.dao_fork.state_db.flush", "specifier": 0, "path": "src/ethereum_optimized/dao_fork/state_db.py"}, "content": {"type": ["function"], "name": ["flush"], "text": ["Send everything in the internal caches to the Rust layer."]}}, {"source": {"identifier": "ethereum_optimized.dao_fork.state_db.rollback_db_transaction", "specifier": 0, "path": "src/ethereum_optimized/dao_fork/state_db.py"}, "content": {"type": ["function"], "name": ["rollback_db_transaction"], "text": ["Rollback the current database transaction."]}}, {"source": {"identifier": "ethereum_optimized.dao_fork.state_db.begin_transaction", "specifier": 0, "path": "src/ethereum_optimized/dao_fork/state_db.py"}, "content": {"type": ["function"], "name": ["begin_transaction"], "text": ["See  ethereum.dao_fork.state ."]}}, {"source": {"identifier": "ethereum_optimized.dao_fork.state_db.commit_transaction", "specifier": 0, "path": "src/ethereum_optimized/dao_fork/state_db.py"}, "content": {"type": ["function"], "name": ["commit_transaction"], "text": ["See  ethereum.dao_fork.state ."]}}, {"source": {"identifier": "ethereum_optimized.dao_fork.state_db.rollback_transaction", "specifier": 0, "path": "src/ethereum_optimized/dao_fork/state_db.py"}, "content": {"type": ["function"], "name": ["rollback_transaction"], "text": ["See  ethereum.dao_fork.state ."]}}, {"source": {"identifier": "ethereum_optimized.dao_fork.state_db.get_storage", "specifier": 0, "path": "src/ethereum_optimized/dao_fork/state_db.py"}, "content": {"type": ["function"], "name": ["get_storage"], "text": ["See  ethereum.dao_fork.state ."]}}, {"source": {"identifier": "ethereum_optimized.dao_fork.state_db.get_storage_original", "specifier": 0, "path": "src/ethereum_optimized/dao_fork/state_db.py"}, "content": {"type": ["function"], "name": ["get_storage_original"], "text": ["See  ethereum.istanbul.state ."]}}, {"source": {"identifier": "ethereum_optimized.dao_fork.state_db.set_storage", "specifier": 0, "path": "src/ethereum_optimized/dao_fork/state_db.py"}, "content": {"type": ["function"], "name": ["set_storage"], "text": ["See  ethereum.dao_fork.state ."]}}, {"source": {"identifier": "ethereum_optimized.dao_fork.state_db.get_account_optional", "specifier": 0, "path": "src/ethereum_optimized/dao_fork/state_db.py"}, "content": {"type": ["function"], "name": ["get_account_optional"], "text": ["See  ethereum.dao_fork.state ."]}}, {"source": {"identifier": "ethereum_optimized.dao_fork.state_db.set_account", "specifier": 0, "path": "src/ethereum_optimized/dao_fork/state_db.py"}, "content": {"type": ["function"], "name": ["set_account"], "text": ["See  ethereum.dao_fork.state ."]}}, {"source": {"identifier": "ethereum_optimized.dao_fork.state_db.destroy_storage", "specifier": 0, "path": "src/ethereum_optimized/dao_fork/state_db.py"}, "content": {"type": ["function"], "name": ["destroy_storage"], "text": ["See  ethereum.dao_fork.state ."]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.system", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/system.py"}, "content": {"type": ["module"], "name": ["ethereum.byzantium.vm.instructions.system"], "text": ["Ethereum Virtual Machine (EVM) System Instructions ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementations of the EVM system related instructions."]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.system.create", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/system.py"}, "content": {"type": ["function"], "name": ["create"], "text": ["Creates a new account with associated code. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.system.return_", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/system.py"}, "content": {"type": ["function"], "name": ["return_"], "text": ["Halts execution returning output data. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.system.generic_call", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/system.py"}, "content": {"type": ["function"], "name": ["generic_call"], "text": ["Perform the core logic of the  CALL*  family of opcodes."]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.system.call", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/system.py"}, "content": {"type": ["function"], "name": ["call"], "text": ["Message-call into an account. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.system.callcode", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/system.py"}, "content": {"type": ["function"], "name": ["callcode"], "text": ["Message-call into this account with alternative account\u2019s code. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.system.selfdestruct", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/system.py"}, "content": {"type": ["function"], "name": ["selfdestruct"], "text": ["Halt execution and register account for later deletion. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.system.delegatecall", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/system.py"}, "content": {"type": ["function"], "name": ["delegatecall"], "text": ["Message-call into an account. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.system.staticcall", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/system.py"}, "content": {"type": ["function"], "name": ["staticcall"], "text": ["Message-call into an account. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.byzantium.vm.instructions.system.revert", "specifier": 0, "path": "src/ethereum/byzantium/vm/instructions/system.py"}, "content": {"type": ["function"], "name": ["revert"], "text": ["Stop execution and revert state changes, without consuming all provided gas and also has the ability to return a reason Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.paris.vm.instructions", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/__init__.py"}, "content": {"type": ["module"], "name": ["ethereum.paris.vm.instructions"], "text": ["EVM Instruction Encoding (Opcodes) ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Machine readable representations of EVM instructions, and a mapping to their implementations."]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.Ops", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/__init__.py"}, "content": {"type": ["class"], "name": ["Ops"], "text": ["Enum for EVM Opcodes"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.Ops.ADD", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["ADD"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.Ops.MUL", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["MUL"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.Ops.SUB", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SUB"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.Ops.DIV", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DIV"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.Ops.SDIV", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SDIV"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.Ops.MOD", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["MOD"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.Ops.SMOD", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SMOD"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.Ops.ADDMOD", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["ADDMOD"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.Ops.MULMOD", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["MULMOD"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.Ops.EXP", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["EXP"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.Ops.SIGNEXTEND", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SIGNEXTEND"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.Ops.LT", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["LT"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.Ops.GT", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["GT"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.Ops.SLT", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SLT"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.Ops.SGT", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SGT"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.Ops.EQ", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["EQ"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.Ops.ISZERO", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["ISZERO"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.Ops.AND", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["AND"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.Ops.OR", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["OR"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.Ops.XOR", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["XOR"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.Ops.NOT", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["NOT"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.Ops.BYTE", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["BYTE"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.Ops.SHL", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SHL"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.Ops.SHR", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SHR"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.Ops.SAR", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SAR"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.Ops.KECCAK", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["KECCAK"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.Ops.ADDRESS", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["ADDRESS"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.Ops.BALANCE", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["BALANCE"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.Ops.ORIGIN", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["ORIGIN"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.Ops.CALLER", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["CALLER"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.Ops.CALLVALUE", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["CALLVALUE"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.Ops.CALLDATALOAD", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["CALLDATALOAD"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.Ops.CALLDATASIZE", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["CALLDATASIZE"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.Ops.CALLDATACOPY", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["CALLDATACOPY"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.Ops.CODESIZE", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["CODESIZE"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.Ops.CODECOPY", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["CODECOPY"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.Ops.GASPRICE", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["GASPRICE"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.Ops.EXTCODESIZE", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["EXTCODESIZE"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.Ops.EXTCODECOPY", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["EXTCODECOPY"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.Ops.RETURNDATASIZE", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["RETURNDATASIZE"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.Ops.RETURNDATACOPY", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["RETURNDATACOPY"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.Ops.EXTCODEHASH", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["EXTCODEHASH"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.Ops.BLOCKHASH", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["BLOCKHASH"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.Ops.COINBASE", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["COINBASE"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.Ops.TIMESTAMP", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["TIMESTAMP"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.Ops.NUMBER", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["NUMBER"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.Ops.PREVRANDAO", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PREVRANDAO"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.Ops.GASLIMIT", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["GASLIMIT"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.Ops.CHAINID", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["CHAINID"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.Ops.SELFBALANCE", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SELFBALANCE"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.Ops.BASEFEE", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["BASEFEE"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.Ops.STOP", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["STOP"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.Ops.JUMP", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["JUMP"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.Ops.JUMPI", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["JUMPI"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.Ops.PC", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PC"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.Ops.GAS", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["GAS"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.Ops.JUMPDEST", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["JUMPDEST"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.Ops.SLOAD", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SLOAD"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.Ops.SSTORE", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SSTORE"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.Ops.POP", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["POP"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.Ops.PUSH1", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH1"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.Ops.PUSH2", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH2"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.Ops.PUSH3", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH3"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.Ops.PUSH4", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH4"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.Ops.PUSH5", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH5"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.Ops.PUSH6", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH6"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.Ops.PUSH7", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH7"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.Ops.PUSH8", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH8"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.Ops.PUSH9", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH9"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.Ops.PUSH10", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH10"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.Ops.PUSH11", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH11"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.Ops.PUSH12", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH12"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.Ops.PUSH13", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH13"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.Ops.PUSH14", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH14"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.Ops.PUSH15", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH15"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.Ops.PUSH16", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH16"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.Ops.PUSH17", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH17"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.Ops.PUSH18", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH18"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.Ops.PUSH19", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH19"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.Ops.PUSH20", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH20"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.Ops.PUSH21", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH21"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.Ops.PUSH22", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH22"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.Ops.PUSH23", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH23"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.Ops.PUSH24", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH24"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.Ops.PUSH25", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH25"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.Ops.PUSH26", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH26"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.Ops.PUSH27", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH27"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.Ops.PUSH28", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH28"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.Ops.PUSH29", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH29"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.Ops.PUSH30", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH30"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.Ops.PUSH31", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH31"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.Ops.PUSH32", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["PUSH32"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.Ops.DUP1", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP1"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.Ops.DUP2", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP2"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.Ops.DUP3", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP3"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.Ops.DUP4", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP4"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.Ops.DUP5", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP5"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.Ops.DUP6", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP6"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.Ops.DUP7", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP7"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.Ops.DUP8", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP8"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.Ops.DUP9", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP9"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.Ops.DUP10", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP10"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.Ops.DUP11", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP11"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.Ops.DUP12", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP12"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.Ops.DUP13", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP13"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.Ops.DUP14", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP14"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.Ops.DUP15", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP15"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.Ops.DUP16", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DUP16"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.Ops.SWAP1", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP1"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.Ops.SWAP2", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP2"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.Ops.SWAP3", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP3"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.Ops.SWAP4", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP4"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.Ops.SWAP5", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP5"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.Ops.SWAP6", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP6"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.Ops.SWAP7", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP7"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.Ops.SWAP8", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP8"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.Ops.SWAP9", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP9"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.Ops.SWAP10", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP10"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.Ops.SWAP11", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP11"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.Ops.SWAP12", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP12"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.Ops.SWAP13", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP13"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.Ops.SWAP14", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP14"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.Ops.SWAP15", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP15"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.Ops.SWAP16", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SWAP16"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.Ops.MLOAD", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["MLOAD"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.Ops.MSTORE", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["MSTORE"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.Ops.MSTORE8", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["MSTORE8"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.Ops.MSIZE", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["MSIZE"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.Ops.LOG0", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["LOG0"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.Ops.LOG1", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["LOG1"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.Ops.LOG2", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["LOG2"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.Ops.LOG3", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["LOG3"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.Ops.LOG4", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["LOG4"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.Ops.CREATE", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["CREATE"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.Ops.RETURN", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["RETURN"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.Ops.CALL", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["CALL"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.Ops.CALLCODE", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["CALLCODE"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.Ops.DELEGATECALL", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["DELEGATECALL"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.Ops.STATICCALL", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["STATICCALL"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.Ops.REVERT", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["REVERT"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.Ops.SELFDESTRUCT", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["SELFDESTRUCT"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.Ops.CREATE2", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["CREATE2"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.op_implementation", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/__init__.py"}, "content": {"type": ["attribute"], "name": ["op_implementation"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.control_flow", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/control_flow.py"}, "content": {"type": ["module"], "name": ["ethereum.paris.vm.instructions.control_flow"], "text": ["Ethereum Virtual Machine (EVM) Control Flow Instructions ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementations of the EVM control flow instructions."]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.control_flow.stop", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/control_flow.py"}, "content": {"type": ["function"], "name": ["stop"], "text": ["Stop further execution of EVM code. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.control_flow.jump", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/control_flow.py"}, "content": {"type": ["function"], "name": ["jump"], "text": ["Alter the program counter to the location specified by the top of the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.control_flow.jumpi", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/control_flow.py"}, "content": {"type": ["function"], "name": ["jumpi"], "text": ["Alter the program counter to the specified location if and only if a condition is true. If the condition is not true, then the program counter would increase only by 1. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.control_flow.pc", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/control_flow.py"}, "content": {"type": ["function"], "name": ["pc"], "text": ["Push onto the stack the value of the program counter after reaching the current instruction and without increasing it for the next instruction. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.control_flow.gas_left", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/control_flow.py"}, "content": {"type": ["function"], "name": ["gas_left"], "text": ["Push the amount of available gas (including the corresponding reduction for the cost of this instruction) onto the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.control_flow.jumpdest", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/control_flow.py"}, "content": {"type": ["function"], "name": ["jumpdest"], "text": ["Mark a valid destination for jumps. This is a noop, present only to be used by  JUMP  and  JUMPI  opcodes to verify that their jump is valid. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.comparison", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/comparison.py"}, "content": {"type": ["module"], "name": ["ethereum.paris.vm.instructions.comparison"], "text": ["Ethereum Virtual Machine (EVM) Comparison Instructions ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementations of the EVM Comparison instructions."]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.comparison.less_than", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/comparison.py"}, "content": {"type": ["function"], "name": ["less_than"], "text": ["Checks if the top element is less than the next top element. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.comparison.signed_less_than", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/comparison.py"}, "content": {"type": ["function"], "name": ["signed_less_than"], "text": ["Signed less-than comparison. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.comparison.greater_than", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/comparison.py"}, "content": {"type": ["function"], "name": ["greater_than"], "text": ["Checks if the top element is greater than the next top element. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.comparison.signed_greater_than", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/comparison.py"}, "content": {"type": ["function"], "name": ["signed_greater_than"], "text": ["Signed greater-than comparison. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.comparison.equal", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/comparison.py"}, "content": {"type": ["function"], "name": ["equal"], "text": ["Checks if the top element is equal to the next top element. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.comparison.is_zero", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/comparison.py"}, "content": {"type": ["function"], "name": ["is_zero"], "text": ["Checks if the top element is equal to 0. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.log", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/log.py"}, "content": {"type": ["module"], "name": ["ethereum.paris.vm.instructions.log"], "text": ["Ethereum Virtual Machine (EVM) Logging Instructions ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementations of the EVM logging instructions."]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.log.log_n", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/log.py"}, "content": {"type": ["function"], "name": ["log_n"], "text": ["Appends a log entry, having  num_topics  topics, to the evm logs. This will also expand the memory if the data (required by the log entry) corresponding to the memory is not accessible. Parameters evm : The current EVM frame. num_topics : The number of topics to be included in the log entry."]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.log.log0", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/log.py"}, "content": {"type": ["attribute"], "name": ["log0"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.log.log1", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/log.py"}, "content": {"type": ["attribute"], "name": ["log1"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.log.log2", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/log.py"}, "content": {"type": ["attribute"], "name": ["log2"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.log.log3", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/log.py"}, "content": {"type": ["attribute"], "name": ["log3"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.log.log4", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/log.py"}, "content": {"type": ["attribute"], "name": ["log4"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.storage", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/storage.py"}, "content": {"type": ["module"], "name": ["ethereum.paris.vm.instructions.storage"], "text": ["Ethereum Virtual Machine (EVM) Storage Instructions ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementations of the EVM storage related instructions."]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.storage.sload", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/storage.py"}, "content": {"type": ["function"], "name": ["sload"], "text": ["Loads to the stack, the value corresponding to a certain key from the storage of the current account. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.storage.sstore", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/storage.py"}, "content": {"type": ["function"], "name": ["sstore"], "text": ["Stores a value at a certain key in the current context's storage. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.block", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/block.py"}, "content": {"type": ["module"], "name": ["ethereum.paris.vm.instructions.block"], "text": ["Ethereum Virtual Machine (EVM) Block Instructions ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementations of the EVM block instructions."]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.block.block_hash", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/block.py"}, "content": {"type": ["function"], "name": ["block_hash"], "text": ["Push the hash of one of the 256 most recent complete blocks onto the stack. The block number to hash is present at the top of the stack. Parameters evm : The current EVM frame. Raises :py:class: ~ethereum.paris.vm.exceptions.StackUnderflowError If  len(stack)  is less than  1 . :py:class: ~ethereum.paris.vm.exceptions.OutOfGasError If  evm.gas_left  is less than  20 ."]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.block.coinbase", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/block.py"}, "content": {"type": ["function"], "name": ["coinbase"], "text": ["Push the current block's beneficiary address (address of the block miner) onto the stack. Here the current block refers to the block in which the currently executing transaction/call resides. Parameters evm : The current EVM frame. Raises :py:class: ~ethereum.paris.vm.exceptions.StackOverflowError If  len(stack)  is equal to  1024 . :py:class: ~ethereum.paris.vm.exceptions.OutOfGasError If  evm.gas_left  is less than  2 ."]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.block.timestamp", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/block.py"}, "content": {"type": ["function"], "name": ["timestamp"], "text": ["Push the current block's timestamp onto the stack. Here the timestamp being referred is actually the unix timestamp in seconds. Here the current block refers to the block in which the currently executing transaction/call resides. Parameters evm : The current EVM frame. Raises :py:class: ~ethereum.paris.vm.exceptions.StackOverflowError If  len(stack)  is equal to  1024 . :py:class: ~ethereum.paris.vm.exceptions.OutOfGasError If  evm.gas_left  is less than  2 ."]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.block.number", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/block.py"}, "content": {"type": ["function"], "name": ["number"], "text": ["Push the current block's number onto the stack. Here the current block refers to the block in which the currently executing transaction/call resides. Parameters evm : The current EVM frame. Raises :py:class: ~ethereum.paris.vm.exceptions.StackOverflowError If  len(stack)  is equal to  1024 . :py:class: ~ethereum.paris.vm.exceptions.OutOfGasError If  evm.gas_left  is less than  2 ."]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.block.prev_randao", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/block.py"}, "content": {"type": ["function"], "name": ["prev_randao"], "text": ["Push the  prev_randao  value onto the stack. The  prev_randao  value is the random output of the beacon chain's randomness oracle for the previous block. Parameters evm : The current EVM frame. Raises :py:class: ~ethereum.paris.vm.exceptions.StackOverflowError If  len(stack)  is equal to  1024 . :py:class: ~ethereum.paris.vm.exceptions.OutOfGasError If  evm.gas_left  is less than  2 ."]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.block.gas_limit", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/block.py"}, "content": {"type": ["function"], "name": ["gas_limit"], "text": ["Push the current block's gas limit onto the stack. Here the current block refers to the block in which the currently executing transaction/call resides. Parameters evm : The current EVM frame. Raises :py:class: ~ethereum.paris.vm.exceptions.StackOverflowError If  len(stack)  is equal to  1024 . :py:class: ~ethereum.paris.vm.exceptions.OutOfGasError If  evm.gas_left  is less than  2 ."]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.block.chain_id", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/block.py"}, "content": {"type": ["function"], "name": ["chain_id"], "text": ["Push the chain id onto the stack. Parameters evm : The current EVM frame. Raises :py:class: ~ethereum.paris.vm.exceptions.StackOverflowError If  len(stack)  is equal to  1024 . :py:class: ~ethereum.paris.vm.exceptions.OutOfGasError If  evm.gas_left  is less than  2 ."]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.arithmetic", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/arithmetic.py"}, "content": {"type": ["module"], "name": ["ethereum.paris.vm.instructions.arithmetic"], "text": ["Ethereum Virtual Machine (EVM) Arithmetic Instructions ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementations of the EVM Arithmetic instructions."]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.arithmetic.add", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/arithmetic.py"}, "content": {"type": ["function"], "name": ["add"], "text": ["Adds the top two elements of the stack together, and pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.arithmetic.sub", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/arithmetic.py"}, "content": {"type": ["function"], "name": ["sub"], "text": ["Subtracts the top two elements of the stack, and pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.arithmetic.mul", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/arithmetic.py"}, "content": {"type": ["function"], "name": ["mul"], "text": ["Multiply the top two elements of the stack, and pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.arithmetic.div", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/arithmetic.py"}, "content": {"type": ["function"], "name": ["div"], "text": ["Integer division of the top two elements of the stack. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.arithmetic.sdiv", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/arithmetic.py"}, "content": {"type": ["function"], "name": ["sdiv"], "text": ["Signed integer division of the top two elements of the stack. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.arithmetic.mod", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/arithmetic.py"}, "content": {"type": ["function"], "name": ["mod"], "text": ["Modulo remainder of the top two elements of the stack. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.arithmetic.smod", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/arithmetic.py"}, "content": {"type": ["function"], "name": ["smod"], "text": ["Signed modulo remainder of the top two elements of the stack. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.arithmetic.addmod", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/arithmetic.py"}, "content": {"type": ["function"], "name": ["addmod"], "text": ["Modulo addition of the top 2 elements with the 3rd element. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.arithmetic.mulmod", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/arithmetic.py"}, "content": {"type": ["function"], "name": ["mulmod"], "text": ["Modulo multiplication of the top 2 elements with the 3rd element. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.arithmetic.exp", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/arithmetic.py"}, "content": {"type": ["function"], "name": ["exp"], "text": ["Exponential operation of the top 2 elements. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.arithmetic.signextend", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/arithmetic.py"}, "content": {"type": ["function"], "name": ["signextend"], "text": ["Sign extend operation. In other words, extend a signed number which fits in N bytes to 32 bytes. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.keccak", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/keccak.py"}, "content": {"type": ["module"], "name": ["ethereum.paris.vm.instructions.keccak"], "text": ["Ethereum Virtual Machine (EVM) Keccak Instructions ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementations of the EVM keccak instructions."]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.keccak.keccak", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/keccak.py"}, "content": {"type": ["function"], "name": ["keccak"], "text": ["Pushes to the stack the Keccak-256 hash of a region of memory. This also expands the memory, in case the memory is insufficient to access the data's memory location. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.bitwise", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/bitwise.py"}, "content": {"type": ["module"], "name": ["ethereum.paris.vm.instructions.bitwise"], "text": ["Ethereum Virtual Machine (EVM) Bitwise Instructions ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementations of the EVM bitwise instructions."]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.bitwise.bitwise_and", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/bitwise.py"}, "content": {"type": ["function"], "name": ["bitwise_and"], "text": ["Bitwise AND operation of the top 2 elements of the stack. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.bitwise.bitwise_or", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/bitwise.py"}, "content": {"type": ["function"], "name": ["bitwise_or"], "text": ["Bitwise OR operation of the top 2 elements of the stack. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.bitwise.bitwise_xor", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/bitwise.py"}, "content": {"type": ["function"], "name": ["bitwise_xor"], "text": ["Bitwise XOR operation of the top 2 elements of the stack. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.bitwise.bitwise_not", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/bitwise.py"}, "content": {"type": ["function"], "name": ["bitwise_not"], "text": ["Bitwise NOT operation of the top element of the stack. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.bitwise.get_byte", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/bitwise.py"}, "content": {"type": ["function"], "name": ["get_byte"], "text": ["For a word (defined by next top element of the stack), retrieve the Nth byte (0-indexed and defined by top element of stack) from the left (most significant) to right (least significant). Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.bitwise.bitwise_shl", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/bitwise.py"}, "content": {"type": ["function"], "name": ["bitwise_shl"], "text": ["Logical shift left (SHL) operation of the top 2 elements of the stack. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.bitwise.bitwise_shr", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/bitwise.py"}, "content": {"type": ["function"], "name": ["bitwise_shr"], "text": ["Logical shift right (SHR) operation of the top 2 elements of the stack. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.bitwise.bitwise_sar", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/bitwise.py"}, "content": {"type": ["function"], "name": ["bitwise_sar"], "text": ["Arithmetic shift right (SAR) operation of the top 2 elements of the stack. Pushes the result back on the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.environment", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/environment.py"}, "content": {"type": ["module"], "name": ["ethereum.paris.vm.instructions.environment"], "text": ["Ethereum Virtual Machine (EVM) Environmental Instructions ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementations of the EVM environment related instructions."]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.environment.address", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["address"], "text": ["Pushes the address of the current executing account to the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.environment.balance", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["balance"], "text": ["Pushes the balance of the given account onto the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.environment.origin", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["origin"], "text": ["Pushes the address of the original transaction sender to the stack. The origin address can only be an EOA. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.environment.caller", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["caller"], "text": ["Pushes the address of the caller onto the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.environment.callvalue", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["callvalue"], "text": ["Push the value (in wei) sent with the call onto the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.environment.calldataload", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["calldataload"], "text": ["Push a word (32 bytes) of the input data belonging to the current environment onto the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.environment.calldatasize", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["calldatasize"], "text": ["Push the size of input data in current environment onto the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.environment.calldatacopy", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["calldatacopy"], "text": ["Copy a portion of the input data in current environment to memory. This will also expand the memory, in case that the memory is insufficient to store the data. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.environment.codesize", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["codesize"], "text": ["Push the size of code running in current environment onto the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.environment.codecopy", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["codecopy"], "text": ["Copy a portion of the code in current environment to memory. This will also expand the memory, in case that the memory is insufficient to store the data. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.environment.gasprice", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["gasprice"], "text": ["Push the gas price used in current environment onto the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.environment.extcodesize", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["extcodesize"], "text": ["Push the code size of a given account onto the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.environment.extcodecopy", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["extcodecopy"], "text": ["Copy a portion of an account's code to memory. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.environment.returndatasize", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["returndatasize"], "text": ["Pushes the size of the return data buffer onto the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.environment.returndatacopy", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["returndatacopy"], "text": ["Copies data from the return data buffer code to memory Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.environment.extcodehash", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["extcodehash"], "text": ["Returns the keccak256 hash of a contract\u2019s bytecode Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.environment.self_balance", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["self_balance"], "text": ["Pushes the balance of the current address to the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.environment.base_fee", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/environment.py"}, "content": {"type": ["function"], "name": ["base_fee"], "text": ["Pushes the base fee of the current block on to the stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.stack", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/stack.py"}, "content": {"type": ["module"], "name": ["ethereum.paris.vm.instructions.stack"], "text": ["Ethereum Virtual Machine (EVM) Stack Instructions ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementations of the EVM stack related instructions."]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.stack.pop", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/stack.py"}, "content": {"type": ["function"], "name": ["pop"], "text": ["Remove item from stack. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.stack.push_n", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/stack.py"}, "content": {"type": ["function"], "name": ["push_n"], "text": ["Pushes a N-byte immediate onto the stack. Parameters evm : The current EVM frame. num_bytes : The number of immediate bytes to be read from the code and pushed to the stack."]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.stack.dup_n", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/stack.py"}, "content": {"type": ["function"], "name": ["dup_n"], "text": ["Duplicate the Nth stack item (from top of the stack) to the top of stack. Parameters evm : The current EVM frame. item_number : The stack item number (0-indexed from top of stack) to be duplicated to the top of stack."]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.stack.swap_n", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/stack.py"}, "content": {"type": ["function"], "name": ["swap_n"], "text": ["Swap the top and the  item_number  element of the stack, where the top of the stack is position zero. If  item_number  is zero, this function does nothing (which should not be possible, since there is no  SWAP0  instruction). Parameters evm : The current EVM frame. item_number : The stack item number (0-indexed from top of stack) to be swapped with the top of stack element."]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.stack.push1", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push1"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.stack.push2", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push2"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.stack.push3", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push3"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.stack.push4", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push4"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.stack.push5", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push5"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.stack.push6", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push6"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.stack.push7", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push7"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.stack.push8", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push8"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.stack.push9", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push9"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.stack.push10", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push10"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.stack.push11", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push11"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.stack.push12", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push12"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.stack.push13", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push13"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.stack.push14", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push14"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.stack.push15", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push15"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.stack.push16", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push16"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.stack.push17", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push17"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.stack.push18", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push18"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.stack.push19", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push19"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.stack.push20", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push20"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.stack.push21", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push21"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.stack.push22", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push22"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.stack.push23", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push23"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.stack.push24", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push24"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.stack.push25", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push25"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.stack.push26", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push26"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.stack.push27", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push27"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.stack.push28", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push28"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.stack.push29", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push29"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.stack.push30", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push30"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.stack.push31", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push31"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.stack.push32", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["push32"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.stack.dup1", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup1"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.stack.dup2", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup2"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.stack.dup3", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup3"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.stack.dup4", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup4"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.stack.dup5", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup5"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.stack.dup6", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup6"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.stack.dup7", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup7"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.stack.dup8", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup8"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.stack.dup9", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup9"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.stack.dup10", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup10"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.stack.dup11", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup11"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.stack.dup12", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup12"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.stack.dup13", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup13"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.stack.dup14", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup14"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.stack.dup15", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup15"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.stack.dup16", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["dup16"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.stack.swap1", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap1"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.stack.swap2", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap2"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.stack.swap3", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap3"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.stack.swap4", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap4"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.stack.swap5", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap5"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.stack.swap6", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap6"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.stack.swap7", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap7"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.stack.swap8", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap8"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.stack.swap9", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap9"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.stack.swap10", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap10"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.stack.swap11", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap11"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.stack.swap12", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap12"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.stack.swap13", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap13"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.stack.swap14", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap14"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.stack.swap15", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap15"]}}, {"source": {"identifier": "ethereum.paris.vm.instructions.stack.swap16", "specifier": 0, "path": "src/ethereum/paris/vm/instructions/stack.py"}, "content": {"type": ["attribute"], "name": ["swap16"]}}, {"source": {"identifier": "ethereum.paris.utils", "specifier": 0, "path": "src/ethereum/paris/utils/__init__.py"}, "content": {"type": ["module"], "name": ["ethereum.paris.utils"], "text": ["Hardfork Utility Functions ^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Utility functions used in this paris version of specification."]}}, {"source": {"identifier": "ethereum.paris.utils.address", "specifier": 0, "path": "src/ethereum/paris/utils/address.py"}, "content": {"type": ["module"], "name": ["ethereum.paris.utils.address"], "text": ["Hardfork Utility Functions For Addresses ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Address specific functions used in this paris version of specification."]}}, {"source": {"identifier": "ethereum.paris.utils.address.to_address", "specifier": 0, "path": "src/ethereum/paris/utils/address.py"}, "content": {"type": ["function"], "name": ["to_address"], "text": ["Convert a Uint or U256 value to a valid address (20 bytes). Parameters data : The string to be converted to bytes. Returns address :  Address The obtained address."]}}, {"source": {"identifier": "ethereum.paris.utils.address.compute_contract_address", "specifier": 0, "path": "src/ethereum/paris/utils/address.py"}, "content": {"type": ["function"], "name": ["compute_contract_address"], "text": ["Computes address of the new account that needs to be created. Parameters address : The address of the account that wants to create the new account. nonce : The transaction count of the account that wants to create the new account. Returns address:  Address The computed address of the new account."]}}, {"source": {"identifier": "ethereum.paris.utils.address.compute_create2_contract_address", "specifier": 0, "path": "src/ethereum/paris/utils/address.py"}, "content": {"type": ["function"], "name": ["compute_create2_contract_address"], "text": ["Computes address of the new account that needs to be created, which is based on the sender address, salt and the call data as well. Parameters address : The address of the account that wants to create the new account. salt : Address generation salt. call_data : The code of the new account which is to be created. Returns address:  ethereum.paris.fork_types.Address The computed address of the new account."]}}, {"source": {"identifier": "ethereum.paris.utils.message", "specifier": 0, "path": "src/ethereum/paris/utils/message.py"}, "content": {"type": ["module"], "name": ["ethereum.paris.utils.message"], "text": ["Hardfork Utility Functions For The Message Data-structure ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Message specific functions used in this paris version of specification."]}}, {"source": {"identifier": "ethereum.paris.utils.message.prepare_message", "specifier": 0, "path": "src/ethereum/paris/utils/message.py"}, "content": {"type": ["function"], "name": ["prepare_message"], "text": ["Execute a transaction against the provided environment. Parameters caller : Address which initiated the transaction target : Address whose code will be executed value : Value to be transferred. data : Array of bytes provided to the code in  target . gas : Gas provided for the code in  target . env : Environment for the Ethereum Virtual Machine. code_address : This is usually same as the  target  address except when an alternative accounts code needs to be executed. eg.  CALLCODE  calling a precompile. should_transfer_value : if True ETH should be transferred while executing a message call. is_static: if True then it prevents all state-changing operations from being executed. preaccessed_addresses: Addresses that should be marked as accessed prior to the message call preaccessed_storage_keys: Storage keys that should be marked as accessed prior to the message call Returns message:  ethereum.paris.vm.Message Items containing contract creation or message call specific data."]}}, {"source": {"identifier": "ethereum.paris.utils.hexadecimal", "specifier": 0, "path": "src/ethereum/paris/utils/hexadecimal.py"}, "content": {"type": ["module"], "name": ["ethereum.paris.utils.hexadecimal"], "text": ["Utility Functions For Hexadecimal Strings ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Hexadecimal utility functions used in this specification, specific to Paris types."]}}, {"source": {"identifier": "ethereum.paris.utils.hexadecimal.hex_to_root", "specifier": 0, "path": "src/ethereum/paris/utils/hexadecimal.py"}, "content": {"type": ["function"], "name": ["hex_to_root"], "text": ["Convert hex string to trie root. Parameters hex_string : The hexadecimal string to be converted to trie root. Returns root :  Root Trie root obtained from the given hexadecimal string."]}}, {"source": {"identifier": "ethereum.paris.utils.hexadecimal.hex_to_bloom", "specifier": 0, "path": "src/ethereum/paris/utils/hexadecimal.py"}, "content": {"type": ["function"], "name": ["hex_to_bloom"], "text": ["Convert hex string to bloom. Parameters hex_string : The hexadecimal string to be converted to bloom. Returns bloom :  Bloom Bloom obtained from the given hexadecimal string."]}}, {"source": {"identifier": "ethereum.paris.utils.hexadecimal.hex_to_address", "specifier": 0, "path": "src/ethereum/paris/utils/hexadecimal.py"}, "content": {"type": ["function"], "name": ["hex_to_address"], "text": ["Convert hex string to Address (20 bytes). Parameters hex_string : The hexadecimal string to be converted to Address. Returns address :  Address The address obtained from the given hexadecimal string."]}}, {"source": {"identifier": "ethereum.london.state", "specifier": 0, "path": "src/ethereum/london/state.py"}, "content": {"type": ["module"], "name": ["ethereum.london.state"], "text": ["State ^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction The state contains all information that is preserved between transactions. It consists of a main account trie and storage tries for each contract. There is a distinction between an account that does not exist and EMPTY_ACCOUNT ."]}}, {"source": {"identifier": "ethereum.london.state.State", "specifier": 0, "path": "src/ethereum/london/state.py"}, "content": {"type": ["class"], "name": ["State"], "text": ["Contains all information that is preserved between transactions."]}}, {"source": {"identifier": "ethereum.london.state.State._main_trie", "specifier": 0, "path": "src/ethereum/london/state.py"}, "content": {"type": ["attribute"], "name": ["_main_trie"]}}, {"source": {"identifier": "ethereum.london.state.State._storage_tries", "specifier": 0, "path": "src/ethereum/london/state.py"}, "content": {"type": ["attribute"], "name": ["_storage_tries"]}}, {"source": {"identifier": "ethereum.london.state.State._snapshots", "specifier": 0, "path": "src/ethereum/london/state.py"}, "content": {"type": ["attribute"], "name": ["_snapshots"]}}, {"source": {"identifier": "ethereum.london.state.close_state", "specifier": 0, "path": "src/ethereum/london/state.py"}, "content": {"type": ["function"], "name": ["close_state"], "text": ["Free resources held by the state. Used by optimized implementations to release file descriptors."]}}, {"source": {"identifier": "ethereum.london.state.begin_transaction", "specifier": 0, "path": "src/ethereum/london/state.py"}, "content": {"type": ["function"], "name": ["begin_transaction"], "text": ["Start a state transaction. Transactions are entirely implicit and can be nested. It is not possible to calculate the state root during a transaction. Parameters state : State The state."]}}, {"source": {"identifier": "ethereum.london.state.commit_transaction", "specifier": 0, "path": "src/ethereum/london/state.py"}, "content": {"type": ["function"], "name": ["commit_transaction"], "text": ["Commit a state transaction. Parameters state : State The state."]}}, {"source": {"identifier": "ethereum.london.state.rollback_transaction", "specifier": 0, "path": "src/ethereum/london/state.py"}, "content": {"type": ["function"], "name": ["rollback_transaction"], "text": ["Rollback a state transaction, resetting the state to the point when the corresponding  start_transaction()  call was made. Parameters state : State The state."]}}, {"source": {"identifier": "ethereum.london.state.get_account", "specifier": 0, "path": "src/ethereum/london/state.py"}, "content": {"type": ["function"], "name": ["get_account"], "text": ["Get the  Account  object at an address. Returns  EMPTY_ACCOUNT  if there is no account at the address. Use  get_account_optional()  if you care about the difference between a non-existent account and  EMPTY_ACCOUNT . Parameters state:  State The state address :  Address Address to lookup. Returns account :  Account Account at address."]}}, {"source": {"identifier": "ethereum.london.state.get_account_optional", "specifier": 0, "path": "src/ethereum/london/state.py"}, "content": {"type": ["function"], "name": ["get_account_optional"], "text": ["Get the  Account  object at an address. Returns  None  (rather than EMPTY_ACCOUNT ) if there is no account at the address. Parameters state:  State The state address :  Address Address to lookup. Returns account :  Account Account at address."]}}, {"source": {"identifier": "ethereum.london.state.set_account", "specifier": 0, "path": "src/ethereum/london/state.py"}, "content": {"type": ["function"], "name": ["set_account"], "text": ["Set the  Account  object at an address. Setting to  None  deletes the account (but not its storage, see  destroy_account() ). Parameters state:  State The state address :  Address Address to set. account :  Account Account to set at address."]}}, {"source": {"identifier": "ethereum.london.state.destroy_account", "specifier": 0, "path": "src/ethereum/london/state.py"}, "content": {"type": ["function"], "name": ["destroy_account"], "text": ["Completely remove the account at  address  and all of its storage. This function is made available exclusively for the  SELFDESTRUCT opcode. It is expected that  SELFDESTRUCT  will be disabled in a future hardfork and this function will be removed. Parameters state:  State The state address :  Address Address of account to destroy."]}}, {"source": {"identifier": "ethereum.london.state.destroy_storage", "specifier": 0, "path": "src/ethereum/london/state.py"}, "content": {"type": ["function"], "name": ["destroy_storage"], "text": ["Completely remove the storage at  address . Parameters state:  State The state address :  Address Address of account whose storage is to be deleted."]}}, {"source": {"identifier": "ethereum.london.state.get_storage", "specifier": 0, "path": "src/ethereum/london/state.py"}, "content": {"type": ["function"], "name": ["get_storage"], "text": ["Get a value at a storage key on an account. Returns  U256(0)  if the storage key has not been set previously. Parameters state:  State The state address :  Address Address of the account. key :  Bytes Key to lookup. Returns value :  U256 Value at the key."]}}, {"source": {"identifier": "ethereum.london.state.set_storage", "specifier": 0, "path": "src/ethereum/london/state.py"}, "content": {"type": ["function"], "name": ["set_storage"], "text": ["Set a value at a storage key on an account. Setting to  U256(0)  deletes the key. Parameters state:  State The state address :  Address Address of the account. key :  Bytes Key to set. value :  U256 Value to set at the key."]}}, {"source": {"identifier": "ethereum.london.state.storage_root", "specifier": 0, "path": "src/ethereum/london/state.py"}, "content": {"type": ["function"], "name": ["storage_root"], "text": ["Calculate the storage root of an account. Parameters state: The state address : Address of the account. Returns root :  Root Storage root of the account."]}}, {"source": {"identifier": "ethereum.london.state.state_root", "specifier": 0, "path": "src/ethereum/london/state.py"}, "content": {"type": ["function"], "name": ["state_root"], "text": ["Calculate the state root. Parameters state: The current state. Returns root :  Root The state root."]}}, {"source": {"identifier": "ethereum.london.state.account_exists", "specifier": 0, "path": "src/ethereum/london/state.py"}, "content": {"type": ["function"], "name": ["account_exists"], "text": ["Checks if an account exists in the state trie Parameters state: The state address: Address of the account that needs to be checked. Returns account_exists :  bool True if account exists in the state trie, False otherwise"]}}, {"source": {"identifier": "ethereum.london.state.account_has_code_or_nonce", "specifier": 0, "path": "src/ethereum/london/state.py"}, "content": {"type": ["function"], "name": ["account_has_code_or_nonce"], "text": ["Checks if an account has non zero nonce or non empty code Parameters state: The state address: Address of the account that needs to be checked. Returns has_code_or_nonce :  bool True if if an account has non zero nonce or non empty code, False otherwise."]}}, {"source": {"identifier": "ethereum.london.state.is_account_empty", "specifier": 0, "path": "src/ethereum/london/state.py"}, "content": {"type": ["function"], "name": ["is_account_empty"], "text": ["Checks if an account has zero nonce, empty code and zero balance. Parameters state: The state address: Address of the account that needs to be checked. Returns is_empty :  bool True if if an account has zero nonce, empty code and zero balance, False otherwise."]}}, {"source": {"identifier": "ethereum.london.state.account_exists_and_is_empty", "specifier": 0, "path": "src/ethereum/london/state.py"}, "content": {"type": ["function"], "name": ["account_exists_and_is_empty"], "text": ["Checks if an account exists and has zero nonce, empty code and zero balance. Parameters state: The state address: Address of the account that needs to be checked. Returns exists_and_is_empty :  bool True if an account exists and has zero nonce, empty code and zero balance, False otherwise."]}}, {"source": {"identifier": "ethereum.london.state.is_account_alive", "specifier": 0, "path": "src/ethereum/london/state.py"}, "content": {"type": ["function"], "name": ["is_account_alive"], "text": ["Check whether is an account is both in the state and non empty. Parameters state: The state address: Address of the account that needs to be checked. Returns is_alive :  bool True if the account is alive."]}}, {"source": {"identifier": "ethereum.london.state.modify_state", "specifier": 0, "path": "src/ethereum/london/state.py"}, "content": {"type": ["function"], "name": ["modify_state"], "text": ["Modify an  Account  in the  State ."]}}, {"source": {"identifier": "ethereum.london.state.move_ether", "specifier": 0, "path": "src/ethereum/london/state.py"}, "content": {"type": ["function"], "name": ["move_ether"], "text": ["Move funds between accounts."]}}, {"source": {"identifier": "ethereum.london.state.set_account_balance", "specifier": 0, "path": "src/ethereum/london/state.py"}, "content": {"type": ["function"], "name": ["set_account_balance"], "text": ["Sets the balance of an account. Parameters state: The current state. address: Address of the account whose nonce needs to be incremented. amount: The amount that needs to set in balance."]}}, {"source": {"identifier": "ethereum.london.state.touch_account", "specifier": 0, "path": "src/ethereum/london/state.py"}, "content": {"type": ["function"], "name": ["touch_account"], "text": ["Initializes an account to state. Parameters state: The current state. address: The address of the account that need to initialised."]}}, {"source": {"identifier": "ethereum.london.state.increment_nonce", "specifier": 0, "path": "src/ethereum/london/state.py"}, "content": {"type": ["function"], "name": ["increment_nonce"], "text": ["Increments the nonce of an account. Parameters state: The current state. address: Address of the account whose nonce needs to be incremented."]}}, {"source": {"identifier": "ethereum.london.state.set_code", "specifier": 0, "path": "src/ethereum/london/state.py"}, "content": {"type": ["function"], "name": ["set_code"], "text": ["Sets Account code. Parameters state: The current state. address: Address of the account whose code needs to be update. code: The bytecode that needs to be set."]}}, {"source": {"identifier": "ethereum.london.state.create_ether", "specifier": 0, "path": "src/ethereum/london/state.py"}, "content": {"type": ["function"], "name": ["create_ether"], "text": ["Add newly created ether to an account. Parameters state: The current state. address: Address of the account to which ether is added. amount: The amount of ether to be added to the account of interest."]}}, {"source": {"identifier": "ethereum.london.state.get_storage_original", "specifier": 0, "path": "src/ethereum/london/state.py"}, "content": {"type": ["function"], "name": ["get_storage_original"], "text": ["Get the original value in a storage slot i.e. the value before the current transaction began. This function reads the value from the snapshots taken before executing the transaction. Parameters state: The current state. address: Address of the account to read the value from. key: Key of the storage slot."]}}, {"source": {"identifier": "ethereum.london", "specifier": 0, "path": "src/ethereum/london/__init__.py"}, "content": {"type": ["module"], "name": ["ethereum.london"], "text": ["Ethereum London Hardfork ^^^^^^^^^^^^^^^^^^^^^^^^ The Eleventh Ethereum hardfork."]}}, {"source": {"identifier": "ethereum.london.MAINNET_FORK_BLOCK", "specifier": 0, "path": "src/ethereum/london/__init__.py"}, "content": {"type": ["attribute"], "name": ["MAINNET_FORK_BLOCK"]}}, {"source": {"identifier": "ethereum.london.bloom", "specifier": 0, "path": "src/ethereum/london/bloom.py"}, "content": {"type": ["module"], "name": ["ethereum.london.bloom"], "text": ["Ethereum Logs Bloom ^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction This modules defines functions for calculating bloom filters of logs. For the general theory of bloom filters see e.g.  Wikipedia <https://en.wikipedia.org/wiki/Bloom_filter> _. Bloom filters are used to allow for efficient searching of logs by address and/or topic, by rapidly eliminating blocks and reciepts from their search."]}}, {"source": {"identifier": "ethereum.london.bloom.add_to_bloom", "specifier": 0, "path": "src/ethereum/london/bloom.py"}, "content": {"type": ["function"], "name": ["add_to_bloom"], "text": ["Add a bloom entry to the bloom filter ( bloom ). The number of hash functions used is 3. They are calculated by taking the least significant 11 bits from the first 3 16-bit words of the keccak_256()  hash of  bloom_entry . Parameters bloom : The bloom filter. bloom_entry : An entry which is to be added to bloom filter."]}}, {"source": {"identifier": "ethereum.london.bloom.logs_bloom", "specifier": 0, "path": "src/ethereum/london/bloom.py"}, "content": {"type": ["function"], "name": ["logs_bloom"], "text": ["Obtain the logs bloom from a list of log entries. The address and each topic of a log are added to the bloom filter. Parameters logs : List of logs for which the logs bloom is to be obtained. Returns logs_bloom :  Bloom The logs bloom obtained which is 256 bytes with some bits set as per the caller address and the log topics."]}}, {"source": {"identifier": "ethereum.london.fork_types", "specifier": 0, "path": "src/ethereum/london/fork_types.py"}, "content": {"type": ["module"], "name": ["ethereum.london.fork_types"], "text": ["Ethereum Types ^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Types re-used throughout the specification, which are specific to Ethereum."]}}, {"source": {"identifier": "ethereum.london.fork_types.Address", "specifier": 0, "path": "src/ethereum/london/fork_types.py"}, "content": {"type": ["attribute"], "name": ["Address"]}}, {"source": {"identifier": "ethereum.london.fork_types.Root", "specifier": 0, "path": "src/ethereum/london/fork_types.py"}, "content": {"type": ["attribute"], "name": ["Root"]}}, {"source": {"identifier": "ethereum.london.fork_types.Bloom", "specifier": 0, "path": "src/ethereum/london/fork_types.py"}, "content": {"type": ["attribute"], "name": ["Bloom"]}}, {"source": {"identifier": "ethereum.london.fork_types.TX_BASE_COST", "specifier": 0, "path": "src/ethereum/london/fork_types.py"}, "content": {"type": ["attribute"], "name": ["TX_BASE_COST"]}}, {"source": {"identifier": "ethereum.london.fork_types.TX_DATA_COST_PER_NON_ZERO", "specifier": 0, "path": "src/ethereum/london/fork_types.py"}, "content": {"type": ["attribute"], "name": ["TX_DATA_COST_PER_NON_ZERO"]}}, {"source": {"identifier": "ethereum.london.fork_types.TX_DATA_COST_PER_ZERO", "specifier": 0, "path": "src/ethereum/london/fork_types.py"}, "content": {"type": ["attribute"], "name": ["TX_DATA_COST_PER_ZERO"]}}, {"source": {"identifier": "ethereum.london.fork_types.TX_CREATE_COST", "specifier": 0, "path": "src/ethereum/london/fork_types.py"}, "content": {"type": ["attribute"], "name": ["TX_CREATE_COST"]}}, {"source": {"identifier": "ethereum.london.fork_types.TX_ACCESS_LIST_ADDRESS_COST", "specifier": 0, "path": "src/ethereum/london/fork_types.py"}, "content": {"type": ["attribute"], "name": ["TX_ACCESS_LIST_ADDRESS_COST"]}}, {"source": {"identifier": "ethereum.london.fork_types.TX_ACCESS_LIST_STORAGE_KEY_COST", "specifier": 0, "path": "src/ethereum/london/fork_types.py"}, "content": {"type": ["attribute"], "name": ["TX_ACCESS_LIST_STORAGE_KEY_COST"]}}, {"source": {"identifier": "ethereum.london.fork_types.LegacyTransaction", "specifier": 0, "path": "src/ethereum/london/fork_types.py"}, "content": {"type": ["class"], "name": ["LegacyTransaction"], "text": ["Atomic operation performed on the block chain."]}}, {"source": {"identifier": "ethereum.london.fork_types.LegacyTransaction.nonce", "specifier": 0, "path": "src/ethereum/london/fork_types.py"}, "content": {"type": ["attribute"], "name": ["nonce"]}}, {"source": {"identifier": "ethereum.london.fork_types.LegacyTransaction.gas_price", "specifier": 0, "path": "src/ethereum/london/fork_types.py"}, "content": {"type": ["attribute"], "name": ["gas_price"]}}, {"source": {"identifier": "ethereum.london.fork_types.LegacyTransaction.gas", "specifier": 0, "path": "src/ethereum/london/fork_types.py"}, "content": {"type": ["attribute"], "name": ["gas"]}}, {"source": {"identifier": "ethereum.london.fork_types.LegacyTransaction.to", "specifier": 0, "path": "src/ethereum/london/fork_types.py"}, "content": {"type": ["attribute"], "name": ["to"]}}, {"source": {"identifier": "ethereum.london.fork_types.LegacyTransaction.value", "specifier": 0, "path": "src/ethereum/london/fork_types.py"}, "content": {"type": ["attribute"], "name": ["value"]}}, {"source": {"identifier": "ethereum.london.fork_types.LegacyTransaction.data", "specifier": 0, "path": "src/ethereum/london/fork_types.py"}, "content": {"type": ["attribute"], "name": ["data"]}}, {"source": {"identifier": "ethereum.london.fork_types.LegacyTransaction.v", "specifier": 0, "path": "src/ethereum/london/fork_types.py"}, "content": {"type": ["attribute"], "name": ["v"]}}, {"source": {"identifier": "ethereum.london.fork_types.LegacyTransaction.r", "specifier": 0, "path": "src/ethereum/london/fork_types.py"}, "content": {"type": ["attribute"], "name": ["r"]}}, {"source": {"identifier": "ethereum.london.fork_types.LegacyTransaction.s", "specifier": 0, "path": "src/ethereum/london/fork_types.py"}, "content": {"type": ["attribute"], "name": ["s"]}}, {"source": {"identifier": "ethereum.london.fork_types.AccessListTransaction", "specifier": 0, "path": "src/ethereum/london/fork_types.py"}, "content": {"type": ["class"], "name": ["AccessListTransaction"], "text": ["The transaction type added in EIP-2930 to support access lists."]}}, {"source": {"identifier": "ethereum.london.fork_types.AccessListTransaction.chain_id", "specifier": 0, "path": "src/ethereum/london/fork_types.py"}, "content": {"type": ["attribute"], "name": ["chain_id"]}}, {"source": {"identifier": "ethereum.london.fork_types.AccessListTransaction.nonce", "specifier": 0, "path": "src/ethereum/london/fork_types.py"}, "content": {"type": ["attribute"], "name": ["nonce"]}}, {"source": {"identifier": "ethereum.london.fork_types.AccessListTransaction.gas_price", "specifier": 0, "path": "src/ethereum/london/fork_types.py"}, "content": {"type": ["attribute"], "name": ["gas_price"]}}, {"source": {"identifier": "ethereum.london.fork_types.AccessListTransaction.gas", "specifier": 0, "path": "src/ethereum/london/fork_types.py"}, "content": {"type": ["attribute"], "name": ["gas"]}}, {"source": {"identifier": "ethereum.london.fork_types.AccessListTransaction.to", "specifier": 0, "path": "src/ethereum/london/fork_types.py"}, "content": {"type": ["attribute"], "name": ["to"]}}, {"source": {"identifier": "ethereum.london.fork_types.AccessListTransaction.value", "specifier": 0, "path": "src/ethereum/london/fork_types.py"}, "content": {"type": ["attribute"], "name": ["value"]}}, {"source": {"identifier": "ethereum.london.fork_types.AccessListTransaction.data", "specifier": 0, "path": "src/ethereum/london/fork_types.py"}, "content": {"type": ["attribute"], "name": ["data"]}}, {"source": {"identifier": "ethereum.london.fork_types.AccessListTransaction.access_list", "specifier": 0, "path": "src/ethereum/london/fork_types.py"}, "content": {"type": ["attribute"], "name": ["access_list"]}}, {"source": {"identifier": "ethereum.london.fork_types.AccessListTransaction.v", "specifier": 0, "path": "src/ethereum/london/fork_types.py"}, "content": {"type": ["attribute"], "name": ["v"]}}, {"source": {"identifier": "ethereum.london.fork_types.AccessListTransaction.r", "specifier": 0, "path": "src/ethereum/london/fork_types.py"}, "content": {"type": ["attribute"], "name": ["r"]}}, {"source": {"identifier": "ethereum.london.fork_types.AccessListTransaction.s", "specifier": 0, "path": "src/ethereum/london/fork_types.py"}, "content": {"type": ["attribute"], "name": ["s"]}}, {"source": {"identifier": "ethereum.london.fork_types.FeeMarketTransaction", "specifier": 0, "path": "src/ethereum/london/fork_types.py"}, "content": {"type": ["class"], "name": ["FeeMarketTransaction"], "text": ["The transaction type added in EIP-1559."]}}, {"source": {"identifier": "ethereum.london.fork_types.FeeMarketTransaction.chain_id", "specifier": 0, "path": "src/ethereum/london/fork_types.py"}, "content": {"type": ["attribute"], "name": ["chain_id"]}}, {"source": {"identifier": "ethereum.london.fork_types.FeeMarketTransaction.nonce", "specifier": 0, "path": "src/ethereum/london/fork_types.py"}, "content": {"type": ["attribute"], "name": ["nonce"]}}, {"source": {"identifier": "ethereum.london.fork_types.FeeMarketTransaction.max_priority_fee_per_gas", "specifier": 0, "path": "src/ethereum/london/fork_types.py"}, "content": {"type": ["attribute"], "name": ["max_priority_fee_per_gas"]}}, {"source": {"identifier": "ethereum.london.fork_types.FeeMarketTransaction.max_fee_per_gas", "specifier": 0, "path": "src/ethereum/london/fork_types.py"}, "content": {"type": ["attribute"], "name": ["max_fee_per_gas"]}}, {"source": {"identifier": "ethereum.london.fork_types.FeeMarketTransaction.gas", "specifier": 0, "path": "src/ethereum/london/fork_types.py"}, "content": {"type": ["attribute"], "name": ["gas"]}}, {"source": {"identifier": "ethereum.london.fork_types.FeeMarketTransaction.to", "specifier": 0, "path": "src/ethereum/london/fork_types.py"}, "content": {"type": ["attribute"], "name": ["to"]}}, {"source": {"identifier": "ethereum.london.fork_types.FeeMarketTransaction.value", "specifier": 0, "path": "src/ethereum/london/fork_types.py"}, "content": {"type": ["attribute"], "name": ["value"]}}, {"source": {"identifier": "ethereum.london.fork_types.FeeMarketTransaction.data", "specifier": 0, "path": "src/ethereum/london/fork_types.py"}, "content": {"type": ["attribute"], "name": ["data"]}}, {"source": {"identifier": "ethereum.london.fork_types.FeeMarketTransaction.access_list", "specifier": 0, "path": "src/ethereum/london/fork_types.py"}, "content": {"type": ["attribute"], "name": ["access_list"]}}, {"source": {"identifier": "ethereum.london.fork_types.FeeMarketTransaction.v", "specifier": 0, "path": "src/ethereum/london/fork_types.py"}, "content": {"type": ["attribute"], "name": ["v"]}}, {"source": {"identifier": "ethereum.london.fork_types.FeeMarketTransaction.r", "specifier": 0, "path": "src/ethereum/london/fork_types.py"}, "content": {"type": ["attribute"], "name": ["r"]}}, {"source": {"identifier": "ethereum.london.fork_types.FeeMarketTransaction.s", "specifier": 0, "path": "src/ethereum/london/fork_types.py"}, "content": {"type": ["attribute"], "name": ["s"]}}, {"source": {"identifier": "ethereum.london.fork_types.Transaction", "specifier": 0, "path": "src/ethereum/london/fork_types.py"}, "content": {"type": ["attribute"], "name": ["Transaction"]}}, {"source": {"identifier": "ethereum.london.fork_types.encode_transaction", "specifier": 0, "path": "src/ethereum/london/fork_types.py"}, "content": {"type": ["function"], "name": ["encode_transaction"], "text": ["Encode a transaction. Needed because non-legacy transactions aren't RLP."]}}, {"source": {"identifier": "ethereum.london.fork_types.decode_transaction", "specifier": 0, "path": "src/ethereum/london/fork_types.py"}, "content": {"type": ["function"], "name": ["decode_transaction"], "text": ["Decode a transaction. Needed because non-legacy transactions aren't RLP."]}}, {"source": {"identifier": "ethereum.london.fork_types.Account", "specifier": 0, "path": "src/ethereum/london/fork_types.py"}, "content": {"type": ["class"], "name": ["Account"], "text": ["State associated with an address."]}}, {"source": {"identifier": "ethereum.london.fork_types.Account.nonce", "specifier": 0, "path": "src/ethereum/london/fork_types.py"}, "content": {"type": ["attribute"], "name": ["nonce"]}}, {"source": {"identifier": "ethereum.london.fork_types.Account.balance", "specifier": 0, "path": "src/ethereum/london/fork_types.py"}, "content": {"type": ["attribute"], "name": ["balance"]}}, {"source": {"identifier": "ethereum.london.fork_types.Account.code", "specifier": 0, "path": "src/ethereum/london/fork_types.py"}, "content": {"type": ["attribute"], "name": ["code"]}}, {"source": {"identifier": "ethereum.london.fork_types.EMPTY_ACCOUNT", "specifier": 0, "path": "src/ethereum/london/fork_types.py"}, "content": {"type": ["attribute"], "name": ["EMPTY_ACCOUNT"]}}, {"source": {"identifier": "ethereum.london.fork_types.encode_account", "specifier": 0, "path": "src/ethereum/london/fork_types.py"}, "content": {"type": ["function"], "name": ["encode_account"], "text": ["Encode  Account  dataclass. Storage is not stored in the  Account  dataclass, so  Accounts  cannot be encoded with providing a storage root."]}}, {"source": {"identifier": "ethereum.london.fork_types.Header", "specifier": 0, "path": "src/ethereum/london/fork_types.py"}, "content": {"type": ["class"], "name": ["Header"], "text": ["Header portion of a block on the chain."]}}, {"source": {"identifier": "ethereum.london.fork_types.Header.parent_hash", "specifier": 0, "path": "src/ethereum/london/fork_types.py"}, "content": {"type": ["attribute"], "name": ["parent_hash"]}}, {"source": {"identifier": "ethereum.london.fork_types.Header.ommers_hash", "specifier": 0, "path": "src/ethereum/london/fork_types.py"}, "content": {"type": ["attribute"], "name": ["ommers_hash"]}}, {"source": {"identifier": "ethereum.london.fork_types.Header.coinbase", "specifier": 0, "path": "src/ethereum/london/fork_types.py"}, "content": {"type": ["attribute"], "name": ["coinbase"]}}, {"source": {"identifier": "ethereum.london.fork_types.Header.state_root", "specifier": 0, "path": "src/ethereum/london/fork_types.py"}, "content": {"type": ["attribute"], "name": ["state_root"]}}, {"source": {"identifier": "ethereum.london.fork_types.Header.transactions_root", "specifier": 0, "path": "src/ethereum/london/fork_types.py"}, "content": {"type": ["attribute"], "name": ["transactions_root"]}}, {"source": {"identifier": "ethereum.london.fork_types.Header.receipt_root", "specifier": 0, "path": "src/ethereum/london/fork_types.py"}, "content": {"type": ["attribute"], "name": ["receipt_root"]}}, {"source": {"identifier": "ethereum.london.fork_types.Header.bloom", "specifier": 0, "path": "src/ethereum/london/fork_types.py"}, "content": {"type": ["attribute"], "name": ["bloom"]}}, {"source": {"identifier": "ethereum.london.fork_types.Header.difficulty", "specifier": 0, "path": "src/ethereum/london/fork_types.py"}, "content": {"type": ["attribute"], "name": ["difficulty"]}}, {"source": {"identifier": "ethereum.london.fork_types.Header.number", "specifier": 0, "path": "src/ethereum/london/fork_types.py"}, "content": {"type": ["attribute"], "name": ["number"]}}, {"source": {"identifier": "ethereum.london.fork_types.Header.gas_limit", "specifier": 0, "path": "src/ethereum/london/fork_types.py"}, "content": {"type": ["attribute"], "name": ["gas_limit"]}}, {"source": {"identifier": "ethereum.london.fork_types.Header.gas_used", "specifier": 0, "path": "src/ethereum/london/fork_types.py"}, "content": {"type": ["attribute"], "name": ["gas_used"]}}, {"source": {"identifier": "ethereum.london.fork_types.Header.timestamp", "specifier": 0, "path": "src/ethereum/london/fork_types.py"}, "content": {"type": ["attribute"], "name": ["timestamp"]}}, {"source": {"identifier": "ethereum.london.fork_types.Header.extra_data", "specifier": 0, "path": "src/ethereum/london/fork_types.py"}, "content": {"type": ["attribute"], "name": ["extra_data"]}}, {"source": {"identifier": "ethereum.london.fork_types.Header.mix_digest", "specifier": 0, "path": "src/ethereum/london/fork_types.py"}, "content": {"type": ["attribute"], "name": ["mix_digest"]}}, {"source": {"identifier": "ethereum.london.fork_types.Header.nonce", "specifier": 0, "path": "src/ethereum/london/fork_types.py"}, "content": {"type": ["attribute"], "name": ["nonce"]}}, {"source": {"identifier": "ethereum.london.fork_types.Header.base_fee_per_gas", "specifier": 0, "path": "src/ethereum/london/fork_types.py"}, "content": {"type": ["attribute"], "name": ["base_fee_per_gas"]}}, {"source": {"identifier": "ethereum.london.fork_types.Block", "specifier": 0, "path": "src/ethereum/london/fork_types.py"}, "content": {"type": ["class"], "name": ["Block"], "text": ["A complete block."]}}, {"source": {"identifier": "ethereum.london.fork_types.Block.header", "specifier": 0, "path": "src/ethereum/london/fork_types.py"}, "content": {"type": ["attribute"], "name": ["header"]}}, {"source": {"identifier": "ethereum.london.fork_types.Block.transactions", "specifier": 0, "path": "src/ethereum/london/fork_types.py"}, "content": {"type": ["attribute"], "name": ["transactions"]}}, {"source": {"identifier": "ethereum.london.fork_types.Block.ommers", "specifier": 0, "path": "src/ethereum/london/fork_types.py"}, "content": {"type": ["attribute"], "name": ["ommers"]}}, {"source": {"identifier": "ethereum.london.fork_types.Log", "specifier": 0, "path": "src/ethereum/london/fork_types.py"}, "content": {"type": ["class"], "name": ["Log"], "text": ["Data record produced during the execution of a transaction."]}}, {"source": {"identifier": "ethereum.london.fork_types.Log.address", "specifier": 0, "path": "src/ethereum/london/fork_types.py"}, "content": {"type": ["attribute"], "name": ["address"]}}, {"source": {"identifier": "ethereum.london.fork_types.Log.topics", "specifier": 0, "path": "src/ethereum/london/fork_types.py"}, "content": {"type": ["attribute"], "name": ["topics"]}}, {"source": {"identifier": "ethereum.london.fork_types.Log.data", "specifier": 0, "path": "src/ethereum/london/fork_types.py"}, "content": {"type": ["attribute"], "name": ["data"]}}, {"source": {"identifier": "ethereum.london.fork_types.Receipt", "specifier": 0, "path": "src/ethereum/london/fork_types.py"}, "content": {"type": ["class"], "name": ["Receipt"], "text": ["Result of a transaction."]}}, {"source": {"identifier": "ethereum.london.fork_types.Receipt.succeeded", "specifier": 0, "path": "src/ethereum/london/fork_types.py"}, "content": {"type": ["attribute"], "name": ["succeeded"]}}, {"source": {"identifier": "ethereum.london.fork_types.Receipt.cumulative_gas_used", "specifier": 0, "path": "src/ethereum/london/fork_types.py"}, "content": {"type": ["attribute"], "name": ["cumulative_gas_used"]}}, {"source": {"identifier": "ethereum.london.fork_types.Receipt.bloom", "specifier": 0, "path": "src/ethereum/london/fork_types.py"}, "content": {"type": ["attribute"], "name": ["bloom"]}}, {"source": {"identifier": "ethereum.london.fork_types.Receipt.logs", "specifier": 0, "path": "src/ethereum/london/fork_types.py"}, "content": {"type": ["attribute"], "name": ["logs"]}}, {"source": {"identifier": "ethereum.london.trie", "specifier": 0, "path": "src/ethereum/london/trie.py"}, "content": {"type": ["module"], "name": ["ethereum.london.trie"], "text": ["State Trie ^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction The state trie is the structure responsible for storing .fork_types.Account  objects."]}}, {"source": {"identifier": "ethereum.london.trie.EMPTY_TRIE_ROOT", "specifier": 0, "path": "src/ethereum/london/trie.py"}, "content": {"type": ["attribute"], "name": ["EMPTY_TRIE_ROOT"]}}, {"source": {"identifier": "ethereum.london.trie.Node", "specifier": 0, "path": "src/ethereum/london/trie.py"}, "content": {"type": ["attribute"], "name": ["Node"]}}, {"source": {"identifier": "ethereum.london.trie.K", "specifier": 0, "path": "src/ethereum/london/trie.py"}, "content": {"type": ["attribute"], "name": ["K"]}}, {"source": {"identifier": "ethereum.london.trie.V", "specifier": 0, "path": "src/ethereum/london/trie.py"}, "content": {"type": ["attribute"], "name": ["V"]}}, {"source": {"identifier": "ethereum.london.trie.LeafNode", "specifier": 0, "path": "src/ethereum/london/trie.py"}, "content": {"type": ["class"], "name": ["LeafNode"], "text": ["Leaf node in the Merkle Trie"]}}, {"source": {"identifier": "ethereum.london.trie.LeafNode.rest_of_key", "specifier": 0, "path": "src/ethereum/london/trie.py"}, "content": {"type": ["attribute"], "name": ["rest_of_key"]}}, {"source": {"identifier": "ethereum.london.trie.LeafNode.value", "specifier": 0, "path": "src/ethereum/london/trie.py"}, "content": {"type": ["attribute"], "name": ["value"]}}, {"source": {"identifier": "ethereum.london.trie.ExtensionNode", "specifier": 0, "path": "src/ethereum/london/trie.py"}, "content": {"type": ["class"], "name": ["ExtensionNode"], "text": ["Extension node in the Merkle Trie"]}}, {"source": {"identifier": "ethereum.london.trie.ExtensionNode.key_segment", "specifier": 0, "path": "src/ethereum/london/trie.py"}, "content": {"type": ["attribute"], "name": ["key_segment"]}}, {"source": {"identifier": "ethereum.london.trie.ExtensionNode.subnode", "specifier": 0, "path": "src/ethereum/london/trie.py"}, "content": {"type": ["attribute"], "name": ["subnode"]}}, {"source": {"identifier": "ethereum.london.trie.BranchNode", "specifier": 0, "path": "src/ethereum/london/trie.py"}, "content": {"type": ["class"], "name": ["BranchNode"], "text": ["Branch node in the Merkle Trie"]}}, {"source": {"identifier": "ethereum.london.trie.BranchNode.subnodes", "specifier": 0, "path": "src/ethereum/london/trie.py"}, "content": {"type": ["attribute"], "name": ["subnodes"]}}, {"source": {"identifier": "ethereum.london.trie.BranchNode.value", "specifier": 0, "path": "src/ethereum/london/trie.py"}, "content": {"type": ["attribute"], "name": ["value"]}}, {"source": {"identifier": "ethereum.london.trie.InternalNode", "specifier": 0, "path": "src/ethereum/london/trie.py"}, "content": {"type": ["attribute"], "name": ["InternalNode"]}}, {"source": {"identifier": "ethereum.london.trie.encode_internal_node", "specifier": 0, "path": "src/ethereum/london/trie.py"}, "content": {"type": ["function"], "name": ["encode_internal_node"], "text": ["Encodes a Merkle Trie node into its RLP form. The RLP will then be serialized into a  Bytes  and hashed unless it is less that 32 bytes when serialized. This function also accepts  None , representing the absence of a node, which is encoded to  b\"\" . Parameters node : Optional[InternalNode] The node to encode. Returns encoded :  rlp.RLP The node encoded as RLP."]}}, {"source": {"identifier": "ethereum.london.trie.encode_node", "specifier": 0, "path": "src/ethereum/london/trie.py"}, "content": {"type": ["function"], "name": ["encode_node"], "text": ["Encode a Node for storage in the Merkle Trie. Currently mostly an unimplemented stub."]}}, {"source": {"identifier": "ethereum.london.trie.Trie", "specifier": 0, "path": "src/ethereum/london/trie.py"}, "content": {"type": ["class"], "name": ["Trie"], "text": ["The Merkle Trie."]}}, {"source": {"identifier": "ethereum.london.trie.Trie.secured", "specifier": 0, "path": "src/ethereum/london/trie.py"}, "content": {"type": ["attribute"], "name": ["secured"]}}, {"source": {"identifier": "ethereum.london.trie.Trie.default", "specifier": 0, "path": "src/ethereum/london/trie.py"}, "content": {"type": ["attribute"], "name": ["default"]}}, {"source": {"identifier": "ethereum.london.trie.Trie._data", "specifier": 0, "path": "src/ethereum/london/trie.py"}, "content": {"type": ["attribute"], "name": ["_data"]}}, {"source": {"identifier": "ethereum.london.trie.copy_trie", "specifier": 0, "path": "src/ethereum/london/trie.py"}, "content": {"type": ["function"], "name": ["copy_trie"], "text": ["Create a copy of  trie . Since only frozen objects may be stored in tries, the contents are reused. Parameters trie:  Trie Trie to copy. Returns new_trie :  Trie[K, V] A copy of the trie."]}}, {"source": {"identifier": "ethereum.london.trie.trie_set", "specifier": 0, "path": "src/ethereum/london/trie.py"}, "content": {"type": ["function"], "name": ["trie_set"], "text": ["Stores an item in a Merkle Trie. This method deletes the key if  value == trie.default , because the Merkle Trie represents the default value by omitting it from the trie. Parameters trie:  Trie Trie to store in. key :  Bytes Key to lookup. value :  V Node to insert at  key ."]}}, {"source": {"identifier": "ethereum.london.trie.trie_get", "specifier": 0, "path": "src/ethereum/london/trie.py"}, "content": {"type": ["function"], "name": ["trie_get"], "text": ["Gets an item from the Merkle Trie. This method returns  trie.default  if the key is missing. Parameters trie: Trie to lookup in. key : Key to lookup. Returns node :  V Node at  key  in the trie."]}}, {"source": {"identifier": "ethereum.london.trie.common_prefix_length", "specifier": 0, "path": "src/ethereum/london/trie.py"}, "content": {"type": ["function"], "name": ["common_prefix_length"], "text": ["Find the longest common prefix of two sequences."]}}, {"source": {"identifier": "ethereum.london.trie.nibble_list_to_compact", "specifier": 0, "path": "src/ethereum/london/trie.py"}, "content": {"type": ["function"], "name": ["nibble_list_to_compact"], "text": ["Compresses nibble-list into a standard byte array with a flag. A nibble-list is a list of byte values no greater than  15 . The flag is encoded in high nibble of the highest byte. The flag nibble can be broken down into two two-bit flags. Highest nibble:: +---+---+----------+--------+\n| _ | _ | is_leaf | parity |\n+---+---+----------+--------+\n  3   2      1         0\n The lowest bit of the nibble encodes the parity of the length of the remaining nibbles --  0  when even and  1  when odd. The second lowest bit is used to distinguish leaf and extension nodes. The other two bits are not used. Parameters x : Array of nibbles. is_leaf : True if this is part of a leaf node, or false if it is an extension node. Returns compressed :  bytearray Compact byte array."]}}, {"source": {"identifier": "ethereum.london.trie.bytes_to_nibble_list", "specifier": 0, "path": "src/ethereum/london/trie.py"}, "content": {"type": ["function"], "name": ["bytes_to_nibble_list"], "text": ["Converts a  Bytes  into to a sequence of nibbles (bytes with value < 16). Parameters bytes_: The  Bytes  to convert. Returns nibble_list :  Bytes The  Bytes  in nibble-list format."]}}, {"source": {"identifier": "ethereum.london.trie._prepare_trie", "specifier": 0, "path": "src/ethereum/london/trie.py"}, "content": {"type": ["function"], "name": ["_prepare_trie"], "text": ["Prepares the trie for root calculation. Removes values that are empty, hashes the keys (if  secured == True ) and encodes all the nodes. Parameters trie : The  Trie  to prepare. get_storage_root : Function to get the storage root of an account. Needed to encode Account  objects. Returns out :  Mapping[ethereum.base_types.Bytes, Node] Object with keys mapped to nibble-byte form."]}}, {"source": {"identifier": "ethereum.london.trie.root", "specifier": 0, "path": "src/ethereum/london/trie.py"}, "content": {"type": ["function"], "name": ["root"], "text": ["Computes the root of a modified merkle patricia trie (MPT). Parameters trie : Trie  to get the root of. get_storage_root : Function to get the storage root of an account. Needed to encode Account  objects. Returns root :  .fork_types.Root MPT root of the underlying key-value pairs."]}}, {"source": {"identifier": "ethereum.london.trie.patricialize", "specifier": 0, "path": "src/ethereum/london/trie.py"}, "content": {"type": ["function"], "name": ["patricialize"], "text": ["Structural composition function. Used to recursively patricialize and merkleize a dictionary. Includes memoization of the tree structure and hashes. Parameters obj : Underlying trie key-value pairs, with keys in nibble-list format. level : Current trie level. Returns node :  ethereum.base_types.Bytes Root node of  obj ."]}}, {"source": {"identifier": "ethereum.london.fork", "specifier": 0, "path": "src/ethereum/london/fork.py"}, "content": {"type": ["module"], "name": ["ethereum.london.fork"], "text": ["Ethereum Specification ^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Entry point for the Ethereum specification."]}}, {"source": {"identifier": "ethereum.london.fork.BLOCK_REWARD", "specifier": 0, "path": "src/ethereum/london/fork.py"}, "content": {"type": ["attribute"], "name": ["BLOCK_REWARD"]}}, {"source": {"identifier": "ethereum.london.fork.BASE_FEE_MAX_CHANGE_DENOMINATOR", "specifier": 0, "path": "src/ethereum/london/fork.py"}, "content": {"type": ["attribute"], "name": ["BASE_FEE_MAX_CHANGE_DENOMINATOR"]}}, {"source": {"identifier": "ethereum.london.fork.ELASTICITY_MULTIPLIER", "specifier": 0, "path": "src/ethereum/london/fork.py"}, "content": {"type": ["attribute"], "name": ["ELASTICITY_MULTIPLIER"]}}, {"source": {"identifier": "ethereum.london.fork.GAS_LIMIT_ADJUSTMENT_FACTOR", "specifier": 0, "path": "src/ethereum/london/fork.py"}, "content": {"type": ["attribute"], "name": ["GAS_LIMIT_ADJUSTMENT_FACTOR"]}}, {"source": {"identifier": "ethereum.london.fork.GAS_LIMIT_MINIMUM", "specifier": 0, "path": "src/ethereum/london/fork.py"}, "content": {"type": ["attribute"], "name": ["GAS_LIMIT_MINIMUM"]}}, {"source": {"identifier": "ethereum.london.fork.MINIMUM_DIFFICULTY", "specifier": 0, "path": "src/ethereum/london/fork.py"}, "content": {"type": ["attribute"], "name": ["MINIMUM_DIFFICULTY"]}}, {"source": {"identifier": "ethereum.london.fork.INITIAL_BASE_FEE", "specifier": 0, "path": "src/ethereum/london/fork.py"}, "content": {"type": ["attribute"], "name": ["INITIAL_BASE_FEE"]}}, {"source": {"identifier": "ethereum.london.fork.MAX_OMMER_DEPTH", "specifier": 0, "path": "src/ethereum/london/fork.py"}, "content": {"type": ["attribute"], "name": ["MAX_OMMER_DEPTH"]}}, {"source": {"identifier": "ethereum.london.fork.BOMB_DELAY_BLOCKS", "specifier": 0, "path": "src/ethereum/london/fork.py"}, "content": {"type": ["attribute"], "name": ["BOMB_DELAY_BLOCKS"]}}, {"source": {"identifier": "ethereum.london.fork.EMPTY_OMMER_HASH", "specifier": 0, "path": "src/ethereum/london/fork.py"}, "content": {"type": ["attribute"], "name": ["EMPTY_OMMER_HASH"]}}, {"source": {"identifier": "ethereum.london.fork.BlockChain", "specifier": 0, "path": "src/ethereum/london/fork.py"}, "content": {"type": ["class"], "name": ["BlockChain"], "text": ["History and current state of the block chain."]}}, {"source": {"identifier": "ethereum.london.fork.BlockChain.blocks", "specifier": 0, "path": "src/ethereum/london/fork.py"}, "content": {"type": ["attribute"], "name": ["blocks"]}}, {"source": {"identifier": "ethereum.london.fork.BlockChain.state", "specifier": 0, "path": "src/ethereum/london/fork.py"}, "content": {"type": ["attribute"], "name": ["state"]}}, {"source": {"identifier": "ethereum.london.fork.BlockChain.chain_id", "specifier": 0, "path": "src/ethereum/london/fork.py"}, "content": {"type": ["attribute"], "name": ["chain_id"]}}, {"source": {"identifier": "ethereum.london.fork.apply_fork", "specifier": 0, "path": "src/ethereum/london/fork.py"}, "content": {"type": ["function"], "name": ["apply_fork"], "text": ["Transforms the state from the previous hard fork ( old ) into the block chain object for this hard fork and returns it. When forks need to implement an irregular state transition, this function is used to handle the irregularity. See the :ref: DAO Fork <dao-fork>  for an example. Parameters old : Previous block chain object. Returns new :  BlockChain Upgraded block chain object for this hard fork."]}}, {"source": {"identifier": "ethereum.london.fork.get_last_256_block_hashes", "specifier": 0, "path": "src/ethereum/london/fork.py"}, "content": {"type": ["function"], "name": ["get_last_256_block_hashes"], "text": ["Obtain the list of hashes of the previous 256 blocks in order of increasing block number. This function will return less hashes for the first 256 blocks. The  BLOCKHASH  opcode needs to access the latest hashes on the chain, therefore this function retrieves them. Parameters chain : History and current state. Returns recent_block_hashes :  List[Hash32] Hashes of the recent 256 blocks in order of increasing block number."]}}, {"source": {"identifier": "ethereum.london.fork.state_transition", "specifier": 0, "path": "src/ethereum/london/fork.py"}, "content": {"type": ["function"], "name": ["state_transition"], "text": ["Attempts to apply a block to an existing block chain. All parts of the block's contents need to be verified before being added to the chain. Blocks are verified by ensuring that the contents of the block make logical sense with the contents of the parent block. The information in the block's header must also match the corresponding information in the block. To implement Ethereum, in theory clients are only required to store the most recent 255 blocks of the chain since as far as execution is concerned, only those blocks are accessed. Practically, however, clients should store more blocks to handle reorgs. Parameters chain : History and current state. block : Block to apply to  chain ."]}}, {"source": {"identifier": "ethereum.london.fork.calculate_base_fee_per_gas", "specifier": 0, "path": "src/ethereum/london/fork.py"}, "content": {"type": ["function"], "name": ["calculate_base_fee_per_gas"], "text": ["Calculates the base fee per gas for the block. Parameters block_gas_limit : Gas limit of the block for which the base fee is being calculated. parent_gas_limit : Gas limit of the parent block. parent_gas_used : Gas used in the parent block. parent_base_fee_per_gas : Base fee per gas of the parent block. is_fork_block : Whether the block is the fork block. Returns base_fee_per_gas :  Uint Base fee per gas for the block."]}}, {"source": {"identifier": "ethereum.london.fork.validate_header", "specifier": 0, "path": "src/ethereum/london/fork.py"}, "content": {"type": ["function"], "name": ["validate_header"], "text": ["Verifies a block header. In order to consider a block's header valid, the logic for the quantities in the header should match the logic for the block itself. For example the header timestamp should be greater than the block's parent timestamp because the block was created  after  the parent block. Additionally, the block's number should be directly folowing the parent block's number since it is the next block in the sequence. Parameters header : Header to check for correctness. parent_header : Parent Header of the header to check for correctness"]}}, {"source": {"identifier": "ethereum.london.fork.generate_header_hash_for_pow", "specifier": 0, "path": "src/ethereum/london/fork.py"}, "content": {"type": ["function"], "name": ["generate_header_hash_for_pow"], "text": ["Generate rlp hash of the header which is to be used for Proof-of-Work verification. In other words, the PoW artefacts  mix_digest  and  nonce  are ignored while calculating this hash. A particular PoW is valid for a single hash, that hash is computed by this function. The  nonce  and  mix_digest  are omitted from this hash because they are being changed by miners in their search for a sufficient proof-of-work. Parameters header : The header object for which the hash is to be generated. Returns hash :  Hash32 The PoW valid rlp hash of the passed in header."]}}, {"source": {"identifier": "ethereum.london.fork.validate_proof_of_work", "specifier": 0, "path": "src/ethereum/london/fork.py"}, "content": {"type": ["function"], "name": ["validate_proof_of_work"], "text": ["Validates the Proof of Work constraints. In order to verify that a miner's proof-of-work is valid for a block, a mix-digest  and  result  are calculated using the  hashimoto_light hash function. The mix digest is a hash of the header and the nonce that is passed through and it confirms whether or not proof-of-work was done on the correct block. The result is the actual hash value of the block. Parameters header : Header of interest."]}}, {"source": {"identifier": "ethereum.london.fork.check_transaction", "specifier": 0, "path": "src/ethereum/london/fork.py"}, "content": {"type": ["function"], "name": ["check_transaction"], "text": ["Check if the transaction is includable in the block. Parameters tx : The transaction. base_fee_per_gas : The block base fee. gas_available : The gas remaining in the block. chain_id : The ID of the current chain. Returns sender_address : The sender of the transaction. effective_gas_price : The price to charge for gas when the transaction is executed. Raises InvalidBlock : If the transaction is not includable."]}}, {"source": {"identifier": "ethereum.london.fork.make_receipt", "specifier": 0, "path": "src/ethereum/london/fork.py"}, "content": {"type": ["function"], "name": ["make_receipt"], "text": ["Make the receipt for a transaction that was executed. Parameters tx : The executed transaction. has_erred : Whether the top level frame of the transaction exited with an error. cumulative_gas_used : The total gas used so far in the block after the transaction was executed. logs : The logs produced by the transaction. Returns receipt : The receipt for the transaction."]}}, {"source": {"identifier": "ethereum.london.fork.apply_body", "specifier": 0, "path": "src/ethereum/london/fork.py"}, "content": {"type": ["function"], "name": ["apply_body"], "text": ["Executes a block. Many of the contents of a block are stored in data structures called tries. There is a transactions trie which is similar to a ledger of the transactions stored in the current block. There is also a receipts trie which stores the results of executing a transaction, like the post state and gas used. This function creates and executes the block that is to be added to the chain. Parameters state : Current account state. block_hashes : List of hashes of the previous 256 blocks in the order of increasing block number. coinbase : Address of account which receives block reward and transaction fees. block_number : Position of the block within the chain. base_fee_per_gas : Base fee per gas of within the block. block_gas_limit : Initial amount of gas available for execution in this block. block_time : Time the block was produced, measured in seconds since the epoch. block_difficulty : Difficulty of the block. transactions : Transactions included in the block. ommers : Headers of ancestor blocks which are not direct parents (formerly uncles.) chain_id : ID of the executing chain. Returns gas_available :  ethereum.base_types.Uint Remaining gas after all transactions have been executed. transactions_root :  ethereum.fork_types.Root Trie root of all the transactions in the block. receipt_root :  ethereum.fork_types.Root Trie root of all the receipts in the block. block_logs_bloom :  Bloom Logs bloom of all the logs included in all the transactions of the block. state :  ethereum.fork_types.State State after all transactions have been executed."]}}, {"source": {"identifier": "ethereum.london.fork.validate_ommers", "specifier": 0, "path": "src/ethereum/london/fork.py"}, "content": {"type": ["function"], "name": ["validate_ommers"], "text": ["Validates the ommers mentioned in the block. An ommer block is a block that wasn't canonically added to the blockchain because it wasn't validated as fast as the canonical block but was mined at the same time. To be considered valid, the ommers must adhere to the rules defined in the Ethereum protocol. The maximum amount of ommers is 2 per block and there cannot be duplicate ommers in a block. Many of the other ommer contraints are listed in the in-line comments of this function. Parameters ommers : List of ommers mentioned in the current block. block_header: The header of current block. chain : History and current state."]}}, {"source": {"identifier": "ethereum.london.fork.pay_rewards", "specifier": 0, "path": "src/ethereum/london/fork.py"}, "content": {"type": ["function"], "name": ["pay_rewards"], "text": ["Pay rewards to the block miner as well as the ommers miners. The miner of the canonical block is rewarded with the predetermined block reward,  BLOCK_REWARD , plus a variable award based off of the number of ommer blocks that were mined around the same time, and included in the canonical block's header. An ommer block is a block that wasn't added to the canonical blockchain because it wasn't validated as fast as the accepted block but was mined at the same time. Although not all blocks that are mined are added to the canonical chain, miners are still paid a reward for their efforts. This reward is called an ommer reward and is calculated based on the number associated with the ommer block that they mined. Parameters state : Current account state. block_number : Position of the block within the chain. coinbase : Address of account which receives block reward and transaction fees. ommers : List of ommers mentioned in the current block."]}}, {"source": {"identifier": "ethereum.london.fork.process_transaction", "specifier": 0, "path": "src/ethereum/london/fork.py"}, "content": {"type": ["function"], "name": ["process_transaction"], "text": ["Execute a transaction against the provided environment. This function processes the actions needed to execute a transaction. It decrements the sender's account after calculating the gas fee and refunds them the proper amount after execution. Calling contracts, deploying code, and incrementing nonces are all examples of actions that happen within this function or from a call made within this function. Accounts that are marked for deletion are processed and destroyed after execution. Parameters env : Environment for the Ethereum Virtual Machine. tx : Transaction to execute. Returns gas_left :  ethereum.base_types.U256 Remaining gas after execution. logs :  Tuple[ethereum.fork_types.Log, ...] Logs generated during execution."]}}, {"source": {"identifier": "ethereum.london.fork.validate_transaction", "specifier": 0, "path": "src/ethereum/london/fork.py"}, "content": {"type": ["function"], "name": ["validate_transaction"], "text": ["Verifies a transaction. The gas in a transaction gets used to pay for the intrinsic cost of operations, therefore if there is insufficient gas then it would not be possible to execute a transaction and it will be declared invalid. Additionally, the nonce of a transaction must not equal or exceed the limit defined in  EIP-2681 <https://eips.ethereum.org/EIPS/eip-2681> _. In practice, defining the limit as  2**64-1  has no impact because sending  2**64-1  transactions is improbable. It's not strictly impossible though,  2**64-1  transactions is the entire capacity of the Ethereum blockchain at 2022 gas limits for a little over 22 years. Parameters tx : Transaction to validate. Returns verified :  bool True if the transaction can be executed, or False otherwise."]}}, {"source": {"identifier": "ethereum.london.fork.calculate_intrinsic_cost", "specifier": 0, "path": "src/ethereum/london/fork.py"}, "content": {"type": ["function"], "name": ["calculate_intrinsic_cost"], "text": ["Calculates the gas that is charged before execution is started. The intrinsic cost of the transaction is charged before execution has begun. Functions/operations in the EVM cost money to execute so this intrinsic cost is for the operations that need to be paid for as part of the transaction. Data transfer, for example, is part of this intrinsic cost. It costs ether to send data over the wire and that ether is accounted for in the intrinsic cost calculated in this function. This intrinsic cost must be calculated and paid for before execution in order for all operations to be implemented. Parameters tx : Transaction to compute the intrinsic cost of. Returns verified :  ethereum.base_types.Uint The intrinsic cost of the transaction."]}}, {"source": {"identifier": "ethereum.london.fork.recover_sender", "specifier": 0, "path": "src/ethereum/london/fork.py"}, "content": {"type": ["function"], "name": ["recover_sender"], "text": ["Extracts the sender address from a transaction. The v, r, and s values are the three parts that make up the signature of a transaction. In order to recover the sender of a transaction the two components needed are the signature ( v ,  r , and  s ) and the signing hash of the transaction. The sender's public key can be obtained with these two values and therefore the sender address can be retrieved. Parameters tx : Transaction of interest. chain_id : ID of the executing chain. Returns sender :  ethereum.fork_types.Address The address of the account that signed the transaction."]}}, {"source": {"identifier": "ethereum.london.fork.signing_hash_pre155", "specifier": 0, "path": "src/ethereum/london/fork.py"}, "content": {"type": ["function"], "name": ["signing_hash_pre155"], "text": ["Compute the hash of a transaction used in a legacy (pre EIP 155) signature. Parameters tx : Transaction of interest. Returns hash :  ethereum.crypto.hash.Hash32 Hash of the transaction."]}}, {"source": {"identifier": "ethereum.london.fork.signing_hash_155", "specifier": 0, "path": "src/ethereum/london/fork.py"}, "content": {"type": ["function"], "name": ["signing_hash_155"], "text": ["Compute the hash of a transaction used in a EIP 155 signature. Parameters tx : Transaction of interest. Returns hash :  ethereum.crypto.hash.Hash32 Hash of the transaction."]}}, {"source": {"identifier": "ethereum.london.fork.signing_hash_2930", "specifier": 0, "path": "src/ethereum/london/fork.py"}, "content": {"type": ["function"], "name": ["signing_hash_2930"], "text": ["Compute the hash of a transaction used in a EIP 2930 signature. Parameters tx : Transaction of interest. Returns hash :  ethereum.crypto.hash.Hash32 Hash of the transaction."]}}, {"source": {"identifier": "ethereum.london.fork.signing_hash_1559", "specifier": 0, "path": "src/ethereum/london/fork.py"}, "content": {"type": ["function"], "name": ["signing_hash_1559"], "text": ["Compute the hash of a transaction used in a EIP 1559 signature. Parameters tx : Transaction of interest. Returns hash :  ethereum.crypto.hash.Hash32 Hash of the transaction."]}}, {"source": {"identifier": "ethereum.london.fork.compute_header_hash", "specifier": 0, "path": "src/ethereum/london/fork.py"}, "content": {"type": ["function"], "name": ["compute_header_hash"], "text": ["Computes the hash of a block header. The header hash of a block is the canonical hash that is used to refer to a specific block and completely distinguishes a block from another. keccak256  is a function that produces a 256 bit hash of any input. It also takes in any number of bytes as an input and produces a single hash for them. A hash is a completely unique output for a single input. So an input corresponds to one unique hash that can be used to identify the input exactly. Prior to using the  keccak256  hash function, the header must be encoded using the Recursive-Length Prefix. See :ref: rlp . RLP encoding the header converts it into a space-efficient format that allows for easy transfer of data between nodes. The purpose of RLP is to encode arbitrarily nested arrays of binary data, and RLP is the primary encoding method used to serialize objects in Ethereum's execution layer. The only purpose of RLP is to encode structure; encoding specific data types (e.g. strings, floats) is left up to higher-order protocols. Parameters header : Header of interest. Returns hash :  ethereum.crypto.hash.Hash32 Hash of the header."]}}, {"source": {"identifier": "ethereum.london.fork.check_gas_limit", "specifier": 0, "path": "src/ethereum/london/fork.py"}, "content": {"type": ["function"], "name": ["check_gas_limit"], "text": ["Validates the gas limit for a block. The bounds of the gas limit,  max_adjustment_delta , is set as the quotient of the parent block's gas limit and the GAS_LIMIT_ADJUSTMENT_FACTOR . Therefore, if the gas limit that is passed through as a parameter is greater than or equal to the  sum  of the parent's gas and the adjustment delta then the limit for gas is too high and fails this function's check. Similarly, if the limit is less than or equal to the  difference  of the parent's gas and the adjustment delta  or  the predefined  GAS_LIMIT_MINIMUM  then this function's check fails because the gas limit doesn't allow for a sufficient or reasonable amount of gas to be used on a block. Parameters gas_limit : Gas limit to validate. parent_gas_limit : Gas limit of the parent block. Returns check :  bool True if gas limit constraints are satisfied, False otherwise."]}}, {"source": {"identifier": "ethereum.london.fork.calculate_block_difficulty", "specifier": 0, "path": "src/ethereum/london/fork.py"}, "content": {"type": ["function"], "name": ["calculate_block_difficulty"], "text": ["Computes difficulty of a block using its header and parent header. The difficulty is determined by the time the block was created after its parent. The  offset  is calculated using the parent block's difficulty, parent_difficulty , and the timestamp between blocks. This offset is then added to the parent difficulty and is stored as the  difficulty variable. If the time between the block and its parent is too short, the offset will result in a positive number thus making the sum of parent_difficulty  and  offset  to be a greater value in order to avoid mass forking. But, if the time is long enough, then the offset results in a negative value making the block less difficult than its parent. The base standard for a block's difficulty is the predefined value set for the genesis block since it has no parent. So, a block can't be less difficult than the genesis block, therefore each block's difficulty is set to the maximum value between the calculated difficulty and the  GENESIS_DIFFICULTY . Parameters block_number : Block number of the block. block_timestamp : Timestamp of the block. parent_timestamp : Timestamp of the parent block. parent_difficulty : difficulty of the parent block. parent_has_ommers: does the parent have ommers. Returns difficulty :  ethereum.base_types.Uint Computed difficulty for a block."]}}, {"source": {"identifier": "ethereum.london.vm.memory", "specifier": 0, "path": "src/ethereum/london/vm/memory.py"}, "content": {"type": ["module"], "name": ["ethereum.london.vm.memory"], "text": ["Ethereum Virtual Machine (EVM) Memory ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction EVM memory operations."]}}, {"source": {"identifier": "ethereum.london.vm.memory.memory_write", "specifier": 0, "path": "src/ethereum/london/vm/memory.py"}, "content": {"type": ["function"], "name": ["memory_write"], "text": ["Writes to memory. Parameters memory : Memory contents of the EVM. start_position : Starting pointer to the memory. value : Data to write to memory."]}}, {"source": {"identifier": "ethereum.london.vm.memory.memory_read_bytes", "specifier": 0, "path": "src/ethereum/london/vm/memory.py"}, "content": {"type": ["function"], "name": ["memory_read_bytes"], "text": ["Read bytes from memory. Parameters memory : Memory contents of the EVM. start_position : Starting pointer to the memory. size : Size of the data that needs to be read from  start_position . Returns data_bytes : Data read from memory."]}}, {"source": {"identifier": "ethereum.london.vm.memory.buffer_read", "specifier": 0, "path": "src/ethereum/london/vm/memory.py"}, "content": {"type": ["function"], "name": ["buffer_read"], "text": ["Read bytes from a buffer. Padding with zeros if neccesary. Parameters buffer : Memory contents of the EVM. start_position : Starting pointer to the memory. size : Size of the data that needs to be read from  start_position . Returns data_bytes : Data read from memory."]}}, {"source": {"identifier": "ethereum.london.vm.exceptions", "specifier": 0, "path": "src/ethereum/london/vm/exceptions.py"}, "content": {"type": ["module"], "name": ["ethereum.london.vm.exceptions"], "text": ["Ethereum Virtual Machine (EVM) Exceptions ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Exceptions which cause the EVM to halt exceptionally."]}}, {"source": {"identifier": "ethereum.london.vm.exceptions.ExceptionalHalt", "specifier": 0, "path": "src/ethereum/london/vm/exceptions.py"}, "content": {"type": ["class"], "name": ["ExceptionalHalt"], "text": ["Indicates that the EVM has experienced an exceptional halt. This causes execution to immediately end with all gas being consumed."]}}, {"source": {"identifier": "ethereum.london.vm.exceptions.Revert", "specifier": 0, "path": "src/ethereum/london/vm/exceptions.py"}, "content": {"type": ["class"], "name": ["Revert"], "text": ["Raised by the  REVERT  opcode. Unlike other EVM exceptions this does not result in the consumption of all gas."]}}, {"source": {"identifier": "ethereum.london.vm.exceptions.StackUnderflowError", "specifier": 0, "path": "src/ethereum/london/vm/exceptions.py"}, "content": {"type": ["class"], "name": ["StackUnderflowError"], "text": ["Occurs when a pop is executed on an empty stack."]}}, {"source": {"identifier": "ethereum.london.vm.exceptions.StackOverflowError", "specifier": 0, "path": "src/ethereum/london/vm/exceptions.py"}, "content": {"type": ["class"], "name": ["StackOverflowError"], "text": ["Occurs when a push is executed on a stack at max capacity."]}}, {"source": {"identifier": "ethereum.london.vm.exceptions.OutOfGasError", "specifier": 0, "path": "src/ethereum/london/vm/exceptions.py"}, "content": {"type": ["class"], "name": ["OutOfGasError"], "text": ["Occurs when an operation costs more than the amount of gas left in the frame."]}}, {"source": {"identifier": "ethereum.london.vm.exceptions.InvalidOpcode", "specifier": 0, "path": "src/ethereum/london/vm/exceptions.py"}, "content": {"type": ["class"], "name": ["InvalidOpcode"], "text": ["Raised when an invalid opcode is encountered."]}}, {"source": {"identifier": "ethereum.london.vm.exceptions.InvalidJumpDestError", "specifier": 0, "path": "src/ethereum/london/vm/exceptions.py"}, "content": {"type": ["class"], "name": ["InvalidJumpDestError"], "text": ["Occurs when the destination of a jump operation doesn't meet any of the following criteria: The jump destination is less than the length of the code. The jump destination should have the  JUMPDEST  opcode (0x5B). The jump destination shouldn't be part of the data corresponding to PUSH-N  opcodes."]}}, {"source": {"identifier": "ethereum.london.vm.exceptions.StackDepthLimitError", "specifier": 0, "path": "src/ethereum/london/vm/exceptions.py"}, "content": {"type": ["class"], "name": ["StackDepthLimitError"], "text": ["Raised when the message depth is greater than  1024"]}}, {"source": {"identifier": "ethereum.london.vm.exceptions.WriteInStaticContext", "specifier": 0, "path": "src/ethereum/london/vm/exceptions.py"}, "content": {"type": ["class"], "name": ["WriteInStaticContext"], "text": ["Raised when an attempt is made to modify the state while operating inside of a STATICCALL context."]}}, {"source": {"identifier": "ethereum.london.vm.exceptions.OutOfBoundsRead", "specifier": 0, "path": "src/ethereum/london/vm/exceptions.py"}, "content": {"type": ["class"], "name": ["OutOfBoundsRead"], "text": ["Raised when an attempt was made to read data beyond the boundaries of the buffer."]}}, {"source": {"identifier": "ethereum.london.vm.exceptions.InvalidParameter", "specifier": 0, "path": "src/ethereum/london/vm/exceptions.py"}, "content": {"type": ["class"], "name": ["InvalidParameter"], "text": ["Raised when invalid parameters are passed."]}}, {"source": {"identifier": "ethereum.london.vm.exceptions.InvalidContractPrefix", "specifier": 0, "path": "src/ethereum/london/vm/exceptions.py"}, "content": {"type": ["class"], "name": ["InvalidContractPrefix"], "text": ["Raised when the new contract code starts with 0xEF."]}}, {"source": {"identifier": "ethereum.london.vm", "specifier": 0, "path": "src/ethereum/london/vm/__init__.py"}, "content": {"type": ["module"], "name": ["ethereum.london.vm"], "text": ["Ethereum Virtual Machine (EVM) ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction The abstract computer which runs the code stored in an .fork_types.Account ."]}}, {"source": {"identifier": "ethereum.london.vm.__all__", "specifier": 0, "path": "src/ethereum/london/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["__all__"]}}, {"source": {"identifier": "ethereum.london.vm.Environment", "specifier": 0, "path": "src/ethereum/london/vm/__init__.py"}, "content": {"type": ["class"], "name": ["Environment"], "text": ["Items external to the virtual machine itself, provided by the environment."]}}, {"source": {"identifier": "ethereum.london.vm.Environment.caller", "specifier": 0, "path": "src/ethereum/london/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["caller"]}}, {"source": {"identifier": "ethereum.london.vm.Environment.block_hashes", "specifier": 0, "path": "src/ethereum/london/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["block_hashes"]}}, {"source": {"identifier": "ethereum.london.vm.Environment.origin", "specifier": 0, "path": "src/ethereum/london/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["origin"]}}, {"source": {"identifier": "ethereum.london.vm.Environment.coinbase", "specifier": 0, "path": "src/ethereum/london/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["coinbase"]}}, {"source": {"identifier": "ethereum.london.vm.Environment.number", "specifier": 0, "path": "src/ethereum/london/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["number"]}}, {"source": {"identifier": "ethereum.london.vm.Environment.base_fee_per_gas", "specifier": 0, "path": "src/ethereum/london/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["base_fee_per_gas"]}}, {"source": {"identifier": "ethereum.london.vm.Environment.gas_limit", "specifier": 0, "path": "src/ethereum/london/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["gas_limit"]}}, {"source": {"identifier": "ethereum.london.vm.Environment.gas_price", "specifier": 0, "path": "src/ethereum/london/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["gas_price"]}}, {"source": {"identifier": "ethereum.london.vm.Environment.time", "specifier": 0, "path": "src/ethereum/london/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["time"]}}, {"source": {"identifier": "ethereum.london.vm.Environment.difficulty", "specifier": 0, "path": "src/ethereum/london/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["difficulty"]}}, {"source": {"identifier": "ethereum.london.vm.Environment.state", "specifier": 0, "path": "src/ethereum/london/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["state"]}}, {"source": {"identifier": "ethereum.london.vm.Environment.chain_id", "specifier": 0, "path": "src/ethereum/london/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["chain_id"]}}, {"source": {"identifier": "ethereum.london.vm.Message", "specifier": 0, "path": "src/ethereum/london/vm/__init__.py"}, "content": {"type": ["class"], "name": ["Message"], "text": ["Items that are used by contract creation or message call."]}}, {"source": {"identifier": "ethereum.london.vm.Message.caller", "specifier": 0, "path": "src/ethereum/london/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["caller"]}}, {"source": {"identifier": "ethereum.london.vm.Message.target", "specifier": 0, "path": "src/ethereum/london/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["target"]}}, {"source": {"identifier": "ethereum.london.vm.Message.current_target", "specifier": 0, "path": "src/ethereum/london/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["current_target"]}}, {"source": {"identifier": "ethereum.london.vm.Message.gas", "specifier": 0, "path": "src/ethereum/london/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["gas"]}}, {"source": {"identifier": "ethereum.london.vm.Message.value", "specifier": 0, "path": "src/ethereum/london/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["value"]}}, {"source": {"identifier": "ethereum.london.vm.Message.data", "specifier": 0, "path": "src/ethereum/london/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["data"]}}, {"source": {"identifier": "ethereum.london.vm.Message.code_address", "specifier": 0, "path": "src/ethereum/london/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["code_address"]}}, {"source": {"identifier": "ethereum.london.vm.Message.code", "specifier": 0, "path": "src/ethereum/london/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["code"]}}, {"source": {"identifier": "ethereum.london.vm.Message.depth", "specifier": 0, "path": "src/ethereum/london/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["depth"]}}, {"source": {"identifier": "ethereum.london.vm.Message.should_transfer_value", "specifier": 0, "path": "src/ethereum/london/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["should_transfer_value"]}}, {"source": {"identifier": "ethereum.london.vm.Message.is_static", "specifier": 0, "path": "src/ethereum/london/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["is_static"]}}, {"source": {"identifier": "ethereum.london.vm.Message.accessed_addresses", "specifier": 0, "path": "src/ethereum/london/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["accessed_addresses"]}}, {"source": {"identifier": "ethereum.london.vm.Message.accessed_storage_keys", "specifier": 0, "path": "src/ethereum/london/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["accessed_storage_keys"]}}, {"source": {"identifier": "ethereum.london.vm.Evm", "specifier": 0, "path": "src/ethereum/london/vm/__init__.py"}, "content": {"type": ["class"], "name": ["Evm"], "text": ["The internal state of the virtual machine."]}}, {"source": {"identifier": "ethereum.london.vm.Evm.pc", "specifier": 0, "path": "src/ethereum/london/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["pc"]}}, {"source": {"identifier": "ethereum.london.vm.Evm.stack", "specifier": 0, "path": "src/ethereum/london/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["stack"]}}, {"source": {"identifier": "ethereum.london.vm.Evm.memory", "specifier": 0, "path": "src/ethereum/london/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["memory"]}}, {"source": {"identifier": "ethereum.london.vm.Evm.code", "specifier": 0, "path": "src/ethereum/london/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["code"]}}, {"source": {"identifier": "ethereum.london.vm.Evm.gas_left", "specifier": 0, "path": "src/ethereum/london/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["gas_left"]}}, {"source": {"identifier": "ethereum.london.vm.Evm.env", "specifier": 0, "path": "src/ethereum/london/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["env"]}}, {"source": {"identifier": "ethereum.london.vm.Evm.valid_jump_destinations", "specifier": 0, "path": "src/ethereum/london/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["valid_jump_destinations"]}}, {"source": {"identifier": "ethereum.london.vm.Evm.logs", "specifier": 0, "path": "src/ethereum/london/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["logs"]}}, {"source": {"identifier": "ethereum.london.vm.Evm.refund_counter", "specifier": 0, "path": "src/ethereum/london/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["refund_counter"]}}, {"source": {"identifier": "ethereum.london.vm.Evm.running", "specifier": 0, "path": "src/ethereum/london/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["running"]}}, {"source": {"identifier": "ethereum.london.vm.Evm.message", "specifier": 0, "path": "src/ethereum/london/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["message"]}}, {"source": {"identifier": "ethereum.london.vm.Evm.output", "specifier": 0, "path": "src/ethereum/london/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["output"]}}, {"source": {"identifier": "ethereum.london.vm.Evm.accounts_to_delete", "specifier": 0, "path": "src/ethereum/london/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["accounts_to_delete"]}}, {"source": {"identifier": "ethereum.london.vm.Evm.touched_accounts", "specifier": 0, "path": "src/ethereum/london/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["touched_accounts"]}}, {"source": {"identifier": "ethereum.london.vm.Evm.has_erred", "specifier": 0, "path": "src/ethereum/london/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["has_erred"]}}, {"source": {"identifier": "ethereum.london.vm.Evm.return_data", "specifier": 0, "path": "src/ethereum/london/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["return_data"]}}, {"source": {"identifier": "ethereum.london.vm.Evm.error", "specifier": 0, "path": "src/ethereum/london/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["error"]}}, {"source": {"identifier": "ethereum.london.vm.Evm.accessed_addresses", "specifier": 0, "path": "src/ethereum/london/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["accessed_addresses"]}}, {"source": {"identifier": "ethereum.london.vm.Evm.accessed_storage_keys", "specifier": 0, "path": "src/ethereum/london/vm/__init__.py"}, "content": {"type": ["attribute"], "name": ["accessed_storage_keys"]}}, {"source": {"identifier": "ethereum.london.vm.incorporate_child_on_success", "specifier": 0, "path": "src/ethereum/london/vm/__init__.py"}, "content": {"type": ["function"], "name": ["incorporate_child_on_success"], "text": ["Incorporate the state of a successful  child_evm  into the parent  evm . Parameters evm : The parent  EVM . child_evm : The child evm to incorporate."]}}, {"source": {"identifier": "ethereum.london.vm.incorporate_child_on_error", "specifier": 0, "path": "src/ethereum/london/vm/__init__.py"}, "content": {"type": ["function"], "name": ["incorporate_child_on_error"], "text": ["Incorporate the state of an unsuccessful  child_evm  into the parent  evm . Parameters evm : The parent  EVM . child_evm : The child evm to incorporate."]}}, {"source": {"identifier": "ethereum.london.vm.runtime", "specifier": 0, "path": "src/ethereum/london/vm/runtime.py"}, "content": {"type": ["module"], "name": ["ethereum.london.vm.runtime"], "text": ["Ethereum Virtual Machine (EVM) Runtime Operations ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Runtime related operations used while executing EVM code."]}}, {"source": {"identifier": "ethereum.london.vm.runtime.get_valid_jump_destinations", "specifier": 0, "path": "src/ethereum/london/vm/runtime.py"}, "content": {"type": ["function"], "name": ["get_valid_jump_destinations"], "text": ["Analyze the evm code to obtain the set of valid jump destinations. Valid jump destinations are defined as follows: * The jump destination is less than the length of the code. * The jump destination should have the  JUMPDEST  opcode (0x5B). * The jump destination shouldn't be part of the data corresponding to PUSH-N  opcodes. Note - Jump destinations are 0-indexed. Parameters code : The EVM code which is to be executed. Returns valid_jump_destinations:  Set[Uint] The set of valid jump destinations in the code."]}}, {"source": {"identifier": "ethereum.london.vm.interpreter", "specifier": 0, "path": "src/ethereum/london/vm/interpreter.py"}, "content": {"type": ["module"], "name": ["ethereum.london.vm.interpreter"], "text": ["Ethereum Virtual Machine (EVM) Interpreter ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction A straightforward interpreter that executes EVM code."]}}, {"source": {"identifier": "ethereum.london.vm.interpreter.STACK_DEPTH_LIMIT", "specifier": 0, "path": "src/ethereum/london/vm/interpreter.py"}, "content": {"type": ["attribute"], "name": ["STACK_DEPTH_LIMIT"]}}, {"source": {"identifier": "ethereum.london.vm.interpreter.MAX_CODE_SIZE", "specifier": 0, "path": "src/ethereum/london/vm/interpreter.py"}, "content": {"type": ["attribute"], "name": ["MAX_CODE_SIZE"]}}, {"source": {"identifier": "ethereum.london.vm.interpreter.MessageCallOutput", "specifier": 0, "path": "src/ethereum/london/vm/interpreter.py"}, "content": {"type": ["class"], "name": ["MessageCallOutput"], "text": ["Output of a particular message call Contains the following:   1. `gas_left`: remaining gas after execution.\n  2. `refund_counter`: gas to refund after execution.\n  3. `logs`: list of `Log` generated during execution.\n  4. `accounts_to_delete`: Contracts which have self-destructed.\n  5. `touched_accounts`: Accounts that have been touched.\n  6. `has_erred`: True if execution has caused an error.\n"]}}, {"source": {"identifier": "ethereum.london.vm.interpreter.MessageCallOutput.gas_left", "specifier": 0, "path": "src/ethereum/london/vm/interpreter.py"}, "content": {"type": ["attribute"], "name": ["gas_left"]}}, {"source": {"identifier": "ethereum.london.vm.interpreter.MessageCallOutput.refund_counter", "specifier": 0, "path": "src/ethereum/london/vm/interpreter.py"}, "content": {"type": ["attribute"], "name": ["refund_counter"]}}, {"source": {"identifier": "ethereum.london.vm.interpreter.MessageCallOutput.logs", "specifier": 0, "path": "src/ethereum/london/vm/interpreter.py"}, "content": {"type": ["attribute"], "name": ["logs"]}}, {"source": {"identifier": "ethereum.london.vm.interpreter.MessageCallOutput.accounts_to_delete", "specifier": 0, "path": "src/ethereum/london/vm/interpreter.py"}, "content": {"type": ["attribute"], "name": ["accounts_to_delete"]}}, {"source": {"identifier": "ethereum.london.vm.interpreter.MessageCallOutput.touched_accounts", "specifier": 0, "path": "src/ethereum/london/vm/interpreter.py"}, "content": {"type": ["attribute"], "name": ["touched_accounts"]}}, {"source": {"identifier": "ethereum.london.vm.interpreter.MessageCallOutput.has_erred", "specifier": 0, "path": "src/ethereum/london/vm/interpreter.py"}, "content": {"type": ["attribute"], "name": ["has_erred"]}}, {"source": {"identifier": "ethereum.london.vm.interpreter.process_message_call", "specifier": 0, "path": "src/ethereum/london/vm/interpreter.py"}, "content": {"type": ["function"], "name": ["process_message_call"], "text": ["If  message.current  is empty then it creates a smart contract else it executes a call from the  message.caller  to the  message.target . Parameters message : Transaction specific items. env : External items required for EVM execution. Returns output :  MessageCallOutput Output of the message call"]}}, {"source": {"identifier": "ethereum.london.vm.interpreter.process_create_message", "specifier": 0, "path": "src/ethereum/london/vm/interpreter.py"}, "content": {"type": ["function"], "name": ["process_create_message"], "text": ["Executes a call to create a smart contract. Parameters message : Transaction specific items. env : External items required for EVM execution. Returns evm: :py:class: ~ethereum.london.vm.Evm Items containing execution specific objects."]}}, {"source": {"identifier": "ethereum.london.vm.interpreter.process_message", "specifier": 0, "path": "src/ethereum/london/vm/interpreter.py"}, "content": {"type": ["function"], "name": ["process_message"], "text": ["Executes a call to create a smart contract. Parameters message : Transaction specific items. env : External items required for EVM execution. Returns evm: :py:class: ~ethereum.london.vm.Evm Items containing execution specific objects"]}}, {"source": {"identifier": "ethereum.london.vm.interpreter.execute_code", "specifier": 0, "path": "src/ethereum/london/vm/interpreter.py"}, "content": {"type": ["function"], "name": ["execute_code"], "text": ["Executes bytecode present in the  message . Parameters message : Transaction specific items. env : External items required for EVM execution. Returns evm:  ethereum.vm.EVM Items containing execution specific objects"]}}, {"source": {"identifier": "ethereum.london.vm.stack", "specifier": 0, "path": "src/ethereum/london/vm/stack.py"}, "content": {"type": ["module"], "name": ["ethereum.london.vm.stack"], "text": ["Ethereum Virtual Machine (EVM) Stack ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementation of the stack operators for the EVM."]}}, {"source": {"identifier": "ethereum.london.vm.stack.pop", "specifier": 0, "path": "src/ethereum/london/vm/stack.py"}, "content": {"type": ["function"], "name": ["pop"], "text": ["Pops the top item off of  stack . Parameters stack : EVM stack. Returns value :  U256 The top element on the stack."]}}, {"source": {"identifier": "ethereum.london.vm.stack.push", "specifier": 0, "path": "src/ethereum/london/vm/stack.py"}, "content": {"type": ["function"], "name": ["push"], "text": ["Pushes  value  onto  stack . Parameters stack : EVM stack. value : Item to be pushed onto  stack ."]}}, {"source": {"identifier": "ethereum.london.vm.gas", "specifier": 0, "path": "src/ethereum/london/vm/gas.py"}, "content": {"type": ["module"], "name": ["ethereum.london.vm.gas"], "text": ["Ethereum Virtual Machine (EVM) Gas ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction EVM gas constants and calculators."]}}, {"source": {"identifier": "ethereum.london.vm.gas.GAS_JUMPDEST", "specifier": 0, "path": "src/ethereum/london/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_JUMPDEST"]}}, {"source": {"identifier": "ethereum.london.vm.gas.GAS_BASE", "specifier": 0, "path": "src/ethereum/london/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_BASE"]}}, {"source": {"identifier": "ethereum.london.vm.gas.GAS_VERY_LOW", "specifier": 0, "path": "src/ethereum/london/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_VERY_LOW"]}}, {"source": {"identifier": "ethereum.london.vm.gas.GAS_STORAGE_SET", "specifier": 0, "path": "src/ethereum/london/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_STORAGE_SET"]}}, {"source": {"identifier": "ethereum.london.vm.gas.GAS_STORAGE_UPDATE", "specifier": 0, "path": "src/ethereum/london/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_STORAGE_UPDATE"]}}, {"source": {"identifier": "ethereum.london.vm.gas.GAS_STORAGE_CLEAR_REFUND", "specifier": 0, "path": "src/ethereum/london/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_STORAGE_CLEAR_REFUND"]}}, {"source": {"identifier": "ethereum.london.vm.gas.GAS_LOW", "specifier": 0, "path": "src/ethereum/london/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_LOW"]}}, {"source": {"identifier": "ethereum.london.vm.gas.GAS_MID", "specifier": 0, "path": "src/ethereum/london/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_MID"]}}, {"source": {"identifier": "ethereum.london.vm.gas.GAS_HIGH", "specifier": 0, "path": "src/ethereum/london/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_HIGH"]}}, {"source": {"identifier": "ethereum.london.vm.gas.GAS_EXPONENTIATION", "specifier": 0, "path": "src/ethereum/london/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_EXPONENTIATION"]}}, {"source": {"identifier": "ethereum.london.vm.gas.GAS_EXPONENTIATION_PER_BYTE", "specifier": 0, "path": "src/ethereum/london/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_EXPONENTIATION_PER_BYTE"]}}, {"source": {"identifier": "ethereum.london.vm.gas.GAS_MEMORY", "specifier": 0, "path": "src/ethereum/london/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_MEMORY"]}}, {"source": {"identifier": "ethereum.london.vm.gas.GAS_KECCAK256", "specifier": 0, "path": "src/ethereum/london/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_KECCAK256"]}}, {"source": {"identifier": "ethereum.london.vm.gas.GAS_KECCAK256_WORD", "specifier": 0, "path": "src/ethereum/london/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_KECCAK256_WORD"]}}, {"source": {"identifier": "ethereum.london.vm.gas.GAS_COPY", "specifier": 0, "path": "src/ethereum/london/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_COPY"]}}, {"source": {"identifier": "ethereum.london.vm.gas.GAS_BLOCK_HASH", "specifier": 0, "path": "src/ethereum/london/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_BLOCK_HASH"]}}, {"source": {"identifier": "ethereum.london.vm.gas.GAS_LOG", "specifier": 0, "path": "src/ethereum/london/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_LOG"]}}, {"source": {"identifier": "ethereum.london.vm.gas.GAS_LOG_DATA", "specifier": 0, "path": "src/ethereum/london/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_LOG_DATA"]}}, {"source": {"identifier": "ethereum.london.vm.gas.GAS_LOG_TOPIC", "specifier": 0, "path": "src/ethereum/london/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_LOG_TOPIC"]}}, {"source": {"identifier": "ethereum.london.vm.gas.GAS_CREATE", "specifier": 0, "path": "src/ethereum/london/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_CREATE"]}}, {"source": {"identifier": "ethereum.london.vm.gas.GAS_CODE_DEPOSIT", "specifier": 0, "path": "src/ethereum/london/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_CODE_DEPOSIT"]}}, {"source": {"identifier": "ethereum.london.vm.gas.GAS_ZERO", "specifier": 0, "path": "src/ethereum/london/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_ZERO"]}}, {"source": {"identifier": "ethereum.london.vm.gas.GAS_NEW_ACCOUNT", "specifier": 0, "path": "src/ethereum/london/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_NEW_ACCOUNT"]}}, {"source": {"identifier": "ethereum.london.vm.gas.GAS_CALL_VALUE", "specifier": 0, "path": "src/ethereum/london/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_CALL_VALUE"]}}, {"source": {"identifier": "ethereum.london.vm.gas.GAS_CALL_STIPEND", "specifier": 0, "path": "src/ethereum/london/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_CALL_STIPEND"]}}, {"source": {"identifier": "ethereum.london.vm.gas.GAS_SELF_DESTRUCT", "specifier": 0, "path": "src/ethereum/london/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_SELF_DESTRUCT"]}}, {"source": {"identifier": "ethereum.london.vm.gas.GAS_SELF_DESTRUCT_NEW_ACCOUNT", "specifier": 0, "path": "src/ethereum/london/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_SELF_DESTRUCT_NEW_ACCOUNT"]}}, {"source": {"identifier": "ethereum.london.vm.gas.GAS_ECRECOVER", "specifier": 0, "path": "src/ethereum/london/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_ECRECOVER"]}}, {"source": {"identifier": "ethereum.london.vm.gas.GAS_SHA256", "specifier": 0, "path": "src/ethereum/london/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_SHA256"]}}, {"source": {"identifier": "ethereum.london.vm.gas.GAS_SHA256_WORD", "specifier": 0, "path": "src/ethereum/london/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_SHA256_WORD"]}}, {"source": {"identifier": "ethereum.london.vm.gas.GAS_RIPEMD160", "specifier": 0, "path": "src/ethereum/london/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_RIPEMD160"]}}, {"source": {"identifier": "ethereum.london.vm.gas.GAS_RIPEMD160_WORD", "specifier": 0, "path": "src/ethereum/london/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_RIPEMD160_WORD"]}}, {"source": {"identifier": "ethereum.london.vm.gas.GAS_IDENTITY", "specifier": 0, "path": "src/ethereum/london/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_IDENTITY"]}}, {"source": {"identifier": "ethereum.london.vm.gas.GAS_IDENTITY_WORD", "specifier": 0, "path": "src/ethereum/london/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_IDENTITY_WORD"]}}, {"source": {"identifier": "ethereum.london.vm.gas.GAS_RETURN_DATA_COPY", "specifier": 0, "path": "src/ethereum/london/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_RETURN_DATA_COPY"]}}, {"source": {"identifier": "ethereum.london.vm.gas.GAS_FAST_STEP", "specifier": 0, "path": "src/ethereum/london/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_FAST_STEP"]}}, {"source": {"identifier": "ethereum.london.vm.gas.GAS_BLAKE2_PER_ROUND", "specifier": 0, "path": "src/ethereum/london/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_BLAKE2_PER_ROUND"]}}, {"source": {"identifier": "ethereum.london.vm.gas.GAS_COLD_SLOAD", "specifier": 0, "path": "src/ethereum/london/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_COLD_SLOAD"]}}, {"source": {"identifier": "ethereum.london.vm.gas.GAS_COLD_ACCOUNT_ACCESS", "specifier": 0, "path": "src/ethereum/london/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_COLD_ACCOUNT_ACCESS"]}}, {"source": {"identifier": "ethereum.london.vm.gas.GAS_WARM_ACCESS", "specifier": 0, "path": "src/ethereum/london/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["GAS_WARM_ACCESS"]}}, {"source": {"identifier": "ethereum.london.vm.gas.ExtendMemory", "specifier": 0, "path": "src/ethereum/london/vm/gas.py"}, "content": {"type": ["class"], "name": ["ExtendMemory"], "text": ["Define the parameters for memory extension in opcodes cost :  ethereum.base_types.Uint The gas required to perform the extension expand_by :  ethereum.base_types.Uint The size by which the memory will be extended"]}}, {"source": {"identifier": "ethereum.london.vm.gas.ExtendMemory.cost", "specifier": 0, "path": "src/ethereum/london/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["cost"]}}, {"source": {"identifier": "ethereum.london.vm.gas.ExtendMemory.expand_by", "specifier": 0, "path": "src/ethereum/london/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["expand_by"]}}, {"source": {"identifier": "ethereum.london.vm.gas.MessageCallGas", "specifier": 0, "path": "src/ethereum/london/vm/gas.py"}, "content": {"type": ["class"], "name": ["MessageCallGas"], "text": ["Define the gas cost and stipend for executing the call opcodes. cost :  ethereum.base_types.Uint The non-refundable portion of gas reserved for executing the call opcode. stipend :  ethereum.base_types.Uint The portion of gas available to sub-calls that is refundable if not consumed"]}}, {"source": {"identifier": "ethereum.london.vm.gas.MessageCallGas.cost", "specifier": 0, "path": "src/ethereum/london/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["cost"]}}, {"source": {"identifier": "ethereum.london.vm.gas.MessageCallGas.stipend", "specifier": 0, "path": "src/ethereum/london/vm/gas.py"}, "content": {"type": ["attribute"], "name": ["stipend"]}}, {"source": {"identifier": "ethereum.london.vm.gas.charge_gas", "specifier": 0, "path": "src/ethereum/london/vm/gas.py"}, "content": {"type": ["function"], "name": ["charge_gas"], "text": ["Subtracts  amount  from  evm.gas_left . Parameters evm : The current EVM. amount : The amount of gas the current operation requires."]}}, {"source": {"identifier": "ethereum.london.vm.gas.calculate_memory_gas_cost", "specifier": 0, "path": "src/ethereum/london/vm/gas.py"}, "content": {"type": ["function"], "name": ["calculate_memory_gas_cost"], "text": ["Calculates the gas cost for allocating memory to the smallest multiple of 32 bytes, such that the allocated size is at least as big as the given size. Parameters size_in_bytes : The size of the data in bytes. Returns total_gas_cost :  ethereum.base_types.Uint The gas cost for storing data in memory."]}}, {"source": {"identifier": "ethereum.london.vm.gas.calculate_gas_extend_memory", "specifier": 0, "path": "src/ethereum/london/vm/gas.py"}, "content": {"type": ["function"], "name": ["calculate_gas_extend_memory"], "text": ["Calculates the gas amount to extend memory Parameters memory : Memory contents of the EVM. extensions: List of extensions to be made to the memory. Consists of a tuple of start position and size. Returns extend_memory:  ExtendMemory"]}}, {"source": {"identifier": "ethereum.london.vm.gas.calculate_message_call_gas", "specifier": 0, "path": "src/ethereum/london/vm/gas.py"}, "content": {"type": ["function"], "name": ["calculate_message_call_gas"], "text": ["Calculates the MessageCallGas (cost and stipend) for executing call Opcodes. Parameters value: The amount of  ETH  that needs to be transferred. gas : The amount of gas provided to the message-call. gas_left : The amount of gas left in the current frame. memory_cost : The amount needed to extend the memory in the current frame. extra_gas : The amount of gas needed for transferring value + creating a new account inside a message call. call_stipend : The amount of stipend provided to a message call to execute code while transferring value(ETH). Returns message_call_gas:  MessageCallGas"]}}, {"source": {"identifier": "ethereum.london.vm.gas.max_message_call_gas", "specifier": 0, "path": "src/ethereum/london/vm/gas.py"}, "content": {"type": ["function"], "name": ["max_message_call_gas"], "text": ["Calculates the maximum gas that is allowed for making a message call Parameters gas : The amount of gas provided to the message-call. Returns max_allowed_message_call_gas:  ethereum.base_types.Uint The maximum gas allowed for making the message-call."]}}, {"source": {"identifier": "ethereum.london.vm.precompiled_contracts.blake2f", "specifier": 0, "path": "src/ethereum/london/vm/precompiled_contracts/blake2f.py"}, "content": {"type": ["module"], "name": ["ethereum.london.vm.precompiled_contracts.blake2f"], "text": ["Ethereum Virtual Machine (EVM) Blake2 PRECOMPILED CONTRACT ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Implementation of the  Blake2  precompiled contract."]}}, {"source": {"identifier": "ethereum.london.vm.precompiled_contracts.blake2f.blake2f", "specifier": 0, "path": "src/ethereum/london/vm/precompiled_contracts/blake2f.py"}, "content": {"type": ["function"], "name": ["blake2f"], "text": ["Writes the Blake2 hash to output. Parameters evm : The current EVM frame."]}}, {"source": {"identifier": "ethereum.london.vm.precompiled_contracts.mapping", "specifier": 0, "path": "src/ethereum/london/vm/precompiled_contracts/mapping.py"}, "content": {"type": ["module"], "name": ["ethereum.london.vm.precompiled_contracts.mapping"], "text": ["Precompiled Contract Addresses ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. contents:: Table of Contents :backlinks: none :local: Introduction Mapping of precompiled contracts their implementations."]}}, {"source": {"identifier": "ethereum.london.vm.precompiled_contracts.mapping.PRE_COMPILED_CONTRACTS", "specifier": 0, "path": "src/ethereum/london/vm/precompiled_contracts/mapping.py"}, "content": {"type": ["attribute"], "name": ["PRE_COMPILED_CONTRACTS"]}}]; Object.freeze(this.SEARCH_INDEX);